<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFLT_INSTANCE_TEARDOWN_CALLBACK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFLT_INSTANCE_TEARDOWN_CALLBACK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFLT_INSTANCE_TEARDOWN_CALLBACK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFLT_INSTANCE_TEARDOWN_CALLBACK PfltInstanceTeardownCallback;

VOID PfltInstanceTeardownCallback(
  [in] PCFLT_RELATED_OBJECTS FltObjects,
  [in] FLT_INSTANCE_TEARDOWN_FLAGS Reason
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_instance_teardown_callback">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pflt_instance_teardown_callback.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-fltkernel-pflt_instance_teardown_callback)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pflt_instance_teardown_callback-callback">PFLT_INSTANCE_TEARDOWN_CALLBACK callback</h1>

<h2 id="description">Description</h2>

<p>A minifilter driver can register two routines of type <strong>PFLT_INSTANCE_TEARDOWN_CALLBACK</strong> as the minifilter driver's <em>InstanceTeardownStartCallback</em> and <em>InstanceTeardownCompleteCallback</em> routines.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="fltobjects-in"><code>FltObjects</code> [in]</h3>

<p>Pointer to a <strong><a href="flt_related_objects" title="typedef struct _FLT_RELATED_OBJECTS {&#10;  USHORT        Size;&#10;  USHORT        TransactionContext;&#10;  PFLT_FILTER   Filter;&#10;  PFLT_VOLUME   Volume;&#10;  PFLT_INSTANCE Instance;&#10;  PFILE_OBJECT  FileObject;&#10;  PKTRANSACTION Transaction;&#10;} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;">FLT_RELATED_OBJECTS</a></strong> structure that contains opaque pointers for the objects related to the current I/O operation.</p>

<h3 id="reason-in"><code>Reason</code> [in]</h3>

<p>Flag that indicates why the minifilter driver instance is being torn down. One of the following:</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLTFL_INSTANCE_TEARDOWN_MANUAL (0x00000001)</td>
  <td>The instance is being detached because a user-mode application has called <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fltuser/nf-fltuser-filterdetach"><strong>FilterDetach</strong></a> or a kernel-mode component has called <strong><a href="fltdetachvolume" title="NTSTATUS FLTAPI FltDetachVolume(&#10;  [in, out]      PFLT_FILTER      Filter,&#10;  [in, out]      PFLT_VOLUME      Volume,&#10;  [in, optional] PCUNICODE_STRING InstanceName&#10;);">FltDetachVolume</a></strong>.</td>
</tr>
<tr>
  <td>FLTFL_INSTANCE_TEARDOWN_FILTER_UNLOAD (0x00000002)</td>
  <td>The minifilter driver is being unloaded.</td>
</tr>
<tr>
  <td>FLTFL_INSTANCE_TEARDOWN_MANDATORY_FILTER_UNLOAD (0x00000004)</td>
  <td>The minifilter driver is being unloaded.</td>
</tr>
<tr>
  <td>FLTFL_INSTANCE_TEARDOWN_VOLUME_DISMOUNT (0x00000008)</td>
  <td>If set, the volume is being dismounted. (Or the volume has already been dismounted. Or the volume mount operation failed. Or the minifilter driver instance or the volume is being torn down. Or the file system unregistered itself as an active file system.)</td>
</tr>
<tr>
  <td>FLTFL_INSTANCE_TEARDOWN_INTERNAL_ERROR (0x00000010)</td>
  <td>The system experienced an unexpected internal error.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>When a minifilter driver registers itself by calling <strong><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></strong> from its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/writing-a-driverentry-routine-for-a-minifilter-driver"><strong>DriverEntry</strong></a> routine, it can register two routines of type PFLT_INSTANCE_TEARDOWN_CALLBACK as the minifilter driver's *InstanceTeardownStartCallback* and <em>InstanceTeardownCompleteCallback</em> routines. To register these callback routines, the minifilter driver stores the addresses of the two routines of type PFLT_INSTANCE_TEARDOWN_CALLBACK in the **InstanceTeardownStartCallback** and **InstanceTeardownCompleteCallback** members of the <a href="flt_registration" title="typedef struct _FLT_REGISTRATION {&#10;  USHORT                                      Size;&#10;  USHORT                                      Version;&#10;  FLT_REGISTRATION_FLAGS                      Flags;&#10;  const FLT_CONTEXT_REGISTRATION              *ContextRegistration;&#10;  const FLT_OPERATION_REGISTRATION            *OperationRegistration;&#10;  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;&#10;  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;&#10;  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback;&#10;  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;&#10;  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;&#10;  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;&#10;  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;&#10;} FLT_REGISTRATION, *PFLT_REGISTRATION;">FLT_REGISTRATION</a> structure that the minifilter driver passes as the <em>Registration</em> parameter of <strong><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></strong>.</p>

<p>The <em>InstanceTeardownStartCallback</em> and <em>InstanceTeardownCompleteCallback</em> routines are optional and can be <strong>NULL</strong>. If the minifilter driver specifies <strong>NULL</strong> for the <em>InstanceTeardownStartCallback</em> or <em>InstanceTeardownCompleteCallback</em> routine, the instance is still torn down.</p>

<p>The <em>InstanceTeardownStartCallback</em> routine is called when the filter manager starts tearing down a minifilter driver instance to allow the minifilter driver to complete any pended I/O operations and save state information.</p>

<p>The <em>InstanceTeardownStartCallback</em> routine must:</p>

<ul>
<li>Call <strong><a href="fltcompletependedpreoperation" title="VOID FLTAPI FltCompletePendedPreOperation(&#10;                 PFLT_CALLBACK_DATA        CallbackData,&#10;  [in]           FLT_PREOP_CALLBACK_STATUS CallbackStatus,&#10;  [in, optional] PVOID                     Context&#10;);">FltCompletePendedPreOperation</a></strong> for each I/O operation that was pended in the minifilter driver's preoperation callback routine to complete the operation or return control of the operation to the filter manager.</li>
<li>Not pend any new I/O operations. If the minifilter driver uses a callback data queue, it must call <strong><a href="fltcbdqdisable" title="VOID FLTAPI FltCbdqDisable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqDisable</a></strong> to disable it.</li>
<li>Call <strong><a href="fltcompletependedpostoperation" title="VOID FLTAPI FltCompletePendedPostOperation(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCompletePendedPostOperation</a></strong> for each I/O operation that was pended in the minifilter driver's postoperation callback routine to return control of the operation to the filter manager.</li>
</ul>

<p>The <em>InstanceTeardownStartCallback</em> routine can optionally do the following to allow the minifilter driver to unload as quickly as possible:</p>

<ul>
<li>Close any opened files.</li>
<li>Ensure that worker threads perform only the minimum necessary to complete processing of outstanding work items.</li>
<li>Call <strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong> to cancel any I/O operations that were initiated by the minifilter driver.</li>
<li>Stop queuing new work items.</li>
</ul>

<p>Once the minifilter driver's <em>InstanceTeardownStartCallback</em> routine is called, the minifilter driver's preoperation and postoperation callback routines are not called for any new I/O operations. However, they may be called for I/O operations that were started before instance teardown was initiated.</p>

<p>The <em>InstanceTeardownCompleteCallback</em> routine is called when the teardown process is complete to allow the minifilter driver to close open files and perform any other necessary cleanup processing.</p>

<p>The <em>InstanceTeardownCompleteCallback</em> routine must close any files that were opened by the minifilter driver.</p>

<p>The filter manager calls the minifilter driver's <em>InstanceTeardownCompleteCallback</em> routine only after all outstanding I/O operations have been completed or drained.</p>

<blockquote>
  <p>[!WARNING]
  The <em>InstanceTeardownCompleteCallback</em> routine will not be called if any of the following conditions are true:</p>
  
  <ul>
  <li>There are outstanding pended I/O operations.</li>
  <li>There are any outstanding I/O operations that were initiated by the minifilter driver.</li>
  </ul>
</blockquote>

<p>If the minifilter driver instance is being torn down because the minifilter driver is being unloaded, the unload operation appears to hang until the <em>InstanceTeardownCompleteCallback</em> routine returns. To debug these kinds of problems, you should enable the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/devtest/driver-verifier">Driver Verifier</a> on your minifilter driver. The Filter Verifier <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/devtest/i-o-verification">I/O Verification</a> option can help identify possible causes, such as unreleased references, that would prevent the minifilter driver from unloading. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/development-and-testing-tools">Filter Verifier</a>.</p>

<p>Note that referencing the instance (by calling <strong><a href="fltobjectreference" title="NTSTATUS FLTAPI FltObjectReference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectReference</a></strong>) does not prevent the <em>InstanceTeardownCompleteCallback</em> routine from being called.</p>

<p>The filter manager calls the <em>InstanceTeardownStartCallback</em> and <em>InstanceTeardownCompleteCallback</em> routines at IRQL PASSIVE_LEVEL.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="flt_registration" title="typedef struct _FLT_REGISTRATION {&#10;  USHORT                                      Size;&#10;  USHORT                                      Version;&#10;  FLT_REGISTRATION_FLAGS                      Flags;&#10;  const FLT_CONTEXT_REGISTRATION              *ContextRegistration;&#10;  const FLT_OPERATION_REGISTRATION            *OperationRegistration;&#10;  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;&#10;  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;&#10;  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback;&#10;  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;&#10;  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;&#10;  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;&#10;  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;&#10;} FLT_REGISTRATION, *PFLT_REGISTRATION;">FLT_REGISTRATION</a></strong></p>

<p><strong><a href="flt_related_objects" title="typedef struct _FLT_RELATED_OBJECTS {&#10;  USHORT        Size;&#10;  USHORT        TransactionContext;&#10;  PFLT_FILTER   Filter;&#10;  PFLT_VOLUME   Volume;&#10;  PFLT_INSTANCE Instance;&#10;  PFILE_OBJECT  FileObject;&#10;  PKTRANSACTION Transaction;&#10;} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;">FLT_RELATED_OBJECTS</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fltuser/nf-fltuser-filterdetach"><strong>FilterDetach</strong></a></p>

<p><strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong></p>

<p><strong><a href="fltcbdqdisable" title="VOID FLTAPI FltCbdqDisable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqDisable</a></strong></p>

<p><strong><a href="fltcompletependedpostoperation" title="VOID FLTAPI FltCompletePendedPostOperation(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCompletePendedPostOperation</a></strong></p>

<p><strong><a href="fltcompletependedpreoperation" title="VOID FLTAPI FltCompletePendedPreOperation(&#10;                 PFLT_CALLBACK_DATA        CallbackData,&#10;  [in]           FLT_PREOP_CALLBACK_STATUS CallbackStatus,&#10;  [in, optional] PVOID                     Context&#10;);">FltCompletePendedPreOperation</a></strong></p>

<p><strong><a href="fltdetachvolume" title="NTSTATUS FLTAPI FltDetachVolume(&#10;  [in, out]      PFLT_FILTER      Filter,&#10;  [in, out]      PFLT_VOLUME      Volume,&#10;  [in, optional] PCUNICODE_STRING InstanceName&#10;);">FltDetachVolume</a></strong></p>

<p><strong><a href="fltobjectreference" title="NTSTATUS FLTAPI FltObjectReference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectReference</a></strong></p>

<p><strong><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></strong></p>

<p><strong><a href="pflt_instance_query_teardown_callback" title="PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK PfltInstanceQueryTeardownCallback;&#10;&#10;NTSTATUS PfltInstanceQueryTeardownCallback(&#10;  [in] PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in] FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags&#10;)&#10;{...}">PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK</a></strong></p>

<p><strong><a href="pflt_instance_setup_callback" title="PFLT_INSTANCE_SETUP_CALLBACK PfltInstanceSetupCallback;&#10;&#10;NTSTATUS PfltInstanceSetupCallback(&#10;  [in] PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in] FLT_INSTANCE_SETUP_FLAGS Flags,&#10;  [in] DEVICE_TYPE VolumeDeviceType,&#10;  [in] FLT_FILESYSTEM_TYPE VolumeFilesystemType&#10;)&#10;{...}">PFLT_INSTANCE_SETUP_CALLBACK</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_instance_teardown_callback">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nc-fltkernel-pflt_instance_teardown_callback.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
