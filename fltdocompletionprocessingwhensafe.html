<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltDoCompletionProcessingWhenSafe - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltDoCompletionProcessingWhenSafe - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltDoCompletionProcessingWhenSafe - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">BOOLEAN FLTAPI FltDoCompletionProcessingWhenSafe(
  [in]           <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a>           Data,
  [in]           PCFLT_RELATED_OBJECTS        FltObjects,
  [in, optional] PVOID                        CompletionContext,
  [in]           FLT_POST_OPERATION_FLAGS     Flags,
  [in]           <a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a> SafePostCallback,
  [out]          PFLT_POSTOP_CALLBACK_STATUS  RetPostOperationStatus
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltdocompletionprocessingwhensafe">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltdocompletionprocessingwhensafe.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltdocompletionprocessingwhensafe)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FltDoCompletionProcessingWhenSafe function</h1>
<h2>Description</h2>
<p>If it is safe to do so, the <strong>FltDoCompletionProcessingWhenSafe</strong> function executes a minifilter driver post-operation callback routine.</p>
<h2>Parameters</h2>
<h3><code>Data</code> [in]</h3>
<p>Pointer to the callback data structure (<a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a>) for the I/O operation. Usually this is the same as the <em>Data</em> pointer that was passed to the postoperation callback routine (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>) that called <strong>FltDoCompletionProcessingWhenSafe</strong>.</p>
<h3><code>FltObjects</code> [in]</h3>
<p>Pointer to the related objects structure (<a href="flt_related_objects" title="typedef struct _FLT_RELATED_OBJECTS {&#10;  USHORT        Size;&#10;  USHORT        TransactionContext;&#10;  PFLT_FILTER   Filter;&#10;  PFLT_VOLUME   Volume;&#10;  PFLT_INSTANCE Instance;&#10;  PFILE_OBJECT  FileObject;&#10;  PKTRANSACTION Transaction;&#10;} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;">FLT_RELATED_OBJECTS</a>) for the I/O operation. Usually this is the same as the <em>FltObjects</em> pointer that was passed to the postoperation callback routine that called <strong>FltDoCompletionProcessingWhenSafe</strong>.</p>
<h3><code>CompletionContext</code> [in, optional]</h3>
<p>Pointer to a caller-supplied context information that will be passed in to the callback function that is specified in the <em>SafePostCallback</em> parameter.</p>
<h3><code>Flags</code> [in]</h3>
<p>Bitmask of flags which specify how completion processing will be performed. Usually this is the same as the <em>Flags</em> value that was passed to the postoperation callback routine that called <strong>FltDoCompletionProcessingWhenSafe</strong>. For more information, see the following Remarks section.</p>
<h3><code>SafePostCallback</code> [in]</h3>
<p>Pointer to a caller-supplied <a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>-typed callback routine that the operating system calls when it is safe to do so.</p>
<h3><code>RetPostOperationStatus</code> [out]</h3>
<p>Caller-allocated variable that receives the final status value for the I/O operation. For more information on how this parameter is set, see the following Remarks section.</p>
<h2>Return value</h2>
<p><strong>FltDoCompletionProcessingWhenSafe</strong> returns <strong>TRUE</strong> if completion processing for the I/O operation can be performed immediately or the I/O operation was successfully posted to a worker thread; otherwise, it returns <strong>FALSE</strong>.</p>
<h2>Remarks</h2>
<p><strong>FltDoCompletionProcessingWhenSafe</strong> executes the <em>SafePostCallback</em> immediately if the caller is running at IRQL &lt;= APC_LEVEL. Otherwise, if it is safe to post the operation to a worker thread, the <em>SafePostCallback</em> processing is deferred until it can be called in a thread context where IRQL &lt;= APC_LEVEL.</p>
<p>If IRQL &lt; DISPATCH_LEVEL:</p>
<ul>
<li>
<strong>FltDoCompletionProcessingWhenSafe</strong> immediately calls the <em>SafePostCallback</em> callback routine.
</li>
<li>
The <em>RetPostOperationStatus</em> parameter receives a FLT_POSTOP_CALLBACK_STATUS value returned by <em>SafePostCallback</em>.
</li>
<li>
<strong>FltDoCompletionProcessingWhenSafe</strong> returns <strong>TRUE</strong>.
</li>
</ul>
<p>If IRQL &gt;= DISPATCH_LEVEL:</p>
<ul>
<li>
<strong>FltDoCompletionProcessingWhenSafe</strong> attempts to post the I/O operation to a worker thread, and then call the <em>SafePostCallback</em> routine from the worker thread.
</li>
<li>If the I/O operation could be safely posted:
<ul>
<li>
Filter manager sets <em>RetPostOperationStatus</em> to FLT_POSTOP_MORE_PROCESSING_REQUIRED.
</li>
<li>
<strong>FltDoCompletionProcessingWhenSafe</strong> returns <strong>TRUE</strong>.
</li>
</ul>
</li>
<li>If the I/O operation could not be safely posted:
<ul>
<li>
Filter manager sets <em>RetPostOperationStatus</em> to FLT_POSTOP_FINISHED_PROCESSING.
</li>
<li>
<strong>FltDoCompletionProcessingWhenSafe</strong> returns <strong>FALSE</strong>.
</li>
</ul>
</li>
</ul>
<p><strong>FltDoCompletionProcessingWhenSafe</strong> can only be called for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations. To determine whether the operation is an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operation, use the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)">FLT_IS_IRP_OPERATION</a> macro.</p>
<p><strong>FltDoCompletionProcessingWhenSafe</strong> cannot be used to post completion of a paging I/O operation to a worker thread.</p>
<p><strong>FltDoCompletionProcessingWhenSafe</strong> can only be called from a minifilter driver's postoperation callback routine (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>). Note that <strong>FltDoCompletionProcessingWhenSafe</strong> should never be called if the <em>Flags</em> parameter of the postoperation callback has the FLTFL_POST_OPERATION_DRAINING bit set.</p>
<p>If a minifilter calls <strong>FltDoCompletionProcessingWhenSafe</strong> and the <em>SafePostCallback</em> is invoked in a worker thread because it is not safe to invoke it in the current thread context, the filter manager will resume completion processing as long as the minifilter does not return FLT_POSTOP_MORE_PROCESSING_REQUIRED from the <em>SafePostCallback</em>.</p>
<p>If the minifilter does return FLT_POSTOP_MORE_PROCESSING_REQUIRED from the <em>SafePostCallback</em>, the minifilter must call <strong><a href="fltcompletependedpostoperation" title="VOID FLTAPI FltCompletePendedPostOperation(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCompletePendedPostOperation</a></strong> to resume completion processing.</p>
<h2>See also</h2>
<p><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)">FLT_IS_IRP_OPERATION</a></p>
<p><a href="flt_related_objects" title="typedef struct _FLT_RELATED_OBJECTS {&#10;  USHORT        Size;&#10;  USHORT        TransactionContext;&#10;  PFLT_FILTER   Filter;&#10;  PFLT_VOLUME   Volume;&#10;  PFLT_INSTANCE Instance;&#10;  PFILE_OBJECT  FileObject;&#10;  PKTRANSACTION Transaction;&#10;} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;">FLT_RELATED_OBJECTS</a></p>
<p><strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong></p>
<p><strong><a href="fltcompletependedpostoperation" title="VOID FLTAPI FltCompletePendedPostOperation(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCompletePendedPostOperation</a></strong></p>
<p><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltdocompletionprocessingwhensafe">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltdocompletionprocessingwhensafe.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
