<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FSCTL_QUERY_ALLOCATED_RANGES - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FSCTL_QUERY_ALLOCATED_RANGES - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FSCTL_QUERY_ALLOCATED_RANGES - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0009, 0x033, METHOD_NEITHER, FILE_READ_ACCESS)
#define FSCTL_QUERY_ALLOCATED_RANGES 0x000940CF</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ni-ntifs-fsctl_query_allocated_ranges">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winioctl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0009, 0x033, METHOD_NEITHER, FILE_READ_ACCESS)
#define FSCTL_QUERY_ALLOCATED_RANGES 0x000940CF</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_query_allocated_ranges">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fsctl_query_allocated_ranges.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ni-ntifs-fsctl_query_allocated_ranges)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p><strong>FSCTL_QUERY_ALLOCATED_RANGES</strong> requests a scan of a file or alternate <a rel="noopener" target="_blank" href="https://learn.microsoft.com/openspecs/windows_protocols/ms-fscc/8ac44452-328c-4d7b-a784-d72afd19bd9f#gt_f3529cd8-50da-4f36-aa0b-66af455edbb6">stream</a> looking for byte ranges that can contain nonzero data, and then return of information on those ranges. Only sparse files can have zeroed ranges known to the operating system. For other files, the output buffer will contain only a single range that contains the starting point and the length requested.</p>
<h2>Parameters</h2>
<h3>Major code</h3>
<p>FSCTL_QUERY_ALLOCATED_RANGES</p>
<h3>Input buffer</h3>
<p>Pointer to a <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structure that indicates the range to query for allocation.</p>
<h3>Input buffer length</h3>
<p>Size of the <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structure that <strong>InputBuffer</strong> points to, in bytes.</p>
<h3>Output buffer</h3>
<p>Pointer to an array of zero or more <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> data elements in which the results of the query are returned. See below for more information.</p>
<h3>Output buffer length</h3>
<p>Size of the buffer that <strong>OutputBuffer</strong> points to, in bytes.</p>
<h3>Input/output buffer</h3>
<p>n/a</p>
<h3>Input/output buffer length</h3>
<p>n/a</p>
<h3>Status block</h3>
<p>Reserved for system use.</p>
<h2>Remarks</h2>
<p>To perform this operation, call <strong><a href="fltfscontrolfile" title="NTSTATUS FLTAPI FltFsControlFile(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PFILE_OBJECT  FileObject,&#10;  [in]            ULONG         FsControlCode,&#10;  [in, optional]  PVOID         InputBuffer,&#10;  [in]            ULONG         InputBufferLength,&#10;  [out, optional] PVOID         OutputBuffer,&#10;  [in]            ULONG         OutputBufferLength,&#10;  [out, optional] PULONG        LengthReturned&#10;);">FltFsControlFile</a></strong> or <strong><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">ZwFsControlFile</a></strong> with the following parameters.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Instance</strong></td>
<td>[in] For <strong><a href="fltfscontrolfile" title="NTSTATUS FLTAPI FltFsControlFile(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PFILE_OBJECT  FileObject,&#10;  [in]            ULONG         FsControlCode,&#10;  [in, optional]  PVOID         InputBuffer,&#10;  [in]            ULONG         InputBufferLength,&#10;  [out, optional] PVOID         OutputBuffer,&#10;  [in]            ULONG         OutputBufferLength,&#10;  [out, optional] PULONG        LengthReturned&#10;);">FltFsControlFile</a></strong> only. An opaque instance pointer for the caller. This parameter is required and cannot be NULL.</td>
</tr>
<tr>
<td><strong>FileObject</strong></td>
<td>[in] For <strong><a href="fltfscontrolfile" title="NTSTATUS FLTAPI FltFsControlFile(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PFILE_OBJECT  FileObject,&#10;  [in]            ULONG         FsControlCode,&#10;  [in, optional]  PVOID         InputBuffer,&#10;  [in]            ULONG         InputBufferLength,&#10;  [out, optional] PVOID         OutputBuffer,&#10;  [in]            ULONG         OutputBufferLength,&#10;  [out, optional] PULONG        LengthReturned&#10;);">FltFsControlFile</a></strong> only. A file object pointer for the file or directory that is the target of this request. This parameter is required and cannot be NULL.</td>
</tr>
<tr>
<td><strong>FileHandle</strong></td>
<td>[in] For <strong><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">ZwFsControlFile</a></strong> only. File handle of the file or directory that is the target of this request. This parameter is required and cannot be NULL.</td>
</tr>
<tr>
<td><strong>IoStatusBlock</strong></td>
<td>[out] For <strong><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">ZwFsControlFile</a></strong> only. Pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that contains the final status of the request.</td>
</tr>
<tr>
<td><strong>FsControlCode</strong></td>
<td>[in] Set to <strong>FSCTL_QUERY_ALLOCATED_RANGES</strong>.</td>
</tr>
<tr>
<td><strong>InputBuffer</strong></td>
<td>[in] Pointer to a <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structure that indicates the range to query for allocation.</td>
</tr>
<tr>
<td><strong>InputBufferLength</strong></td>
<td>[in] Size of the buffer that <strong>InputBuffer</strong> points to, in bytes.</td>
</tr>
<tr>
<td><strong>OutputBuffer</strong></td>
<td>[out] Pointer to an array of zero or more <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> data elements in which the results of the query are returned. See below for more information.</td>
</tr>
<tr>
<td><strong>OutputBufferLength</strong></td>
<td>[out] Size of the buffer that <strong>OutputBuffer</strong> points to, in bytes.</td>
</tr>
<tr>
<td><strong>LengthReturned</strong></td>
<td>[out] Pointer to a caller-allocated variable that receives the size in bytes of the information returned in the buffer at <strong>OutputBuffer</strong>.</td>
</tr>
</tbody>
</table>
<p><strong>FSCTL_QUERY_ALLOCATED_RANGES</strong> returns an array of zero or more <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> data elements in the buffer that <strong>OutputBuffer</strong> points to. The number of <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> elements returned is computed by dividing the value returned in <strong>LengthReturned</strong> by <code>sizeof(<a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a>)</code>. The returned ranges must intersect the range specified in <strong>InputBuffer</strong>. Zero <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> data elements are returned when the file has no allocated ranges.</p>
<h2>Return values</h2>
<p><strong>FSCTL_QUERY_ALLOCATED_RANGES</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> upon successful completion; otherwise it returns an error code. Common error codes follow.</p>
<table>
<thead>
<tr>
<th>Error code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>A parameter is invalid. For example: the handle is not to a file; the size of <strong>InputBuffer</strong> is less than the size of a <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structure; <strong>FileOffset</strong> is less than zero; <strong>Length</strong> is less than zero; or <strong>FileOffset</strong> plus <strong>Length</strong> is larger than 0x7FFFFFFFFFFFFFFF.</td>
</tr>
<tr>
<td>STATUS_INVALID_USER_BUFFER</td>
<td>The input buffer or output buffer is not aligned to a 4-byte boundary.</td>
</tr>
<tr>
<td>STATUS_BUFFER_TOO_SMALL</td>
<td>The output buffer is too small to contain a <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structure.</td>
</tr>
<tr>
<td>STATUS_BUFFER_OVERFLOW</td>
<td>The output buffer is too small to contain the required number of <strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong> structures.</td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<p><strong><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></strong></p>
<p><strong><a href="fltfscontrolfile" title="NTSTATUS FLTAPI FltFsControlFile(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PFILE_OBJECT  FileObject,&#10;  [in]            ULONG         FsControlCode,&#10;  [in, optional]  PVOID         InputBuffer,&#10;  [in]            ULONG         InputBufferLength,&#10;  [out, optional] PVOID         OutputBuffer,&#10;  [in]            ULONG         OutputBufferLength,&#10;  [out, optional] PULONG        LengthReturned&#10;);">FltFsControlFile</a></strong></p>
<p><strong><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">ZwFsControlFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ni-ntifs-fsctl_query_allocated_ranges">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/ni-ntifs-fsctl_query_allocated_ranges.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (ni-winioctl-fsctl_query_allocated_ranges)</h1>
</div>
<div class="ntdoc-description">
<h1>FSCTL_QUERY_ALLOCATED_RANGES IOCTL</h1>
<h2>Description</h2>
<p>Scans a file or alternate stream looking for ranges that may contain nonzero data. Only compressed or sparse files can have zeroed ranges known to the operating system. For other files, the output buffer will contain only a single entry that contains the starting point and the length requested.
To perform this operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> function with the following parameters.</p>
<pre><code>BOOL DeviceIoControl(
  (HANDLE) hDevice,                 // handle to file
  FSCTL_QUERY_ALLOCATED_RANGES,     // dwIoControlCode
  (LPVOID) lpInBuffer,              // input buffer
  (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>) nInBufferSize,            // size of input buffer
  (LPVOID) lpOutBuffer,             // output buffer
  (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>) nOutBufferSize,           // size of output buffer
  (LPDWORD) lpBytesReturned,        // number of bytes returned
  (LPOVERLAPPED) lpOverlapped       // OVERLAPPED structure
);
</code></pre>
<h2>Parameters</h2>
<h3>Input buffer</h3>
<h3>Input buffer length</h3>
<h3>Output buffer</h3>
<h3>Output buffer length</h3>
<h3>Input/output buffer</h3>
<h3>Input/output buffer length</h3>
<h3>Status block</h3>
<p>Irp-&gt;IoStatus.Status is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the request is successful.</p>
<p>Otherwise, Status to the appropriate error condition as a <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code.</p>
<p>For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/ntstatus-values">NTSTATUS Values</a>.</p>
<h2>Remarks</h2>
<p>For the implications of overlapped I/O on this operation, see the Remarks section of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>.</p>
<p>The NTFS file system rounds the input file offset down to a convenient boundary and the length up to a convenient boundary and then begins to walk through the file.</p>
<p>The operating system does not track every piece of zero (0) or nonzero data. Because zero (0) is often a perfectly legal datum, it would be misleading. Instead, the system tracks ranges where disk space is allocated. Where no disk space is allocated, all data are assumed to be zero (0). Allocated storage can contain zero (0) or nonzero data. So all this operation does is return information about parts of the file where nonzero data may be located. It is up to the application to scan these parts of the file in accordance with the application's data conventions.</p>
<p>Each entry in the output array contains an offset and a length that indicates a range in the file that may contain nonzero data. The actual nonzero data, if any, is somewhere within this range, and the calling program must scan further within the range to locate it and determine if it really is valid data. Multiple instances of valid data may exist within the range.</p>
<p>Allocated ranges are subject to the rule that a memory mapped remote (network) file and an open handle to the file are not necessarily coherent. If you memory mapped a sparse network file and wrote nonzero data to previously unallocated regions of the file, disk space would be allocated for the new data. However, a call to <strong>FSCTL_QUERY_ALLOCATED_RANGES</strong> thereafter would not necessarily return a correct list of allocated regions. To ensure coherency between the view memory and the file handle, flush the data to the file with the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-flushviewoffile">FlushViewOfFile</a> function.</p>
<p>In Windows 8 and Windows Server 2012, this code is supported by the following technologies.</p>
<table>
<thead>
<tr>
<th>Technology</th>
<th>Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server Message Block (SMB) 3.0 protocol</td>
<td>Yes</td>
</tr>
<tr>
<td>SMB 3.0 Transparent Failover (TFO)</td>
<td>Yes</td>
</tr>
<tr>
<td>SMB 3.0 with Scale-out File Shares (SO)</td>
<td>Yes</td>
</tr>
<tr>
<td>Cluster Shared Volume File System (CsvFS)</td>
<td>Yes</td>
</tr>
<tr>
<td>Resilient File System (ReFS)</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a></li>
<li><a href="file_allocated_range_buffer" title="typedef struct _FILE_ALLOCATED_RANGE_BUFFER {&#10;  LARGE_INTEGER FileOffset;&#10;  LARGE_INTEGER Length;&#10;} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;">FILE_ALLOCATED_RANGE_BUFFER</a></li>
<li><a href="fsctl_set_sparse" title="// CTL_CODE(0x0009, 0x031, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_SET_SPARSE 0x000900C4">FSCTL_SET_SPARSE</a></li>
<li><a href="fsctl_set_zero_data" title="// CTL_CODE(0x0009, 0x032, METHOD_BUFFERED, FILE_WRITE_ACCESS)&#10;#define FSCTL_SET_ZERO_DATA 0x000980C8">FSCTL_SET_ZERO_DATA</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/file-management-control-codes">File Management Control Codes</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/sparse-files">Sparse Files</a></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_query_allocated_ranges">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winioctl/ni-winioctl-fsctl_query_allocated_ranges.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
