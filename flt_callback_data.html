<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FLT_CALLBACK_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FLT_CALLBACK_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FLT_CALLBACK_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _FLT_CALLBACK_DATA {
  FLT_CALLBACK_DATA_FLAGS     Flags;
  PETHREAD                    Thread;
  <a href="flt_io_parameter_block" title="typedef struct _FLT_IO_PARAMETER_BLOCK {&#10;  ULONG          IrpFlags;&#10;  UCHAR          MajorFunction;&#10;  UCHAR          MinorFunction;&#10;  UCHAR          OperationFlags;&#10;  UCHAR          Reserved;&#10;  PFILE_OBJECT   TargetFileObject;&#10;  PFLT_INSTANCE  TargetInstance;&#10;  FLT_PARAMETERS Parameters;&#10;} FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;">PFLT_IO_PARAMETER_BLOCK</a>     Iopb;
  <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a>             IoStatus;
  <a href="flt_tag_data_buffer" title="typedef struct _FLT_TAG_DATA_BUFFER {&#10;  ULONG  FileTag;&#10;  USHORT TagDataLength;&#10;  USHORT UnparsedNameLength;&#10;  union {&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      ULONG  Flags;&#10;      WCHAR  PathBuffer[1];&#10;    } SymbolicLinkReparseBuffer;&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      WCHAR  PathBuffer[1];&#10;    } MountPointReparseBuffer;&#10;...">struct _FLT_TAG_DATA_BUFFER</a> *TagData;
  union {
    struct {
      <a href="list_entry" title="typedef struct _LIST_ENTRY LIST_ENTRY, *PLIST_ENTRY;">LIST_ENTRY</a> QueueLinks;
      PVOID      QueueContext[2];
    };
    PVOID FilterContext[4];
  };
  KPROCESSOR_MODE             RequestorMode;
} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_callback_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/flt_callback_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-fltkernel-_flt_callback_data)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="flt_callback_data-structure">FLT_CALLBACK_DATA structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>FLT_CALLBACK_DATA</strong> structure represents an I/O operation. The Filter Manager and minifilters use this structure to initiate and process I/O operations.</p>

<h2 id="members">Members</h2>

<h3 id="flags"><code>Flags</code></h3>

<p>Bitmask of flags describing the I/O operation.</p>

<p>Minifilters can set the following flag.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="fltfl_callback_data_dirty" title="#define FLTFL_CALLBACK_DATA_DIRTY 0x80000000 // Set by caller if parameters were changed">FLTFL_CALLBACK_DATA_DIRTY</a></td>
  <td>A minifilter sets this flag (by calling <strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong>) to indicate that it has modified the contents of the callback data structure. (For more information, see the following Remarks section.)</td>
</tr>
</tbody>
</table>

<blockquote>
  <p>[!NOTE]
  Only the Filter Manager can set the following flags.</p>
</blockquote>

<p>When the Filter Manager initializes the callback data structure, it sets one of the following flags to specify the type of I/O operation that the callback data structure represents.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="fltfl_callback_data_fast_io_operation" title="#define FLTFL_CALLBACK_DATA_FAST_IO_OPERATION 0x00000002 // Set for Fast Io operations">FLTFL_CALLBACK_DATA_FAST_IO_OPERATION</a></td>
  <td>The callback data structure represents a fast I/O operation.</td>
</tr>
<tr>
  <td><a href="fltfl_callback_data_fs_filter_operation" title="#define FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION 0x00000004 // Set for Fs Filter operations">FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION</a></td>
  <td>The callback data structure represents a file system minifilter callback operation.</td>
</tr>
<tr>
  <td><a href="fltfl_callback_data_irp_operation" title="#define FLTFL_CALLBACK_DATA_IRP_OPERATION 0x00000001 // Set for Irp operations">FLTFL_CALLBACK_DATA_IRP_OPERATION</a></td>
  <td>The callback data structure represents an I/O request packet (<a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>)-based operation.</td>
</tr>
</tbody>
</table>

<blockquote>
  <p>[!NOTE]
  Only the Filter Manager can set the following flags.</p>
</blockquote>

<p>When the Filter Manager initializes the callback data structure, it can also set the following flags.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="fltfl_callback_data_generated_io" title="#define FLTFL_CALLBACK_DATA_GENERATED_IO 0x00010000 // Set if this is I/O generated by a mini-filter">FLTFL_CALLBACK_DATA_GENERATED_IO</a></td>
  <td>The callback data structure represents an I/O operation that was generated by a minifilter. This flag is valid only for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations.</td>
</tr>
<tr>
  <td><a href="fltfl_callback_data_reissued_io" title="#define FLTFL_CALLBACK_DATA_REISSUED_IO 0x00020000 // Set if this I/O was reissued">FLTFL_CALLBACK_DATA_REISSUED_IO</a></td>
  <td>The callback data structure represents an I/O operation that is being reissued by a minifilter. (To reissue an I/O operation, a minifilter calls <strong><a href="fltreissuesynchronousio" title="VOID FLTAPI FltReissueSynchronousIo(&#10;  [in] PFLT_INSTANCE      InitiatingInstance,&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltReissueSynchronousIo</a></strong>.) This flag is valid only for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations.</td>
</tr>
<tr>
  <td><a href="fltfl_callback_data_system_buffer" title="#define FLTFL_CALLBACK_DATA_SYSTEM_BUFFER 0x00000008 // Set if the buffer passed in for the i/o was a system buffer">FLTFL_CALLBACK_DATA_SYSTEM_BUFFER</a></td>
  <td>The buffer for the I/O operation was allocated from nonpaged pool. This flag can be set for any type of I/O operation. Minifilters must never set this flag.</td>
</tr>
</tbody>
</table>

<blockquote>
  <p>[!NOTE]
  Only the Filter Manager can set the following flags.</p>
</blockquote>

<p>When the Filter Manager performs completion processing for the I/O operation that the callback data structure represents, it sets one or both of the following flags.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="fltfl_callback_data_draining_io" title="#define FLTFL_CALLBACK_DATA_DRAINING_IO 0x00040000 // set if this operation is being drained. If set,">FLTFL_CALLBACK_DATA_DRAINING_IO</a></td>
  <td>The Filter Manager sets this flag to indicate that it is currently draining the completion node for the I/O operation. This flag is valid only during I/O completion.</td>
</tr>
<tr>
  <td><a href="fltfl_callback_data_post_operation" title="#define FLTFL_CALLBACK_DATA_POST_OPERATION 0x00080000 // Set if this is a POST operation">FLTFL_CALLBACK_DATA_POST_OPERATION</a></td>
  <td>The Filter Manager sets this flag to indicate that it is currently calling registered post-operation callback (<strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong>) routines for the operation. This flag is valid only during I/O completion.</td>
</tr>
</tbody>
</table>

<h3 id="thread"><code>Thread</code></h3>

<p>Pointer to the thread that initiated the I/O operation. This field may be NULL.</p>

<h3 id="iopb"><code>Iopb</code></h3>

<p>Pointer to an <strong><a href="flt_io_parameter_block" title="typedef struct _FLT_IO_PARAMETER_BLOCK {&#10;  ULONG          IrpFlags;&#10;  UCHAR          MajorFunction;&#10;  UCHAR          MinorFunction;&#10;  UCHAR          OperationFlags;&#10;  UCHAR          Reserved;&#10;  PFILE_OBJECT   TargetFileObject;&#10;  PFLT_INSTANCE  TargetInstance;&#10;  FLT_PARAMETERS Parameters;&#10;} FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;">FLT_IO_PARAMETER_BLOCK</a></strong> structure that contains the parameters for the I/O operation.</p>

<h3 id="iostatus"><code>IoStatus</code></h3>

<p>An <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that contains status and information for the I/O operation. A minifilter can modify the contents of this structure only in a pre-operation callback (<strong><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></strong>) routine from which it is about to return FLT_PREOP_COMPLETE or in a post-operation callback (<strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong>) routine from which it is about to return FLT_POSTOP_FINISHED_PROCESSING. Otherwise, the contents of this structure are normally set by the Filter Manager.</p>

<h3 id="tagdata"><code>TagData</code></h3>

<p>Pointer to an <strong><a href="flt_tag_data_buffer" title="typedef struct _FLT_TAG_DATA_BUFFER {&#10;  ULONG  FileTag;&#10;  USHORT TagDataLength;&#10;  USHORT UnparsedNameLength;&#10;  union {&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      ULONG  Flags;&#10;      WCHAR  PathBuffer[1];&#10;    } SymbolicLinkReparseBuffer;&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      WCHAR  PathBuffer[1];&#10;    } MountPointReparseBuffer;&#10;...">FLT_TAG_DATA_BUFFER</a></strong> structure that contains reparse point data for the I/O operation. This pointer is valid only in the post-create path. Thus only a minifilter's post-operation callback routine can change the value of this member. A minifilter's post-create callback routine can change this member to point to a different <strong><a href="flt_tag_data_buffer" title="typedef struct _FLT_TAG_DATA_BUFFER {&#10;  ULONG  FileTag;&#10;  USHORT TagDataLength;&#10;  USHORT UnparsedNameLength;&#10;  union {&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      ULONG  Flags;&#10;      WCHAR  PathBuffer[1];&#10;    } SymbolicLinkReparseBuffer;&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      WCHAR  PathBuffer[1];&#10;    } MountPointReparseBuffer;&#10;...">FLT_TAG_DATA_BUFFER</a></strong> structure. However, if it changes the member to point to a different structure, it must first call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong> to free the existing structure to prevent a pool memory leak.</p>

<h3 id="queuelinks"><code>QueueLinks</code></h3>

<p>Queue links that a minifilter can use when the Filter Manager's callback data queue is used to pend the I/O operation.</p>

<h3 id="queuecontext"><code>QueueContext</code></h3>

<p>Array of context information pointers that a minifilter can use when the Filter Manager's queue is used to pend the I/O operation.</p>

<h3 id="filtercontext"><code>FilterContext</code></h3>

<p>Array of context information pointers that a minifilter can use when a queue other than the Filter Manager's queue is used to pend the I/O operation.</p>

<h3 id="requestormode"><code>RequestorMode</code></h3>

<p>Indicates the execution mode of the process that initiated the I/O operation, either <strong>KernelMode</strong> or <strong>UserMode</strong>.</p>

<h2 id="remarks">Remarks</h2>

<p>A minifilter registers pre-operation (<strong><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></strong>) and post-operation (<strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong>) callback routines for one or more types of I/O operations. When the Filter Manager calls one of these callback routines, it passes a callback data (FLT_CALLBACK_DATA) structure as the first parameter. This structure represents the I/O operation.</p>

<p>A minifilter's pre-operation or post-operation callback routine can modify the contents of the callback data structure, except for the <strong>Thread</strong> and <strong>RequestorMode</strong> members. If it does, it must then call <strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong>, unless it has also modified the contents of the <strong>IoStatus</strong> member. Otherwise, the modified values are ignored.</p>

<p>A minifilter can initiate an I/O operation by calling a support routine such as <strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong> or by calling <strong><a href="fltallocatecallbackdata" title="NTSTATUS FLTAPI FltAllocateCallbackData(&#10;  [in]           PFLT_INSTANCE      Instance,&#10;  [in, optional] PFILE_OBJECT       FileObject,&#10;  [out]          PFLT_CALLBACK_DATA *RetNewCallbackData&#10;);">FltAllocateCallbackData</a></strong> to allocate a callback data structure; initializing the structure's I/O parameters, and passing the structure to <strong><a href="fltperformsynchronousio" title="VOID FLTAPI FltPerformSynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA CallbackData&#10;);">FltPerformSynchronousIo</a></strong> or <strong><a href="fltperformasynchronousio" title="NTSTATUS FLTAPI FltPerformAsynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA               CallbackData,&#10;  [in]      PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in]      PVOID                            CallbackContext&#10;);">FltPerformAsynchronousIo</a></strong>.</p>

<p>A minifilter-initiated I/O operation is sent only to the minifilter instances attached below the calling instance, and to the file system. Minifilters attached above the specified instance do not receive the I/O operation.</p>

<p>Minifilters can only initiate <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based I/O operations. They cannot initiate fast I/O or file system filter (FSFilter) callback operations.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="flt_io_parameter_block" title="typedef struct _FLT_IO_PARAMETER_BLOCK {&#10;  ULONG          IrpFlags;&#10;  UCHAR          MajorFunction;&#10;  UCHAR          MinorFunction;&#10;  UCHAR          OperationFlags;&#10;  UCHAR          Reserved;&#10;  PFILE_OBJECT   TargetFileObject;&#10;  PFLT_INSTANCE  TargetInstance;&#10;  FLT_PARAMETERS Parameters;&#10;} FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;">FLT_IO_PARAMETER_BLOCK</a></strong></p>

<p><strong><a href="flt_is_fastio_operation" title="void FLT_IS_FASTIO_OPERATION(&#10;  [in] Data&#10;);">FLT_IS_FASTIO_OPERATION</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544648(v=vs.85)"><strong>FLT_IS_FS_FILTER_OPERATION</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)"><strong>FLT_IS_IRP_OPERATION</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544660(v=vs.85)"><strong>FLT_IS_REISSUED_IO</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544663(v=vs.85)"><strong>FLT_IS_SYSTEM_BUFFER</strong></a></p>

<p><strong><a href="flt_registration" title="typedef struct _FLT_REGISTRATION {&#10;  USHORT                                      Size;&#10;  USHORT                                      Version;&#10;  FLT_REGISTRATION_FLAGS                      Flags;&#10;  const FLT_CONTEXT_REGISTRATION              *ContextRegistration;&#10;  const FLT_OPERATION_REGISTRATION            *OperationRegistration;&#10;  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;&#10;  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;&#10;  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback;&#10;  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;&#10;  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;&#10;  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;&#10;  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;&#10;} FLT_REGISTRATION, *PFLT_REGISTRATION;">FLT_REGISTRATION</a></strong></p>

<p><strong><a href="flt_related_objects" title="typedef struct _FLT_RELATED_OBJECTS {&#10;  USHORT        Size;&#10;  USHORT        TransactionContext;&#10;  PFLT_FILTER   Filter;&#10;  PFLT_VOLUME   Volume;&#10;  PFLT_INSTANCE Instance;&#10;  PFILE_OBJECT  FileObject;&#10;  PKTRANSACTION Transaction;&#10;} FLT_RELATED_OBJECTS, *PFLT_RELATED_OBJECTS;">FLT_RELATED_OBJECTS</a></strong></p>

<p><strong><a href="flt_tag_data_buffer" title="typedef struct _FLT_TAG_DATA_BUFFER {&#10;  ULONG  FileTag;&#10;  USHORT TagDataLength;&#10;  USHORT UnparsedNameLength;&#10;  union {&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      ULONG  Flags;&#10;      WCHAR  PathBuffer[1];&#10;    } SymbolicLinkReparseBuffer;&#10;    struct {&#10;      USHORT SubstituteNameOffset;&#10;      USHORT SubstituteNameLength;&#10;      USHORT PrintNameOffset;&#10;      USHORT PrintNameLength;&#10;      WCHAR  PathBuffer[1];&#10;    } MountPointReparseBuffer;&#10;...">FLT_TAG_DATA_BUFFER</a></strong></p>

<p><strong><a href="fltallocatecallbackdata" title="NTSTATUS FLTAPI FltAllocateCallbackData(&#10;  [in]           PFLT_INSTANCE      Instance,&#10;  [in, optional] PFILE_OBJECT       FileObject,&#10;  [out]          PFLT_CALLBACK_DATA *RetNewCallbackData&#10;);">FltAllocateCallbackData</a></strong></p>

<p><strong><a href="fltfreecallbackdata" title="VOID FLTAPI FltFreeCallbackData(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltFreeCallbackData</a></strong></p>

<p><strong><a href="fltperformasynchronousio" title="NTSTATUS FLTAPI FltPerformAsynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA               CallbackData,&#10;  [in]      PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in]      PVOID                            CallbackContext&#10;);">FltPerformAsynchronousIo</a></strong></p>

<p><strong><a href="fltperformsynchronousio" title="VOID FLTAPI FltPerformSynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA CallbackData&#10;);">FltPerformSynchronousIo</a></strong></p>

<p><strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong></p>

<p><strong><a href="fltreissuesynchronousio" title="VOID FLTAPI FltReissueSynchronousIo(&#10;  [in] PFLT_INSTANCE      InitiatingInstance,&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltReissueSynchronousIo</a></strong></p>

<p><strong><a href="fltreusecallbackdata" title="VOID FLTAPI FltReuseCallbackData(&#10;  [in, out] PFLT_CALLBACK_DATA CallbackData&#10;);">FltReuseCallbackData</a></strong></p>

<p><strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong></p>

<p><strong><a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a></strong></p>

<p><strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong></p>

<p><strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong></p>

<p><strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong></p>

<p><strong><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_callback_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/ns-fltkernel-_flt_callback_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
