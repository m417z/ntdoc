<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PCREATE_COMMON_BUFFER_FROM_MDL - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PCREATE_COMMON_BUFFER_FROM_MDL - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PCREATE_COMMON_BUFFER_FROM_MDL - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wdm.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">PCREATE_COMMON_BUFFER_FROM_MDL PcreateCommonBufferFromMdl;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PcreateCommonBufferFromMdl(
  [in]  PDMA_ADAPTER DmaAdapter,
  [in]  <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a> Mdl,
  [in]  <a href="dma_common_buffer_extended_configuration" title="typedef struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {&#10;  DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE ConfigType;&#10;  union {&#10;    struct {&#10;      PHYSICAL_ADDRESS MinimumAddress;&#10;      PHYSICAL_ADDRESS MaximumAddress;&#10;    } LogicalAddressLimits;&#10;    struct {&#10;      ULONGLONG Offset;&#10;      ULONG     Length;&#10;    } SubSection;&#10;    DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE HardwareAccessType;&#10;    ULONGLONG                                            Reserved[4];&#10;  };&#10;} DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION, *PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;">PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION</a> ExtendedConfigs,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ExtendedConfigsCount,
  [out] <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PPHYSICAL_ADDRESS</a> LogicalAddress
)
{...}</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcreate-common-buffer-from-mdl">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pcreate_common_buffer_from_mdl.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wdm-pcreate-common-buffer-from-mdl)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p>The CreateCommonBufferFromMdl routine will attempt to create a common buffer from an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> by testing for device access compatibility and potentially mapping the memory to a contiguous logical range depending on the translation type. Like all other common buffer allocation functions, this function does not provide a forward progress guarantee.</p>
<h2>Parameters</h2>
<h3><code>DmaAdapter</code> [in]</h3>
<p>Provides a pointer to the DMA Adapter that is performing the operation.</p>
<h3><code>Mdl</code> [in]</h3>
<p>Provides the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that will be mapped to a common buffer.</p>
<p>For an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to be able to back a common buffer, the following conditions must be met:</p>
<ul>
<li>
<p>The <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must have pages that are always resident for the lifetime of the common buffer and that are mapped into the system address space. This can be accomplished by the following approaches:</p>
</li>
<li>
<p>The <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is created from a buffer in the non-paged pool via <em><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></em>.</p>
</li>
<li>
<p>The <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> has been locked via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmprobeandlockselectedpages"><em>MmProbeAndLockPages</em></a> and mapped to system space via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer#mmgetsystemaddressformdlsafe"><em>MmGetSystemAddressForMdlSafe</em></a>.</p>
</li>
<li>
<p>The physical pages for the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> have been allocated via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatepagesformdl"><em>MmAllocatePagesForMdlEx</em></a> and mapped to system space via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer#mmgetsystemaddressformdlsafe"><em>MmGetSystemAddressForMdlSafe</em></a>.</p>
</li>
<li>
<p>The <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must represent a page-aligned region and be a multiple of <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a>.</p>
<ul>
<li>If the SubSection extended configuration is being used, then the portion of the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> being used must be page-aligned and be a multiple of <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a>.</li>
</ul>
</li>
<li>
<p>The <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must not be a chained <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>
<ul>
<li>If the SubSection extended configuration is being used, then a chained <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> can be provided, but the portion of the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> being used must be contained in a single <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> in the chain.</li>
</ul>
</li>
<li>
<p>If DMA Remapping is not being used, the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must represent physically contiguous memory and be accessible to the device.</p>
</li>
</ul>
<h3><code>ExtendedConfigs</code> [in]</h3>
<p>Provides an optional array of <a href="dma_common_buffer_extended_configuration" title="typedef struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {&#10;  DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE ConfigType;&#10;  union {&#10;    struct {&#10;      PHYSICAL_ADDRESS MinimumAddress;&#10;      PHYSICAL_ADDRESS MaximumAddress;&#10;    } LogicalAddressLimits;&#10;    struct {&#10;      ULONGLONG Offset;&#10;      ULONG     Length;&#10;    } SubSection;&#10;    DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE HardwareAccessType;&#10;    ULONGLONG                                            Reserved[4];&#10;  };&#10;} DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION, *PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;">DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION</a> structures to further configure the creation of the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> backed common buffer.</p>
<p>If multiple configurations of the same <a href="dma_common_buffer_extended_configuration_type" title="typedef enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE {&#10;  CommonBufferConfigTypeLogicalAddressLimits,&#10;  CommonBufferConfigTypeSubSection,&#10;  CommonBufferConfigTypeHardwareAccessPermissions,&#10;  CommonBufferConfigTypeMax&#10;} DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE, *PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;">DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE</a> are provided in the array, creation will fail.</p>
<h3><code>ExtendedConfigsCount</code> [in]</h3>
<p>Provides the number of extended configurations in the <em>ExtendedConfigs</em> array.</p>
<h3><code>LogicalAddress</code> [out]</h3>
<p>On success provides the logical address of the resulting common buffer.</p>
<h2>Return value</h2>
<p><strong>CreateCommonBufferFromMdl</strong> return <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong> if the call is successful. Possible error return values include the following status codes.</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>STATUS_INVALID_PARAMETER</strong></td>
<td>The caller has provided an incompatible <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> or extended configuration.</td>
</tr>
<tr>
<td><strong>STATUS_NOT_SUPPORTED</strong></td>
<td>The caller has provided an extended configuration that is not supported on the current system.</td>
</tr>
<tr>
<td><strong>STATUS_INSUFFICIENT_RESOURCES</strong></td>
<td>The system does not have enough memory to create book-keeping and mapping metadata.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p><strong>CreateCommonBufferFromMdl</strong> is not a system routine that can be called directly by name. This routine can be called only by pointer from the address returned in a <em><a href="dma_operations" title="typedef struct _DMA_OPERATIONS {&#10;  ULONG                                   Size;&#10;  PPUT_DMA_ADAPTER                        PutDmaAdapter;&#10;  PALLOCATE_COMMON_BUFFER                 AllocateCommonBuffer;&#10;  PFREE_COMMON_BUFFER                     FreeCommonBuffer;&#10;  PALLOCATE_ADAPTER_CHANNEL               AllocateAdapterChannel;&#10;  PFLUSH_ADAPTER_BUFFERS                  FlushAdapterBuffers;&#10;  PFREE_ADAPTER_CHANNEL                   FreeAdapterChannel;&#10;  PFREE_MAP_REGISTERS                     FreeMapRegisters;&#10;  PMAP_TRANSFER                           MapTransfer;&#10;  PGET_DMA_ALIGNMENT                      GetDmaAlignment;&#10;  PREAD_DMA_COUNTER                       ReadDmaCounter;&#10;  PGET_SCATTER_GATHER_LIST                GetScatterGatherList;&#10;  PPUT_SCATTER_GATHER_LIST                PutScatterGatherList;&#10;  PCALCULATE_SCATTER_GATHER_LIST_SIZE     CalculateScatterGatherList;&#10;  PBUILD_SCATTER_GATHER_LIST              BuildScatterGatherList;&#10;  PBUILD_MDL_FROM_SCATTER_GATHER_LIST     BuildMdlFromScatterGatherList;&#10;  PGET_DMA_ADAPTER_INFO                   GetDmaAdapterInfo;&#10;  PGET_DMA_TRANSFER_INFO                  GetDmaTransferInfo;&#10;  PINITIALIZE_DMA_TRANSFER_CONTEXT        InitializeDmaTransferContext;&#10;...">DMA_OPERATIONS</a></em> structure. Drivers obtain the address of this routine by calling <a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a> with the <strong>Version</strong> member of the <em>DeviceDescription</em> parameter set to DEVICE_DESCRIPTION_VERSION3. If <strong><a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a></strong> returns <strong>NULL</strong>, the routine is not available on your platform.</p>
<p>A common buffer created by <strong>CreateCommonBufferFromMdl</strong> will be removed via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pfree_common_buffer">FreeCommonBuffer</a>. The caller must provide the system virtual address as the virtual address to ensure the common buffer is correctly removed from the Adapter's common buffer bookkeeping structures. The driver is still responsible for unlocking and freeing the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> and its backing pages.</p>
<p>To create a common buffer where the HAL is responsible for maintaining the backing memory, use <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pallocate_common_buffer_with_bounds">AllocateCommonBufferWithBounds</a>.</p>
<h2>See also</h2>
<p><strong><a href="padapter_object" title="typedef struct _DMA_ADAPTER {&#10;  USHORT          Version;&#10;  USHORT          Size;&#10;  PDMA_OPERATIONS DmaOperations;&#10;} *PADAPTER_OBJECT, DMA_ADAPTER, *PDMA_ADAPTER;">DMA_ADAPTER</a></strong></p>
<p><strong><a href="dma_common_buffer_extended_configuration" title="typedef struct _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION {&#10;  DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE ConfigType;&#10;  union {&#10;    struct {&#10;      PHYSICAL_ADDRESS MinimumAddress;&#10;      PHYSICAL_ADDRESS MaximumAddress;&#10;    } LogicalAddressLimits;&#10;    struct {&#10;      ULONGLONG Offset;&#10;      ULONG     Length;&#10;    } SubSection;&#10;    DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_ACCESS_TYPE HardwareAccessType;&#10;    ULONGLONG                                            Reserved[4];&#10;  };&#10;} DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION, *PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION;">DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION</a></strong></p>
<p><a href="dma_common_buffer_extended_configuration_type" title="typedef enum _DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE {&#10;  CommonBufferConfigTypeLogicalAddressLimits,&#10;  CommonBufferConfigTypeSubSection,&#10;  CommonBufferConfigTypeHardwareAccessPermissions,&#10;  CommonBufferConfigTypeMax&#10;} DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE, *PDMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE;">DMA_COMMON_BUFFER_EXTENDED_CONFIGURATION_TYPE</a></p>
<p><strong><a href="dma_operations" title="typedef struct _DMA_OPERATIONS {&#10;  ULONG                                   Size;&#10;  PPUT_DMA_ADAPTER                        PutDmaAdapter;&#10;  PALLOCATE_COMMON_BUFFER                 AllocateCommonBuffer;&#10;  PFREE_COMMON_BUFFER                     FreeCommonBuffer;&#10;  PALLOCATE_ADAPTER_CHANNEL               AllocateAdapterChannel;&#10;  PFLUSH_ADAPTER_BUFFERS                  FlushAdapterBuffers;&#10;  PFREE_ADAPTER_CHANNEL                   FreeAdapterChannel;&#10;  PFREE_MAP_REGISTERS                     FreeMapRegisters;&#10;  PMAP_TRANSFER                           MapTransfer;&#10;  PGET_DMA_ALIGNMENT                      GetDmaAlignment;&#10;  PREAD_DMA_COUNTER                       ReadDmaCounter;&#10;  PGET_SCATTER_GATHER_LIST                GetScatterGatherList;&#10;  PPUT_SCATTER_GATHER_LIST                PutScatterGatherList;&#10;  PCALCULATE_SCATTER_GATHER_LIST_SIZE     CalculateScatterGatherList;&#10;  PBUILD_SCATTER_GATHER_LIST              BuildScatterGatherList;&#10;  PBUILD_MDL_FROM_SCATTER_GATHER_LIST     BuildMdlFromScatterGatherList;&#10;  PGET_DMA_ADAPTER_INFO                   GetDmaAdapterInfo;&#10;  PGET_DMA_TRANSFER_INFO                  GetDmaTransferInfo;&#10;  PINITIALIZE_DMA_TRANSFER_CONTEXT        InitializeDmaTransferContext;&#10;...">DMA_OPERATIONS</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pfree_common_buffer">FreeCommonBuffer</a></p>
<p><a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a></p>
<p><a href="pallocate_common_buffer_with_bounds" title="PALLOCATE_COMMON_BUFFER_WITH_BOUNDS PallocateCommonBufferWithBounds;&#10;&#10;PVOID PallocateCommonBufferWithBounds(&#10;  [in]           PDMA_ADAPTER DmaAdapter,&#10;  [in, optional] PPHYSICAL_ADDRESS MinimumAddress,&#10;  [in, optional] PPHYSICAL_ADDRESS MaximumAddress,&#10;  [in]           ULONG Length,&#10;  [in]           ULONG Flags,&#10;  [in, optional] MEMORY_CACHING_TYPE *CacheType,&#10;  [in]           NODE_REQUIREMENT PreferredNode,&#10;  [out]          PPHYSICAL_ADDRESS LogicalAddress&#10;)&#10;{...}">PALLOCATE_COMMON_BUFFER_WITH_BOUNDS</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcreate-common-buffer-from-mdl">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nc-wdm-pcreate-common-buffer-from-mdl.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
