<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_CONTROL_SOCKET - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_CONTROL_SOCKET - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_CONTROL_SOCKET - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFN_WSK_CONTROL_SOCKET PfnWskControlSocket;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskControlSocket(
  [in]            <a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">PWSK_SOCKET</a> Socket,
  [in]            WSK_CONTROL_SOCKET_TYPE RequestType,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ControlCode,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Level,
  [in]            <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> InputSize,
  [in, optional]  PVOID InputBuffer,
  [in]            <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> OutputSize,
  [out, optional] PVOID OutputBuffer,
  [out, optional] <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> *OutputSizeReturned,
  [in, out]       PIRP Irp
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_socket">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_control_socket.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_control_socket)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfn_wsk_control_socket-callback-function">PFN_WSK_CONTROL_SOCKET callback function</h1>

<h2 id="description">Description</h2>

<p>The
<strong>WskControlSocket</strong> function performs control operations on a socket.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="socket-in"><code>Socket</code> [in]</h3>

<p>A pointer to a
<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a> structure that specifies the socket
object for the socket on which the control operation is being performed.</p>

<h3 id="requesttype-in"><code>RequestType</code> [in]</h3>

<p>A value that specifies the type of control operation that is being performed. A WSK application
sets this parameter to one of the following values:</p>

<h4 id="wsksetoption">WskSetOption</h4>

<p>Set the state or value for a socket option.</p>

<h4 id="wskgetoption">WskGetOption</h4>

<p>Get the state or value of a socket option.</p>

<h4 id="wskioctl">WskIoctl</h4>

<p>Perform an I/O control operation.</p>

<h3 id="controlcode-in"><code>ControlCode</code> [in]</h3>

<p>If the
<em>RequestType</em> parameter is set to
<strong>WskSetOption</strong> or
<strong>WskGetOption</strong>, the
<em>ControlCode</em> parameter specifies the particular socket option whose value is being set or
retrieved. For more information about socket options that are supported by the WSK subsystem, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">WSK Socket Options</a>. The underlying
network protocol might support additional socket options.</p>

<p>If the
<em>RequestType</em> parameter is set to
<strong>WskIoctl</strong>, the
<em>ControlCode</em> parameter specifies the particular I/O control operation that is being performed. For
more information about I/O control operations that are supported by the WSK subsystem, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-query-ideal-send-backlog">WSK Socket IOCTL Operations</a>. The
underlying network protocol might support additional socket I/O control operations.</p>

<h3 id="level-in"><code>Level</code> [in]</h3>

<p>The level in the network stack at which the value for a socket option is being either set or
retrieved. For WSK subsystem level socket options, the WSK application should set this parameter to
SOL_SOCKET. For transport protocol or network protocol level socket options, the WSK application should
set this parameter to the appropriate level for the underlying transport.</p>

<p>If the
<em>RequestType</em> parameter is set to
<strong>WskIoctl</strong>, the
<em>Level</em> parameter is ignored.</p>

<h3 id="inputsize-in"><code>InputSize</code> [in]</h3>

<p>The number of bytes of data in the buffer that is pointed to by the
<em>InputBuffer</em> parameter.</p>

<h3 id="inputbuffer-in-optional"><code>InputBuffer</code> [in, optional]</h3>

<p>A caller-allocated buffer that supplies any input data that is required to perform the specified
control operation. If no input data is required for the specified control operation, the WSK application
should set this parameter to <strong>NULL</strong> and set the
<em>InputSize</em> parameter to zero.</p>

<h3 id="outputsize-in"><code>OutputSize</code> [in]</h3>

<p>The size of the buffer that is pointed to by the
<em>OutputBuffer</em> parameter.</p>

<h3 id="outputbuffer-out-optional"><code>OutputBuffer</code> [out, optional]</h3>

<p>A caller-allocated buffer that receives any output data that is returned by the specified control
operation. If no output data is returned by the specified control operation, the WSK application should
set this parameter to <strong>NULL</strong> and set the
<em>OutputSize</em> parameter to zero.</p>

<h3 id="outputsizereturned-out-optional"><code>OutputSizeReturned</code> [out, optional]</h3>

<p>A pointer to a <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>-typed variable that receives the number of bytes of data that is returned in
the buffer that is pointed to by the
<em>OutputBuffer</em> parameter. A WSK application should set the
<em>OutputSizeReturned</em> parameter to <strong>NULL</strong> except when all of the following are true:</p>

<ul>
<li>The
<em>Irp</em> parameter is set to <strong>NULL</strong>.</li>
<li>The operation that is being performed returns output data in the buffer that is pointed to by the
<em>OutputBuffer</em> parameter.</li>
<li>The number of bytes of output data that is returned by the operation that is being performed is
unknown.</li>
</ul>

<h3 id="irp-in-out"><code>Irp</code> [in, out]</h3>

<p>A pointer to a caller-allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that the WSK subsystem uses to complete the control operation
asynchronously. For more information about using IRPs with WSK functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions">Using IRPs with Winsock
Kernel Functions</a>.</p>

<p>If the
<em>RequestType</em> parameter is set to either
<strong>WskSetOption</strong> or
<strong>WskGetOption</strong>, the
<em>Irp</em> parameter is required, is optional, or must be <strong>NULL</strong> depending on the particular socket option
that is being set or retrieved. For more information about the requirements for the
<em>Irp</em> parameter for each of the supported socket options, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">WSK Socket Options</a>.</p>

<p>If the
<em>RequestType</em> parameter is set to
<strong>WskIoctl</strong>, the
<em>Irp</em> parameter is required, is optional, or must be <strong>NULL</strong> depending on the particular I/O control
operation that is being performed. For more information about the requirements for the
<em>Irp</em> parameter for each of the supported I/O control operations, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-query-ideal-send-backlog">WSK Socket IOCTL
Operations</a>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>WskControlSocket</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The control operation completed successfully. If the WSK application specified a pointer to an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> in the <em>Irp</em> parameter, the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with success status, and the number of bytes that is returned in the buffer that is pointed to by the <em>OutputBuffer</em> parameter will be returned in the <strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><strong>STATUS_PENDING</strong></td>
  <td>The WSK subsystem could not complete the control operation immediately. The WSK subsystem will complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> after it has completed the control operation. The status of the control operation will be returned in the <strong>IoStatus.Status</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. If the operation succeeds, the number of bytes that is returned in the buffer that is pointed to by the <em>OutputBuffer</em> parameter will be returned in the <strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><strong>STATUS_EVENT_PENDING</strong></td>
  <td>The WSK subsystem could not complete the control operation immediately. This value is returned only when a WSK application is disabling an event callback function on a socket when there are currently in-progress calls to that event callback function and when the <em>Irp</em> parameter is <strong>NULL</strong>. For more information about disabling event callback functions, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">SO_WSK_EVENT_CALLBACK</a>.</td>
</tr>
<tr>
  <td><strong>STATUS_FILE_FORCED_CLOSED</strong></td>
  <td>The socket is no longer functional. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status. The WSK application must call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a> function to close the socket as soon as possible.</td>
</tr>
<tr>
  <td><strong>Other status codes</strong></td>
  <td>An error occurred. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>If a WSK application specifies
<strong>WskSetOption</strong> or
<strong>WskGetOption</strong> in the
<em>RequestType</em> parameter, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">WSK Socket Options</a> for more information
about how the input and output buffers are used for each socket option.</p>

<p>If a WSK application specifies
<strong>WskIoctl</strong> in the
<em>RequestType</em> parameter, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-query-ideal-send-backlog">WSK Socket IOCTL Operations</a> for
more information about how the input and output buffers are used for each I/O control operation.</p>

<p>If the
<strong>WskControlSocket</strong> function returns STATUS_PENDING, any buffers that are pointed to by the
<em>InputBuffer</em> parameter or the
<em>OutputBuffer</em> parameter must remain valid until the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed. If the WSK application
allocated the buffers with one of the
<strong>ExAllocate*Xxx</strong>* functions, it cannot free the memory with the corresponding
<strong>ExFree*Xxx</strong>* function until after the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed. If the WSK application allocated the buffers on the
stack, it cannot return from the function that calls the
<strong>WskControlSocket</strong> function until after the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed.</p>

<p>Callers of the
<strong>WskControlSocket</strong> function must be running at IRQL &lt;= DISPATCH_LEVEL except when the
<em>RequestType</em> parameter is set to
<strong>WskIoctl</strong> and the
<em>ControlCode</em> parameter is set to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-address-list-query">SIO_ADDRESS_LIST_QUERY</a>,
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-address-list-change">SIO_ADDRESS_LIST_CHANGE</a>, or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/WinSock/using-sio-address-list-sort">SIO_ADDRESS_LIST_SORT</a>. In this
situation, callers must be running at IRQL = PASSIVE_LEVEL.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-query-ideal-send-backlog">WSK Socket IOCTL Operations</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">WSK Socket Options</a></p>

<p><a href="wsk_provider_basic_dispatch" title="typedef struct _WSK_PROVIDER_BASIC_DISPATCH {&#10;  PFN_WSK_CONTROL_SOCKET WskControlSocket;&#10;  PFN_WSK_CLOSE_SOCKET   WskCloseSocket;&#10;} WSK_PROVIDER_BASIC_DISPATCH, *PWSK_PROVIDER_BASIC_DISPATCH;">WSK_PROVIDER_BASIC_DISPATCH</a></p>

<p><a href="wsk_provider_connection_dispatch" title="typedef struct _WSK_PROVIDER_CONNECTION_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH          Basic;&#10;  PFN_WSK_BIND                         WskBind;&#10;  PFN_WSK_CONNECT                      WskConnect;&#10;  PFN_WSK_GET_LOCAL_ADDRESS            WskGetLocalAddress;&#10;  PFN_WSK_GET_REMOTE_ADDRESS           WskGetRemoteAddress;&#10;  PFN_WSK_SEND                         WskSend;&#10;  PFN_WSK_RECEIVE                      WskReceive;&#10;  PFN_WSK_DISCONNECT                   WskDisconnect;&#10;  PFN_WSK_RELEASE_DATA_INDICATION_LIST WskRelease;&#10;  PFN_WSK_CONNECT_EX                   WskConnectEx;&#10;  PFN_WSK_SEND_EX                      WskSendEx;&#10;  PFN_WSK_RECEIVE_EX                   WskReceiveEx;&#10;} WSK_PROVIDER_CONNECTION_DISPATCH, *PWSK_PROVIDER_CONNECTION_DISPATCH;">WSK_PROVIDER_CONNECTION_DISPATCH</a></p>

<p><a href="wsk_provider_datagram_dispatch" title="typedef struct _WSK_PROVIDER_DATAGRAM_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH              Basic;&#10;  PFN_WSK_BIND                             WskBind;&#10;  PFN_WSK_SEND_TO                          WskSendTo;&#10;  PFN_WSK_RECEIVE_FROM                     WskReceiveFrom;&#10;  PFN_WSK_RELEASE_DATAGRAM_INDICATION_LIST WskRelease;&#10;  PFN_WSK_GET_LOCAL_ADDRESS                WskGetLocalAddress;&#10;  PFN_WSK_SEND_MESSAGES                    WskSendMessages;&#10;} WSK_PROVIDER_DATAGRAM_DISPATCH, *PWSK_PROVIDER_DATAGRAM_DISPATCH;">WSK_PROVIDER_DATAGRAM_DISPATCH</a></p>

<p><a href="wsk_provider_listen_dispatch" title="typedef struct _WSK_PROVIDER_LISTEN_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH Basic;&#10;  PFN_WSK_BIND                WskBind;&#10;  PFN_WSK_ACCEPT              WskAccept;&#10;  PFN_WSK_INSPECT_COMPLETE    WskInspectComplete;&#10;  PFN_WSK_GET_LOCAL_ADDRESS   WskGetLocalAddress;&#10;} WSK_PROVIDER_LISTEN_DISPATCH, *PWSK_PROVIDER_LISTEN_DISPATCH;">WSK_PROVIDER_LISTEN_DISPATCH</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">WskSocket</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_socket">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_control_socket.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
