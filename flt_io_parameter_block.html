<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FLT_IO_PARAMETER_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FLT_IO_PARAMETER_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FLT_IO_PARAMETER_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _FLT_IO_PARAMETER_BLOCK {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          IrpFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>          MajorFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>          MinorFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>          OperationFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>          Reserved;
  <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a>   TargetFileObject;
  PFLT_INSTANCE  TargetInstance;
  <a href="flt_parameters" title="typedef union _FLT_PARAMETERS {&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT FileAttributes;&#10;    USHORT                   ShareAccess;&#10;    ULONG POINTER_ALIGNMENT  EaLength;&#10;    PVOID                    EaBuffer;&#10;    LARGE_INTEGER            AllocationSize;&#10;  } Create;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT Reserved;&#10;    USHORT                   ShareAccess;&#10;    PVOID                    Parameters;&#10;  } CreatePipe;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;...">FLT_PARAMETERS</a> Parameters;
} FLT_IO_PARAMETER_BLOCK, *PFLT_IO_PARAMETER_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_io_parameter_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/flt_io_parameter_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-fltkernel-_flt_io_parameter_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="flt_io_parameter_block-structure">FLT_IO_PARAMETER_BLOCK structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>FLT_IO_PARAMETER_BLOCK</strong> structure contains the parameters for the I/O operation represented by a <strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong> callback data structure.</p>

<h2 id="members">Members</h2>

<h3 id="irpflags"><code>IrpFlags</code></h3>

<p>A bitmask of flags that specify various aspects of the I/O operation. These flags are used only for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations. The following table shows flag values.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="irp_buffered_io" title="#define IRP_BUFFERED_IO 0x00000010">IRP_BUFFERED_IO</a></td>
  <td>The operation is a buffered I/O operation.</td>
</tr>
<tr>
  <td><a href="irp_close_operation" title="#define IRP_CLOSE_OPERATION 0x00000400">IRP_CLOSE_OPERATION</a></td>
  <td>The operation is a cleanup or close operation.</td>
</tr>
<tr>
  <td><a href="irp_deallocate_buffer" title="#define IRP_DEALLOCATE_BUFFER 0x00000020">IRP_DEALLOCATE_BUFFER</a></td>
  <td>The I/O Manager will free the buffer during the completion phase for the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><a href="irp_input_operation" title="#define IRP_INPUT_OPERATION 0x00000040">IRP_INPUT_OPERATION</a></td>
  <td>The operation is an input operation.</td>
</tr>
<tr>
  <td><a href="irp_nocache" title="#define IRP_NOCACHE 0x00000001">IRP_NOCACHE</a></td>
  <td>The operation is a noncached I/O operation.</td>
</tr>
<tr>
  <td><a href="irp_paging_io" title="#define IRP_PAGING_IO 0x00000002">IRP_PAGING_IO</a></td>
  <td>The operation is a paging I/O operation.</td>
</tr>
<tr>
  <td><a href="irp_synchronous_api" title="#define IRP_SYNCHRONOUS_API 0x00000004">IRP_SYNCHRONOUS_API</a></td>
  <td>The I/O operation is synchronous.</td>
</tr>
<tr>
  <td><a href="irp_synchronous_paging_io" title="#define IRP_SYNCHRONOUS_PAGING_IO 0x00000040">IRP_SYNCHRONOUS_PAGING_IO</a></td>
  <td>The operation is a synchronous paging I/O operation.</td>
</tr>
<tr>
  <td><a href="irp_mount_completion" title="#define IRP_MOUNT_COMPLETION 0x00000002">IRP_MOUNT_COMPLETION</a></td>
  <td>A volume mount is completed for the operation.</td>
</tr>
<tr>
  <td><a href="irp_create_operation" title="#define IRP_CREATE_OPERATION 0x00000080">IRP_CREATE_OPERATION</a></td>
  <td>The operation is a create or open operation.</td>
</tr>
<tr>
  <td><a href="irp_read_operation" title="#define IRP_READ_OPERATION 0x00000100">IRP_READ_OPERATION</a></td>
  <td>The I/O operation is for reading.</td>
</tr>
<tr>
  <td><a href="irp_write_operation" title="#define IRP_WRITE_OPERATION 0x00000200">IRP_WRITE_OPERATION</a></td>
  <td>The I/O operation is for writing.</td>
</tr>
<tr>
  <td><a href="irp_defer_io_completion" title="#define IRP_DEFER_IO_COMPLETION 0x00000800">IRP_DEFER_IO_COMPLETION</a></td>
  <td>I/O completion of the operation is deferred.</td>
</tr>
<tr>
  <td><a href="irp_associated_irp" title="#define IRP_ASSOCIATED_IRP 0x00000008">IRP_ASSOCIATED_IRP</a></td>
  <td>The operation is associated with a master <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><a href="irp_ob_query_name" title="#define IRP_OB_QUERY_NAME 0x00001000">IRP_OB_QUERY_NAME</a></td>
  <td>The operation is an asynchronous name query.</td>
</tr>
<tr>
  <td><a href="irp_hold_device_queue" title="#define IRP_HOLD_DEVICE_QUEUE 0x00002000">IRP_HOLD_DEVICE_QUEUE</a></td>
  <td>Reserved.</td>
</tr>
<tr>
  <td><a href="irp_um_driver_initiated_io" title="#define IRP_UM_DRIVER_INITIATED_IO 0x00400000">IRP_UM_DRIVER_INITIATED_IO</a></td>
  <td>The operation originated from a user-mode driver.</td>
</tr>
</tbody>
</table>

<h3 id="majorfunction"><code>MajorFunction</code></h3>

<p>The major function code for the I/O operation. Major function codes are used for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations, fast I/O operations, and file system (FSFilter) callback operations. For more information about additional operations, see <strong><a href="flt_parameters" title="typedef union _FLT_PARAMETERS {&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT FileAttributes;&#10;    USHORT                   ShareAccess;&#10;    ULONG POINTER_ALIGNMENT  EaLength;&#10;    PVOID                    EaBuffer;&#10;    LARGE_INTEGER            AllocationSize;&#10;  } Create;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT Reserved;&#10;    USHORT                   ShareAccess;&#10;    PVOID                    Parameters;&#10;  } CreatePipe;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;...">FLT_PARAMETERS</a></strong>.</p>

<h3 id="minorfunction"><code>MinorFunction</code></h3>

<p>The minor function code for the I/O operation. This member is optional and can be <strong>NULL</strong>. The value of the <strong>MajorFunction</strong> member determines the possible values. For more information about minor function codes, see <strong><a href="flt_parameters" title="typedef union _FLT_PARAMETERS {&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT FileAttributes;&#10;    USHORT                   ShareAccess;&#10;    ULONG POINTER_ALIGNMENT  EaLength;&#10;    PVOID                    EaBuffer;&#10;    LARGE_INTEGER            AllocationSize;&#10;  } Create;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT Reserved;&#10;    USHORT                   ShareAccess;&#10;    PVOID                    Parameters;&#10;  } CreatePipe;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;...">FLT_PARAMETERS</a></strong>.</p>

<h3 id="operationflags"><code>OperationFlags</code></h3>

<p>A bitmask of flags that specify various aspects of the I/O operation. These flags are used only for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operations. The Filter Manager copies these flags from the <strong>Flags</strong> member of the <strong><a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a></strong> structure that is associated with the <strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong>. The following table shows the most commonly used flag values.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="sl_case_sensitive" title="#define SL_CASE_SENSITIVE 0x80">SL_CASE_SENSITIVE</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a>. If this flag is set, file name comparisons should be case-sensitive.</td>
</tr>
<tr>
  <td><a href="sl_exclusive_lock" title="#define SL_EXCLUSIVE_LOCK 0x02">SL_EXCLUSIVE_LOCK</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a>. If this flag is set, an exclusive byte-range lock is requested. Otherwise, a shared lock is requested.</td>
</tr>
<tr>
  <td><a href="sl_fail_immediately" title="#define SL_FAIL_IMMEDIATELY 0x01">SL_FAIL_IMMEDIATELY</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a>. If this flag is set, the lock request should fail if it cannot be granted immediately.</td>
</tr>
<tr>
  <td><a href="sl_force_access_check" title="#define SL_FORCE_ACCESS_CHECK 0x01">SL_FORCE_ACCESS_CHECK</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a>. If this flag is set, access checks must be performed even if the value of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>'s <strong>RequestorMode</strong> member is <strong>KernelMode</strong>.</td>
</tr>
<tr>
  <td><a href="sl_force_direct_write" title="#define SL_FORCE_DIRECT_WRITE 0x10">SL_FORCE_DIRECT_WRITE</a></td>
  <td>Used for <a href="irp_mj_write" title="#define IRP_MJ_WRITE 0x04">IRP_MJ_WRITE</a> and <a href="ioctl_disk_copy_data" title="// CTL_CODE(0x0007, 0x019, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)&#10;#define IOCTL_DISK_COPY_DATA 0x0007C064">IOCTL_DISK_COPY_DATA</a>. If this flag is set, kernel-mode drivers can write to volume areas that they are normally blocked from writing to due to security reasons. This flag is checked both at the file system layer and storage stack layer. The <a href="sl_force_direct_write" title="#define SL_FORCE_DIRECT_WRITE 0x10">SL_FORCE_DIRECT_WRITE</a> flag is available in Windows Vista and later versions of Windows.</td>
</tr>
<tr>
  <td><a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-ea"><strong>IRP_MJ_QUERY_EA</strong></a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-quota"><strong>IRP_MJ_SET_QUOTA</strong></a>. If this flag is set, the scan for directory, quota, or extended-attribute information should begin at the entry in the list whose index is specified.</td>
</tr>
<tr>
  <td><a href="sl_open_paging_file" title="#define SL_OPEN_PAGING_FILE 0x02">SL_OPEN_PAGING_FILE</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a>. If this flag is set, the file is a paging file.</td>
</tr>
<tr>
  <td><a href="sl_open_target_directory" title="#define SL_OPEN_TARGET_DIRECTORY 0x04">SL_OPEN_TARGET_DIRECTORY</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a>. If this flag is set, the file's parent directory should be opened.</td>
</tr>
<tr>
  <td><a href="sl_override_verify_volume" title="#define SL_OVERRIDE_VERIFY_VOLUME 0x02">SL_OVERRIDE_VERIFY_VOLUME</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-read"><strong>IRP_MJ_READ</strong></a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write"><strong>IRP_MJ_WRITE</strong></a>. If this flag is set, the I/O operation should be performed even if the <a href="do_verify_volume" title="#define DO_VERIFY_VOLUME 0x00000002">DO_VERIFY_VOLUME</a> flag is set on the volume's device object.</td>
</tr>
<tr>
  <td><a href="sl_restart_scan" title="#define SL_RESTART_SCAN 0x01">SL_RESTART_SCAN</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-ea"><strong>IRP_MJ_QUERY_EA</strong></a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-quota"><strong>IRP_MJ_SET_QUOTA</strong></a>. If this flag is set, the scan for directory, quota, or extended-attribute information should begin at the first entry in the directory or list. Otherwise, the scan should be resumed from the previous scan.</td>
</tr>
<tr>
  <td><a href="sl_return_single_entry" title="#define SL_RETURN_SINGLE_ENTRY 0x02">SL_RETURN_SINGLE_ENTRY</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-ea"><strong>IRP_MJ_QUERY_EA</strong></a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-quota"><strong>IRP_MJ_SET_QUOTA</strong></a>. If this flag is set, the scan for directory, quota, or extended-attribute information should return only the first entry that is found.</td>
</tr>
<tr>
  <td><a href="sl_watch_tree" title="#define SL_WATCH_TREE 0x01">SL_WATCH_TREE</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a>. If this flag is set, all subdirectories of this directory should also be watched. Otherwise, only the directory itself is to be watched.</td>
</tr>
<tr>
  <td><a href="sl_write_through" title="#define SL_WRITE_THROUGH 0x04">SL_WRITE_THROUGH</a></td>
  <td>Used for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write"><strong>IRP_MJ_WRITE</strong></a>. If this flag is set, the file data must be written through to persistent storage, not just written to the cache.</td>
</tr>
</tbody>
</table>

<h3 id="reserved"><code>Reserved</code></h3>

<p>Reserved for system use. Do not use.</p>

<h3 id="targetfileobject"><code>TargetFileObject</code></h3>

<p>A file object pointer for the file or directory that is the target for this I/O operation.</p>

<h3 id="targetinstance"><code>TargetInstance</code></h3>

<p>An opaque instance pointer for the minifilter that is the target for this I/O operation.</p>

<h3 id="parameters"><code>Parameters</code></h3>

<p>An <strong><a href="flt_parameters" title="typedef union _FLT_PARAMETERS {&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT FileAttributes;&#10;    USHORT                   ShareAccess;&#10;    ULONG POINTER_ALIGNMENT  EaLength;&#10;    PVOID                    EaBuffer;&#10;    LARGE_INTEGER            AllocationSize;&#10;  } Create;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT Reserved;&#10;    USHORT                   ShareAccess;&#10;    PVOID                    Parameters;&#10;  } CreatePipe;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;...">FLT_PARAMETERS</a></strong> structure that contains the parameters for the I/O operation that are specified by the <strong>MajorFunction</strong> and <strong>MinorFunction</strong> members.</p>

<h2 id="remarks">Remarks</h2>

<p>The <strong>FLT_IO_PARAMETER_BLOCK</strong> structure contains the parameters for the I/O operation that is represented by a callback data (<strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong>) structure. The callback data structure contains a pointer to the FLT_IO_PARAMETER_BLOCK structure in its <strong>Iopb</strong> member.</p>

<p>A minifilter receives a pointer to the callback data structure as the <em>Data</em> or <em>CallbackData</em> input parameter to the following callback routine types:</p>

<ul>
<li><strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong></li>
<li><strong><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></strong></li>
<li><strong><a href="pflt_completed_async_io_callback" title="PFLT_COMPLETED_ASYNC_IO_CALLBACK PfltCompletedAsyncIoCallback;&#10;&#10;VOID PfltCompletedAsyncIoCallback(&#10;  [in] PFLT_CALLBACK_DATA CallbackData,&#10;  [in] PFLT_CONTEXT Context&#10;)&#10;{...}">PFLT_COMPLETED_ASYNC_IO_CALLBACK</a></strong></li>
<li><strong><a href="pflt_generate_file_name" title="PFLT_GENERATE_FILE_NAME PfltGenerateFileName;&#10;&#10;NTSTATUS PfltGenerateFileName(&#10;  [in]           PFLT_INSTANCE Instance,&#10;  [in]           PFILE_OBJECT FileObject,&#10;  [in, optional] PFLT_CALLBACK_DATA CallbackData,&#10;  [in]           FLT_FILE_NAME_OPTIONS NameOptions,&#10;  [out]          PBOOLEAN CacheFileNameInformation,&#10;  [out]          PFLT_NAME_CONTROL FileName&#10;)&#10;{...}">PFLT_GENERATE_FILE_NAME</a></strong></li>
</ul>

<p>A minifilter's preoperation and postoperation callback routines can modify the contents of the FLT_IO_PARAMETER_BLOCK structure for the I/O operation, except for the <strong>MajorFunction</strong> and <strong>Reserved</strong> members. If it does, it must call <strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong>, unless it has also modified the <strong>IoStatus</strong> member of the callback data structure for the operation. Otherwise, the modified values are ignored.</p>

<p>When Filter Manager issues a preoperation or postoperation callback to a minifilter, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_related_objects"><strong>FltObjects->FileObject</strong></a> and <strong>TargetFileObject</strong> (CallbackData->Iopb->TargetFileObject) are initially the same. If a minifilter modifies <strong>TargetFileObject</strong> or <strong>TargetInstance</strong>, its subsequent call to <strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong> from a preoperation callback will cause Filter Manager to replace <strong>FltObjects->FileObject</strong> and <strong>FltObjects->Instance</strong> before sending the operation to lower filters.</p>

<p>If a minifilter's preoperation callback routine modifies the parameters for an I/O operation, all minifilters below it in the minifilter instance stack will receive the modified parameters in their preoperation and postoperation callback routines.</p>

<p>The modified parameters are not received by the minifilter's own postoperation callback routine, or by any minifilters above that minifilter in the minifilter instance stack. In all cases, a minifilter's preoperation and postoperation callback routines receive the same input parameter values.</p>

<p>If a minifilter changes the value of the <strong>TargetInstance</strong> member, the new value must be a pointer to an instance of the same minifilter at the same altitude on a different volume. In addition, the new volume's device object must have a stack size that is greater than or equal to that of the original volume's device object.</p>

<p>To get the stack size for a volume device object, given an opaque instance pointer for an instance that is attached to the volume, do the following:</p>

<ul>
<li>Call <strong><a href="fltgetvolumefrominstance" title="NTSTATUS FLTAPI FltGetVolumeFromInstance(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [out] PFLT_VOLUME   *RetVolume&#10;);">FltGetVolumeFromInstance</a></strong> to get the volume pointer.</li>
<li>Call <strong><a href="fltgetdeviceobject" title="NTSTATUS FLTAPI FltGetDeviceObject(&#10;  [in]  PFLT_VOLUME    Volume,&#10;  [out] PDEVICE_OBJECT *DeviceObject&#10;);">FltGetDeviceObject</a></strong> to get a pointer to the volume device object. This pointer is returned in the <em>DeviceObject</em> parameter. The device object's stack size can be found in <strong>DeviceObject->StackSize</strong>.</li>
<li>When the volume pointer is no longer needed, call <strong><a href="fltobjectdereference" title="VOID FLTAPI FltObjectDereference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectDereference</a></strong> to decrement its reference count.</li>
<li>When the volume device object pointer is no longer needed, call <strong><a href="obdereferenceobject" title="void ObDereferenceObject(&#10;  [in] a&#10;);">ObDereferenceObject</a></strong> to decrement its reference count.</li>
</ul>

<p>A minifilter can change the value of the <strong>TargetFileObject</strong> member. However, the new value must be a pointer to a file object for a file that resides on the same volume as the instance specified by the <strong>TargetInstance</strong> member.</p>

<p>A minifilter cannot safely change the value of the <strong>MajorFunction</strong> member. Instead, it must initiate a new I/O operation.</p>

<p>A minifilter can initiate an I/O operation by calling a support routine such as <strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong> or by calling <strong><a href="fltallocatecallbackdata" title="NTSTATUS FLTAPI FltAllocateCallbackData(&#10;  [in]           PFLT_INSTANCE      Instance,&#10;  [in, optional] PFILE_OBJECT       FileObject,&#10;  [out]          PFLT_CALLBACK_DATA *RetNewCallbackData&#10;);">FltAllocateCallbackData</a></strong> to allocate a callback data structure; initializing the I/O parameters in the <strong>FLT_IO_PARAMETER_BLOCK</strong> structure, and passing the callback data structure to <strong><a href="fltperformsynchronousio" title="VOID FLTAPI FltPerformSynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA CallbackData&#10;);">FltPerformSynchronousIo</a></strong> or <strong><a href="fltperformasynchronousio" title="NTSTATUS FLTAPI FltPerformAsynchronousIo(&#10;  [in, out] PFLT_CALLBACK_DATA               CallbackData,&#10;  [in]      PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in]      PVOID                            CallbackContext&#10;);">FltPerformAsynchronousIo</a></strong>.</p>

<blockquote>
  <p>[!NOTE]</p>
  
  <p>Use support routines wherever possible when initiating I/O operations. A minifilter should allocate its own callback data only if there is no support function for a particular I/O operation.</p>
</blockquote>

<h2 id="see-also">See also</h2>

<p><strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)"><strong>FLT_IS_IRP_OPERATION</strong></a></p>

<p><strong><a href="fltallocatecallbackdata" title="NTSTATUS FLTAPI FltAllocateCallbackData(&#10;  [in]           PFLT_INSTANCE      Instance,&#10;  [in, optional] PFILE_OBJECT       FileObject,&#10;  [out]          PFLT_CALLBACK_DATA *RetNewCallbackData&#10;);">FltAllocateCallbackData</a></strong></p>

<p><strong><a href="fltclearcallbackdatadirty" title="VOID FLTAPI FltClearCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltClearCallbackDataDirty</a></strong></p>

<p><strong><a href="fltdecodeparameters" title="NTSTATUS FLTAPI FltDecodeParameters(&#10;  [in]            PFLT_CALLBACK_DATA CallbackData,&#10;  [out]           PMDL               **MdlAddressPointer,&#10;  [out]           PVOID              **Buffer,&#10;  [out]           PULONG             *Length,&#10;  [out, optional] LOCK_OPERATION     *DesiredAccess&#10;);">FltDecodeParameters</a></strong></p>

<p><strong><a href="fltiscallbackdatadirty" title="BOOLEAN FLTAPI FltIsCallbackDataDirty(&#10;  [in] PFLT_CALLBACK_DATA Data&#10;);">FltIsCallbackDataDirty</a></strong></p>

<p><strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong></p>

<p><strong><a href="fltsetcallbackdatadirty" title="VOID FLTAPI FltSetCallbackDataDirty(&#10;  [in, out] PFLT_CALLBACK_DATA Data&#10;);">FltSetCallbackDataDirty</a></strong></p>

<p><strong><a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a></strong></p>

<p><strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong></p>

<p><strong><a href="flt_parameters" title="typedef union _FLT_PARAMETERS {&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT FileAttributes;&#10;    USHORT                   ShareAccess;&#10;    ULONG POINTER_ALIGNMENT  EaLength;&#10;    PVOID                    EaBuffer;&#10;    LARGE_INTEGER            AllocationSize;&#10;  } Create;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;    USHORT POINTER_ALIGNMENT Reserved;&#10;    USHORT                   ShareAccess;&#10;    PVOID                    Parameters;&#10;  } CreatePipe;&#10;  struct {&#10;    PIO_SECURITY_CONTEXT     SecurityContext;&#10;    ULONG                    Options;&#10;...">FLT_PARAMETERS</a></strong></p>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-acquire-for-mod-write"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_ACQUIRE_FOR_MOD_WRITE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-acquire-for-section-synchronization"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-create"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_CREATE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-create-mailslot"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_CREATE_MAILSLOT</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-create-named-pipe"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_CREATE_NAMED_PIPE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-device-control-and-irp-mj-internal-device-co"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_DEVICE_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-directory-control"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_DIRECTORY_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-fast-io-check-if-possible"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-file-system-control"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_FILE_SYSTEM_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-device-control-and-irp-mj-internal-device-co"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_INTERNAL_DEVICE_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-lock-control"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_LOCK_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-mdl-read"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_MDL_READ</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-mdl-read-complete"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_MDL_READ_COMPLETE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-mdl-write-complete"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_MDL_WRITE_COMPLETE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-network-query-open"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_NETWORK_QUERY_OPEN</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-pnp"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_PNP</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-prepare-mdl-write"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_PREPARE_MDL_WRITE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-ea"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_EA</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-information"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_INFORMATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-open"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_OPEN</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-quota"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_QUOTA</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-security"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_SECURITY</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-query-volume-information"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_QUERY_VOLUME_INFORMATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-read"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_READ</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-release-for-mod-write"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_RELEASE_FOR_MOD_WRITE</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-release-for-section-synchronization"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-set-ea"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SET_EA</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-set-information"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SET_INFORMATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-set-quota"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SET_QUOTA</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-set-security"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SET_SECURITY</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-set-volume-information"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SET_VOLUME_INFORMATION</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-system-control"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_SYSTEM_CONTROL</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-volume-mount"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_VOLUME_MOUNT</strong></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-parameters-for-irp-mj-write"><strong>FLT_PARAMETERS</strong> for <strong>IRP_MJ_WRITE</strong></a></li>
</ul>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-cleanup"><strong>IRP_MJ_CLEANUP</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-close"><strong>IRP_MJ_CLOSE</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-flush-buffers"><strong>IRP_MJ_FLUSH_BUFFERS</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-shutdown"><strong>IRP_MJ_SHUTDOWN</strong></a></p>

<p><strong><a href="pflt_completed_async_io_callback" title="PFLT_COMPLETED_ASYNC_IO_CALLBACK PfltCompletedAsyncIoCallback;&#10;&#10;VOID PfltCompletedAsyncIoCallback(&#10;  [in] PFLT_CALLBACK_DATA CallbackData,&#10;  [in] PFLT_CONTEXT Context&#10;)&#10;{...}">PFLT_COMPLETED_ASYNC_IO_CALLBACK</a></strong></p>

<p><strong><a href="pflt_generate_file_name" title="PFLT_GENERATE_FILE_NAME PfltGenerateFileName;&#10;&#10;NTSTATUS PfltGenerateFileName(&#10;  [in]           PFLT_INSTANCE Instance,&#10;  [in]           PFILE_OBJECT FileObject,&#10;  [in, optional] PFLT_CALLBACK_DATA CallbackData,&#10;  [in]           FLT_FILE_NAME_OPTIONS NameOptions,&#10;  [out]          PBOOLEAN CacheFileNameInformation,&#10;  [out]          PFLT_NAME_CONTROL FileName&#10;)&#10;{...}">PFLT_GENERATE_FILE_NAME</a></strong></p>

<p><strong><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></strong></p>

<p><strong><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_io_parameter_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/ns-fltkernel-_flt_io_parameter_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
