<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IO_STACK_LOCATION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IO_STACK_LOCATION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IO_STACK_LOCATION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _IO_STACK_LOCATION {
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  MajorFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  MinorFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  Flags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  Control;
  union {
    struct {
      <a href="io_security_context" title="typedef struct _IO_SECURITY_CONTEXT {&#10;  PSECURITY_QUALITY_OF_SERVICE SecurityQos;&#10;  PACCESS_STATE                AccessState;&#10;  ACCESS_MASK                  DesiredAccess;&#10;  ULONG                        FullCreateOptions;&#10;} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;">PIO_SECURITY_CONTEXT</a>     SecurityContext;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                    Options;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FileAttributes;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                   ShareAccess;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>  EaLength;
    } Create;
    struct {
      <a href="io_security_context" title="typedef struct _IO_SECURITY_CONTEXT {&#10;  PSECURITY_QUALITY_OF_SERVICE SecurityQos;&#10;  PACCESS_STATE                AccessState;&#10;  ACCESS_MASK                  DesiredAccess;&#10;  ULONG                        FullCreateOptions;&#10;} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;">PIO_SECURITY_CONTEXT</a>          SecurityContext;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Options;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>      Reserved;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ShareAccess;
      <a href="named_pipe_create_parameters" title="typedef struct _NAMED_PIPE_CREATE_PARAMETERS&#10;{&#10;    ULONG NamedPipeType;&#10;    ULONG ReadMode;&#10;    ULONG CompletionMode;&#10;    ULONG MaximumInstances;&#10;    ULONG InboundQuota;&#10;    ULONG OutboundQuota;&#10;    LARGE_INTEGER DefaultTimeout;&#10;    BOOLEAN TimeoutSpecified;&#10;} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;">PNAMED_PIPE_CREATE_PARAMETERS</a> Parameters;
    } CreatePipe;
    struct {
      <a href="io_security_context" title="typedef struct _IO_SECURITY_CONTEXT {&#10;  PSECURITY_QUALITY_OF_SERVICE SecurityQos;&#10;  PACCESS_STATE                AccessState;&#10;  ACCESS_MASK                  DesiredAccess;&#10;  ULONG                        FullCreateOptions;&#10;} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;">PIO_SECURITY_CONTEXT</a>        SecurityContext;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       Options;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>    Reserved;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                      ShareAccess;
      <a href="mailslot_create_parameters" title="typedef struct _MAILSLOT_CREATE_PARAMETERS&#10;{&#10;    ULONG MailslotQuota;&#10;    ULONG MaximumMessageSize;&#10;    LARGE_INTEGER ReadTimeout;&#10;    BOOLEAN TimeoutSpecified;&#10;} MAILSLOT_CREATE_PARAMETERS, *PMAILSLOT_CREATE_PARAMETERS;">PMAILSLOT_CREATE_PARAMETERS</a> Parameters;
    } CreateMailslot;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Length;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Key;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Flags;
      LARGE_INTEGER           ByteOffset;
    } Read;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Length;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Key;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Flags;
      LARGE_INTEGER           ByteOffset;
    } Write;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Length;
      <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">PUNICODE_STRING</a>         FileName;
      <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a>  FileInformationClass;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FileIndex;
    } QueryDirectory;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Length;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> CompletionFilter;
    } NotifyDirectory;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                                Length;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>                              CompletionFilter;
      <a href="directory_notify_information_class" title="typedef enum _DIRECTORY_NOTIFY_INFORMATION_CLASS&#10;{&#10;    DirectoryNotifyInformation = 1, // FILE_NOTIFY_INFORMATION&#10;    DirectoryNotifyExtendedInformation, // FILE_NOTIFY_EXTENDED_INFORMATION&#10;    DirectoryNotifyFullInformation, // FILE_NOTIFY_FULL_INFORMATION // since 22H2&#10;    DirectoryNotifyMaximumInformation&#10;} DIRECTORY_NOTIFY_INFORMATION_CLASS, *PDIRECTORY_NOTIFY_INFORMATION_CLASS;">DIRECTORY_NOTIFY_INFORMATION_CLASS</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> DirectoryNotifyInformationClass;
    } NotifyDirectoryEx;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                    Length;
      <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FileInformationClass;
    } QueryFile;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                    Length;
      <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FileInformationClass;
      <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a>                             FileObject;
      union {
        struct {
          BOOLEAN ReplaceIfExists;
          BOOLEAN AdvanceOnly;
        };
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  ClusterCount;
        HANDLE DeleteHandle;
      };
    } SetFile;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Length;
      PVOID                   EaList;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   EaListLength;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> EaIndex;
    } QueryEa;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length;
    } SetEa;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  Length;
      <a href="fs_information_class" title="typedef enum _FSINFOCLASS&#10;{&#10;    FileFsVolumeInformation = 1,            // q: FILE_FS_VOLUME_INFORMATION&#10;    FileFsLabelInformation,                 // s: FILE_FS_LABEL_INFORMATION // SeManageVolumePrivilege&#10;    FileFsSizeInformation,                  // q: FILE_FS_SIZE_INFORMATION&#10;    FileFsDeviceInformation,                // q: FILE_FS_DEVICE_INFORMATION&#10;    FileFsAttributeInformation,             // q: FILE_FS_ATTRIBUTE_INFORMATION&#10;    FileFsControlInformation,               // qs: FILE_FS_CONTROL_INFORMATION // SeManageVolumePrivilege&#10;    FileFsFullSizeInformation,              // q: FILE_FS_FULL_SIZE_INFORMATION&#10;    FileFsObjectIdInformation,              // qs: FILE_FS_OBJECTID_INFORMATION // SeRestorePrivilege&#10;    FileFsDriverPathInformation,            // q: FILE_FS_DRIVER_PATH_INFORMATION&#10;    FileFsVolumeFlagsInformation,           // qs: FILE_FS_VOLUME_FLAGS_INFORMATION // SeManageVolumePrivilege // 10&#10;    FileFsSectorSizeInformation,            // q: FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8&#10;    FileFsDataCopyInformation,              // q: FILE_FS_DATA_COPY_INFORMATION&#10;    FileFsMetadataSizeInformation,          // q: FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD&#10;    FileFsFullSizeInformationEx,            // q: FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5&#10;    FileFsGuidInformation,                  // q: FILE_FS_GUID_INFORMATION // since 23H2&#10;    FileFsMaximumInformation&#10;} FSINFOCLASS, *PFSINFOCLASS;">FS_INFORMATION_CLASS</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FsInformationClass;
    } QueryVolume;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  Length;
      <a href="fs_information_class" title="typedef enum _FSINFOCLASS&#10;{&#10;    FileFsVolumeInformation = 1,            // q: FILE_FS_VOLUME_INFORMATION&#10;    FileFsLabelInformation,                 // s: FILE_FS_LABEL_INFORMATION // SeManageVolumePrivilege&#10;    FileFsSizeInformation,                  // q: FILE_FS_SIZE_INFORMATION&#10;    FileFsDeviceInformation,                // q: FILE_FS_DEVICE_INFORMATION&#10;    FileFsAttributeInformation,             // q: FILE_FS_ATTRIBUTE_INFORMATION&#10;    FileFsControlInformation,               // qs: FILE_FS_CONTROL_INFORMATION // SeManageVolumePrivilege&#10;    FileFsFullSizeInformation,              // q: FILE_FS_FULL_SIZE_INFORMATION&#10;    FileFsObjectIdInformation,              // qs: FILE_FS_OBJECTID_INFORMATION // SeRestorePrivilege&#10;    FileFsDriverPathInformation,            // q: FILE_FS_DRIVER_PATH_INFORMATION&#10;    FileFsVolumeFlagsInformation,           // qs: FILE_FS_VOLUME_FLAGS_INFORMATION // SeManageVolumePrivilege // 10&#10;    FileFsSectorSizeInformation,            // q: FILE_FS_SECTOR_SIZE_INFORMATION // since WIN8&#10;    FileFsDataCopyInformation,              // q: FILE_FS_DATA_COPY_INFORMATION&#10;    FileFsMetadataSizeInformation,          // q: FILE_FS_METADATA_SIZE_INFORMATION // since THRESHOLD&#10;    FileFsFullSizeInformationEx,            // q: FILE_FS_FULL_SIZE_INFORMATION_EX // since REDSTONE5&#10;    FileFsGuidInformation,                  // q: FILE_FS_GUID_INFORMATION // since 23H2&#10;    FileFsMaximumInformation&#10;} FSINFOCLASS, *PFSINFOCLASS;">FS_INFORMATION_CLASS</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FsInformationClass;
    } SetVolume;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   OutputBufferLength;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> InputBufferLength;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> FsControlCode;
      PVOID                   Type3InputBuffer;
    } FileSystemControl;
    struct {
      PLARGE_INTEGER          Length;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Key;
      LARGE_INTEGER           ByteOffset;
    } LockControl;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   OutputBufferLength;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> InputBufferLength;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> IoControlCode;
      PVOID                   Type3InputBuffer;
    } DeviceIoControl;
    struct {
      SECURITY_INFORMATION    SecurityInformation;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Length;
    } QuerySecurity;
    struct {
      SECURITY_INFORMATION SecurityInformation;
      PSECURITY_DESCRIPTOR SecurityDescriptor;
    } SetSecurity;
    struct {
      <a href="vpb" title="typedef struct _VPB {&#10;  CSHORT                Type;&#10;  CSHORT                Size;&#10;  USHORT                Flags;&#10;  USHORT                VolumeLabelLength;&#10;  struct _DEVICE_OBJECT *DeviceObject;&#10;  struct _DEVICE_OBJECT *RealDevice;&#10;  ULONG                 SerialNumber;&#10;  ULONG                 ReferenceCount;&#10;  WCHAR                 VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];&#10;} VPB, *PVPB;">PVPB</a>           Vpb;
      <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a> DeviceObject;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          OutputBufferLength;
    } MountVolume;
    struct {
      <a href="vpb" title="typedef struct _VPB {&#10;  CSHORT                Type;&#10;  CSHORT                Size;&#10;  USHORT                Flags;&#10;  USHORT                VolumeLabelLength;&#10;  struct _DEVICE_OBJECT *DeviceObject;&#10;  struct _DEVICE_OBJECT *RealDevice;&#10;  ULONG                 SerialNumber;&#10;  ULONG                 ReferenceCount;&#10;  WCHAR                 VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];&#10;} VPB, *PVPB;">PVPB</a>           Vpb;
      <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a> DeviceObject;
    } VerifyVolume;
    struct {
      <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">struct _SCSI_REQUEST_BLOCK</a> *Srb;
    } Scsi;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       Length;
      PSID                        StartSid;
      <a href="file_get_quota_information" title="_Struct_size_bytes_(NextEntryOffset)&#10;typedef struct _FILE_GET_QUOTA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    ULONG SidLength;&#10;    _Field_size_bytes_(SidLength) SID Sid;&#10;} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;">PFILE_GET_QUOTA_INFORMATION</a> SidList;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       SidListLength;
    } QueryQuota;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length;
    } SetQuota;
    struct {
      <a href="device_relation_type" title="typedef enum _DEVICE_RELATION_TYPE&#10;{&#10;    BusRelations,&#10;    EjectionRelations,&#10;    PowerRelations,&#10;    RemovalRelations,&#10;    TargetDeviceRelation,&#10;    SingleBusRelations,&#10;    TransportRelations&#10;} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;">DEVICE_RELATION_TYPE</a> Type;
    } QueryDeviceRelations;
    struct {
      const GUID *InterfaceType;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>     Size;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>     Version;
      <a href="interface" title="typedef struct _INTERFACE {&#10;  USHORT                 Size;&#10;  USHORT                 Version;&#10;  PVOID                  Context;&#10;  PINTERFACE_REFERENCE   InterfaceReference;&#10;  PINTERFACE_DEREFERENCE InterfaceDereference;&#10;} INTERFACE, *PINTERFACE;">PINTERFACE</a> Interface;
      PVOID      InterfaceSpecificData;
    } QueryInterface;
    struct {
      <a href="device_capabilities" title="typedef struct _DEVICE_CAPABILITIES {&#10;  USHORT             Size;&#10;  USHORT             Version;&#10;  ULONG              DeviceD1 : 1;&#10;  ULONG              DeviceD2 : 1;&#10;  ULONG              LockSupported : 1;&#10;  ULONG              EjectSupported : 1;&#10;  ULONG              Removable : 1;&#10;  ULONG              DockDevice : 1;&#10;  ULONG              UniqueID : 1;&#10;  ULONG              SilentInstall : 1;&#10;  ULONG              RawDeviceOK : 1;&#10;  ULONG              SurpriseRemovalOK : 1;&#10;  ULONG              WakeFromD0 : 1;&#10;  ULONG              WakeFromD1 : 1;&#10;  ULONG              WakeFromD2 : 1;&#10;  ULONG              WakeFromD3 : 1;&#10;  ULONG              HardwareDisabled : 1;&#10;  ULONG              NonDynamic : 1;&#10;  ULONG              WarmEjectSupported : 1;&#10;...">PDEVICE_CAPABILITIES</a> Capabilities;
    } DeviceCapabilities;
    struct {
      <a href="io_resource_requirements_list" title="typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {&#10;  ULONG            ListSize;&#10;  INTERFACE_TYPE   InterfaceType;&#10;  ULONG            BusNumber;&#10;  ULONG            SlotNumber;&#10;  ULONG            Reserved[3];&#10;  ULONG            AlternativeLists;&#10;  IO_RESOURCE_LIST List[1];&#10;} IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;">PIO_RESOURCE_REQUIREMENTS_LIST</a> IoResourceRequirementList;
    } FilterResourceRequirements;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   WhichSpace;
      PVOID                   Buffer;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   Offset;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Length;
    } ReadWriteConfig;
    struct {
      BOOLEAN Lock;
    } SetLock;
    struct {
      <a href="bus_query_id_type" title="typedef enum _BUS_QUERY_ID_TYPE&#10;{&#10;    BusQueryDeviceID = 0,           // &lt;Enumerator&gt;\&lt;Enumerator-specific device id&gt;&#10;    BusQueryHardwareIDs = 1,        // Hardware ids&#10;    BusQueryCompatibleIDs = 2,      // compatible device ids&#10;    BusQueryInstanceID = 3,         // persistent id for this instance of the device&#10;    BusQueryDeviceSerialNumber = 4, // serial number for this device&#10;    BusQueryContainerID = 5         // unique id of the device&#x27;s physical container&#10;} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;">BUS_QUERY_ID_TYPE</a> IdType;
    } QueryId;
    struct {
      <a href="device_text_type" title="typedef enum _DEVICE_TEXT_TYPE&#10;{&#10;    DeviceTextDescription = 0,        // DeviceDesc property&#10;    DeviceTextLocationInformation = 1 // DeviceLocation property&#10;} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;">DEVICE_TEXT_TYPE</a>       DeviceTextType;
      LCID <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> LocaleId;
    } QueryDeviceText;
    struct {
      BOOLEAN                                          InPath;
      BOOLEAN                                          Reserved[3];
      <a href="device_usage_notification_type" title="typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE&#10;{&#10;    DeviceUsageTypeUndefined,&#10;    DeviceUsageTypePaging,&#10;    DeviceUsageTypeHibernation,&#10;    DeviceUsageTypeDumpFile,&#10;    DeviceUsageTypeBoot,&#10;    DeviceUsageTypePostDisplay,&#10;    DeviceUsageTypeGuestAssigned&#10;} DEVICE_USAGE_NOTIFICATION_TYPE, *PDEVICE_USAGE_NOTIFICATION_TYPE;">DEVICE_USAGE_NOTIFICATION_TYPE</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Type;
    } UsageNotification;
    struct {
      <a href="system_power_state" title="typedef enum _SYSTEM_POWER_STATE {&#10;  PowerSystemUnspecified,&#10;  PowerSystemWorking,&#10;  PowerSystemSleeping1,&#10;  PowerSystemSleeping2,&#10;  PowerSystemSleeping3,&#10;  PowerSystemHibernate,&#10;  PowerSystemShutdown,&#10;  PowerSystemMaximum&#10;} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;">SYSTEM_POWER_STATE</a> PowerState;
    } WaitWake;
    struct {
      PPOWER_SEQUENCE PowerSequence;
    } PowerSequence;
#if ...
    struct {
      union {
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      SystemContext;
        <a href="system_power_state_context" title="typedef struct _SYSTEM_POWER_STATE_CONTEXT&#10;{&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            ULONG Reserved1 : 8;&#10;            ULONG TargetSystemState : 4;&#10;            ULONG EffectiveSystemState : 4;&#10;            ULONG CurrentSystemState : 4;&#10;            ULONG IgnoreHibernationPath : 1;&#10;            ULONG PseudoTransition : 1;&#10;            ULONG KernelSoftReboot : 1;&#10;            ULONG DirectedDripsTransition : 1;&#10;            ULONG Reserved2 : 8;&#10;        };&#10;        ULONG ContextAsUlong;&#10;    };&#10;} SYSTEM_POWER_STATE_CONTEXT, *PSYSTEM_POWER_STATE_CONTEXT;">SYSTEM_POWER_STATE_CONTEXT</a> SystemPowerStateContext;
      };
      <a href="power_state_type" title="typedef enum _POWER_STATE_TYPE&#10;{&#10;    SystemPowerState = 0,&#10;    DevicePowerState&#10;} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;">POWER_STATE_TYPE</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Type;
      <a href="power_state" title="typedef union _POWER_STATE&#10;{&#10;    SYSTEM_POWER_STATE SystemState;&#10;    DEVICE_POWER_STATE DeviceState;&#10;} POWER_STATE, *PPOWER_STATE;">POWER_STATE</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>      State;
      <a href="power_action" title="typedef enum  {&#10;  PowerActionNone           = 0,&#10;  PowerActionReserved       = ( PowerActionNone + 1 ),&#10;  PowerActionSleep          = ( PowerActionReserved + 1 ),&#10;  PowerActionHibernate      = ( PowerActionSleep + 1 ),&#10;  PowerActionShutdown       = ( PowerActionHibernate + 1 ),&#10;  PowerActionShutdownReset  = ( PowerActionShutdown + 1 ),&#10;  PowerActionShutdownOff    = ( PowerActionShutdownReset + 1 ),&#10;  PowerActionWarmEject      = ( PowerActionShutdownOff + 1 )&#10;} POWER_ACTION, *PPOWER_ACTION;">POWER_ACTION</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>     ShutdownType;
    } Power;
#else
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                              SystemContext;
      <a href="power_state_type" title="typedef enum _POWER_STATE_TYPE&#10;{&#10;    SystemPowerState = 0,&#10;    DevicePowerState&#10;} POWER_STATE_TYPE, *PPOWER_STATE_TYPE;">POWER_STATE_TYPE</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a> Type;
      <a href="power_state" title="typedef union _POWER_STATE&#10;{&#10;    SYSTEM_POWER_STATE SystemState;&#10;    DEVICE_POWER_STATE DeviceState;&#10;} POWER_STATE, *PPOWER_STATE;">POWER_STATE</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>      State;
      <a href="power_action" title="typedef enum  {&#10;  PowerActionNone           = 0,&#10;  PowerActionReserved       = ( PowerActionNone + 1 ),&#10;  PowerActionSleep          = ( PowerActionReserved + 1 ),&#10;  PowerActionHibernate      = ( PowerActionSleep + 1 ),&#10;  PowerActionShutdown       = ( PowerActionHibernate + 1 ),&#10;  PowerActionShutdownReset  = ( PowerActionShutdown + 1 ),&#10;  PowerActionShutdownOff    = ( PowerActionShutdownReset + 1 ),&#10;  PowerActionWarmEject      = ( PowerActionShutdownOff + 1 )&#10;} POWER_ACTION, *PPOWER_ACTION;">POWER_ACTION</a> <a href="pointer_alignment" title="#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)">POINTER_ALIGNMENT</a>     ShutdownType;
    } Power;
#endif
    struct {
      <a href="cm_resource_list" title="typedef struct _CM_RESOURCE_LIST {&#10;  ULONG                       Count;&#10;  CM_FULL_RESOURCE_DESCRIPTOR List[1];&#10;} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;">PCM_RESOURCE_LIST</a> AllocatedResources;
      <a href="cm_resource_list" title="typedef struct _CM_RESOURCE_LIST {&#10;  ULONG                       Count;&#10;  CM_FULL_RESOURCE_DESCRIPTOR List[1];&#10;} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;">PCM_RESOURCE_LIST</a> AllocatedResourcesTranslated;
    } StartDevice;
    struct {
      <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a> ProviderId;
      PVOID     DataPath;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     BufferSize;
      PVOID     Buffer;
    } WMI;
    struct {
      PVOID Argument1;
      PVOID Argument2;
      PVOID Argument3;
      PVOID Argument4;
    } Others;
  } Parameters;
  <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>         DeviceObject;
  <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a>           FileObject;
  PIO_COMPLETION_ROUTINE CompletionRoutine;
  PVOID                  Context;
} IO_STACK_LOCATION, *PIO_STACK_LOCATION;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/io_stack_location.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-wdm-_io_stack_location)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p>The <strong>IO_STACK_LOCATION</strong> structure defines an <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/i-o-stack-locations">I/O stack location</a>, which is an entry in the I/O stack that is associated with each <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. Each I/O stack location in an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> has some common members and some request-type-specific members.</p>
<h2>Members</h2>
<h3><code>MajorFunction</code></h3>
<p>The <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-major-function-codes">IRP major function code</a> indicating the type of I/O operation to be performed.</p>
<h3><code>MinorFunction</code></h3>
<p>A subfunction code for <strong>MajorFunction</strong>. The PnP manager, the power manager, file system drivers, and SCSI class drivers set this member for some requests.</p>
<h3><code>Flags</code></h3>
<p>Request-type-specific values used almost exclusively by file system drivers. Removable-media device drivers check whether this member is set with <a href="sl_override_verify_volume" title="#define SL_OVERRIDE_VERIFY_VOLUME 0x02">SL_OVERRIDE_VERIFY_VOLUME</a> for read requests to determine whether to continue the read operation even if the device object's <strong>Flags</strong> is set with <a href="do_verify_volume" title="#define DO_VERIFY_VOLUME 0x00000002">DO_VERIFY_VOLUME</a>. Intermediate drivers layered over a removable-media device driver must copy this member into the I/O stack location of the next-lower driver in all incoming <a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-read">IRP_MJ_READ</a> requests.</p>
<p>For documentation of other <code>SL_*</code> flags for <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a>, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create">IRP_MJ_CREATE (IFS)</a>.</p>
<p>Possible flag values include:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="sl_key_specified" title="#define SL_KEY_SPECIFIED 0x01">SL_KEY_SPECIFIED</a></td>
<td><code>0x01</code></td>
<td>Indicates that the <code>IO_STACK_LOCATION.Parameters.Read(OrWrite).Key</code> contains which copy of a given sector should be read when redundancy is enabled. Today this flag is use only with <a href="irp_mj_read" title="#define IRP_MJ_READ 0x03">IRP_MJ_READ</a> operations.</td>
</tr>
<tr>
<td><a href="sl_override_verify_volume" title="#define SL_OVERRIDE_VERIFY_VOLUME 0x02">SL_OVERRIDE_VERIFY_VOLUME</a></td>
<td><code>0x02</code></td>
<td>This flag is used to determine whether to continue the read operation even if the device object's <strong>Flags</strong> is set with <a href="do_verify_volume" title="#define DO_VERIFY_VOLUME 0x00000002">DO_VERIFY_VOLUME</a>.</td>
</tr>
<tr>
<td><a href="sl_write_through" title="#define SL_WRITE_THROUGH 0x04">SL_WRITE_THROUGH</a></td>
<td><code>0x04</code></td>
<td>This flag informs the storage driver to set appropriate flags so that the disk bypasses the write cache in order to force the disk to write through to its persistent storage media. <strong>This flag is device-specific; not all disk drives support bypassing disk-cache.</strong></td>
</tr>
<tr>
<td><a href="sl_ft_sequential_write" title="#define SL_FT_SEQUENTIAL_WRITE 0x08">SL_FT_SEQUENTIAL_WRITE</a></td>
<td><code>0x08</code></td>
<td>Reserved for system use.</td>
</tr>
<tr>
<td><a href="sl_force_direct_write" title="#define SL_FORCE_DIRECT_WRITE 0x10">SL_FORCE_DIRECT_WRITE</a></td>
<td><code>0x10</code></td>
<td>This flag lets kernel-mode drivers write to volume areas that they normally cannot write to because of blocking direct write in the file system and storage driver stack. Direct write blocking helps improve security. This flag is checked both at the file system layer and storage stack layer. For more information about direct write blocking, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">Blocking Direct Write Operations to Volumes and Disks</a>.</td>
</tr>
<tr>
<td><a href="sl_realtime_stream" title="#define SL_REALTIME_STREAM 0x20 // valid only with optical media">SL_REALTIME_STREAM</a></td>
<td><code>0x20</code></td>
<td>This flag hints that the IO is for real-time streaming requests to a CD-ROM class driver. This hints the driver to perform READ/WRITE operations at a guaranteed speed for real-time streaming. <strong>This flag is valid only with optical media.</strong></td>
</tr>
<tr>
<td><a href="sl_persistent_memory_fixed_mapping" title="#define SL_PERSISTENT_MEMORY_FIXED_MAPPING 0x20 // valid only with persistent memory device and IRP_MJ_WRITE">SL_PERSISTENT_MEMORY_FIXED_MAPPING</a></td>
<td><code>0x20</code></td>
<td>The persistent memory mapping of the bytes in the write request cannot change while handling this write request. <strong>This flag is valid only with a persistent memory device and <a href="irp_mj_write" title="#define IRP_MJ_WRITE 0x04">IRP_MJ_WRITE</a>.</strong></td>
</tr>
</tbody>
</table>
<p>For persistent memory devices, one of the reasons for remapping (modifying the physical address of a given LBA) on persistent memory devices is to provide efficient sector level atomicity. If the flag is not set, remapping is allowed especially if it results in the driver providing sector atomicity. File systems (or the requester) prefer that a persistent memory device driver provides sector atomicity.
If the flag is set, a persistent memory driver shall not remap the physical addresses corresponding
to the LBAs. If that means sector atomicity can't be provided, so be it. However, the driver is more
than welcome to provide sector atomicity as long as there is no remapping.</p>
<h3><code>Control</code></h3>
<p>Drivers can check this member to determine whether it is set with <a href="sl_pending_returned" title="#define SL_PENDING_RETURNED 0x01">SL_PENDING_RETURNED</a> and under what conditions the <em>CompletionRoutine</em> is called. Drivers have read-only access to this member. Drivers call <strong><a href="iosetcompletionroutine" title="VOID IoSetCompletionRoutine(&#10;  [in]           PIRP                   Irp,&#10;  [in, optional] PIO_COMPLETION_ROUTINE CompletionRoutine,&#10;  [in, optional] __drv_aliasesMem PVOID Context,&#10;  [in]           BOOLEAN                InvokeOnSuccess,&#10;  [in]           BOOLEAN                InvokeOnError,&#10;  [in]           BOOLEAN                InvokeOnCancel&#10;);">IoSetCompletionRoutine</a></strong> or <strong><a href="iosetcompletionroutineex" title="NTSTATUS IoSetCompletionRoutineEx(&#10;  [in]           PDEVICE_OBJECT         DeviceObject,&#10;  [in]           PIRP                   Irp,&#10;  [in]           PIO_COMPLETION_ROUTINE CompletionRoutine,&#10;  [in, optional] PVOID                  Context,&#10;  [in]           BOOLEAN                InvokeOnSuccess,&#10;  [in]           BOOLEAN                InvokeOnError,&#10;  [in]           BOOLEAN                InvokeOnCancel&#10;);">IoSetCompletionRoutineEx</a></strong> to specify these conditions.</p>
<h3><code>Parameters</code></h3>
<p>A union that depends on the major and minor <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> function code values contained in <strong>MajorFunction</strong> and <strong>MinorFunction</strong>. The following table shows which IRPs use the individual members of the <strong>Parameters</strong> union.</p>
<table>
<thead>
<tr>
<th>Member name</th>
<th>IRPs that use this member</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Create</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create">IRP_MJ_CREATE</a></td>
</tr>
<tr>
<td><strong>Read</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-read">IRP_MJ_READ</a></td>
</tr>
<tr>
<td><strong>Write</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write">IRP_MJ_WRITE</a></td>
</tr>
<tr>
<td><strong>QueryFile</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-information">IRP_MJ_QUERY_INFORMATION</a></td>
</tr>
<tr>
<td><strong>SetFile</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-information">IRP_MJ_SET_INFORMATION</a></td>
</tr>
<tr>
<td><strong>QueryVolume</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-volume-information">IRP_MJ_QUERY_VOLUME_INFORMATION</a></td>
</tr>
<tr>
<td><strong>DeviceIoControl</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-internal-device-control">IRP_MJ_INTERNAL_DEVICE_CONTROL</a></td>
</tr>
<tr>
<td><strong>MountVolume</strong></td>
<td><strong>IRP_MN_MOUNT_VOLUME</strong></td>
</tr>
<tr>
<td><strong>VerifyVolume</strong></td>
<td><strong>IRP_MN_VERIFY_VOLUME</strong></td>
</tr>
<tr>
<td><strong>Scsi</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-internal-device-control">IRP_MJ_INTERNAL_DEVICE_CONTROL</a> (SCSI)</td>
</tr>
<tr>
<td><strong>QueryDeviceRelations</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-device-relations">IRP_MN_QUERY_DEVICE_RELATIONS</a></td>
</tr>
<tr>
<td><strong>QueryInterface</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-interface">IRP_MN_QUERY_INTERFACE</a></td>
</tr>
<tr>
<td><strong>DeviceCapabilities</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-capabilities">IRP_MN_QUERY_CAPABILITIES</a></td>
</tr>
<tr>
<td><strong>FilterResourceRequirements</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-filter-resource-requirements">IRP_MN_FILTER_RESOURCE_REQUIREMENTS</a></td>
</tr>
<tr>
<td><strong>ReadWriteConfig</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-read-config">IRP_MN_READ_CONFIG</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-write-config">IRP_MN_WRITE_CONFIG</a></td>
</tr>
<tr>
<td><strong>SetLock</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-lock">IRP_MN_SET_LOCK</a></td>
</tr>
<tr>
<td><strong>QueryId</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-id">IRP_MN_QUERY_ID</a></td>
</tr>
<tr>
<td><strong>QueryDeviceText</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-device-text">IRP_MN_QUERY_DEVICE_TEXT</a></td>
</tr>
<tr>
<td><strong>UsageNotification</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-device-usage-notification">IRP_MN_DEVICE_USAGE_NOTIFICATION</a></td>
</tr>
<tr>
<td><strong>WaitWake</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-wait-wake">IRP_MN_WAIT_WAKE</a></td>
</tr>
<tr>
<td><strong>PowerSequence</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-power-sequence">IRP_MN_POWER_SEQUENCE</a></td>
</tr>
<tr>
<td><strong>Power</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-power">IRP_MN_SET_POWER</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-power">IRP_MN_QUERY_POWER</a></td>
</tr>
<tr>
<td><strong>StartDevice</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-start-device">IRP_MN_START_DEVICE</a></td>
</tr>
<tr>
<td><strong>WMI</strong></td>
<td><a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/wmi-minor-irps">WMI minor IRPs</a></td>
</tr>
<tr>
<td><strong>Others</strong></td>
<td>Driver-specific IRPs</td>
</tr>
</tbody>
</table>
<p>For more information, see <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-major-function-codes">IRP Major Function Codes</a>.</p>
<h3><code>Parameters.Create</code></h3>
<p>System service parameters for <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong>.</p>
<h3><code>Parameters.Create.SecurityContext</code></h3>
<h3><code>Parameters.Create.Options</code></h3>
<h3><code>Parameters.Create.FileAttributes</code></h3>
<h3><code>Parameters.Create.ShareAccess</code></h3>
<h3><code>Parameters.Create.EaLength</code></h3>
<h3><code>Parameters.CreatePipe</code></h3>
<p>System service parameters fo <strong><a href="ntcreatenamedpipefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateNamedPipeFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_ ULONG NamedPipeType,&#10;    _In_ ULONG ReadMode,&#10;    _In_ ULONG CompletionMode,&#10;    _In_ ULONG MaximumInstances,&#10;    _In_ ULONG InboundQuota,&#10;    _In_ ULONG OutboundQuota,&#10;    _In_ PLARGE_INTEGER DefaultTimeout&#10;    );">NtCreateNamedPipeFile</a></strong>.</p>
<h3><code>Parameters.CreatePipe.SecurityContext</code></h3>
<h3><code>Parameters.CreatePipe.Options</code></h3>
<h3><code>Parameters.CreatePipe.Reserved</code></h3>
<h3><code>Parameters.CreatePipe.ShareAccess</code></h3>
<h3><code>Parameters.CreatePipe.Parameters</code></h3>
<h3><code>Parameters.CreateMailslot</code></h3>
<p>System service parameters for <strong><a href="ntcreatemailslotfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateMailslotFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG CreateOptions,&#10;    _In_ ULONG MailslotQuota,&#10;    _In_ ULONG MaximumMessageSize,&#10;    _In_ PLARGE_INTEGER ReadTimeout&#10;    );">NtCreateMailslotFile</a></strong>.</p>
<h3><code>Parameters.CreateMailslot.SecurityContext</code></h3>
<h3><code>Parameters.CreateMailslot.Options</code></h3>
<h3><code>Parameters.CreateMailslot.Reserved</code></h3>
<h3><code>Parameters.CreateMailslot.ShareAccess</code></h3>
<h3><code>Parameters.CreateMailslot.Parameters</code></h3>
<h3><code>Parameters.Read</code></h3>
<p>System service parameters for <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong>.</p>
<h3><code>Parameters.Read.Length</code></h3>
<h3><code>Parameters.Read.Key</code></h3>
<h3><code>Parameters.Read.Flags</code></h3>
<h3><code>Parameters.Read.ByteOffset</code></h3>
<h3><code>Parameters.Write</code></h3>
<p>System service parameters for <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong>.</p>
<h3><code>Parameters.Write.Length</code></h3>
<h3><code>Parameters.Write.Key</code></h3>
<h3><code>Parameters.Write.Flags</code></h3>
<h3><code>Parameters.Write.ByteOffset</code></h3>
<h3><code>Parameters.QueryDirectory</code></h3>
<p>System service parameters for <strong><a href="ntquerydirectoryfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryDirectoryFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass,&#10;    _In_ BOOLEAN ReturnSingleEntry,&#10;    _In_opt_ PCUNICODE_STRING FileName,&#10;    _In_ BOOLEAN RestartScan&#10;    );">NtQueryDirectoryFile</a></strong>.</p>
<h3><code>Parameters.QueryDirectory.Length</code></h3>
<h3><code>Parameters.QueryDirectory.FileName</code></h3>
<h3><code>Parameters.QueryDirectory.FileInformationClass</code></h3>
<h3><code>Parameters.QueryDirectory.FileIndex</code></h3>
<h3><code>Parameters.NotifyDirectory</code></h3>
<p>System service parameters for <strong><a href="ntnotifychangedirectoryfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtNotifyChangeDirectoryFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer, // FILE_NOTIFY_INFORMATION&#10;    _In_ ULONG Length,&#10;    _In_ ULONG CompletionFilter,&#10;    _In_ BOOLEAN WatchTree&#10;    );">NtNotifyChangeDirectoryFile</a></strong>.</p>
<h3><code>Parameters.NotifyDirectory.Length</code></h3>
<h3><code>Parameters.NotifyDirectory.CompletionFilter</code></h3>
<h3><code>Parameters.NotifyDirectoryEx</code></h3>
<p>System service parameters for <strong><a href="ntnotifychangedirectoryfileex" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtNotifyChangeDirectoryFileEx(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_ ULONG CompletionFilter,&#10;    _In_ BOOLEAN WatchTree,&#10;    _In_opt_ DIRECTORY_NOTIFY_INFORMATION_CLASS DirectoryNotifyInformationClass&#10;    );">NtNotifyChangeDirectoryFileEx</a></strong>.</p>
<h3><code>Parameters.NotifyDirectoryEx.Length</code></h3>
<h3><code>Parameters.NotifyDirectoryEx.CompletionFilter</code></h3>
<h3><code>Parameters.NotifyDirectoryEx.DirectoryNotifyInformationClass</code></h3>
<h3><code>Parameters.QueryFile</code></h3>
<p>System service parameters for <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong>.</p>
<h3><code>Parameters.QueryFile.Length</code></h3>
<h3><code>Parameters.QueryFile.FileInformationClass</code></h3>
<h3><code>Parameters.SetFile</code></h3>
<p>System service parameters for <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong>.</p>
<h3><code>Parameters.SetFile.Length</code></h3>
<h3><code>Parameters.SetFile.FileInformationClass</code></h3>
<h3><code>Parameters.SetFile.FileObject</code></h3>
<h3><code>Parameters.SetFile.ReplaceIfExists</code></h3>
<h3><code>Parameters.SetFile.AdvanceOnly</code></h3>
<h3><code>Parameters.SetFile.ClusterCount</code></h3>
<h3><code>Parameters.SetFile.DeleteHandle</code></h3>
<h3><code>Parameters.QueryEa</code></h3>
<p>System service parameters for <strong><a href="ntqueryeafile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryEaFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_ BOOLEAN ReturnSingleEntry,&#10;    _In_reads_bytes_opt_(EaListLength) PVOID EaList,&#10;    _In_ ULONG EaListLength,&#10;    _In_opt_ PULONG EaIndex,&#10;    _In_ BOOLEAN RestartScan&#10;    );">NtQueryEaFile</a></strong>.</p>
<h3><code>Parameters.QueryEa.Length</code></h3>
<h3><code>Parameters.QueryEa.EaList</code></h3>
<h3><code>Parameters.QueryEa.EaListLength</code></h3>
<h3><code>Parameters.QueryEa.EaIndex</code></h3>
<h3><code>Parameters.SetEa</code></h3>
<p>System service parameters for <strong><a href="ntseteafile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetEaFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length&#10;    );">NtSetEaFile</a></strong>.</p>
<h3><code>Parameters.SetEa.Length</code></h3>
<h3><code>Parameters.QueryVolume</code></h3>
<p>System service parameters for <strong><a href="ntqueryvolumeinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryVolumeInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FsInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FSINFOCLASS FsInformationClass&#10;    );">NtQueryVolumeInformationFile</a></strong>.</p>
<h3><code>Parameters.QueryVolume.Length</code></h3>
<h3><code>Parameters.QueryVolume.FsInformationClass</code></h3>
<h3><code>Parameters.SetVolume</code></h3>
<p>System service parameters for <strong><a href="ntsetvolumeinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetVolumeInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FsInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FSINFOCLASS FsInformationClass&#10;    );">NtSetVolumeInformationFile</a></strong>.</p>
<h3><code>Parameters.SetVolume.Length</code></h3>
<h3><code>Parameters.SetVolume.FsInformationClass</code></h3>
<h3><code>Parameters.FileSystemControl</code></h3>
<p>System service parameters for <strong><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a></strong>.</p>
<h3><code>Parameters.FileSystemControl.OutputBufferLength</code></h3>
<h3><code>Parameters.FileSystemControl.InputBufferLength</code></h3>
<h3><code>Parameters.FileSystemControl.FsControlCode</code></h3>
<h3><code>Parameters.FileSystemControl.Type3InputBuffer</code></h3>
<h3><code>Parameters.LockControl</code></h3>
<p>System service parameters for <strong>LockFile/<a href="ntunlockfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtUnlockFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ PLARGE_INTEGER ByteOffset,&#10;    _In_ PLARGE_INTEGER Length,&#10;    _In_ ULONG Key&#10;    );">NtUnlockFile</a></strong>.</p>
<h3><code>Parameters.LockControl.Length</code></h3>
<h3><code>Parameters.LockControl.Key</code></h3>
<h3><code>Parameters.LockControl.ByteOffset</code></h3>
<h3><code>Parameters.DeviceIoControl</code></h3>
<p>System service parameters for <strong><a href="ntdeviceiocontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDeviceIoControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG IoControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtDeviceIoControlFile</a></strong>.</p>
<h3><code>Parameters.DeviceIoControl.OutputBufferLength</code></h3>
<h3><code>Parameters.DeviceIoControl.InputBufferLength</code></h3>
<h3><code>Parameters.DeviceIoControl.IoControlCode</code></h3>
<h3><code>Parameters.DeviceIoControl.Type3InputBuffer</code></h3>
<h3><code>Parameters.QuerySecurity</code></h3>
<p>System service parameters for <strong><a href="ntquerysecurityobject" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQuerySecurityObject(&#10;    _In_ HANDLE Handle,&#10;    _In_ SECURITY_INFORMATION SecurityInformation,&#10;    _Out_writes_bytes_to_opt_(Length, *LengthNeeded) PSECURITY_DESCRIPTOR SecurityDescriptor,&#10;    _In_ ULONG Length,&#10;    _Out_ PULONG LengthNeeded&#10;    );">NtQuerySecurityObject</a></strong>.</p>
<h3><code>Parameters.QuerySecurity.SecurityInformation</code></h3>
<h3><code>Parameters.QuerySecurity.Length</code></h3>
<h3><code>Parameters.SetSecurity</code></h3>
<p>System service parameters for <strong><a href="ntsetsecurityobject" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSecurityObject(&#10;    _In_ HANDLE Handle,&#10;    _In_ SECURITY_INFORMATION SecurityInformation,&#10;    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor&#10;    );">NtSetSecurityObject</a></strong>.</p>
<h3><code>Parameters.SetSecurity.SecurityInformation</code></h3>
<h3><code>Parameters.SetSecurity.SecurityDescriptor</code></h3>
<h3><code>Parameters.MountVolume</code></h3>
<p>System service parameters for <strong>MountVolume</strong>.</p>
<h3><code>Parameters.MountVolume.Vpb</code></h3>
<h3><code>Parameters.MountVolume.DeviceObject</code></h3>
<h3><code>Parameters.MountVolume.OutputBufferLength</code></h3>
<h3><code>Parameters.VerifyVolume</code></h3>
<p>System service parameters for <strong>VerifyVolume</strong>.</p>
<h3><code>Parameters.VerifyVolume.Vpb</code></h3>
<h3><code>Parameters.VerifyVolume.DeviceObject</code></h3>
<h3><code>Parameters.Scsi</code></h3>
<p>Parameters for Scsi with internal device control.</p>
<h3><code>Parameters.Scsi.Srb</code></h3>
<h3><code>Parameters.QueryQuota</code></h3>
<p>System service parameters for <strong><a href="ntqueryquotainformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryQuotaInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_ BOOLEAN ReturnSingleEntry,&#10;    _In_reads_bytes_opt_(SidListLength) PVOID SidList,&#10;    _In_ ULONG SidListLength,&#10;    _In_opt_ PSID StartSid,&#10;    _In_ BOOLEAN RestartScan&#10;    );">NtQueryQuotaInformationFile</a></strong>.</p>
<h3><code>Parameters.QueryQuota.Length</code></h3>
<h3><code>Parameters.QueryQuota.StartSid</code></h3>
<h3><code>Parameters.QueryQuota.SidList</code></h3>
<h3><code>Parameters.QueryQuota.SidListLength</code></h3>
<h3><code>Parameters.SetQuota</code></h3>
<p>System service parameters for <strong><a href="ntsetquotainformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetQuotaInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length&#10;    );">NtSetQuotaInformationFile</a></strong>.</p>
<h3><code>Parameters.SetQuota.Length</code></h3>
<h3><code>Parameters.QueryDeviceRelations</code></h3>
<p>Parameters for <a href="irp_mn_query_device_relations" title="#define IRP_MN_QUERY_DEVICE_RELATIONS 0x07">IRP_MN_QUERY_DEVICE_RELATIONS</a>.</p>
<h3><code>Parameters.QueryDeviceRelations.Type</code></h3>
<h3><code>Parameters.QueryInterface</code></h3>
<p>Parameters for <a href="irp_mn_query_interface" title="#define IRP_MN_QUERY_INTERFACE 0x08">IRP_MN_QUERY_INTERFACE</a>.</p>
<h3><code>Parameters.QueryInterface.InterfaceType</code></h3>
<h3><code>Parameters.QueryInterface.Size</code></h3>
<h3><code>Parameters.QueryInterface.Version</code></h3>
<h3><code>Parameters.QueryInterface.Interface</code></h3>
<h3><code>Parameters.QueryInterface.InterfaceSpecificData</code></h3>
<h3><code>Parameters.DeviceCapabilities</code></h3>
<p>Parameters for <a href="irp_mn_query_capabilities" title="#define IRP_MN_QUERY_CAPABILITIES 0x09">IRP_MN_QUERY_CAPABILITIES</a>.</p>
<h3><code>Parameters.DeviceCapabilities.Capabilities</code></h3>
<h3><code>Parameters.FilterResourceRequirements</code></h3>
<p>Parameters for <a href="irp_mn_filter_resource_requirements" title="#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D">IRP_MN_FILTER_RESOURCE_REQUIREMENTS</a>.</p>
<h3><code>Parameters.FilterResourceRequirements.IoResourceRequirementList</code></h3>
<h3><code>Parameters.ReadWriteConfig</code></h3>
<p>Parameters for <a href="irp_mn_read_config" title="#define IRP_MN_READ_CONFIG 0x0F">IRP_MN_READ_CONFIG</a> and <a href="irp_mn_write_config" title="#define IRP_MN_WRITE_CONFIG 0x10">IRP_MN_WRITE_CONFIG</a>.</p>
<h3><code>Parameters.ReadWriteConfig.WhichSpace</code></h3>
<h3><code>Parameters.ReadWriteConfig.Buffer</code></h3>
<h3><code>Parameters.ReadWriteConfig.Offset</code></h3>
<h3><code>Parameters.ReadWriteConfig.Length</code></h3>
<h3><code>Parameters.SetLock</code></h3>
<p>Parameters for <a href="irp_mn_set_lock" title="#define IRP_MN_SET_LOCK 0x12">IRP_MN_SET_LOCK</a>.</p>
<h3><code>Parameters.SetLock.Lock</code></h3>
<h3><code>Parameters.QueryId</code></h3>
<p>Parameters for <a href="irp_mn_query_id" title="#define IRP_MN_QUERY_ID 0x13">IRP_MN_QUERY_ID</a>.</p>
<h3><code>Parameters.QueryId.IdType</code></h3>
<h3><code>Parameters.QueryDeviceText</code></h3>
<p>Parameters for <a href="irp_mn_query_device_text" title="#define IRP_MN_QUERY_DEVICE_TEXT 0x0C">IRP_MN_QUERY_DEVICE_TEXT</a>.</p>
<h3><code>Parameters.QueryDeviceText.DeviceTextType</code></h3>
<h3><code>Parameters.QueryDeviceText.LocaleId</code></h3>
<h3><code>Parameters.UsageNotification</code></h3>
<p>Parameters for <a href="irp_mn_device_usage_notification" title="#define IRP_MN_DEVICE_USAGE_NOTIFICATION 0x16">IRP_MN_DEVICE_USAGE_NOTIFICATION</a>.</p>
<h3><code>Parameters.UsageNotification.InPath</code></h3>
<h3><code>Parameters.UsageNotification.Reserved[3]</code></h3>
<h3><code>Parameters.UsageNotification.Type</code></h3>
<h3><code>Parameters.WaitWake</code></h3>
<p>Parameters for <a href="irp_mn_wait_wake" title="#define IRP_MN_WAIT_WAKE 0x00">IRP_MN_WAIT_WAKE</a>.</p>
<h3><code>Parameters.WaitWake.PowerState</code></h3>
<h3><code>Parameters.PowerSequence</code></h3>
<p>Parameter for <a href="irp_mn_power_sequence" title="#define IRP_MN_POWER_SEQUENCE 0x01">IRP_MN_POWER_SEQUENCE</a>.</p>
<h3><code>Parameters.PowerSequence.PowerSequence</code></h3>
<h3><code>Parameters.Power.SystemPowerStateContext</code></h3>
<h3><code>Parameters.Power</code></h3>
<p>Parameters for <a href="irp_mn_set_power" title="#define IRP_MN_SET_POWER 0x02">IRP_MN_SET_POWER</a> and <a href="irp_mn_query_power" title="#define IRP_MN_QUERY_POWER 0x03">IRP_MN_QUERY_POWER</a>.</p>
<h3><code>Parameters.Power.SystemContext</code></h3>
<h3><code>Parameters.Power.Type</code></h3>
<h3><code>Parameters.Power.State</code></h3>
<h3><code>Parameters.Power.ShutdownType</code></h3>
<h3><code>Parameters.StartDevice</code></h3>
<p>Parameters for StartDevice.</p>
<h3><code>Parameters.StartDevice.AllocatedResources</code></h3>
<h3><code>Parameters.StartDevice.AllocatedResourcesTranslated</code></h3>
<h3><code>Parameters.WMI</code></h3>
<p>Parameters for WMI IRPs.</p>
<h3><code>Parameters.WMI.ProviderId</code></h3>
<h3><code>Parameters.WMI.DataPath</code></h3>
<h3><code>Parameters.WMI.BufferSize</code></h3>
<h3><code>Parameters.WMI.Buffer</code></h3>
<h3><code>Parameters.Others</code></h3>
<p>Parameters for other driver-specific operations.</p>
<h3><code>Parameters.Others.Argument1</code></h3>
<h3><code>Parameters.Others.Argument2</code></h3>
<h3><code>Parameters.Others.Argument3</code></h3>
<h3><code>Parameters.Others.Argument4</code></h3>
<h3><code>DeviceObject</code></h3>
<p>A pointer to the driver-created <strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong> structure representing the target physical, logical, or virtual device for which this driver is to handle the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>
<h3><code>FileObject</code></h3>
<p>A pointer to a <strong><a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">FILE_OBJECT</a></strong> structure that represents the file object, if any, that is associated with <strong>DeviceObject</strong> pointer.</p>
<h3><code>CompletionRoutine</code></h3>
<p>The completion routine that is invoked depending on the flags in the <strong>Control</strong> field of this structure.</p>
<h3><code>Context</code></h3>
<p>Driver-defined context that is used to store the address of the context parameter that is passed to the CompletionRoutine.</p>
<h2>Remarks</h2>
<p>For each <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>, there is one <strong>IO_STACK_LOCATION</strong> structure for each driver in a <a href="https://learn.microsoft.com/windows-hardware/drivers/">driver stack</a>. Each <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>'s set of I/O stack locations is appended to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>, following the <strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong> structure.</p>
<p>Every higher-level driver is responsible for setting up the I/O stack location for the next-lower driver in each <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. A driver must call <a href="iogetcurrentirpstacklocation" title="__drv_aliasesMem PIO_STACK_LOCATION IoGetCurrentIrpStackLocation(&#10;  [in] PIRP Irp&#10;);">IoGetCurrentIrpStackLocation</a> to get a pointer to its own stack location for each <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. Higher-level drivers can call <a href="iogetnextirpstacklocation" title="__drv_aliasesMem PIO_STACK_LOCATION IoGetNextIrpStackLocation(&#10;  [in] PIRP Irp&#10;);">IoGetNextIrpStackLocation</a> to get a pointer to the next-lower driver's stack location.</p>
<p>The higher-level driver must set up the stack location contents before calling <a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a> to pass an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the lower-level driver. If the driver will pass the input <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> on to the next lower-level driver, the dispatch routine should call <a href="ioskipcurrentirpstacklocation" title="VOID IoSkipCurrentIrpStackLocation(&#10;  [in, out] PIRP Irp&#10;);">IoSkipCurrentIrpStackLocation</a> or <a href="iocopycurrentirpstacklocationtonext" title="VOID IoCopyCurrentIrpStackLocationToNext(&#10;  [in, out] PIRP Irp&#10;);">IoCopyCurrentIrpStackLocationToNext</a> to set up the I/O stack location of the next-lower driver.</p>
<p>A higher-level driver's call to <strong><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a></strong> sets the <strong>DeviceObject</strong> member to the next-lower-level driver's target device object, in the I/O stack location of the lower driver. The I/O manager passes each higher-level driver's <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-io_completion_routine">IoCompletion</a> routine a pointer to its own device object when the <em>IoCompletion</em> routine is called on completion of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>
<p>If a higher-level driver allocates IRPs to make requests of its own, its <em>IoCompletion</em> routine is passed a <strong>NULL</strong> <strong>DeviceObject</strong> pointer if that driver neither allocates a stack location for itself nor sets up the <strong>DeviceObject</strong> pointer in its own stack location of the newly allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>
<p>In some cases, a higher-level driver layered over a mass-storage device driver is responsible for splitting up large transfer requests for the underlying device driver. In particular, SCSI class drivers must check the <strong>Parameters.Read.Length</strong> and <strong>Parameters.Write.Length</strong>, determine whether the size of the requested transfer exceeds the underlying HBA's transfer capabilities, and, if so, split the <strong>Length</strong> of the original request into a sequence of partial transfers to satisfy the original <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>
<h2>See also</h2>
<p><strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong></p>
<p><strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong></p>
<p><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a></p>
<p><a href="iocopycurrentirpstacklocationtonext" title="VOID IoCopyCurrentIrpStackLocationToNext(&#10;  [in, out] PIRP Irp&#10;);">IoCopyCurrentIrpStackLocationToNext</a></p>
<p><a href="iogetcurrentirpstacklocation" title="__drv_aliasesMem PIO_STACK_LOCATION IoGetCurrentIrpStackLocation(&#10;  [in] PIRP Irp&#10;);">IoGetCurrentIrpStackLocation</a></p>
<p><a href="iogetnextirpstacklocation" title="__drv_aliasesMem PIO_STACK_LOCATION IoGetNextIrpStackLocation(&#10;  [in] PIRP Irp&#10;);">IoGetNextIrpStackLocation</a></p>
<p><a href="iosetcompletionroutine" title="VOID IoSetCompletionRoutine(&#10;  [in]           PIRP                   Irp,&#10;  [in, optional] PIO_COMPLETION_ROUTINE CompletionRoutine,&#10;  [in, optional] __drv_aliasesMem PVOID Context,&#10;  [in]           BOOLEAN                InvokeOnSuccess,&#10;  [in]           BOOLEAN                InvokeOnError,&#10;  [in]           BOOLEAN                InvokeOnCancel&#10;);">IoSetCompletionRoutine</a></p>
<p><a href="iosetnextirpstacklocation" title="VOID IoSetNextIrpStackLocation(&#10;  [in, out] PIRP Irp&#10;);">IoSetNextIrpStackLocation</a></p>
<p><a href="ioskipcurrentirpstacklocation" title="VOID IoSkipCurrentIrpStackLocation(&#10;  [in, out] PIRP Irp&#10;);">IoSkipCurrentIrpStackLocation</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/ns-wdm-_io_stack_location.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
