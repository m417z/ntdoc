<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="RtlStringCbLengthA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>RtlStringCbLengthA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            RtlStringCbLengthA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTSTRSAFE_H_INCLUDED_
#ifndef NTSTRSAFE_LIB_IMPL
#ifndef NTSTRSAFE_NO_CB_FUNCTIONS

</span><span class="ntdoc-code-intro">/*++

  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
  RtlStringCbLength(
  _In_reads_or_z_(cbMax) LPCTSTR psz,
  _In_ _In_range_(1, <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> * sizeof(TCHAR)) <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a>  cbMax,
  _Out_opt_ _Deref_out_range_(&lt;, cbMax) <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a>* pcbLength   OPTIONAL
  );

  Routine Description:

  This routine is a safer version of the C built-in function &#x27;strlen&#x27;.
  It is used to make sure a string is not larger than a given length, and
  it optionally returns the current length in bytes not including
  the null terminator.

  This function returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value, and not a pointer.  It returns
  <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the string is non-null and the length including the null
  terminator is less than or equal to cbMax bytes.

Arguments:

psz         -   string to check the length of

cbMax       -   maximum number of bytes including the null terminator
that psz is allowed to contain

pcb         -   if the function succeeds and pcb is non-null, the current length
in bytes of psz excluding the null terminator will be returned.
This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
psz can be null but the function will fail

cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

<a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> -   psz is non-null and the length including the null
terminator is less than or equal to cbMax bytes

failure        -   you can use the macro NTSTATUS_CODE() to get a win32
error code for all hresult failure cases

It is strongly recommended to use the <a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>() macro to test the
return value of this function.

--*/


</span><span class="ntdoc-code-body">_Must_inspect_result_
<a href="ntstrsafeddi" title="#define NTSTRSAFEDDI __inline NTSTATUS __clrcall">NTSTRSAFEDDI</a>
    RtlStringCbLengthA(
            _In_reads_or_z_(cbMax) <a href="strsafe_pcnzch" title="typedef const char* STRSAFE_PCNZCH;">STRSAFE_PCNZCH</a> psz,
            _In_ _In_range_(1, <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> * sizeof(char)) <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a> cbMax,
            _Out_opt_ _Deref_out_range_(&lt;, cbMax) <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a>* pcbLength)
{
    <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> status;
    <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a> cchMax = cbMax / sizeof(char);
    <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a> cchLength = 0;

    if ((psz == NULL) || (cchMax &gt; <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a>))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else
    {
        status = <a href="rtlstringlengthworkera" title="NTSTRSAFEWORKERDDI&#10;RtlStringLengthWorkerA(&#10;    _In_reads_or_z_(cchMax) STRSAFE_PCNZCH psz,&#10;    _In_ _In_range_(&lt;=, NTSTRSAFE_MAX_CCH) size_t cchMax,&#10;    _Out_opt_ _Deref_out_range_(&lt;, cchMax) _Deref_out_range_(&lt;=, _String_length_(psz)) size_t* pcchLength);">RtlStringLengthWorkerA</a>(psz, cchMax, &amp;cchLength);
    }

    if (pcbLength)
    {
        if (<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status))
        {
            // safe to multiply cchLength * sizeof(char) since cchLength &lt; <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> and sizeof(char) is 1
            *pcbLength = cchLength * sizeof(char);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return status;
}
</span><span class="ntdoc-code-footer">
#endif
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/92c9ab67ea8f980e12b6ee945393e8607be5e17c/phnt/include/ntstrsafe.h#L6460">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntstrsafe.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstrsafeddi" title="#define NTSTRSAFEDDI __inline NTSTATUS __clrcall">NTSTRSAFEDDI</a> RtlStringCbLengthA(
  [in] <a href="strsafe_pcnzch" title="typedef const char* STRSAFE_PCNZCH;">STRSAFE_PCNZCH</a> psz,
  [in] <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a>         cbMax,
       <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a>         *pcbLength
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntstrsafe/nf-ntstrsafe-rtlstringcblengtha">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/rtlstringcblengtha.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntstrsafe-rtlstringcblengtha)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="rtlstringcblengtha-function">RtlStringCbLengthA function</h1>

<h2 id="description">Description</h2>

<p>The <strong><a href="rtlstringcblengthw" title="_Must_inspect_result_&#10;NTSTRSAFEDDI&#10;    RtlStringCbLengthW(&#10;            _In_reads_or_z_(cbMax / sizeof(wchar_t)) STRSAFE_PCNZWCH psz,&#10;            _In_ _In_range_(1, NTSTRSAFE_MAX_CCH * sizeof(wchar_t)) size_t cbMax,&#10;            _Out_opt_ _Deref_out_range_(&lt;, cbMax - 1) size_t* pcbLength)&#10;{&#10;    NTSTATUS status;&#10;    size_t cchMax = cbMax / sizeof(wchar_t);&#10;    size_t cchLength = 0;&#10;&#10;    if ((psz == NULL) || (cchMax &gt; NTSTRSAFE_MAX_CCH))&#10;    {&#10;        status = STATUS_INVALID_PARAMETER;&#10;    }&#10;    else&#10;    {&#10;        status = RtlStringLengthWorkerW(psz, cchMax, &amp;cchLength);&#10;    }&#10;&#10;...">RtlStringCbLengthW</a></strong> and <strong>RtlStringCbLengthA</strong> functions determine the length, in bytes, of a supplied string.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="psz-in"><code>psz</code> [in]</h3>

<p>A pointer to a buffer that contains a null-terminated string, the length of which will be checked.</p>

<h3 id="cbmax-in"><code>cbMax</code> [in]</h3>

<p>The maximum number of bytes allowed in the buffer that is pointed to by <em>psz</em>, including the terminating null character.</p>

<p>For Unicode strings, the maximum number of bytes is <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> * sizeof(WCHAR).</p>

<p>For ANSI strings, the maximum number of bytes is <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> * sizeof(char).</p>

<h3 id="pcblength"><code>pcbLength</code></h3>

<p>If the caller supplies a non-<strong>NULL</strong> address pointer, the function loads the address with the length, in bytes, of the string that is contained in the buffer. The length does not include the string's terminating null character.</p>

<h2 id="return-value">Return value</h2>

<p>The function returns one of the <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> values that are listed in the following table. For information about how to test <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> values, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-ntstatus-values">Using NTSTATUS Values</a>.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>This <em>success</em> status means the string at <em>psz</em> was not <strong>NULL</strong>, and the length of the string (including the terminating null character) is less than or equal to <em>cbMax</em> characters.</td>
</tr>
<tr>
  <td><strong>STATUS_INVALID_PARAMETER</strong></td>
  <td>This <em>error</em> status means the value in <em>psz</em> is <strong>NULL</strong>, <em>cbMax</em> is larger than <a href="ntstrsafe_max_cch" title="#define NTSTRSAFE_MAX_CCH 2147483647 // max buffer size, in characters, that we support (same as INT_MAX)">NTSTRSAFE_MAX_CCH</a> * sizeof(TCHAR), or <em>psz</em> is longer than <em>cbMax</em>.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p><strong><a href="rtlstringcblengthw" title="_Must_inspect_result_&#10;NTSTRSAFEDDI&#10;    RtlStringCbLengthW(&#10;            _In_reads_or_z_(cbMax / sizeof(wchar_t)) STRSAFE_PCNZWCH psz,&#10;            _In_ _In_range_(1, NTSTRSAFE_MAX_CCH * sizeof(wchar_t)) size_t cbMax,&#10;            _Out_opt_ _Deref_out_range_(&lt;, cbMax - 1) size_t* pcbLength)&#10;{&#10;    NTSTATUS status;&#10;    size_t cchMax = cbMax / sizeof(wchar_t);&#10;    size_t cchLength = 0;&#10;&#10;    if ((psz == NULL) || (cchMax &gt; NTSTRSAFE_MAX_CCH))&#10;    {&#10;        status = STATUS_INVALID_PARAMETER;&#10;    }&#10;    else&#10;    {&#10;        status = RtlStringLengthWorkerW(psz, cchMax, &amp;cchLength);&#10;    }&#10;&#10;...">RtlStringCbLengthW</a></strong> and <strong>RtlStringCbLengthA</strong> should be used instead of <strong>strlen</strong>. Use these functions to ensure that a string is not larger than a given length, in bytes. If that condition is met, <strong><a href="rtlstringcblengthw" title="_Must_inspect_result_&#10;NTSTRSAFEDDI&#10;    RtlStringCbLengthW(&#10;            _In_reads_or_z_(cbMax / sizeof(wchar_t)) STRSAFE_PCNZWCH psz,&#10;            _In_ _In_range_(1, NTSTRSAFE_MAX_CCH * sizeof(wchar_t)) size_t cbMax,&#10;            _Out_opt_ _Deref_out_range_(&lt;, cbMax - 1) size_t* pcbLength)&#10;{&#10;    NTSTATUS status;&#10;    size_t cchMax = cbMax / sizeof(wchar_t);&#10;    size_t cchLength = 0;&#10;&#10;    if ((psz == NULL) || (cchMax &gt; NTSTRSAFE_MAX_CCH))&#10;    {&#10;        status = STATUS_INVALID_PARAMETER;&#10;    }&#10;    else&#10;    {&#10;        status = RtlStringLengthWorkerW(psz, cchMax, &amp;cchLength);&#10;    }&#10;&#10;...">RtlStringCbLengthW</a></strong> and <strong>RtlStringCbLengthA</strong> return the current length of the string in bytes, not including those bytes used for the terminating null character.</p>

<p>Use <strong><a href="rtlstringcblengthw" title="_Must_inspect_result_&#10;NTSTRSAFEDDI&#10;    RtlStringCbLengthW(&#10;            _In_reads_or_z_(cbMax / sizeof(wchar_t)) STRSAFE_PCNZWCH psz,&#10;            _In_ _In_range_(1, NTSTRSAFE_MAX_CCH * sizeof(wchar_t)) size_t cbMax,&#10;            _Out_opt_ _Deref_out_range_(&lt;, cbMax - 1) size_t* pcbLength)&#10;{&#10;    NTSTATUS status;&#10;    size_t cchMax = cbMax / sizeof(wchar_t);&#10;    size_t cchLength = 0;&#10;&#10;    if ((psz == NULL) || (cchMax &gt; NTSTRSAFE_MAX_CCH))&#10;    {&#10;        status = STATUS_INVALID_PARAMETER;&#10;    }&#10;    else&#10;    {&#10;        status = RtlStringLengthWorkerW(psz, cchMax, &amp;cchLength);&#10;    }&#10;&#10;...">RtlStringCbLengthW</a></strong> to handle Unicode strings and <strong>RtlStringCbLengthA</strong> to handle ANSI strings. The form you use depends on your data, as shown in the following table.</p>

<table>
<thead>
<tr>
  <th>String data type</th>
  <th>String literal</th>
  <th>Function</th>
</tr>
</thead>
<tbody>
<tr>
  <td>WCHAR</td>
  <td>L"string"</td>
  <td><strong><a href="rtlstringcblengthw" title="_Must_inspect_result_&#10;NTSTRSAFEDDI&#10;    RtlStringCbLengthW(&#10;            _In_reads_or_z_(cbMax / sizeof(wchar_t)) STRSAFE_PCNZWCH psz,&#10;            _In_ _In_range_(1, NTSTRSAFE_MAX_CCH * sizeof(wchar_t)) size_t cbMax,&#10;            _Out_opt_ _Deref_out_range_(&lt;, cbMax - 1) size_t* pcbLength)&#10;{&#10;    NTSTATUS status;&#10;    size_t cchMax = cbMax / sizeof(wchar_t);&#10;    size_t cchLength = 0;&#10;&#10;    if ((psz == NULL) || (cchMax &gt; NTSTRSAFE_MAX_CCH))&#10;    {&#10;        status = STATUS_INVALID_PARAMETER;&#10;    }&#10;    else&#10;    {&#10;        status = RtlStringLengthWorkerW(psz, cchMax, &amp;cchLength);&#10;    }&#10;&#10;...">RtlStringCbLengthW</a></strong></td>
</tr>
<tr>
  <td><strong>char</strong></td>
  <td>"string"</td>
  <td><strong>RtlStringCbLengthA</strong></td>
</tr>
</tbody>
</table>

<p>For more information about the safe string functions, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-safe-string-functions">Using Safe String Functions</a>.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntstrsafe/nf-ntstrsafe-rtlstringcchlengtha">RtlStringCchLength</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntstrsafe/nf-ntstrsafe-rtlstringcblengtha">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntstrsafe/nf-ntstrsafe-rtlstringcblengtha.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
