<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="MmGetSystemAddressForMdlSafe - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>MmGetSystemAddressForMdlSafe - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            MmGetSystemAddressForMdlSafe - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PVOID MmGetSystemAddressForMdlSafe(
  [in] <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a>  Mdl,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Priority
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmgetsystemaddressformdlsafe">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/mmgetsystemaddressformdlsafe.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-mmgetsystemaddressformdlsafe)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>MmGetSystemAddressForMdlSafe</strong> macro returns a nonpaged system-space virtual address for the buffer that the specified <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> describes.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="mdl-in"><code>Mdl</code> [in]</h3>

<p>Pointer to a buffer whose corresponding base virtual address is to be mapped.</p>

<h3 id="priority-in"><code>Priority</code> [in]</h3>

<p>Specifies an <strong>MM_PAGE_PRIORITY</strong> value that indicates the importance of success under low available PTE conditions. Specify a priority value of <strong>LowPagePriority</strong>, <strong>NormalPagePriority</strong>, or <strong>HighPagePriority</strong>. Starting with Windows 8, the specified priority value can be bitwise-ORed with the <strong>MdlMappingNoWrite</strong> or <strong>MdlMappingNoExecute</strong> flags.</p>

<ul>
<li><p><strong>LowPagePriority</strong> indicates that the mapping request can fail if the system is fairly low on resources. An example of this situation is a noncritical network connection where the driver can handle the mapping failure.</p></li>
<li><p><strong>NormalPagePriority</strong> indicates that the mapping request can fail if the system is very low on resources. An example of this situation is a noncritical local file system request.</p></li>
<li><p><strong>HighPagePriority</strong> indicates that the mapping request must not fail unless the system is completely out of resources. An example of this situation is the paging file path in a driver.</p></li>
<li><p><strong>MdlMappingNoWrite</strong> indicates that the mapped physical pages are to be configured as no-write (read only) memory. Starting with Windows 8, this flag bit can be bitwise-ORed with the <strong>MM_PAGE_PRIORITY</strong> value to specify memory in which writes are disabled.</p></li>
<li><p><strong>MdlMappingNoExecute</strong> indicates that the mapped physical pages are to be configured as no-execute memory. Starting with Windows 8, this flag bit can be bitwise-ORed with the <strong>MM_PAGE_PRIORITY</strong> value to specify memory in which instruction execution is disabled. As a best practice, drivers written for Windows 8 and later versions of Windows should always specify no-execute memory unless executable memory is explicitly required.</p></li>
</ul>

<h2 id="return-value">Return value</h2>

<p><strong>MmGetSystemAddressForMdlSafe</strong> returns the base system-space virtual address that maps the physical pages that the specified <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> describes. If the pages are not already mapped to system address space and the attempt to map them fails, <strong>NULL</strong> is returned.</p>

<h2 id="remarks">Remarks</h2>

<p>This routine maps the physical pages that are described by the specified <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> into system address space, if they are not already mapped to system address space.</p>

<p>Drivers of programmed-I/O (PIO) devices call this routine to map a user-mode buffer, which is described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> at <strong>Irp->MdlAddress</strong> and which is already mapped to a user-mode virtual address range, to a range in system address space.</p>

<p>On entry to this routine, the specified <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must describe physical pages that are locked down. A locked-down <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> can be built by using the <strong><a href="mmprobeandlockpages" title="VOID MmProbeAndLockPages(&#10;  [in, out] PMDL            MemoryDescriptorList,&#10;  [in]      KPROCESSOR_MODE AccessMode,&#10;  [in]      LOCK_OPERATION  Operation&#10;);">MmProbeAndLockPages</a></strong>, <strong><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></strong>, <strong><a href="iobuildpartialmdl" title="VOID IoBuildPartialMdl(&#10;  [in]      PMDL  SourceMdl,&#10;  [in, out] PMDL  TargetMdl,&#10;  [in]      PVOID VirtualAddress,&#10;  [in]      ULONG Length&#10;);">IoBuildPartialMdl</a></strong>, or <strong><a href="mmallocatepagesformdlex" title="PMDL MmAllocatePagesForMdlEx(&#10;  [in] PHYSICAL_ADDRESS    LowAddress,&#10;  [in] PHYSICAL_ADDRESS    HighAddress,&#10;  [in] PHYSICAL_ADDRESS    SkipBytes,&#10;  [in] SIZE_T              TotalBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType,&#10;  [in] ULONG               Flags&#10;);">MmAllocatePagesForMdlEx</a></strong> routine.</p>

<p>When the system-address-space mapping that is returned by <strong>MmGetSystemAddressForMdlSafe</strong> is no longer needed, it must be released. The steps that are required to release the mapping depend on how the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> was built. These are the four possible cases:</p>

<ul>
<li><p>If the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> was built by a call to the <strong><a href="mmprobeandlockpages" title="VOID MmProbeAndLockPages(&#10;  [in, out] PMDL            MemoryDescriptorList,&#10;  [in]      KPROCESSOR_MODE AccessMode,&#10;  [in]      LOCK_OPERATION  Operation&#10;);">MmProbeAndLockPages</a></strong> routine, it is not necessary to explicitly release the system-address-space mapping. Instead, a call to the <strong><a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a></strong> routine releases the mapping, if one was allocated.</p></li>
<li><p>If the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> was built by a call to the <strong><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></strong> routine, <strong>MmGetSystemAddressForMdlSafe</strong> reuses the existing system-address-space mapping instead of creating a new one. In this case, no cleanup is required (that is, unlocking and unmapping are not necessary).</p></li>
<li><p>If the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> was built by a call to the <strong><a href="iobuildpartialmdl" title="VOID IoBuildPartialMdl(&#10;  [in]      PMDL  SourceMdl,&#10;  [in, out] PMDL  TargetMdl,&#10;  [in]      PVOID VirtualAddress,&#10;  [in]      ULONG Length&#10;);">IoBuildPartialMdl</a></strong> routine, the driver must call either the <strong><a href="mmpreparemdlforreuse" title="VOID MmPrepareMdlForReuse(&#10;  [in] PMDL MDL&#10;);">MmPrepareMdlForReuse</a></strong> routine or the <strong><a href="iofreemdl" title="VOID IoFreeMdl(&#10;  [in] PMDL Mdl&#10;);">IoFreeMdl</a></strong> routine to release the system-address-space mapping.</p></li>
<li><p>If the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> was built by a call to the <strong><a href="mmallocatepagesformdlex" title="PMDL MmAllocatePagesForMdlEx(&#10;  [in] PHYSICAL_ADDRESS    LowAddress,&#10;  [in] PHYSICAL_ADDRESS    HighAddress,&#10;  [in] PHYSICAL_ADDRESS    SkipBytes,&#10;  [in] SIZE_T              TotalBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType,&#10;  [in] ULONG               Flags&#10;);">MmAllocatePagesForMdlEx</a></strong> routine, the driver must call the <strong><a href="mmunmaplockedpages" title="VOID MmUnmapLockedPages(&#10;  [in] PVOID BaseAddress,&#10;  [in] PMDL  MemoryDescriptorList&#10;);">MmUnmapLockedPages</a></strong> routine to release the system-address-space mapping. If <strong>MmGetSystemAddressForMdlSafe</strong> is called more than one time for an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>, subsequent <strong>MmGetSystemAddressForMdlSafe</strong> calls simply return the mapping that was created by the first call. One call to <strong><a href="mmunmaplockedpages" title="VOID MmUnmapLockedPages(&#10;  [in] PVOID BaseAddress,&#10;  [in] PMDL  MemoryDescriptorList&#10;);">MmUnmapLockedPages</a></strong> is sufficient to release this mapping.</p></li>
</ul>

<p>Starting with Windows 7 and Windows Server 2008 R2, it is not necessary to explicitly call <strong><a href="mmunmaplockedpages" title="VOID MmUnmapLockedPages(&#10;  [in] PVOID BaseAddress,&#10;  [in] PMDL  MemoryDescriptorList&#10;);">MmUnmapLockedPages</a></strong> for an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that was created by <strong><a href="mmallocatepagesformdlex" title="PMDL MmAllocatePagesForMdlEx(&#10;  [in] PHYSICAL_ADDRESS    LowAddress,&#10;  [in] PHYSICAL_ADDRESS    HighAddress,&#10;  [in] PHYSICAL_ADDRESS    SkipBytes,&#10;  [in] SIZE_T              TotalBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType,&#10;  [in] ULONG               Flags&#10;);">MmAllocatePagesForMdlEx</a></strong>. Instead, a call to the <strong><a href="mmfreepagesfrommdl" title="VOID MmFreePagesFromMdl(&#10;  [in] PMDL MemoryDescriptorList&#10;);">MmFreePagesFromMdl</a></strong> routine releases the system-address-space mapping, if one was allocated.</p>

<p>To create a new system-address-space mapping, <strong>MmGetSystemAddressForMdlSafe</strong> calls <strong><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></strong> with the _CacheType_ parameter set to <strong>MmCached</strong>. A driver that requires a cache type other than <strong>MmCached</strong> should call <strong><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></strong> directly instead of calling <strong>MmGetSystemAddressForMdlSafe</strong>. For more information about the _CacheType_ parameter, see <strong><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></strong>.</p>

<p>In a call to <strong><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></strong>, the specified cache type is used only if the pages that are described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> do not already have a cache type associated with them. However, in nearly all cases, the pages already have an associated cache type, and this cache type is used by the new mapping. An exception to this rule is for pages that are allocated by <strong><a href="mmallocatepagesformdl" title="PMDL MmAllocatePagesForMdl(&#10;  [in] PHYSICAL_ADDRESS LowAddress,&#10;  [in] PHYSICAL_ADDRESS HighAddress,&#10;  [in] PHYSICAL_ADDRESS SkipBytes,&#10;  [in] SIZE_T           TotalBytes&#10;);">MmAllocatePagesForMdl</a></strong>, which sets the cache type to <strong>MmCached</strong> regardless of the original cache type of the pages.</p>

<p>Only one thread at a time can safely call <strong>MmGetSystemAddressForMdlSafe</strong> for a particular <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> because this routine assumes that the calling thread owns the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>. However, <strong>MmGetSystemAddressForMdlSafe</strong> can be called more than one time for the same <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> either by making all calls from the same thread or, if the calls are from multiple threads, by explicitly synchronizing the calls.</p>

<p>If a driver must split a request into smaller requests, the driver can allocate additional MDLs, or the driver can use the <strong><a href="iobuildpartialmdl" title="VOID IoBuildPartialMdl(&#10;  [in]      PMDL  SourceMdl,&#10;  [in, out] PMDL  TargetMdl,&#10;  [in]      PVOID VirtualAddress,&#10;  [in]      ULONG Length&#10;);">IoBuildPartialMdl</a></strong> routine.</p>

<p>The returned base address has the same offset as the virtual address in the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<p>Windows 98 does not support <strong>MmGetSystemAddressForMdlSafe</strong>. Use <strong><a href="mmgetsystemaddressformdl" title="PVOID MmGetSystemAddressForMdl(&#10;   MDL&#10;);">MmGetSystemAddressForMdl</a></strong> instead.</p>

<p>Because this macro calls <strong><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></strong>, using it may require linking to NtosKrnl.lib.</p>

<h2 id="see-also">See also</h2>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmgetsystemaddressformdlsafe">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-mmgetsystemaddressformdlsafe.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
