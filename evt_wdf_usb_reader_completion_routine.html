<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="EVT_WDF_USB_READER_COMPLETION_ROUTINE - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>EVT_WDF_USB_READER_COMPLETION_ROUTINE - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            EVT_WDF_USB_READER_COMPLETION_ROUTINE - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdfusb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">EVT_WDF_USB_READER_COMPLETION_ROUTINE EvtWdfUsbReaderCompletionRoutine;

VOID EvtWdfUsbReaderCompletionRoutine(
  [in] WDFUSBPIPE Pipe,
  [in] WDFMEMORY Buffer,
  [in] <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a> NumBytesTransferred,
  [in] WDFCONTEXT Context
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_reader_completion_routine">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/evt_wdf_usb_reader_completion_routine.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wdfusb-evt_wdf_usb_reader_completion_routine)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="evt_wdf_usb_reader_completion_routine-callback-function">EVT_WDF_USB_READER_COMPLETION_ROUTINE callback function</h1>

<h2 id="description">Description</h2>

<p>[Applies to KMDF and UMDF]</p>

<p>A driver's <em>EvtUsbTargetPipeReadComplete</em> event callback function informs the driver that a continuous reader has successfully completed a read request.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="pipe-in"><code>Pipe</code> [in]</h3>

<p>A handle to a framework pipe object.</p>

<h3 id="buffer-in"><code>Buffer</code> [in]</h3>

<p>A handle to a framework memory object that represents a buffer that contains data from the device.</p>

<h3 id="numbytestransferred-in"><code>NumBytesTransferred</code> [in]</h3>

<p>The number of bytes of data that are in the read buffer.</p>

<h3 id="context-in"><code>Context</code> [in]</h3>

<p>Driver-defined context information that the driver specified in the <strong>EvtUsbTargetPipeReadCompleteContext</strong> member of the pipe's <a href="wdf_usb_continuous_reader_config" title="typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG {&#10;  ULONG                                 Size;&#10;  size_t                                TransferLength;&#10;  size_t                                HeaderLength;&#10;  size_t                                TrailerLength;&#10;  UCHAR                                 NumPendingReads;&#10;  PWDF_OBJECT_ATTRIBUTES                BufferAttributes;&#10;  PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;&#10;  WDFCONTEXT                            EvtUsbTargetPipeReadCompleteContext;&#10;  PFN_WDF_USB_READERS_FAILED            EvtUsbTargetPipeReadersFailed;&#10;} WDF_USB_CONTINUOUS_READER_CONFIG, *PWDF_USB_CONTINUOUS_READER_CONFIG;">WDF_USB_CONTINUOUS_READER_CONFIG</a> structure.</p>

<h2 id="remarks">Remarks</h2>

<p>To register an <em>EvtUsbTargetPipeReadComplete</em> callback function, the driver must place the function's address in a <a href="wdf_usb_continuous_reader_config" title="typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG {&#10;  ULONG                                 Size;&#10;  size_t                                TransferLength;&#10;  size_t                                HeaderLength;&#10;  size_t                                TrailerLength;&#10;  UCHAR                                 NumPendingReads;&#10;  PWDF_OBJECT_ATTRIBUTES                BufferAttributes;&#10;  PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;&#10;  WDFCONTEXT                            EvtUsbTargetPipeReadCompleteContext;&#10;  PFN_WDF_USB_READERS_FAILED            EvtUsbTargetPipeReadersFailed;&#10;} WDF_USB_CONTINUOUS_READER_CONFIG, *PWDF_USB_CONTINUOUS_READER_CONFIG;">WDF_USB_CONTINUOUS_READER_CONFIG</a> structure.</p>

<p>If a driver has created a continuous reader for a USB pipe, the framework calls the driver's <em>EvtUsbTargetPipeReadComplete</em> callback function each time the driver's I/O target successfully completes a read request. The callback function is called at the IRQL at which the I/O target completed the read request, which is typically IRQL = DISPATCH_LEVEL, but no higher than DISPATCH_LEVEL. (If the I/O target does not successfully complete a request, the framework calls the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_readers_failed">EvtUsbTargetPipeReadersFailed</a> callback function.)</p>

<p>To access the buffer that contains data that was read from the device, the driver can call <a href="wdfmemorygetbuffer" title="PVOID WdfMemoryGetBuffer(&#10;  [in]            WDFMEMORY Memory,&#10;  [out, optional] size_t    *BufferSize&#10;);">WdfMemoryGetBuffer</a>. The framework writes the data into the buffer, after the header that is defined by the <strong>HeaderLength</strong> member of the <a href="wdf_usb_continuous_reader_config" title="typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG {&#10;  ULONG                                 Size;&#10;  size_t                                TransferLength;&#10;  size_t                                HeaderLength;&#10;  size_t                                TrailerLength;&#10;  UCHAR                                 NumPendingReads;&#10;  PWDF_OBJECT_ATTRIBUTES                BufferAttributes;&#10;  PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;&#10;  WDFCONTEXT                            EvtUsbTargetPipeReadCompleteContext;&#10;  PFN_WDF_USB_READERS_FAILED            EvtUsbTargetPipeReadersFailed;&#10;} WDF_USB_CONTINUOUS_READER_CONFIG, *PWDF_USB_CONTINUOUS_READER_CONFIG;">WDF_USB_CONTINUOUS_READER_CONFIG</a> structure. Note that the pointer that <strong><a href="wdfmemorygetbuffer" title="PVOID WdfMemoryGetBuffer(&#10;  [in]            WDFMEMORY Memory,&#10;  [out, optional] size_t    *BufferSize&#10;);">WdfMemoryGetBuffer</a></strong> returns points to the beginning of the header, but the <em>EvtUsbTargetPipeReadComplete</em> callback function's <em>NumBytesTransferred</em> parameter does <em>not</em> include the header's length.</p>

<p>By default, the framework deletes the buffer's memory object after the <em>EvtUsbTargetPipeReadComplete</em> callback function returns. However, you might want the memory object to remain valid after the callback function returns. For example, you might want your driver to store the object handle in the framework pipe object's context space so that the driver can process the memory object's contents after the callback function returns. To extend the lifetime of the memory object, the callback function must pass the memory object's handle to <a href="wdfobjectreference" title="VOID WdfObjectReference(&#10;  [in] WDFOBJECT Handle&#10;);">WdfObjectReference</a>. Subsequently, the driver must call <a href="wdfobjectdereference" title="VOID WdfObjectDereference(&#10;  [in] WDFOBJECT Handle&#10;);">WdfObjectDereference</a> so that the framework can delete the object.</p>

<p>The framework synchronizes calls to the <em>EvtUsbTargetPipeReadComplete</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_readers_failed">EvtUsbTargetPipeReadersFailed</a> callback functions according to the following rules:</p>

<ul>
<li>These callback functions do not run simultaneously for an individual USB pipe.</li>
<li>If the driver creates multiple continuous readers for multiple USB pipes, with multiple <em>EvtUsbTargetPipeReadComplete</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_readers_failed">EvtUsbTargetPipeReadersFailed</a> callback functions, the multiple callback functions can run simultaneously.</li>
<li>If the driver has specified the default <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/ns-wdfusb-_wdf_usb_continuous_reader_config">NumPendingReads</a> value or a value that is greater than 1, and if a read request completes while the <em>EvtUsbTargetPipeReadComplete</em> callback function is executing, the framework can call the <em>EvtUsbTargetPipeReadComplete</em> callback function again before the callback function returns.</li>
<li>The framework does not synchronize these callback functions with any other callback functions.</li>
</ul>

<p>In the <strong>BufferAttributes</strong> member of the <a href="wdf_usb_continuous_reader_config" title="typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG {&#10;  ULONG                                 Size;&#10;  size_t                                TransferLength;&#10;  size_t                                HeaderLength;&#10;  size_t                                TrailerLength;&#10;  UCHAR                                 NumPendingReads;&#10;  PWDF_OBJECT_ATTRIBUTES                BufferAttributes;&#10;  PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;&#10;  WDFCONTEXT                            EvtUsbTargetPipeReadCompleteContext;&#10;  PFN_WDF_USB_READERS_FAILED            EvtUsbTargetPipeReadersFailed;&#10;} WDF_USB_CONTINUOUS_READER_CONFIG, *PWDF_USB_CONTINUOUS_READER_CONFIG;">WDF_USB_CONTINUOUS_READER_CONFIG</a> structure, your driver can specify <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfobject/nc-wdfobject-evt_wdf_object_context_cleanup">EvtCleanupCallback</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfobject/nc-wdfobject-evt_wdf_object_context_destroy">EvtDestroyCallback</a> callback functions for the memory object. If you specify an <em>EvtCleanupCallback</em> callback function, the framework will call that callback function when it attempts to delete the memory object, after the <em>EvtUsbTargetPipeReadComplete</em> callback function returns. If the <em>EvtUsbTargetPipeReadComplete</em> callback function has called <a href="wdfobjectreference" title="VOID WdfObjectReference(&#10;  [in] WDFOBJECT Handle&#10;);">WdfObjectReference</a>, the <em>EvtCleanupCallback</em> callback function (if provided) must not call <a href="wdfobjectdereference" title="VOID WdfObjectDereference(&#10;  [in] WDFOBJECT Handle&#10;);">WdfObjectDereference</a>.</p>

<p>The driver must call <a href="wdfobjectdereference" title="VOID WdfObjectDereference(&#10;  [in] WDFOBJECT Handle&#10;);">WdfObjectDereference</a> when it has finished using the memory object. The framework can then call the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfobject/nc-wdfobject-evt_wdf_object_context_destroy">EvtDestroyCallback</a> callback function (if provided) and delete the memory object.</p>

<p>For more information about the <em>EvtUsbTargetPipeReadComplete</em> callback function and USB I/O targets, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/wdf/usb-i-o-targets">USB I/O Targets</a>.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_readers_failed">EvtUsbTargetPipeReadersFailed</a></p>

<p><a href="wdf_usb_continuous_reader_config" title="typedef struct _WDF_USB_CONTINUOUS_READER_CONFIG {&#10;  ULONG                                 Size;&#10;  size_t                                TransferLength;&#10;  size_t                                HeaderLength;&#10;  size_t                                TrailerLength;&#10;  UCHAR                                 NumPendingReads;&#10;  PWDF_OBJECT_ATTRIBUTES                BufferAttributes;&#10;  PFN_WDF_USB_READER_COMPLETION_ROUTINE EvtUsbTargetPipeReadComplete;&#10;  WDFCONTEXT                            EvtUsbTargetPipeReadCompleteContext;&#10;  PFN_WDF_USB_READERS_FAILED            EvtUsbTargetPipeReadersFailed;&#10;} WDF_USB_CONTINUOUS_READER_CONFIG, *PWDF_USB_CONTINUOUS_READER_CONFIG;">WDF_USB_CONTINUOUS_READER_CONFIG</a></p>

<p><a href="wdfmemorygetbuffer" title="PVOID WdfMemoryGetBuffer(&#10;  [in]            WDFMEMORY Memory,&#10;  [out, optional] size_t    *BufferSize&#10;);">WdfMemoryGetBuffer</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nc-wdfusb-evt_wdf_usb_reader_completion_routine">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdfusb/nc-wdfusb-evt_wdf_usb_reader_completion_routine.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
