<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FLT_CREATEFILE_TARGET_ECP_CONTEXT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FLT_CREATEFILE_TARGET_ECP_CONTEXT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FLT_CREATEFILE_TARGET_ECP_CONTEXT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _FLT_CREATEFILE_TARGET_ECP_CONTEXT {
  PFLT_INSTANCE               Instance;
  PFLT_VOLUME                 Volume;
  <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">PFLT_FILE_NAME_INFORMATION</a>  FileNameInformation;
  FLT_CREATEFILE_TARGET_FLAGS Flags;
} FLT_CREATEFILE_TARGET_ECP_CONTEXT, *PFLT_CREATEFILE_TARGET_ECP_CONTEXT;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_createfile_target_ecp_context">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/flt_createfile_target_ecp_context.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-fltkernel-_flt_createfile_target_ecp_context)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_flt_createfile_target_ecp_context-structure">_FLT_CREATEFILE_TARGET_ECP_CONTEXT structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>FLT_CREATEFILE_TARGET_ECP_CONTEXT</strong> structure is an extra create parameter (ECP) used to return reparse target information back to the caller of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a>.</p>

<h2 id="members">Members</h2>

<h3 id="instance"><code>Instance</code></h3>

<p>The filter instance attached to the adjusted target.</p>

<h3 id="volume"><code>Volume</code></h3>

<p>The adjusted target volume.</p>

<h3 id="filenameinformation"><code>FileNameInformation</code></h3>

<p>The file information for the adjusted target.</p>

<h3 id="flags"><code>Flags</code></h3>

<p>Flags controlling the reparse operation. This value can be either 0 or the following.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>FLTTCFL_AUTO_REPARSE</strong></td>
  <td>Request that the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a> attempt a reparse operation when a target is not found with the original file information.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>When a caller of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a> wishes to enable reparsing for a volume target, a <strong>FLT_CREATEFILE_TARGET_ECP_CONTEXT</strong> can be included as an ECP to the ECP list in the <em>DriverContext</em> parameter. If this ECP is present, <strong><a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a></strong> will adjust the target device for the create operation and attempt to find a filtered instance of a volume appropriate for the given file information. If the filter manager does not find a corresponding instance for the caller on the target volume, it will set the <strong>Volume</strong> and <strong>FileNameInformation</strong> members of <strong>FLT_CREATEFILE_TARGET_ECP_CONTEXT</strong> for the new target. The caller can then use this information to decide how best to proceed.</p>

<p>If the caller of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a> intends to handle the reparse operation itself, the <strong>FLTTCFL_AUTO_REPARSE</strong> flag is cleared from the <strong>Flags</strong> member. In this case, <strong><a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a></strong> will place the initial target adjustment information in the ECP and then will return, ending the file create attempt.</p>

<p>If the values in <strong>Instance</strong>, <strong>Volume</strong>, or <strong>FileNameInformation</strong> are set in an acknowledged ECP, they are referenced objects. A caller of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a> is responsible for calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltobjectdereference">FltObjectDereference</a> for <strong>Instance</strong> and <strong>Volume</strong>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltreleasefilenameinformation">FltReleaseFileNameInformation</a> for <strong>FileNameInformation</strong>.</p>

<p>The following example routine demonstrates how a minifilter can call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a> with <strong>FLT_CREATEFILE_TARGET_ECP_CONTEXT</strong> to handle a reparse to a different volume when required to find a file target.</p>

<pre><code><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
CrossVolumeCreate(
    _In_ <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">PUNICODE_STRING</a> FileName,
    _In_ PFLT_FILTER Filter,
    _In_ PFLT_INSTANCE Instance,
    _Inout_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatus,
    _Out_ PHANDLE Handle,
    _Outptr_ <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a> *FileObject
    )
/*++

Routine Description:

     Issues a targeted create and handles cross volume reparse.

Arguments:

    FileName - The name of the file to open

    Filter – The filter issuing the create

    Instance - The filter instance for the targeted create

    IoStatus - Receives the operation status

    Handle - Receives the file handle

    FileObject - Receives the file object

Return Value:

    status of the operation

--*/
{
    PFLT_CREATEFILE_TARGET_ECP_CONTEXT ecpContext;
    PECP_LIST ecpList;
    <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">PFLT_FILE_NAME_INFORMATION</a> fileNameInformation;
    <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> myCreateContext;
    <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> objAttr;
    <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> status;

    ecpContext = NULL;
    ecpList = NULL;
    fileNameInformation = NULL;
    status = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;

    <a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a>( &amp;objAttr,
                                FileName,
                                <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a>,
                                NULL,
                                NULL );

    //
    //  First we optimistically send a targeted create that is not
    //  setup to handle cross-volume reparse.
    //

    status = <a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a>( Filter,
                               Instance,
                               Handle,
                               FileObject,
                               FILE_READ_DATA|FILE_WRITE_DATA,
                               &amp;objAttr,
                               IoStatus,
                               NULL,
                               0,
                               <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>,
                               <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>,
                               <a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a> | <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>,
                               NULL,
                               0,
                               IO_IGNORE_SHARE_ACCESS_CHECK,
                               NULL );

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {

        if ((status != STATUS_INVALID_DEVICE_OBJECT_PARAMETER) &amp;&amp;
            (status != STATUS_MOUNT_POINT_NOT_RESOLVED)) {

            goto CrossVolumeCreateExit;
        }

    } else {

        //
        //  The create succeeded. There must not have been a cross-volume
        //  reparse.
        //

        goto CrossVolumeCreateExit;
    }

    //
    //  The create failed traversing a cross-volume link.
    //  Issue another create with a targeting ECP so that
    //  we can handle cross-volume reparse.
    //

    status = <a href="fltallocateextracreateparameterlist" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameterList(&#10;  [in]  PFLT_FILTER                  Filter,&#10;  [in]  FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,&#10;  [out] PECP_LIST                    *EcpList&#10;);">FltAllocateExtraCreateParameterList</a>( Filter,
                                                  0,
                                                  &amp;ecpList );
    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>( status )) {
        goto CrossVolumeCreateExit;
    }

    status = <a href="fltallocateextracreateparameter" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameter(&#10;  [in]           PFLT_FILTER                                    Filter,&#10;  [in]           LPCGUID                                        EcpType,&#10;  [in]           ULONG                                          SizeOfContext,&#10;  [in]           FSRTL_ALLOCATE_ECP_FLAGS                       Flags,&#10;  [in, optional] PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,&#10;  [in]           ULONG                                          PoolTag,&#10;  [out]          PVOID                                          *EcpContext&#10;);">FltAllocateExtraCreateParameter</a>( Filter,
                                              &amp;GUID_ECP_FLT_CREATEFILE_TARGET,
                                              sizeof(FLT_CREATEFILE_TARGET_ECP_CONTEXT),
                                              0,
                                              NULL,
                                              POOL_TAG,
                                              &amp;ecpContext );

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>( status )) {
        goto CrossVolumeCreateExit;
    }

    //
    //  Initialize the ECP with the FLTTCFL_AUTO_REPARSE flag which
    //  tells filter manager to handle the cross-volume reparse
    //  internally when possible (when it can find our instance
    //  on the target volume). If this flag is not set, the filter will
    //  be responsible for calling <a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a> with appropriate
    //  Instance parameter.
    //

    ecpContext-&gt;Flags = FLTTCFL_AUTO_REPARSE;

    ecpContext-&gt;Instance = NULL;
    ecpContext-&gt;Volume = NULL;
    ecpContext-&gt;FileNameInformation = NULL;

    status = <a href="fltinsertextracreateparameter" title="NTSTATUS FLTAPI FltInsertExtraCreateParameter(&#10;  [in]      PFLT_FILTER Filter,&#10;  [in, out] PECP_LIST   EcpList,&#10;  [in, out] PVOID       EcpContext&#10;);">FltInsertExtraCreateParameter</a>( Filter,
                                            ecpList,
                                            ecpContext );
    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>( status )) {
        goto CrossVolumeCreateExit;
    }

    <a href="ioinitializedrivercreatecontext" title="VOID IoInitializeDriverCreateContext(&#10;  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoInitializeDriverCreateContext</a>( &amp;myCreateContext );
    myCreateContext.ExtraCreateParameter = ecpList;

    <a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a>( &amp;objAttr,
                                FileName,
                                <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a>,
                                NULL,
                                NULL );

    status = <a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a>( Filter,
                               Instance,
                               Handle,
                               FileObject,
                               FILE_READ_DATA|FILE_WRITE_DATA,
                               &amp;objAttr,
                               IoStatus,
                               NULL,
                               0,
                               <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>,
                               <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>,
                               <a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a> | <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>,
                               NULL,
                               0,
                               IO_IGNORE_SHARE_ACCESS_CHECK,
                               &amp;myCreateContext );

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {

        if ((status != STATUS_INVALID_DEVICE_OBJECT_PARAMETER) &amp;&amp;
            (status != STATUS_MOUNT_POINT_NOT_RESOLVED)) {

            goto CrossVolumeCreateExit;
        }

    } else {

        goto CrossVolumeCreateExit;
    }

    //
    //  Filter manager should have acknowledged the ECP. If it
    //  is not acknowledged, it does not contain any cross-volume
    //  targeting information.
    //

    if (!<a href="fltisecpacknowledged" title="BOOLEAN FLTAPI FltIsEcpAcknowledged(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltIsEcpAcknowledged</a>( Filter, ecpContext)) {
        goto CrossVolumeCreateExit;
    }

    //
    //  Filter manager could not automatically handle the
    //  cross-volume traversal. We choose to send the create
    //  to the top of the stack on the target volume indicated
    //  in the targeting ECP.
    //

    //
    //  The ECP may contain pointers to referenced objects. We
    //  need to deal with those references before reusing the
    //  ECP.
    //

    if (ecpContext-&gt;Volume != NULL) {
        <a href="fltobjectdereference" title="VOID FLTAPI FltObjectDereference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectDereference</a>( ecpContext-&gt;Volume );
        ecpContext-&gt;Volume = NULL;
    }

    //
    //  Note:  since we flagged the ECP to automatically handle
    //  cross-volume reparse, the create should have failed after
    //  we traversed a mountpoint only if our filter did not have
    //  an instance on the target volume. In that case we would
    //  expect the Instance field in the ECP to be NULL. We still
    //  demonstrate derefing the instance for the general case.
    //

    if (ecpContext-&gt;Instance != NULL) {
        <a href="fltobjectdereference" title="VOID FLTAPI FltObjectDereference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectDereference</a>( ecpContext-&gt;Instance );
        ecpContext-&gt;Instance = NULL;
    }

    fileNameInformation = ecpContext-&gt;FileNameInformation;
    ecpContext-&gt;FileNameInformation = NULL;

    //
    //  Tell filter manager to not handle the cross-volume
    //  reparse itself. Presumably a filter would do this if it
    //  did not want the create automatically targeted at its
    //  instance on another volume.
    //

    ecpContext-&gt;Flags = 0;

    //
    //  Reinitialize the targeting ECP to it can be reused.
    //

    <a href="fltpreparetoreuseecp" title="VOID FLTAPI FltPrepareToReuseEcp(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltPrepareToReuseEcp</a>( Filter, ecpContext );

    <a href="ioinitializedrivercreatecontext" title="VOID IoInitializeDriverCreateContext(&#10;  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoInitializeDriverCreateContext</a>( &amp;myCreateContext );
    myCreateContext.ExtraCreateParameter = ecpList;

    <a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a>( &amp;objAttr,
                                &amp;fileNameInformation-&gt;Name,
                                <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a>,
                                NULL,
                                NULL );

    status = <a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a>( Filter,
                               NULL,
                               Handle,
                               FileObject,
                               FILE_READ_DATA|FILE_WRITE_DATA,
                               &amp;objAttr,
                               IoStatus,
                               NULL,
                               0,
                               <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>,
                               <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>,
                               <a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a> | <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>,
                               NULL,
                               0,
                               IO_IGNORE_SHARE_ACCESS_CHECK,
                               &amp;myCreateContext );

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {

        if ((status != STATUS_INVALID_DEVICE_OBJECT_PARAMETER) &amp;&amp;
            (status != STATUS_MOUNT_POINT_NOT_RESOLVED)) {

            goto CrossVolumeCreateExit;
        }

        //
        //  We hit another cross-volume link. For the purposes of
        //  this example we are just giving up. An actual filter
        //  would determine the next target instance based on the
        //  information provided in the targeting ECP. Some of the
        //  possibilities are:
        //  1) If the Instance field in the ECP is available, target
        //     the create to this instance.
        //  2) If the Instance field is NULL, attempt to attach
        //     an instance based on the Volume parameter in the ECP
        //     and then target that new instance.
        //  3) Use the FileNameInformation provided in the ECP and a
        //     NULL instance to target the top of the other
        //     volume's stack.
        //

    } else {

        goto CrossVolumeCreateExit;
    }

CrossVolumeCreateExit:

    if (ecpContext != NULL &amp;&amp;
        <a href="fltisecpacknowledged" title="BOOLEAN FLTAPI FltIsEcpAcknowledged(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltIsEcpAcknowledged</a>( Filter, ecpContext)) {

        <a href="fltremoveextracreateparameter" title="NTSTATUS FLTAPI FltRemoveExtraCreateParameter(&#10;  [in]            PFLT_FILTER Filter,&#10;  [in, out]       PECP_LIST   EcpList,&#10;  [in]            LPCGUID     EcpType,&#10;  [out]           PVOID       *EcpContext,&#10;  [out, optional] ULONG       *EcpContextSize&#10;);">FltRemoveExtraCreateParameter</a>( Filter,
                                       ecpList,
                                       &amp;GUID_ECP_FLT_CREATEFILE_TARGET,
                                       &amp;ecpContext,
                                       NULL );

        if (ecpContext-&gt;Instance != NULL) {
            <a href="fltobjectdereference" title="VOID FLTAPI FltObjectDereference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectDereference</a>( ecpContext-&gt;Instance );
        }

        if (ecpContext-&gt;Volume != NULL) {
            <a href="fltobjectdereference" title="VOID FLTAPI FltObjectDereference(&#10;  [in, out] PVOID FltObject&#10;);">FltObjectDereference</a>( ecpContext-&gt;Volume );
        }

        if (ecpContext-&gt;FileNameInformation != NULL) {
            <a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a>( ecpContext-&gt;FileNameInformation );
        }

        <a href="fltfreeextracreateparameter" title="VOID FLTAPI FltFreeExtraCreateParameter(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltFreeExtraCreateParameter</a>( Filter, ecpContext );
    }

    if (ecpList != NULL) {
        <a href="fltfreeextracreateparameterlist" title="VOID FLTAPI FltFreeExtraCreateParameterList(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PECP_LIST   EcpList&#10;);">FltFreeExtraCreateParameterList</a>( Filter, ecpList );
    }

    if (fileNameInformation != NULL) {
        <a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a>( fileNameInformation );
    }

    return status;
}

</code></pre>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">FltCreateFileEx2</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltobjectdereference">FltObjectDereference</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltreleasefilenameinformation">FltReleaseFileNameInformation</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_createfile_target_ecp_context">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/ns-fltkernel-_flt_createfile_target_ecp_context.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
