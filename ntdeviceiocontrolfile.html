<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtDeviceIoControlFile - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtDeviceIoControlFile - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtDeviceIoControlFile - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTIOAPI_H

</span><span class="ntdoc-code-intro">/**
 * The NtDeviceIoControlFile function sends a control code directly to a specified device driver, causing the corresponding driver to perform the specified operation.
 *
 * \param[in] FileHandle A handle to the file object representing the file or directory on which the specified action is to be performed.
 * \param[in] Event A handle for a caller-created event. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state.
 * \param[in] ApcRoutine Address of a caller-supplied APC routine to be called when the requested operation completes. This parameter is optional and can be NULL.
 * \param[in] ApcContext Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object.
 * \param[out] IoStatusBlock Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the operation.
 * \param[in] IoControlCode IOCTL_XXX code that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver.
 * \param[in] InputBuffer Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target driver.
 * \param[in] InputBufferLength Size, in bytes, of the buffer at InputBuffer. This value is ignored if InputBuffer is NULL.
 * \param[out] OutputBuffer Pointer to a caller-allocated output buffer in which information is returned from the target driver.
 * \param[in] OutputBufferLength Size, in bytes, of the buffer at OutputBuffer. This value is ignored if OutputBuffer is NULL.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwdeviceiocontrolfile
 */
</span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> OutputBufferLength
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/66e9024965df1192a53aee9b345a8df8f08d8beb/phnt/include/ntioapi.h#L2235">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> OutputBufferLength
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/66e9024965df1192a53aee9b345a8df8f08d8beb/phnt/include/ntzwapi.h#L1662">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntddk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwDeviceIoControlFile(
  [in]            HANDLE           FileHandle,
  [in, optional]  HANDLE           Event,
  [in, optional]  <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional]  PVOID            ApcContext,
  [out]           <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            IoControlCode,
  [in, optional]  PVOID            InputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            InputBufferLength,
  [out, optional] PVOID            OutputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            OutputBufferLength
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-zwdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtDeviceIoControlFile(
  [in]            HANDLE           FileHandle,
  [in, optional]  HANDLE           Event,
  [in, optional]  <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional]  PVOID            ApcContext,
  [out]           <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            IoControlCode,
  [in, optional]  PVOID            InputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            InputBufferLength,
  [out, optional] PVOID            OutputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            OutputBufferLength
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwDeviceIoControlFile(
  [in]            HANDLE           FileHandle,
  [in, optional]  HANDLE           Event,
  [in, optional]  <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional]  PVOID            ApcContext,
  [out]           <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            IoControlCode,
  [in, optional]  PVOID            InputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            InputBufferLength,
  [out, optional] PVOID            OutputBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            OutputBufferLength
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winternl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">__kernel_entry <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtDeviceIoControlFile(
  [in]  HANDLE           FileHandle,
  [in]  HANDLE           Event,
  [in]  <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in]  PVOID            ApcContext,
  [out] <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            IoControlCode,
  [in]  PVOID            InputBuffer,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            InputBufferLength,
  [out] PVOID            OutputBuffer,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            OutputBufferLength
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winternl/nf-winternl-ntdeviceiocontrolfile">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntddk-zwdeviceiocontrolfile)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>ZwDeviceIoControlFile</strong> routine sends a control code directly to a specified device driver, causing the corresponding driver to perform the specified operation.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="filehandle-in"><code>FileHandle</code> [in]</h3>

<p>Handle returned by <a rel="noopener" target="_blank" href="ntcreatefile">ZwCreateFile</a> or <a rel="noopener" target="_blank" href="ntopenfile">ZwOpenFile</a> for the file object representing the device to which the control information should be given or from which information should be returned. The file object must have been opened for asynchronous I/O if the caller specifies an <em>Event</em>, <em>ApcRoutine</em>, and an APC context (in <em>ApcContext</em>), or a completion context (in <em>ApcContext</em>). For I/O to an underlying mass-storage device, the file object must have been opened for Direct Access to Storage Device (DASD) access.</p>

<h3 id="event-in-optional"><code>Event</code> [in, optional]</h3>

<p>Handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be <strong>NULL</strong>. It must be <strong>NULL</strong> if the caller will wait for the <em>FileHandle</em> to be set to the Signaled state.</p>

<h3 id="apcroutine-in-optional"><code>ApcRoutine</code> [in, optional]</h3>

<p>Address of an optional, caller-supplied APC routine to be called when the requested operation completes. This parameter can be <strong>NULL</strong>. It must be <strong>NULL</strong> if there is an I/O completion object associated with the file object.</p>

<h3 id="apccontext-in-optional"><code>ApcContext</code> [in, optional]</h3>

<p>Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object. When the operation completes, either the APC context is passed to the APC, if one was specified, or the completion context is included as part of the completion message that the I/O Manager posts to the associated I/O completion object.</p>

<p>This parameter is optional and can be <strong>NULL</strong>. It must be <strong>NULL</strong> if <em>ApcRoutine</em> is <strong>NULL</strong> and there is no I/O completion object associated with the file object.</p>

<h3 id="iostatusblock-out"><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to a variable that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the <em>OutputBuffer</em> is returned in the <strong>Information</strong> member.</p>

<h3 id="iocontrolcode-in"><code>IoControlCode</code> [in]</h3>

<p>IOCTL_*XXX* code that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver. The value of this parameter determines the format and required length of the *InputBuffer* and *OutputBuffer*, as well as which of the following parameter pairs are required. For detailed information about the system-defined, device-type-specific IOCTL_<em>XXX</em> codes, see the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">device technology-specific section</a> of the Microsoft Windows Driver Kit (WDK) documentation and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a> in the Microsoft Windows SDK documentation.</p>

<h3 id="inputbuffer-in-optional"><code>InputBuffer</code> [in, optional]</h3>

<p>Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target device. If <em>IoControlCode</em> specifies an operation that does not require input data, this pointer can be <strong>NULL</strong>.</p>

<h3 id="inputbufferlength-in"><code>InputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <em>InputBuffer</em>. If <em>InputBuffer</em> is <strong>NULL</strong>, set <em>InputBufferLength</em> to zero.</p>

<h3 id="outputbuffer-out-optional"><code>OutputBuffer</code> [out, optional]</h3>

<p>Pointer to a caller-allocated output buffer in which information is returned from the target device. If <em>IoControlCode</em> specifies an operation that does not produce output data, this pointer can be <strong>NULL</strong>.</p>

<h3 id="outputbufferlength-in"><code>OutputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <em>OutputBuffer</em>. If <em>OutputBuffer</em> is <strong>NULL</strong>, set <em>OutputBufferLength</em> to zero.</p>

<h2 id="return-value">Return value</h2>

<p><strong>ZwDeviceIoControlFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the underlying driver(s) successfully carried out the requested operation. Otherwise, the return value can be an error status code propagated from an underlying driver. Possible error status codes include the following:</p>

<h2 id="remarks">Remarks</h2>

<p><strong>ZwDeviceIoControlFile</strong> provides a consistent view of the input and output data to the system and to kernel-mode drivers, while providing applications and underlying drivers with a device-dependent method of specifying a communications interface.</p>

<p>For more information about system-defined IOCTL_*XXX* codes, and about defining driver-specific IOCTL_<em>XXX</em> or FSCTL_<em>XXX</em> values, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-i-o-control-codes">Using I/O Control Codes</a> in the <em>Kernel Mode Architecture Guide</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a> in the Microsoft Windows SDK documentation.</p>

<p>If the caller opened the file for asynchronous I/O (with neither FILE_SYNCHRONOUS_<em>XXX</em> create/open option set), the specified event, if any, will be set to the signaled state when the device control operation completes. Otherwise, the file object specified by <em>FileHandle</em> will be set to the signaled state. If an <em>ApcRoutine</em> was specified, it is called with the <em>ApcContext</em> and <em>IoStatusBlock</em> pointers.</p>

<p>Minifilters should use <a rel="noopener" target="_blank" href="fltdeviceiocontrolfile">FltDeviceIoControlFile</a> instead of <strong>ZwDeviceIoControlFile</strong>.</p>

<p>Callers of <strong>ZwDeviceIoControlFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>

<p>If the call to the <strong>ZwDeviceIoControlFile</strong> function occurs in user mode, you should use the name "<strong>NtDeviceIoControlFile</strong>" instead of "<strong>ZwDeviceIoControlFile</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="fltdeviceiocontrolfile">FltDeviceIoControlFile</a></p>

<p><a rel="noopener" target="_blank" href="iobuildasynchronousfsdrequest">IoBuildAsynchronousFsdRequest</a></p>

<p><a rel="noopener" target="_blank" href="iobuilddeviceiocontrolrequest">IoBuildDeviceIoControlRequest</a></p>

<p><a rel="noopener" target="_blank" href="iobuildsynchronousfsdrequest">IoBuildSynchronousFsdRequest</a></p>

<p><a rel="noopener" target="_blank" href="iocalldriver">IoCallDriver</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-i-o-control-codes">Using I/O Control Codes</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a></p>

<p><a rel="noopener" target="_blank" href="ntclose">ZwClose</a></p>

<p><a rel="noopener" target="_blank" href="ntcreatefile">ZwCreateFile</a></p>

<p><a rel="noopener" target="_blank" href="ntopenfile">ZwOpenFile</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-zwdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddk/nf-ntddk-zwdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntdeviceiocontrolfile)</h1>
</div>
<div class="ntdoc-description">
<h1>NtDeviceIoControlFile function</h1>

<h2>Description</h2>

<p>The <strong>ZwDeviceIoControlFile</strong> routine sends a control code directly to a specified device driver, causing the corresponding driver to perform the specified operation.</p>

<h2>Parameters</h2>

<h3><code>FileHandle</code> [in]</h3>

<p>Handle returned by <a rel="noopener" target="_blank" href="ntcreatefile"><strong>ZwCreateFile</strong></a> or <a rel="noopener" target="_blank" href="ntopenfile"><strong>ZwOpenFile</strong></a> for the file object representing the device to which the control information should be given or from which information should be returned. The file object must have been opened for asynchronous I/O if the caller specifies an <strong>Event</strong>, <strong>ApcRoutine</strong>, and an APC context (in <strong>ApcContext</strong>), or a completion context (in <strong>ApcContext</strong>). For I/O to an underlying mass-storage device, the file object must have been opened for Direct Access to Storage Device (DASD) access.</p>

<h3><code>Event</code> [in, optional]</h3>

<p>Handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the <strong>FileHandle</strong> to be set to the Signaled state.</p>

<h3><code>ApcRoutine</code> [in, optional]</h3>

<p>Address of an optional, caller-supplied APC routine to be called when the requested operation completes. This parameter can be NULL. It must be NULL if there is an I/O completion object associated with the file object.</p>

<h3><code>ApcContext</code> [in, optional]</h3>

<p>Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object. When the operation completes, either the APC context is passed to the APC, if one was specified, or the completion context is included as part of the completion message that the I/O Manager posts to the associated I/O completion object.</p>

<p>This parameter is optional and can be NULL. It must be NULL if <strong>ApcRoutine</strong> is NULL and there is no I/O completion object associated with the file object.</p>

<h3><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to a variable that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the <strong>OutputBuffer</strong> is returned in the <strong>Information</strong> member.</p>

<h3><code>IoControlCode</code> [in]</h3>

<p>IOCTL_*Xxx* code that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver. The value of this parameter determines the format and required length of the **InputBuffer** and **OutputBuffer**, as well as which of the following parameter pairs are required. For detailed information about the system-defined, device-type-specific IOCTL_<em>Xxx</em> codes, see the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">device technology-specific section</a> of the Microsoft Windows Driver Kit (WDK) documentation and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a>.</p>

<h3><code>InputBuffer</code> [in, optional]</h3>

<p>Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target device. If <strong>IoControlCode</strong> specifies an operation that does not require input data, this pointer can be NULL.</p>

<h3><code>InputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <strong>InputBuffer</strong>. If <strong>InputBuffer</strong> is NULL, set <strong>InputBufferLength</strong> to zero.</p>

<h3><code>OutputBuffer</code> [out, optional]</h3>

<p>Pointer to a caller-allocated output buffer in which information is returned from the target device. If <strong>IoControlCode</strong> specifies an operation that does not produce output data, this pointer can be NULL.</p>

<h3><code>OutputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <strong>OutputBuffer</strong>. If <strong>OutputBuffer</strong> is NULL, set <strong>OutputBufferLength</strong> to zero.</p>

<h2>Return value</h2>

<p><strong>ZwDeviceIoControlFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the underlying driver(s) successfully carried out the requested operation. Otherwise, the return value can be an error status code propagated from an underlying driver. Possible error status codes include the following:</p>

<h2>Remarks</h2>

<p><strong>ZwDeviceIoControlFile</strong> provides a consistent view of the input and output data to the system and to kernel-mode drivers, while providing applications and underlying drivers with a device-dependent method of specifying a communications interface.</p>

<p>For more information about system-defined IOCTL_*Xxx* codes, and about defining driver-specific IOCTL_<em>Xxx</em> or FSCTL_<em>Xxx</em> values, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-i-o-control-codes">Using I/O Control Codes</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a>.</p>

<p>If the caller opened the file for asynchronous I/O (with neither FILE_SYNCHRONOUS_<em>Xxx</em> create/open option set), the specified event, if any, will be set to the signaled state when the device control operation completes. Otherwise, the file object specified by <strong>FileHandle</strong> will be set to the signaled state. If an <strong>ApcRoutine</strong> was specified, it is called with the <strong>ApcContext</strong> and <strong>IoStatusBlock</strong> pointers.</p>

<p>Minifilters should use <a rel="noopener" target="_blank" href="fltdeviceiocontrolfile"><strong>FltDeviceIoControlFile</strong></a> instead of <strong>ZwDeviceIoControlFile</strong>.</p>

<p>Callers of <strong>ZwDeviceIoControlFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>

<p>If the call to the <strong>ZwDeviceIoControlFile</strong> function occurs in user mode, you should use the name "<strong>NtDeviceIoControlFile</strong>" instead of "<strong>ZwDeviceIoControlFile</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="fltdeviceiocontrolfile"><strong>FltDeviceIoControlFile</strong></a></p>

<p><a rel="noopener" target="_blank" href="iobuildasynchronousfsdrequest"><strong>IoBuildAsynchronousFsdRequest</strong></a></p>

<p><a rel="noopener" target="_blank" href="iobuilddeviceiocontrolrequest"><strong>IoBuildDeviceIoControlRequest</strong></a></p>

<p><a rel="noopener" target="_blank" href="iobuildsynchronousfsdrequest"><strong>IoBuildSynchronousFsdRequest</strong></a></p>

<p><a rel="noopener" target="_blank" href="iocalldriver"><strong>IoCallDriver</strong></a></p>

<p><a rel="noopener" target="_blank" href="ntclose"><strong>ZwClose</strong></a></p>

<p><a rel="noopener" target="_blank" href="ntcreatefile"><strong>ZwCreateFile</strong></a></p>

<p><a rel="noopener" target="_blank" href="ntopenfile"><strong>ZwOpenFile</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-zwdeviceiocontrolfile)</h1>
</div>
<div class="ntdoc-description">
<h1>ZwDeviceIoControlFile function (ntifs.h)</h1>

<h2>Description</h2>

<p>The <strong>ZwDeviceIoControlFile</strong> routine sends a control code directly to a specified device driver, causing the corresponding driver to perform the specified operation.</p>

<h2>Parameters</h2>

<h3><code>FileHandle</code> [in]</h3>

<p>Handle returned by <a rel="noopener" target="_blank" href="ntcreatefile">ZwCreateFile</a> or <a rel="noopener" target="_blank" href="ntopenfile">ZwOpenFile</a> for the file object representing the device to which the control information should be given or from which information should be returned. The file object must have been opened for asynchronous I/O if the caller specifies an <em>Event</em>, <em>ApcRoutine</em>, and an APC context (in <em>ApcContext</em>), or a completion context (in <em>ApcContext</em>). For I/O to an underlying mass-storage device, the file object must have been opened for Direct Access to Storage Device (DASD) access.</p>

<h3><code>Event</code> [in, optional]</h3>

<p>Handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the Signaled state. This parameter is optional and can be <strong>NULL</strong>. It must be <strong>NULL</strong> if the caller will wait for the <em>FileHandle</em> to be set to the Signaled state.</p>

<h3><code>ApcRoutine</code> [in, optional]</h3>

<p>Address of an optional, caller-supplied APC routine to be called when the requested operation completes. This parameter can be <strong>NULL</strong>. It must be <strong>NULL</strong> if there is an I/O completion object associated with the file object.</p>

<h3><code>ApcContext</code> [in, optional]</h3>

<p>Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object. When the operation completes, either the APC context is passed to the APC, if one was specified, or the completion context is included as part of the completion message that the I/O Manager posts to the associated I/O completion object.</p>

<p>This parameter is optional and can be <strong>NULL</strong>. It must be <strong>NULL</strong> if <em>ApcRoutine</em> is <strong>NULL</strong> and there is no I/O completion object associated with the file object.</p>

<h3><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to a variable that receives the final completion status and information about the operation. For successful calls that return data, the number of bytes written to the <em>OutputBuffer</em> is returned in the <strong>Information</strong> member.</p>

<h3><code>IoControlCode</code> [in]</h3>

<p>IOCTL_*XXX* code that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver. The value of this parameter determines the format and required length of the *InputBuffer* and *OutputBuffer*, as well as which of the following parameter pairs are required. For detailed information about the system-defined, device-type-specific IOCTL_<em>XXX</em> codes, see the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">device technology-specific section</a> of the Microsoft Windows Driver Kit (WDK) documentation and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a> in the Microsoft Windows SDK documentation.</p>

<h3><code>InputBuffer</code> [in, optional]</h3>

<p>Pointer to a caller-allocated input buffer that contains device-specific information to be given to the target device. If <em>IoControlCode</em> specifies an operation that does not require input data, this pointer can be <strong>NULL</strong>.</p>

<h3><code>InputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <em>InputBuffer</em>. If <em>InputBuffer</em> is <strong>NULL</strong>, set <em>InputBufferLength</em> to zero.</p>

<h3><code>OutputBuffer</code> [out, optional]</h3>

<p>Pointer to a caller-allocated output buffer in which information is returned from the target device. If <em>IoControlCode</em> specifies an operation that does not produce output data, this pointer can be <strong>NULL</strong>.</p>

<h3><code>OutputBufferLength</code> [in]</h3>

<p>Size, in bytes, of the buffer at <em>OutputBuffer</em>. If <em>OutputBuffer</em> is <strong>NULL</strong>, set <em>OutputBufferLength</em> to zero.</p>

<h2>Return value</h2>

<p><strong>ZwDeviceIoControlFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the underlying driver(s) successfully carried out the requested operation. Otherwise, the return value can be an error status code propagated from an underlying driver. Possible error status codes include the following:</p>

<h2>Remarks</h2>

<p><strong>ZwDeviceIoControlFile</strong> provides a consistent view of the input and output data to the system and to kernel-mode drivers, while providing applications and underlying drivers with a device-dependent method of specifying a communications interface.</p>

<p>For more information about system-defined IOCTL_*XXX* codes, and about defining driver-specific IOCTL_<em>XXX</em> or FSCTL_<em>XXX</em> values, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-i-o-control-codes">Using I/O Control Codes</a> in the <em>Kernel Mode Architecture Guide</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/DevIO/device-input-and-output-control-ioctl-">Device Input and Output Control Codes</a> in the Microsoft Windows SDK documentation.</p>

<p>If the caller opened the file for asynchronous I/O (with neither FILE_SYNCHRONOUS_<em>XXX</em> create/open option set), the specified event, if any, will be set to the signaled state when the device control operation completes. Otherwise, the file object specified by <em>FileHandle</em> will be set to the signaled state. If an <em>ApcRoutine</em> was specified, it is called with the <em>ApcContext</em> and <em>IoStatusBlock</em> pointers.</p>

<p>Minifilters should use <a rel="noopener" target="_blank" href="fltdeviceiocontrolfile">FltDeviceIoControlFile</a> instead of <strong>ZwDeviceIoControlFile</strong>.</p>

<p>Callers of <strong>ZwDeviceIoControlFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>

<p><strong>Note</strong> If the call to the <strong>ZwDeviceIoControlFile</strong> function occurs in user mode, you should use the name "<strong>NtDeviceIoControlFile</strong>" instead of "<strong>ZwDeviceIoControlFile</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="fltdeviceiocontrolfile">FltDeviceIoControlFile</a></p>

<p><a rel="noopener" target="_blank" href="iobuildasynchronousfsdrequest">IoBuildAsynchronousFsdRequest</a></p>

<p><a rel="noopener" target="_blank" href="iobuilddeviceiocontrolrequest">IoBuildDeviceIoControlRequest</a></p>

<p><a rel="noopener" target="_blank" href="iobuildsynchronousfsdrequest">IoBuildSynchronousFsdRequest</a></p>

<p><a rel="noopener" target="_blank" href="iocalldriver">IoCallDriver</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-i-o-control-codes">Using I/O Control Codes</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a></p>

<p><a rel="noopener" target="_blank" href="ntclose">ZwClose</a></p>

<p><a rel="noopener" target="_blank" href="ntcreatefile">ZwCreateFile</a></p>

<p><a rel="noopener" target="_blank" href="ntopenfile">ZwOpenFile</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwdeviceiocontrolfile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-zwdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (nf-winternl-ntdeviceiocontrolfile)</h1>
</div>
<div class="ntdoc-description">
<h1>NtDeviceIoControlFile function</h1>

<h2>Description</h2>

<p>Deprecated. Builds descriptors for the supplied buffer(s) and
passes the untyped data to the device driver associated with the file
handle. <strong>NtDeviceIoControlFile</strong> is superseded by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>.</p>

<h2>Parameters</h2>

<h3><code>FileHandle</code> [in]</h3>

<p>Open file handle to the file or device to which the control information should be given.</p>

<h3><code>Event</code> [in]</h3>

<p>A handle to an event to be set to the <code>signaled</code> state when the operation completes. This parameter can be <strong>NULL</strong>.</p>

<h3><code>ApcRoutine</code> [in]</h3>

<p>Procedure to be invoked once the operation completes. This parameter can be <strong>NULL</strong>. For more information on Asynchronous Procedure Calls (APCs), see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a>.</p>

<h3><code>ApcContext</code> [in]</h3>

<p>A pointer to pass to <em>ApcRoutine</em> when the operation completes. This parameter is required if an <em>ApcRoutine</em> is specified.</p>

<h3><code>IoStatusBlock</code> [out]</h3>

<p>Variable to receive the final completion status and information about the operation. Service calls that return information return the length of the data that is written to the output buffer in the Information field of this variable.</p>

<h3><code>IoControlCode</code> [in]</h3>

<p>Code that indicates which device I/O control function is to be executed.</p>

<h3><code>InputBuffer</code> [in]</h3>

<p>A pointer to a buffer that contains the information to be given to the target device. This parameter can be <strong>NULL</strong>. This information is device-dependent.</p>

<h3><code>InputBufferLength</code> [in]</h3>

<p>Length of the <em>InputBuffer</em> in bytes. If the buffer is not supplied, then this value is ignored.</p>

<h3><code>OutputBuffer</code> [out]</h3>

<p>A pointer to a buffer that is to receive the device-dependent return information from the target device. This parameter can be <strong>NULL</strong>.</p>

<h3><code>OutputBufferLength</code> [in]</h3>

<p>Length of the <em>OutputBuffer</em> in bytes. If the buffer is not supplied, then this value is ignored.</p>

<h2>Return value</h2>

<p>The various <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> values are defined in <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>.H, which is distributed with the Windows DDK.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The control operation was properly queued to the I/O system. Once the operation completes, the status can be determined by examining the Status field of the I/O status block.</td>
</tr>
</tbody>
</table>

<h2>Remarks</h2>

<p>The <strong>NtDeviceIoControlFile</strong> service is a device-dependent interface that extends the control that applications have over various devices within the system. This API provides a consistent view of the input and output data to the system while still providing the application and the driver a device-dependent method of specifying a communications interface.</p>

<p>The type of access to the file that the caller needs is dependent on the actual operation being performed.</p>

<p>Once the service is complete the <em>Event</em>, if specified, is set to the <code>signaled</code> state. If no <em>Event</em> parameter is specified, then the file object specified by the <em>FileHandle</em> is set to the <code>signaled</code> state. If an <em>ApcRoutine</em> is specified, it is invoked with the <em>ApcContext</em> and the <em>IoStatusBlock</em> as its arguments.</p>

<p>Because there is no import library for this function, you must use <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/Sync/asynchronous-procedure-calls">Asynchronous Procedure Calls</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winternl/nf-winternl-ntdeviceiocontrolfile">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winternl/nf-winternl-ntdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-zwdeviceiocontrolfile">here</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntdeviceiocontrolfile">here</a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwdeviceiocontrolfile">here</a>.</p>

<hr />

<p>Function <code>NtDeviceIoControlFile</code> sends <code>IOCTL_*</code> control code to Device Driver. It is primary (but not the best) solution to communicate between application and Device Driver.</p>

<h3>FileHandle</h3>

<p><code>HANDLE</code> to Device Object opened as a file.</p>

<h3>Event</h3>

<p>Optional <code>HANDLE</code> to Event Object signalled on the end of processing request.</p>

<h3>ApcRoutine</h3>

<p>Optional pointer to user's <em>APC Routine</em> called on the end of processing request.</p>

<h3>ApcContext</h3>

<p>User's parameter to <code>ApcRoutine</code>.</p>

<h3>IoStatusBlock</h3>

<p>IO result of call.</p>

<h3>IoControlCode</h3>

<p>IO Control code [<code>IOCTL_*</code>].</p>

<h3>InputBuffer</h3>

<p>User's allocated buffer with input data.</p>

<h3>InputBufferLength</h3>

<p>Length of <code>InputBuffer</code>, in bytes.</p>

<h3>OutputBuffer</h3>

<p>User's allocated buffer for result data.</p>

<h3>OutputBufferLength</h3>

<p>Length of <code>OutputBuffer</code>, in bytes.</p>

<hr />

<p>See also <code><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a></code>.</p>

<h1>Documented by</h1>

<ul>
<li>Tomasz Nowak</li>
<li>ReactOS</li>
</ul>

<h1>See also</h1>

<ul>
<li><code><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></code></li>
<li><code><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a></code></li>
<li><code><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntdeviceiocontrolfile.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
