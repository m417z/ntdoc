<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFND3DDDI_LOCKCB - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFND3DDDI_LOCKCB - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFND3DDDI_LOCKCB - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dumddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFND3DDDI_LOCKCB Pfnd3dddiLockcb;

HRESULT Pfnd3dddiLockcb(
  HANDLE hDevice,
  <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> *unnamedParam2
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lockcb">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfnd3dddi_lockcb.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-d3dumddi-pfnd3dddi_lockcb)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfnd3dddi_lockcb-callback-function">PFND3DDDI_LOCKCB callback function</h1>

<h2 id="description">Description</h2>

<p>The <em>pfnLockCb</em> function locks an allocation and obtains a pointer to the allocation from the display miniport driver or video memory manager.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="hdevice"><code>hDevice</code></h3>

<p>A handle to the display device (graphics context).</p>

<h3 id="unnamedparam2"><code>unnamedParam2</code></h3>

<p><em>pData</em> [in, out]</p>

<p>A pointer to a <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> structure that describes the allocation to lock.</p>

<h2 id="return-value">Return value</h2>

<p><em>pfnLockCb</em> returns one of the following values:</p>

<table>
<thead>
<tr>
  <th style="text-align:left;"><strong>Return code</strong></th>
  <th style="text-align:left;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:left;"><strong>S_OK</strong></td>
  <td style="text-align:left;">The allocation was successfully locked.</td>
</tr>
<tr>
  <td style="text-align:left;"><strong>D3DERR_NOTAVAILABLE</strong></td>
  <td style="text-align:left;">An aperture was not available.</td>
</tr>
<tr>
  <td style="text-align:left;"><strong>D3DERR_WASSTILLDRAWING</strong></td>
  <td style="text-align:left;">The allocation was still being used for rendering.</td>
</tr>
<tr>
  <td style="text-align:left;"><strong>D3DDDIERR_CANTEVICTPINNEDALLOCATION</strong></td>
  <td style="text-align:left;">The allocation could not be locked because of the unavailability of a deswizzling aperture and the inability to evict the allocation because it was pinned.</td>
</tr>
<tr>
  <td style="text-align:left;"><strong>E_OUTOFMEMORY</strong></td>
  <td style="text-align:left;"><a href="#">pfnLockCb</a> could not complete because of insufficient memory (this situation occurs when the system is in an extreme low memory situation and there is not enough space to allocate the array of pages).</td>
</tr>
<tr>
  <td style="text-align:left;"><strong>E_INVALIDARG</strong></td>
  <td style="text-align:left;">Parameters were validated and determined to be incorrect.</td>
</tr>
<tr>
  <td style="text-align:left;"></td>
</tr>
<tr>
  <td style="text-align:left;"><strong>D3DDDIERR_DEVICEREMOVED</strong></td>
  <td style="text-align:left;"><a href="#">pfnLockCb</a> could not cause the video memory manager and display miniport driver to perform the appropriate actions because a Plug and Play (PnP) stop or a Timeout Detection and Recovery (TDR) event occurred. The user-mode display driver function that called pfnLockCb(typically, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a> function) must return this error code back to the Direct3D runtime.<br><strong>Direct3D Version 9</strong> Note: For more information about returning error codes, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/returning-error-codes-received-from-runtime-functions">Returning Error Codes Received from Runtime Functions</a>.<br><strong>Direct3D Versions 10 and 11</strong> Note: If the driver function does not return a value (that is, has VOID for a return parameter type), the driver function calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_seterror_cb">pfnSetErrorCb</a> function to send an error code back to the runtime. For more information about handling error codes, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/handling-errors">Handling Errors</a>.</td>
</tr>
</tbody>
</table>

<p>This function might also return other HRESULT values.</p>

<h2 id="remarks">Remarks</h2>

<p>The user-mode display driver can call the Microsoft Direct3D runtime's <em>pfnLockCb</em> function to lock an allocation and obtain a pointer to the allocation from the display miniport driver or video memory manager. The user-mode display driver typically calls <em>pfnLockCb</em> in response to a call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a> function (or other variations of <strong>ResourceMap</strong> such as <em>DynamicIABufferMapDiscard</em>) to lock a resource or a surface within the resource. Before returning from the <strong>Lock</strong> or <strong>ResourceMap</strong> call, the user-mode display driver must first map the resource or surface to the appropriate allocation and then call <em>pfnLockCb</em> to lock the allocation. The allocation must be locked before it can be read from or written to because locking:</p>

<ul>
<li>Guarantees that the virtual address range for the allocation remains unchanged, valid, readable, and writable for the duration of the lock. The video memory manager provides this guarantee.</li>
<li>Provides a way to synchronize the read and write operations of the allocation with graphics hardware accesses of the allocation. The video memory manager and display miniport driver perform the synchronization.</li>
</ul>

<p><strong>Direct3D Version 9 Note:</strong></p>

<p>The user-mode display driver usually calls the <em>pfnLockCb</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_unlockcb">pfnUnlockCb</a> functions that correspond to every call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_unlock">Unlock</a> functions, respectively, except when the driver handles resources in which the <strong>Dynamic</strong> bit-field flag was set in the <strong>Flags</strong> member of the <a href="d3dddiarg_createresource" title="typedef struct _D3DDDIARG_CREATERESOURCE {&#10;  [in]     D3DDDIFORMAT                   Format;&#10;  [in]     D3DDDI_POOL                    Pool;&#10;  [in]     D3DDDIMULTISAMPLE_TYPE         MultisampleType;&#10;  [in]     UINT                           MultisampleQuality;&#10;  [in]     const D3DDDI_SURFACEINFO       *pSurfList;&#10;  [in]     UINT                           SurfCount;&#10;  [in]     UINT                           MipLevels;&#10;  [in]     UINT                           Fvf;&#10;  [in]     D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;&#10;  [in]     D3DDDI_RATIONAL                RefreshRate;&#10;  [in/out] HANDLE                         hResource;&#10;  [in]     D3DDDI_RESOURCEFLAGS           Flags;&#10;  [in]     D3DDDI_ROTATION                Rotation;&#10;} D3DDDIARG_CREATERESOURCE;">D3DDDIARG_CREATERESOURCE</a> structure when the resources were created. The runtime frequently requests that the driver lock these types of resources, often with the <strong>NoOverwrite</strong> bit-field flag set in the <strong>Flags</strong> member of the <a href="d3dddiarg_lock" title="typedef struct _D3DDDIARG_LOCK {&#10;  [in]  HANDLE           hResource;&#10;  [in]  UINT             SubResourceIndex;&#10;  union {&#10;    [in]  D3DDDIRANGE Range;&#10;    [in]  RECT        Area;&#10;    [in]  D3DDDIBOX   Box;&#10;  };&#10;  [out] VOID             *pSurfData;&#10;  [out] UINT             Pitch;&#10;  [out] UINT             SlicePitch;&#10;  [in]  D3DDDI_LOCKFLAGS Flags;&#10;} D3DDDIARG_LOCK;">D3DDDIARG_LOCK</a> structure. Because data in such resources should not be modified (as indicated by <strong>NoOverwrite</strong>), calling <em>pfnLockCb</em> for each lock request consumes excessive processing time. To prevent calling <em>pfnLockCb</em> for each lock request, the driver can cache the virtual memory pointer that it returns in the <strong>pSurfData</strong> member of <a href="d3dddiarg_lock" title="typedef struct _D3DDDIARG_LOCK {&#10;  [in]  HANDLE           hResource;&#10;  [in]  UINT             SubResourceIndex;&#10;  union {&#10;    [in]  D3DDDIRANGE Range;&#10;    [in]  RECT        Area;&#10;    [in]  D3DDDIBOX   Box;&#10;  };&#10;  [out] VOID             *pSurfData;&#10;  [out] UINT             Pitch;&#10;  [out] UINT             SlicePitch;&#10;  [in]  D3DDDI_LOCKFLAGS Flags;&#10;} D3DDDIARG_LOCK;">D3DDDIARG_LOCK</a> when its <strong>Lock</strong> function is called with the <strong>NoOverwrite</strong> bit-field flag set. However, the driver can continue to call <em>pfnLockCb</em> whenever its <strong>Lock</strong> function is called with either the <strong>Discard</strong> bit-field flag set or no flags set.</p>

<p><strong>Direct3D Versions 10 and 11 Note:</strong></p>

<p>The user-mode display driver usually calls the <em>pfnLockCb</em> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_unlockcb">pfnUnlockCb</a> functions that correspond to every call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourceunmap">ResourceUnmap</a> functions (or other variations of these functions). This does not happen when the driver handles resources in which the D3D10_DDI_USAGE_DYNAMIC value was set in the <strong>Usage</strong> member of the <a href="d3d10ddiarg_createresource" title="typedef struct D3D10DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO            *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE             ResourceDimension;&#10;  [in]      UINT                              Usage;&#10;  [in]      UINT                              BindFlags;&#10;  [in]      UINT                              MapFlags;&#10;  [in]      UINT                              MiscFlags;&#10;  [in]      DXGI_FORMAT                       Format;&#10;  [in]      DXGI_SAMPLE_DESC                  SampleDesc;&#10;  [in]      UINT                              MipLevels;&#10;  [in]      UINT                              ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC             *pPrimaryDesc;&#10;} D3D10DDIARG_CREATERESOURCE;">D3D10DDIARG_CREATERESOURCE</a> or <a href="d3d11ddiarg_createresource" title="typedef struct D3D11DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO               *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP    *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE                ResourceDimension;&#10;  [in]      UINT                                 Usage;&#10;  [in]      UINT                                 BindFlags;&#10;  [in]      UINT                                 MapFlags;&#10;  [in]      UINT                                 MiscFlags;&#10;  [in]      DXGI_FORMAT                          Format;&#10;  [in]      DXGI_SAMPLE_DESC                     SampleDesc;&#10;  [in]      UINT                                 MipLevels;&#10;  [in]      UINT                                 ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC                *pPrimaryDesc;&#10;  [in]      UINT                                 ByteStride;&#10;  [in]      D3D11_1DDI_VIDEO_DECODER_BUFFER_TYPE DecoderBufferType;&#10;            D3DWDDM2_0DDI_TEXTURE_LAYOUT         TextureLayout;&#10;} D3D11DDIARG_CREATERESOURCE;">D3D11DDIARG_CREATERESOURCE</a> structure when the resources were created. The runtime frequently requests that the driver lock these types of resources, often by passing the D3D10_DDI_MAP_WRITE_NOOVERWRITE value to the <em>DDIMap</em> parameter in the call to <strong>ResourceMap</strong>. Because data in such resources should not be modified (as indicated by D3D10_DDI_MAP_WRITE_NOOVERWRITE), calling <em>pfnLockCb</em> for each lock request consumes excessive processing time. To prevent calling <em>pfnLockCb</em> for each lock request, the driver can cache the virtual memory pointer that it returns in the <em>pMappedSubResource</em> parameter when its <em>ResourceMap</em> function is called with D3D10_DDI_MAP_WRITE_NOOVERWRITE. However, the driver can continue to call <em>pfnLockCb</em> whenever its <em>ResourceMap</em> function is called with either the D3D10_DDI_MAP_WRITE_DISCARD value or 0 passed to the <em>DDIMap</em> parameter.</p>

<p>While the application does not hold an outstanding lock to the resource that is associated with the virtual memory pointer, the driver typically uncaches the virtual memory pointer by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_unlockcb">pfnUnlockCb</a> function before the driver calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb">pfnRenderCb</a> function. If the lock is not uncached or if the lock cannot be uncached because the application still has the resource locked, the hardware might render from a locked allocation. The video memory manager cannot support this mode of operation if the allocation is in local video memory; therefore, the memory manager evicts the allocation to system or AGP memory when the memory manager detects this situation. If the allocation is not supported in the system or AGP memory segment, the memory manager fails the call to <em>pfnRenderCb</em> with D3DDDIERR_CANTRENDERLOCKEDALLOCATION. Therefore, vertex and index buffer allocations that are allocated in response to creating resources in which the <strong>Dynamic</strong> bit-field flag is set in the <strong>Flags</strong> member of <a href="d3dddiarg_createresource" title="typedef struct _D3DDDIARG_CREATERESOURCE {&#10;  [in]     D3DDDIFORMAT                   Format;&#10;  [in]     D3DDDI_POOL                    Pool;&#10;  [in]     D3DDDIMULTISAMPLE_TYPE         MultisampleType;&#10;  [in]     UINT                           MultisampleQuality;&#10;  [in]     const D3DDDI_SURFACEINFO       *pSurfList;&#10;  [in]     UINT                           SurfCount;&#10;  [in]     UINT                           MipLevels;&#10;  [in]     UINT                           Fvf;&#10;  [in]     D3DDDI_VIDEO_PRESENT_SOURCE_ID VidPnSourceId;&#10;  [in]     D3DDDI_RATIONAL                RefreshRate;&#10;  [in/out] HANDLE                         hResource;&#10;  [in]     D3DDDI_RESOURCEFLAGS           Flags;&#10;  [in]     D3DDDI_ROTATION                Rotation;&#10;} D3DDDIARG_CREATERESOURCE;">D3DDDIARG_CREATERESOURCE</a> (or the D3D10_DDI_USAGE_DYNAMIC value is set in the <strong>Usage</strong> member of <a href="d3d10ddiarg_createresource" title="typedef struct D3D10DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO            *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE             ResourceDimension;&#10;  [in]      UINT                              Usage;&#10;  [in]      UINT                              BindFlags;&#10;  [in]      UINT                              MapFlags;&#10;  [in]      UINT                              MiscFlags;&#10;  [in]      DXGI_FORMAT                       Format;&#10;  [in]      DXGI_SAMPLE_DESC                  SampleDesc;&#10;  [in]      UINT                              MipLevels;&#10;  [in]      UINT                              ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC             *pPrimaryDesc;&#10;} D3D10DDIARG_CREATERESOURCE;">D3D10DDIARG_CREATERESOURCE</a> or <a href="d3d11ddiarg_createresource" title="typedef struct D3D11DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO               *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP    *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE                ResourceDimension;&#10;  [in]      UINT                                 Usage;&#10;  [in]      UINT                                 BindFlags;&#10;  [in]      UINT                                 MapFlags;&#10;  [in]      UINT                                 MiscFlags;&#10;  [in]      DXGI_FORMAT                          Format;&#10;  [in]      DXGI_SAMPLE_DESC                     SampleDesc;&#10;  [in]      UINT                                 MipLevels;&#10;  [in]      UINT                                 ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC                *pPrimaryDesc;&#10;  [in]      UINT                                 ByteStride;&#10;  [in]      D3D11_1DDI_VIDEO_DECODER_BUFFER_TYPE DecoderBufferType;&#10;            D3DWDDM2_0DDI_TEXTURE_LAYOUT         TextureLayout;&#10;} D3D11DDIARG_CREATERESOURCE;">D3D11DDIARG_CREATERESOURCE</a>) should be supported in system or AGP segments.</p>

<p>Setting the <strong>Discard</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> in a call to <em>pfnLockCb</em> causes the video memory manager to create a new instance of the allocation that is being locked. The video memory manager represents the new instance by returning a new handle to the user-mode display driver in the <strong>hAllocation</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a>.</p>

<p><strong>Note</strong> The display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createallocation">DxgkDdiCreateAllocation</a> function is not called when a new instance of an allocation is created. Instances appear to the display miniport driver as allocations that are simultaneously paged in to multiple different locations.</p>

<p>The video memory manager might fail a lock in which the <strong>Discard</strong> bit-field flag is set because the video memory manager cannot create a new instance or reuse an existing instance of an allocation. When this failure occurs, the user-mode display driver should call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb">pfnRenderCb</a> function to flush its current command buffer to the kernel. This flush of the command buffer might retire some instances of the allocation that could not be locked by using the <strong>Discard</strong> bit-field flag.</p>

<p>After flushing its command buffer, the user-mode display driver must try locking the surface again by using both the <strong>Discard</strong> and <strong>NoExistingReference</strong> bit-field flags. The <strong>NoExistingReference</strong> bit-field flag indicates to the video memory manager that the driver does not currently have a reference to any instance of the allocation that is being locked queued in its command buffer. The video memory manager can then reuse any instance of the allocation to handle the lock, including the current instance.</p>

<p>After a call to <em>pfnLockCb</em> in which the <strong>Discard</strong> bit-field flag is set, the user-mode display driver should always check for an updated handle value in the <strong>hAllocation</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a>. If a new allocation handle is provided, the user-mode display driver should update its internal data structure to reference the new allocation handle. The user-mode display driver should also add a re-programmed version of the locked allocation base address to the current command buffer (because allocation instances contain different base addresses). The video memory manager validates the use of allocation instances that are used by the driver and rejects DMA buffers that use the allocation instances incorrectly (that is, calls to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_presentcb">pfnPresentCb</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb">pfnRenderCb</a> fail if they incorrectly use allocation instances). After the driver references a particular instance of an allocation, the driver can no longer reference a previous instance of the same allocation. For example, if a command buffer uses allocation A and currently uses instances A0 and A1, then as soon as A1 is used (that is, appears in the patch-location list) A0 becomes invalid. The display miniport driver can generate a patch-location list that references both A0 and A1. However, the references must be ordered (that is, A0 can be used first; A0 becomes invalid once A2 is used; A1 becomes invalid when A2 is used, and so on).</p>

<p>The user-mode display driver might call <em>pfnLockCb</em> for system memory allocations, even if the memory has not been preallocated, because the display miniport driver might actually be in the process of sending, through DMA, or asynchronously transferring those allocations to graphics hardware. Therefore, before an application is allowed to write to the surface, the display miniport driver and video memory manager must be notified so that they can block the lock if necessary.</p>

<p>The user-mode display driver can also lock subregions of an allocation. This type of lock is typically not necessary when an unswizzling or linearizing hardware aperture is available because, in this situation, the user-mode display driver can translate a lock on the entire allocation to the subregion by offsetting the pointer. However, when <em>pfnLockCb</em> fails by using D3DERR_NOTAVAILABLE to indicate that an aperture is not available, the memory manager requests the user-mode display driver to copy video memory contents. The user-mode display driver unswizzles or linearizes the video memory contents while copying them into another area of memory. In this situation, the user-mode display driver can supply a list of pages to copy to save large amounts of copying when locking small subregions in a large allocation. Note that the memory manager fails a call to <em>pfnLockCb</em> with D3DERR_NOTAVAILABLE if the user-mode display driver did not set the <strong>LockEntire</strong> bit-field flag in the <strong>Flags</strong> member of the <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> structure and did not specify a page list in the <strong>pPages</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a>. If the user-mode display driver sets the <strong>LockEntire</strong> bit-field flag, it must also set the <strong>NumPages</strong> and <strong>pPages</strong> members of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> to 0 and <strong>NULL</strong>, respectively. The user-mode display driver should always supply a page list in <strong>pPages</strong> when locking an allocation that was created with a permanent backing store. In this situation, the memory manager uses the page list to mark as dirty only specific pages and is not required to copy the entire allocation from the backing store when it is used for rendering.</p>

<p>The user-mode display driver can call <em>pfnLockCb</em> to acquire multiple swizzling ranges for a single allocation (for example, one swizzling range for each MIP level). If the driver cannot acquire any one of the ranges, the Direct3D runtime evicts the entire allocation to handle the lock (all of the MIP levels) and reclaims all of the swizzling ranges.</p>

<p>When the user-mode display driver requests that a swizzling range be assigned to the allocation, the driver effectively requests access to the unswizzled bits of the allocation. For such requests, the video memory manager either pages in the allocation into a memory segment and sets up a swizzling range to access the allocation or pages in the allocation into a memory segment and then evicts the allocation to system memory while requesting that the driver unswizzle the allocation on the way to system memory. An allocation that was unswizzled to system memory is reswizzled (by being paged into video memory) before the GPU uses the allocation again. As a result, the driver cannot request a no-overwrite-type lock (by setting the <strong>DonotWait</strong> bit-field flag) when it acquires a swizzling range. Similarly, the driver cannot reference an allocation lock in such a way in a DMA buffer that is submitted to the GPU (because the DMA buffer will be rejected).</p>

<p>The user-mode display driver might lock a swizzled allocation without acquiring a swizzling range if the driver must access the bits of the allocation in a swizzled format. In this situation, the video memory manager provides the driver with a pointer to the swizzled bits of the allocation. However, the driver cannot request a pointer to the swizzled bits of the allocation while a request for the unswizzled bits is outstanding, and vice versa (that is, a lock is currently pending on the allocation with a swizzling range acquired).</p>

<p>The user-mode display driver should pass the <strong>Discard</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> in the <em>pfnLockCb</em> call in the following situations:</p>

<ul>
<li>When the Direct3D runtime passes the <strong>Discard</strong> bit-field flag in the <strong>Flags</strong> member of the <a href="d3dddiarg_lock" title="typedef struct _D3DDDIARG_LOCK {&#10;  [in]  HANDLE           hResource;&#10;  [in]  UINT             SubResourceIndex;&#10;  union {&#10;    [in]  D3DDDIRANGE Range;&#10;    [in]  RECT        Area;&#10;    [in]  D3DDDIBOX   Box;&#10;  };&#10;  [out] VOID             *pSurfData;&#10;  [out] UINT             Pitch;&#10;  [out] UINT             SlicePitch;&#10;  [in]  D3DDDI_LOCKFLAGS Flags;&#10;} D3DDDIARG_LOCK;">D3DDDIARG_LOCK</a> structure in the call to the user-mode display driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a> function</li>
<li>When the runtime passes the D3D10_DDI_MAP_WRITE_DISCARD value to the <em>DDIMap</em> parameter in the call to the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a> function</li>
</ul>

<p>Setting the <strong>Discard</strong> bit-field flag causes the memory manager to determine if it should rename the allocation or should cause the application thread to stall until the allocation is idle. For more information about renaming an allocation, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/requesting-to-rename-an-allocation">Requesting to Rename an Allocation</a>. The driver can use its own renaming support or the memory manager's renaming support. To use its own renaming support, the driver sets the <strong>DonotWait</strong> bit-field flag, in response to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a> call with the <strong>Discard</strong> bit-field flag set, or in response to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a> call with the D3D10_DDI_MAP_WRITE_DISCARD value set. Setting the <strong>DonotWait</strong> bit-field flag causes the memory manager to fail the call to <em>pfnLockCb</em> with D3DERR_WASSTILLDRAWING if the graphics hardware is still using the allocation. Such a failure indicates to the user-mode display driver to rename or multiple-buffer the allocation.</p>

<p><strong>Note</strong> The <strong>DonotWait</strong> bit-field flag has no effect on the memory manager if the <strong>Discard</strong> bit-field flag is also set.</p>

<p>The user-mode display driver should set the <strong>IgnoreSync</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a> when it does not require the memory manager to check whether the graphics hardware is using the allocation. The user-mode display driver must then properly synchronize access to the allocation. If the <strong>DonotWait</strong> bit-field flag is not specified with the <strong>IgnoreSync</strong> bit-field flag, the memory manager ignores the <strong>IgnoreSync</strong> bit-field flag.</p>

<p><strong>Note</strong> The <strong>IgnoreSync</strong> bit-field flag has no effect on the memory manager if the <strong>Discard</strong> bit-field flag is also set.</p>

<p><strong>Example</strong></p>

<p>The following code example shows how the <strong>Discard</strong> bit-field flag is used in a call to <em>pfnLockCb</em>.</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="n">HRESULT</span><span class="w"> </span><span class="n">hr</span><span class="p">;</span>
<span class="n"><a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a></span><span class="w"> </span><span class="n">LockData</span><span class="p">;</span>
<span class="n">LockData</span><span class="p">.</span><span class="n">hAllocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocationToLock</span><span class="p">;</span>
<span class="n">LockData</span><span class="p">.</span><span class="n">Flags</span><span class="p">.</span><span class="n">Discard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfnLockCb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LockData</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FlushAccumulatedCommandBufferToKernel</span><span class="p">();</span>
<span class="w">    </span><span class="n">LockData</span><span class="p">.</span><span class="n">Flags</span><span class="p">.</span><span class="n">Discard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">LockData</span><span class="p">.</span><span class="n">Flags</span><span class="p">.</span><span class="n">NoExistingReference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">    </span><span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfnLockCb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">LockData</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Fails the lock to the application</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">UpdateAllocationHandleInUMDDataStructure</span><span class="p">(</span><span class="n">LockData</span><span class="p">.</span><span class="n">hAllocation</span><span class="p">);</span>
<span class="n">ProgramSurfaceBaseAddressInCurrentCommandBuffer</span><span class="p">(</span><span class="n">LockData</span><span class="p">.</span><span class="n">hAllocation</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="see-also">See also</h2>

<p><a href="d3d10ddiarg_createresource" title="typedef struct D3D10DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO            *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE             ResourceDimension;&#10;  [in]      UINT                              Usage;&#10;  [in]      UINT                              BindFlags;&#10;  [in]      UINT                              MapFlags;&#10;  [in]      UINT                              MiscFlags;&#10;  [in]      DXGI_FORMAT                       Format;&#10;  [in]      DXGI_SAMPLE_DESC                  SampleDesc;&#10;  [in]      UINT                              MipLevels;&#10;  [in]      UINT                              ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC             *pPrimaryDesc;&#10;} D3D10DDIARG_CREATERESOURCE;">D3D10DDIARG_CREATERESOURCE</a></p>

<p><a href="d3d11ddiarg_createresource" title="typedef struct D3D11DDIARG_CREATERESOURCE {&#10;  [in]      const D3D10DDI_MIPINFO               *pMipInfoList;&#10;  [in]      const D3D10_DDIARG_SUBRESOURCE_UP    *pInitialDataUP;&#10;  [in]      D3D10DDIRESOURCE_TYPE                ResourceDimension;&#10;  [in]      UINT                                 Usage;&#10;  [in]      UINT                                 BindFlags;&#10;  [in]      UINT                                 MapFlags;&#10;  [in]      UINT                                 MiscFlags;&#10;  [in]      DXGI_FORMAT                          Format;&#10;  [in]      DXGI_SAMPLE_DESC                     SampleDesc;&#10;  [in]      UINT                                 MipLevels;&#10;  [in]      UINT                                 ArraySize;&#10;  [in, out] DXGI_DDI_PRIMARY_DESC                *pPrimaryDesc;&#10;  [in]      UINT                                 ByteStride;&#10;  [in]      D3D11_1DDI_VIDEO_DECODER_BUFFER_TYPE DecoderBufferType;&#10;            D3DWDDM2_0DDI_TEXTURE_LAYOUT         TextureLayout;&#10;} D3D11DDIARG_CREATERESOURCE;">D3D11DDIARG_CREATERESOURCE</a></p>

<p><a href="d3dddiarg_lock" title="typedef struct _D3DDDIARG_LOCK {&#10;  [in]  HANDLE           hResource;&#10;  [in]  UINT             SubResourceIndex;&#10;  union {&#10;    [in]  D3DDDIRANGE Range;&#10;    [in]  RECT        Area;&#10;    [in]  D3DDDIBOX   Box;&#10;  };&#10;  [out] VOID             *pSurfData;&#10;  [out] UINT             Pitch;&#10;  [out] UINT             SlicePitch;&#10;  [in]  D3DDDI_LOCKFLAGS Flags;&#10;} D3DDDIARG_LOCK;">D3DDDIARG_LOCK</a></p>

<p><a href="d3dddicb_lock" title="typedef struct _D3DDDICB_LOCK {&#10;  [in/out] D3DKMT_HANDLE          hAllocation;&#10;  [in]     UINT                   PrivateDriverData;&#10;  [in]     UINT                   NumPages;&#10;  [in]     const UINT             *pPages;&#10;  [out]    VOID                   *pData;&#10;  [in]     D3DDDICB_LOCKFLAGS     Flags;&#10;           D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;&#10;} D3DDDICB_LOCK;">D3DDDICB_LOCK</a></p>

<p><a href="d3dddi_devicecallbacks" title="typedef struct _D3DDDI_DEVICECALLBACKS {&#10;  PFND3DDDI_ALLOCATECB                            pfnAllocateCb;&#10;  PFND3DDDI_DEALLOCATECB                          pfnDeallocateCb;&#10;  PFND3DDDI_SETPRIORITYCB                         pfnSetPriorityCb;&#10;  PFND3DDDI_QUERYRESIDENCYCB                      pfnQueryResidencyCb;&#10;  PFND3DDDI_SETDISPLAYMODECB                      pfnSetDisplayModeCb;&#10;  PFND3DDDI_PRESENTCB                             pfnPresentCb;&#10;  PFND3DDDI_RENDERCB                              pfnRenderCb;&#10;  PFND3DDDI_LOCKCB                                pfnLockCb;&#10;  PFND3DDDI_UNLOCKCB                              pfnUnlockCb;&#10;  PFND3DDDI_ESCAPECB                              pfnEscapeCb;&#10;  PFND3DDDI_CREATEOVERLAYCB                       pfnCreateOverlayCb;&#10;  PFND3DDDI_UPDATEOVERLAYCB                       pfnUpdateOverlayCb;&#10;  PFND3DDDI_FLIPOVERLAYCB                         pfnFlipOverlayCb;&#10;  PFND3DDDI_DESTROYOVERLAYCB                      pfnDestroyOverlayCb;&#10;  PFND3DDDI_CREATECONTEXTCB                       pfnCreateContextCb;&#10;  PFND3DDDI_DESTROYCONTEXTCB                      pfnDestroyContextCb;&#10;  PFND3DDDI_CREATESYNCHRONIZATIONOBJECTCB         pfnCreateSynchronizationObjectCb;&#10;  PFND3DDDI_DESTROYSYNCHRONIZATIONOBJECTCB        pfnDestroySynchronizationObjectCb;&#10;  PFND3DDDI_WAITFORSYNCHRONIZATIONOBJECTCB        pfnWaitForSynchronizationObjectCb;&#10;...">D3DDDI_DEVICECALLBACKS</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lock">Lock</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourcemap">ResourceMap</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3d10umddi/nc-d3d10umddi-pfnd3d10ddi_resourceunmap">ResourceUnmap</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lockcb">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dumddi/nc-d3dumddi-pfnd3dddi_lockcb.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
