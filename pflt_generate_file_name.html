<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFLT_GENERATE_FILE_NAME - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFLT_GENERATE_FILE_NAME - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFLT_GENERATE_FILE_NAME - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFLT_GENERATE_FILE_NAME PfltGenerateFileName;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfltGenerateFileName(
  [in]           PFLT_INSTANCE Instance,
  [in]           <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a> FileObject,
  [in, optional] <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> CallbackData,
  [in]           FLT_FILE_NAME_OPTIONS NameOptions,
  [out]          PBOOLEAN CacheFileNameInformation,
  [out]          <a href="flt_name_control" title="typedef struct _FLT_NAME_CONTROL {&#10;  UNICODE_STRING Name;&#10;} FLT_NAME_CONTROL, *PFLT_NAME_CONTROL;">PFLT_NAME_CONTROL</a> FileName
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_generate_file_name">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pflt_generate_file_name.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-fltkernel-pflt_generate_file_name)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pflt_generate_file_name-callback-function">PFLT_GENERATE_FILE_NAME callback function</h1>

<h2 id="description">Description</h2>

<p>A minifilter driver that provides file names for the filter manager's name cache can register a routine of type <em>PFLT_GENERATE_FILE_NAME</em> as the minifilter driver's <em>GenerateFileNameCallback</em> routine.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="instance-in"><code>Instance</code> [in]</h3>

<p>Opaque instance pointer for the minifilter driver instance that this callback routine is registered for.</p>

<h3 id="fileobject-in"><code>FileObject</code> [in]</h3>

<p>A pointer to a file object for the file whose name is being requested.</p>

<h3 id="callbackdata-in-optional"><code>CallbackData</code> [in, optional]</h3>

<p>A pointer to the callback data structure for the operation during which this name is being requested. This parameter is <strong>NULL</strong> when <a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a> is called to retrieve the name of the file.</p>

<h3 id="nameoptions-in"><code>NameOptions</code> [in]</h3>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-file-name-options">FLT_FILE_NAME_OPTIONS</a> value that specifies the name format, query method, and flags for this file name information query.</p>

<h3 id="cachefilenameinformation-out"><code>CacheFileNameInformation</code> [out]</h3>

<p>A pointer to a Boolean value specifying whether this name can be cached. Set to <strong>TRUE</strong> on output if the name can be cached; set to <strong>FALSE</strong> otherwise.</p>

<h3 id="filename-out"><code>FileName</code> [out]</h3>

<p>A pointer to a filter manager-allocated <a href="flt_name_control" title="typedef struct _FLT_NAME_CONTROL {&#10;  UNICODE_STRING Name;&#10;} FLT_NAME_CONTROL, *PFLT_NAME_CONTROL;">FLT_NAME_CONTROL</a> structure to receive the file name on output.</p>

<h2 id="return-value">Return value</h2>

<p>This callback routine returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value.</p>

<h2 id="remarks">Remarks</h2>

<p>A minifilter driver that provides file names for the filter manager's name cache can register a routine of type <em>PFLT_GENERATE_FILE_NAME</em> as the minifilter driver's <em>GenerateFileNameCallback</em> routine.</p>

<p>To register this callback routine, the minifilter driver stores the address of a routine of type <em>PFLT_GENERATE_FILE_NAME</em> in the <em>GenerateFileNameCallback</em> member of the <a href="flt_registration" title="typedef struct _FLT_REGISTRATION {&#10;  USHORT                                      Size;&#10;  USHORT                                      Version;&#10;  FLT_REGISTRATION_FLAGS                      Flags;&#10;  const FLT_CONTEXT_REGISTRATION              *ContextRegistration;&#10;  const FLT_OPERATION_REGISTRATION            *OperationRegistration;&#10;  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;&#10;  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;&#10;  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback;&#10;  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;&#10;  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;&#10;  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;&#10;  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;&#10;} FLT_REGISTRATION, *PFLT_REGISTRATION;">FLT_REGISTRATION</a> structure that the minifilter driver passes as a parameter to <a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a>.</p>

<p>The filter manager calls this callback routine to allow the minifilter driver to intercept file name requests by other minifilter drivers above it in the minifilter driver instance stack. Using this callback routine and the <a href="pflt_normalize_name_component" title="PFLT_NORMALIZE_NAME_COMPONENT PfltNormalizeNameComponent;&#10;&#10;NTSTATUS PfltNormalizeNameComponent(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT</a> callback routine, the minifilter driver can provide its own file name information.</p>

<p>To determine which file name format is being requested, call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff543030(v=vs.85)">FltGetFileNameFormat</a> on the <em>NameOptions</em> parameter.</p>

<p>Prior to Windows 8, this callback routine is called only for opened file names and short file names. When the filter manager receives a request for a normalized file name, it calls this callback routine to request the opened file name. Then it calls the minifilter driver's <a href="pflt_normalize_name_component" title="PFLT_NORMALIZE_NAME_COMPONENT PfltNormalizeNameComponent;&#10;&#10;NTSTATUS PfltNormalizeNameComponent(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT</a> callback to normalize each component in the file name.</p>

<p>Starting with Windows 8, this callback routine is also called for normalized names. When the filter manager receives a request for a normalized file name, it calls this callback routine with FLT_FILE_NAME_NORMALIZED specified in the <em>NameOptions</em> parameter. If the minifilter returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> from this callback, the minifilter’s <a href="pflt_normalize_name_component" title="PFLT_NORMALIZE_NAME_COMPONENT PfltNormalizeNameComponent;&#10;&#10;NTSTATUS PfltNormalizeNameComponent(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT</a> callback will not be called. If the minifilter returns a failure code (such as STATUS_NOT_SUPPORTED), the filter manager will call this callback routine again, requesting the opened file name. The filter manager will then call the minifilter driver’s <em><a href="pflt_normalize_name_component" title="PFLT_NORMALIZE_NAME_COMPONENT PfltNormalizeNameComponent;&#10;&#10;NTSTATUS PfltNormalizeNameComponent(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT</a></em> callback to normalize each component in the file name.</p>

<p>When this callback routine is invoked, the minifilter driver generates its own file name information, based on the file system's file name information for the file. To get the file system's file name information for a file, call <a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a>, <a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a>, or <a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a>.</p>

<p>For opened file names, the generated file name information should include volume information. For a remote file, it should include share information as well.</p>

<p>The following is an example of an opened file name for a remote file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>\Device\LanManRedirector\MyServer\MyShare\Docume~1\MyUser\My Documents\TestRe~1.txt:stream1
</code></pre>

<p>For more information about file name formats, see the reference entries for <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a> and <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a>.</p>

<p>After it generates the file name information, the minifilter driver must call <a href="fltcheckandgrownamecontrol" title="NTSTATUS FLTAPI FltCheckAndGrowNameControl(&#10;  [in, out] PFLT_NAME_CONTROL NameCtrl,&#10;  [in]      USHORT            NewSize&#10;);">FltCheckAndGrowNameControl</a> to check whether the <a href="flt_name_control" title="typedef struct _FLT_NAME_CONTROL {&#10;  UNICODE_STRING Name;&#10;} FLT_NAME_CONTROL, *PFLT_NAME_CONTROL;">FLT_NAME_CONTROL</a> structure that the <em>FileName</em> parameter points to contains a name buffer that is large enough to hold the generated file name. If the name buffer is too small, <strong><a href="fltcheckandgrownamecontrol" title="NTSTATUS FLTAPI FltCheckAndGrowNameControl(&#10;  [in, out] PFLT_NAME_CONTROL NameCtrl,&#10;  [in]      USHORT            NewSize&#10;);">FltCheckAndGrowNameControl</a></strong> replaces it with a larger one. The minifilter driver then stores the file name information into the name buffer and returns.</p>

<h2 id="see-also">See also</h2>

<p><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></p>

<p><a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-file-name-options">FLT_FILE_NAME_OPTIONS</a></p>

<p><a href="flt_name_control" title="typedef struct _FLT_NAME_CONTROL {&#10;  UNICODE_STRING Name;&#10;} FLT_NAME_CONTROL, *PFLT_NAME_CONTROL;">FLT_NAME_CONTROL</a></p>

<p><a href="flt_registration" title="typedef struct _FLT_REGISTRATION {&#10;  USHORT                                      Size;&#10;  USHORT                                      Version;&#10;  FLT_REGISTRATION_FLAGS                      Flags;&#10;  const FLT_CONTEXT_REGISTRATION              *ContextRegistration;&#10;  const FLT_OPERATION_REGISTRATION            *OperationRegistration;&#10;  PFLT_FILTER_UNLOAD_CALLBACK                 FilterUnloadCallback;&#10;  PFLT_INSTANCE_SETUP_CALLBACK                InstanceSetupCallback;&#10;  PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK       InstanceQueryTeardownCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownStartCallback;&#10;  PFLT_INSTANCE_TEARDOWN_CALLBACK             InstanceTeardownCompleteCallback;&#10;  PFLT_GENERATE_FILE_NAME                     GenerateFileNameCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT               NormalizeNameComponentCallback;&#10;  PFLT_NORMALIZE_CONTEXT_CLEANUP              NormalizeContextCleanupCallback;&#10;  PFLT_TRANSACTION_NOTIFICATION_CALLBACK      TransactionNotificationCallback;&#10;  PFLT_NORMALIZE_NAME_COMPONENT_EX            NormalizeNameComponentExCallback;&#10;  PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;&#10;} FLT_REGISTRATION, *PFLT_REGISTRATION;">FLT_REGISTRATION</a></p>

<p><a href="fltcheckandgrownamecontrol" title="NTSTATUS FLTAPI FltCheckAndGrowNameControl(&#10;  [in, out] PFLT_NAME_CONTROL NameCtrl,&#10;  [in]      USHORT            NewSize&#10;);">FltCheckAndGrowNameControl</a></p>

<p><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff543030(v=vs.85)">FltGetFileNameFormat</a></p>

<p><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></p>

<p><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff543040(v=vs.85)">FltGetFileNameQueryMethod</a></p>

<p><a href="fltparsefilename" title="NTSTATUS FLTAPI FltParseFileName(&#10;  [in]      PCUNICODE_STRING FileName,&#10;  [in, out] PUNICODE_STRING  Extension,&#10;  [in, out] PUNICODE_STRING  Stream,&#10;  [in, out] PUNICODE_STRING  FinalComponent&#10;);">FltParseFileName</a></p>

<p><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></p>

<p><a href="fltpurgefilenameinformationcache" title="NTSTATUS FLTAPI FltPurgeFileNameInformationCache(&#10;  [in]           PFLT_INSTANCE Instance,&#10;  [in, optional] PFILE_OBJECT  FileObject&#10;);">FltPurgeFileNameInformationCache</a></p>

<p><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></p>

<p><a href="pflt_normalize_context_cleanup" title="PFLT_NORMALIZE_CONTEXT_CLEANUP PfltNormalizeContextCleanup;&#10;&#10;VOID PfltNormalizeContextCleanup(&#10;  [in, optional] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_CONTEXT_CLEANUP</a></p>

<p><a href="pflt_normalize_name_component" title="PFLT_NORMALIZE_NAME_COMPONENT PfltNormalizeNameComponent;&#10;&#10;NTSTATUS PfltNormalizeNameComponent(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT</a></p>

<p><a href="pflt_normalize_name_component_ex" title="PFLT_NORMALIZE_NAME_COMPONENT_EX PfltNormalizeNameComponentEx;&#10;&#10;NTSTATUS PfltNormalizeNameComponentEx(&#10;  [in]      PFLT_INSTANCE Instance,&#10;  [in]      PFILE_OBJECT FileObject,&#10;  [in]      PCUNICODE_STRING ParentDirectory,&#10;  [in]      USHORT VolumeNameLength,&#10;  [in]      PCUNICODE_STRING Component,&#10;  [out]     PFILE_NAMES_INFORMATION ExpandComponentName,&#10;  [in]      ULONG ExpandComponentNameLength,&#10;  [in]      FLT_NORMALIZE_NAME_FLAGS Flags,&#10;  [in, out] PVOID *NormalizationContext&#10;)&#10;{...}">PFLT_NORMALIZE_NAME_COMPONENT_EX</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nc-fltkernel-pflt_generate_file_name">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nc-fltkernel-pflt_generate_file_name.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
