<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltCancellableWaitForSingleObject - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltCancellableWaitForSingleObject - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltCancellableWaitForSingleObject - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltCancellableWaitForSingleObject(
  [in]           PVOID              Object,
  [in, optional] PLARGE_INTEGER     Timeout,
  [in, optional] <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> CallbackData
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcancellablewaitforsingleobject">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltcancellablewaitforsingleobject.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltcancellablewaitforsingleobject)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FltCancellableWaitForSingleObject function</h1>

<h2>Description</h2>

<p>The <strong>FltCancellableWaitForSingleObject</strong> routine executes a cancelable wait operation (a wait that can be terminated) on a dispatcher object.</p>

<h2>Parameters</h2>

<h3><code>Object</code> [in]</h3>

<p>A pointer to an initialized dispatcher object (event, mutex, semaphore, thread, or timer) for which the caller supplies the storage.</p>

<h3><code>Timeout</code> [in, optional]</h3>

<p>A pointer to an optional time-out value. This parameter specifies the absolute or relative time, in 100 nanosecond units, when the wait is to be completed.</p>

<p>If <strong>Timeout</strong> points to a zero value (that is, *<strong>Timeout</strong> == 0), the routine returns without waiting. If the caller supplies a NULL pointer (that is, <strong>Timeout</strong> == NULL), the routine waits indefinitely until the object is set to the signaled state.</p>

<p>A positive <strong>Timeout</strong> value specifies an absolute time, relative to January 1, 1601. A negative <strong>Timeout</strong> value specifies an interval relative to the current time. Absolute expiration times track any changes in the system time. Relative expiration times are not affected by system time changes.</p>

<p>If <strong>Timeout</strong> is specified, the wait is automatically satisfied if the object is not set to the signaled state when the given interval expires.</p>

<p>A time-out value of zero (that is, *<strong>Timeout</strong> == 0) allows you to test a set of wait conditions, and to conditionally perform any additional actions if the wait can be immediately satisfied, as in the acquisition of a mutex.</p>

<h3><code>CallbackData</code> [in, optional]</h3>

<p>A pointer to the <strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong> structure that represents the I/O operation that was issued by the user and that can be canceled by the user. The caller must ensure that the I/O operation will remain valid for the duration of this routine and that the I/O must not have a cancel routine set (for example, a <strong><a href="fltsetcancelcompletion" title="NTSTATUS FLTAPI FltSetCancelCompletion(&#10;  [in] PFLT_CALLBACK_DATA              CallbackData,&#10;  [in] PFLT_COMPLETE_CANCELED_CALLBACK CanceledCallback&#10;);">FltSetCancelCompletion</a></strong> function must not have been called on the I/O operation). Note that the caller must hold the <strong>CallbackData</strong>; it cannot be passed to a lower-level driver.</p>

<h2>Return value</h2>

<p><strong>FltCancellableWaitForSingleObject</strong> can return one of the following values:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></td>
  <td>The dispatcher object that is specified by the <strong>Object</strong> parameter has been set to the signaled state.</td>
</tr>
<tr>
  <td>STATUS_TIMEOUT</td>
  <td>A time-out occurred before the object was set to a signaled state. This value can also be returned when the specified wait condition cannot be immediately met and <strong>Timeout</strong> is set to zero.</td>
</tr>
<tr>
  <td>STATUS_ABANDONED_WAIT_0</td>
  <td>The caller attempted to wait for a mutex that has been abandoned.</td>
</tr>
<tr>
  <td>STATUS_CANCELLED</td>
  <td>The wait was interrupted by a pending cancel request on the I/O operation. Note that this value is returned only if <strong>CallbackData</strong> corresponds to an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> based operation is passed to <strong>FltCancellableWaitForSingleObject</strong> and the I/O was canceled by a routine such as <strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong>.</td>
</tr>
<tr>
  <td>STATUS_THREAD_IS_TERMINATING</td>
  <td>The wait was interrupted because the application or user has terminated the thread.</td>
</tr>
</tbody>
</table>

<p>The return value only indicates the status of the wait.</p>

<p>Note that the <a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a> macro returns FALSE ("failure") for the STATUS_CANCELLED and STATUS_THREAD_IS_TERMINATING status values and TRUE ("success") for all other status values.</p>

<h2>Remarks</h2>

<p>The <strong>FltCancellableWaitForSingleObject</strong> routine executes a cancelable wait operation on a dispatcher object. If the user or application terminates the thread, or if an I/O associated with the thread was canceled by a routine such as <strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong>, the wait is canceled.</p>

<p>The routine is designed to support the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/design/dn613954(v=vs.85)">I/O Completion/Cancellation Guidelines</a>. The goal of these guidelines is to allow users to quickly terminate applications. This, in turn, requires that applications have the ability to quickly terminate threads that are executing I/O and any current I/O operations. This routine provides a way for user threads to block (that is, wait) in the kernel for I/O completion, dispatcher objects, or synchronization variables in a way that allows the wait to be readily canceled. This routine also permits the thread's wait to be terminated if the thread is terminated by a user or an application.</p>

<p>For example, a redirector may need to create a secondary I/O operation in order to process a user-mode I/O and synchronously wait for the secondary request to complete. One way to do this is to set up an event that will be signaled by the completion routine of the secondary I/O operation and then wait for the event to be signaled. Then, to perform a cancelable wait operation, <strong>FltCancellableWaitForSingleObject</strong> is called passing in the event associated with the secondary I/O operation, and the original user-mode I/O operation. The thread's wait for the event to be signaled is canceled if a pending termination event occurs or if the original user-mode I/O operation is canceled.</p>

<p>Note that terminating the wait does not automatically cancel any I/O operation that was issued by the caller - that must be handled separately by the caller.</p>

<p>A special consideration applies when the <strong>Object</strong> parameter passed to <strong>FltCancellableWaitForSingleObject</strong> is a mutex. If the dispatcher object that is waited on is a mutex, APC delivery is the same as for all other dispatcher objects during the wait. However, once <strong>FltCancellableWaitForSingleObject</strong> returns with <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> and the thread actually holds the mutex, only special kernel-mode APCs are delivered. Delivery of all other APCs, both kernel-mode and user-mode, is disabled. This restriction on the delivery of APCs persists until the mutex is released.</p>

<p>A mutex can be recursively acquired only <a href="minlong" title="#define MINLONG 0x80000000 // winnt">MINLONG</a> times. If this limit is exceeded, the routine raises a STATUS_MUTANT_LIMIT_EXCEEDED exception.</p>

<p><strong>FltCancellableWaitForSingleObject</strong> must be called at IRQL PASSIVE_LEVEL if the <strong>CallbackData</strong> parameter represents a valid filter manager <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. Otherwise, the routine can be called at IRQL less or equal to APC_LEVEL. Normal kernel APCs can be disabled by the caller, if needed, by calling the <strong><a href="keentercriticalregion" title="VOID KeEnterCriticalRegion();">KeEnterCriticalRegion</a></strong> or <strong><a href="fsrtlenterfilesystem" title="VOID FsRtlEnterFileSystem(&#10;   VOID&#10;);">FsRtlEnterFileSystem</a></strong> routines. However, special kernel APCs must not be disabled.</p>

<p>The <strong>FltCancellableWaitForSingleObject</strong> routine will assert on debug builds if the <strong>CallbackData</strong> represents a Filter Manager <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> operation, but the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> in the <strong>CallbackData</strong> structure is NULL.</p>

<h2>See also</h2>

<p><strong><a href="exinitializefastmutex" title="VOID ExInitializeFastMutex(&#10;  [out] PFAST_MUTEX FastMutex&#10;);">ExInitializeFastMutex</a></strong></p>

<p><strong><a href="fltcancelio" title="BOOLEAN FLTAPI FltCancelIo(&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancelIo</a></strong></p>

<p><strong><a href="fltcancellablewaitformultipleobjects" title="NTSTATUS FLTAPI FltCancellableWaitForMultipleObjects(&#10;  [in]           ULONG              Count,&#10;  [in]           PVOID []           ObjectArray,&#10;  [in]           WAIT_TYPE          WaitType,&#10;  [in, optional] PLARGE_INTEGER     Timeout,&#10;  [in, optional] PKWAIT_BLOCK       WaitBlockArray,&#10;  [in]           PFLT_CALLBACK_DATA CallbackData&#10;);">FltCancellableWaitForMultipleObjects</a></strong></p>

<p><strong><a href="fltsetcancelcompletion" title="NTSTATUS FLTAPI FltSetCancelCompletion(&#10;  [in] PFLT_CALLBACK_DATA              CallbackData,&#10;  [in] PFLT_COMPLETE_CANCELED_CALLBACK CanceledCallback&#10;);">FltSetCancelCompletion</a></strong></p>

<p><strong>FltCancellableWaitForSingleObject</strong></p>

<p><strong><a href="keinitializemutex" title="VOID KeInitializeMutex(&#10;  [out] PRKMUTEX Mutex,&#10;  [in]  ULONG    Level&#10;);">KeInitializeMutex</a></strong></p>

<p><strong><a href="keinitializesemaphore" title="VOID KeInitializeSemaphore(&#10;  [out] PRKSEMAPHORE Semaphore,&#10;  [in]  LONG         Count,&#10;  [in]  LONG         Limit&#10;);">KeInitializeSemaphore</a></strong></p>

<p><strong><a href="keinitializetimer" title="VOID KeInitializeTimer(&#10;  [out] PKTIMER Timer&#10;);">KeInitializeTimer</a></strong></p>

<p><strong><a href="kewaitformultipleobjects" title="NTSTATUS&#10;KeWaitForMultipleObjects (&#10;    ULONG Count,&#10;    PVOID Object[],&#10;    WaitType,&#10;    KWAIT_REASON WaitReason,&#10;    KPROCESSOR_MODE WaitMode,&#10;    BOOLEAN Alertable,&#10;    PLARGE_INTEGER Timeout,&#10;    PKWAIT_BLOCK WaitBlockArray&#10;    );">KeWaitForMultipleObjects</a></strong></p>

<p><strong><a href="kewaitforsingleobject" title="NTSTATUS&#10;KeWaitForSingleObject (&#10;    PVOID Object,&#10;    KWAIT_REASON WaitReason,&#10;    KPROCESSOR_MODE WaitMode,&#10;    BOOLEAN Alertable,&#10;    PLARGE_INTEGER Timeout&#10;    );">KeWaitForSingleObject</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcancellablewaitforsingleobject">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltcancellablewaitforsingleobject.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
