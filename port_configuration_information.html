<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PORT_CONFIGURATION_INFORMATION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PORT_CONFIGURATION_INFORMATION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PORT_CONFIGURATION_INFORMATION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _PORT_CONFIGURATION_INFORMATION {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           Length;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SystemIoBusNumber;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>  AdapterInterfaceType;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptLevel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptVector;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a> InterruptMode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           MaximumTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           NumberOfPhysicalBreaks;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DmaChannel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DmaPort;
  <a href="dma_width" title="typedef enum _DMA_WIDTH&#10;{&#10;    Width8Bits,&#10;    Width16Bits,&#10;    Width32Bits,&#10;    Width64Bits,&#10;    WidthNoWrap,&#10;    MaximumDmaWidth&#10;} DMA_WIDTH, *PDMA_WIDTH;">DMA_WIDTH</a>       DmaWidth;
  <a href="dma_speed" title="typedef enum _DMA_SPEED&#10;{&#10;    Compatible,&#10;    TypeA,&#10;    TypeB,&#10;    TypeC,&#10;    TypeF,&#10;    MaximumDmaSpeed&#10;} DMA_SPEED, *PDMA_SPEED;">DMA_SPEED</a>       DmaSpeed;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           AlignmentMask;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           NumberOfAccessRanges;
  <a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">ACCESS_RANGE</a>( )   *AccessRanges[];
  PVOID           Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           NumberOfBuses;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           InitiatorBusId[8];
  BOOLEAN         ScatterGather;
  BOOLEAN         Master;
  BOOLEAN         CachesData;
  BOOLEAN         AdapterScansDown;
  BOOLEAN         AtdiskPrimaryClaimed;
  BOOLEAN         AtdiskSecondaryClaimed;
  BOOLEAN         Dma32BitAddresses;
  BOOLEAN         DemandMode;
  BOOLEAN         MapBuffers;
  BOOLEAN         NeedPhysicalAddresses;
  BOOLEAN         TaggedQueuing;
  BOOLEAN         AutoRequestSense;
  BOOLEAN         MultipleRequestPerLu;
  BOOLEAN         ReceiveEvent;
  BOOLEAN         RealModeInitialized;
  BOOLEAN         BufferAccessScsiPortControlled;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           MaximumNumberOfTargets;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           ReservedUchars[2];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SlotNumber;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptLevel2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptVector2;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a> InterruptMode2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DmaChannel2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DmaPort2;
  <a href="dma_width" title="typedef enum _DMA_WIDTH&#10;{&#10;    Width8Bits,&#10;    Width16Bits,&#10;    Width32Bits,&#10;    Width64Bits,&#10;    WidthNoWrap,&#10;    MaximumDmaWidth&#10;} DMA_WIDTH, *PDMA_WIDTH;">DMA_WIDTH</a>       DmaWidth2;
  <a href="dma_speed" title="typedef enum _DMA_SPEED&#10;{&#10;    Compatible,&#10;    TypeA,&#10;    TypeB,&#10;    TypeC,&#10;    TypeF,&#10;    MaximumDmaSpeed&#10;} DMA_SPEED, *PDMA_SPEED;">DMA_SPEED</a>       DmaSpeed2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DeviceExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SpecificLuExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SrbExtensionSize;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           Dma64BitAddresses;
  BOOLEAN         ResetTargetSupported;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>           MaximumNumberOfLogicalUnits;
  BOOLEAN         WmiDataProvider;
} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _PORT_CONFIGURATION_INFORMATION {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  Length;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  SystemIoBusNumber;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>                         AdapterInterfaceType;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  BusInterruptLevel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  BusInterruptVector;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a>                        InterruptMode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  MaximumTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  NumberOfPhysicalBreaks;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  DmaChannel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  DmaPort;
  <a href="dma_width" title="typedef enum _DMA_WIDTH&#10;{&#10;    Width8Bits,&#10;    Width16Bits,&#10;    Width32Bits,&#10;    Width64Bits,&#10;    WidthNoWrap,&#10;    MaximumDmaWidth&#10;} DMA_WIDTH, *PDMA_WIDTH;">DMA_WIDTH</a>                              DmaWidth;
  <a href="dma_speed" title="typedef enum _DMA_SPEED&#10;{&#10;    Compatible,&#10;    TypeA,&#10;    TypeB,&#10;    TypeC,&#10;    TypeF,&#10;    MaximumDmaSpeed&#10;} DMA_SPEED, *PDMA_SPEED;">DMA_SPEED</a>                              DmaSpeed;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  AlignmentMask;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  NumberOfAccessRanges;
  <a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">ACCESS_RANGE</a>( )                          *AccessRanges[];
  PVOID                                  MiniportDumpData;
  PVOID                                  Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  NumberOfBuses;
  <a href="cchar" title="typedef char CCHAR;">CCHAR</a>                                  InitiatorBusId[8];
  BOOLEAN                                ScatterGather;
  BOOLEAN                                Master;
  BOOLEAN                                CachesData;
  BOOLEAN                                AdapterScansDown;
  BOOLEAN                                AtdiskPrimaryClaimed;
  BOOLEAN                                AtdiskSecondaryClaimed;
  BOOLEAN                                Dma32BitAddresses;
  BOOLEAN                                DemandMode;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  MapBuffers;
  BOOLEAN                                NeedPhysicalAddresses;
  BOOLEAN                                TaggedQueuing;
  BOOLEAN                                AutoRequestSense;
  BOOLEAN                                MultipleRequestPerLu;
  BOOLEAN                                ReceiveEvent;
  BOOLEAN                                RealModeInitialized;
  BOOLEAN                                BufferAccessScsiPortControlled;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  MaximumNumberOfTargets;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  SrbType;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  AddressType;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  ReservedUchars[2];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  SlotNumber;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  BusInterruptLevel2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  BusInterruptVector2;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a>                        InterruptMode2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  DmaChannel2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  DmaPort2;
  <a href="dma_width" title="typedef enum _DMA_WIDTH&#10;{&#10;    Width8Bits,&#10;    Width16Bits,&#10;    Width32Bits,&#10;    Width64Bits,&#10;    WidthNoWrap,&#10;    MaximumDmaWidth&#10;} DMA_WIDTH, *PDMA_WIDTH;">DMA_WIDTH</a>                              DmaWidth2;
  <a href="dma_speed" title="typedef enum _DMA_SPEED&#10;{&#10;    Compatible,&#10;    TypeA,&#10;    TypeB,&#10;    TypeC,&#10;    TypeF,&#10;    MaximumDmaSpeed&#10;} DMA_SPEED, *PDMA_SPEED;">DMA_SPEED</a>                              DmaSpeed2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  DeviceExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  SpecificLuExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  SrbExtensionSize;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  Dma64BitAddresses;
  BOOLEAN                                ResetTargetSupported;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  MaximumNumberOfLogicalUnits;
  BOOLEAN                                WmiDataProvider;
  STOR_SYNCHRONIZATION_MODEL             SynchronizationModel;
  PHW_MESSAGE_SIGNALED_INTERRUPT_ROUTINE HwMSInterruptRoutine;
  <a href="interrupt_synchronization_mode" title="typedef enum _INTERRUPT_SYNCHRONIZATION_MODE {&#10;  InterruptSupportNone,&#10;  InterruptSynchronizeAll,&#10;  InterruptSynchronizePerMessage&#10;} INTERRUPT_SYNCHRONIZATION_MODE;">INTERRUPT_SYNCHRONIZATION_MODE</a>         InterruptSynchronizationMode;
  <a href="memory_region" title="typedef struct _MEMORY_REGION {&#10;  PUCHAR           VirtualBase;&#10;  PHYSICAL_ADDRESS PhysicalBase;&#10;  ULONG            Length;&#10;} MEMORY_REGION, *PMEMORY_REGION;">MEMORY_REGION</a>                          DumpRegion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  RequestedDumpBufferSize;
  BOOLEAN                                VirtualDevice;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  DumpMode;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                  DmaAddressWidth;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  ExtendedFlags1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  MaxNumberOfIO;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  MaxIOsPerLun;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  InitialLunQueueDepth;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  BusResetHoldTime;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                  FeatureSupport;
} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// strmini.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _PORT_CONFIGURATION_INFORMATION {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SizeOfThisPacket;
  PVOID           HwDeviceExtension;
  <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>  ClassDeviceObject;
  <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>  PhysicalDeviceObject;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           SystemIoBusNumber;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>  AdapterInterfaceType;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptLevel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           BusInterruptVector;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a> InterruptMode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           DmaChannel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           NumberOfAccessRanges;
  <a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">PACCESS_RANGE</a>   AccessRanges;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           StreamDescriptorSize;
  PIRP            Irp;
  PKINTERRUPT     InterruptObject;
  <a href="padapter_object" title="typedef struct _DMA_ADAPTER {&#10;  USHORT          Version;&#10;  USHORT          Size;&#10;  PDMA_OPERATIONS DmaOperations;&#10;} *PADAPTER_OBJECT, DMA_ADAPTER, *PDMA_ADAPTER;">PADAPTER_OBJECT</a> DmaAdapterObject;
  <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>  RealPhysicalDeviceObject;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>           Reserved[1];
} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_port_configuration_information">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/port_configuration_information.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_port_configuration_information)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="port_configuration_information-structure-srbh">PORT_CONFIGURATION_INFORMATION structure (srb.h)</h1>

<h2 id="description">Description</h2>

<p>PORT_CONFIGURATION_INFORMATION (SCSI) contains configuration information for an HBA. The OS-specific port driver allocates and initializes this structure, supplies as much HBA-specific configuration information as possible, and passes the structure to the miniport driver's <strong>HwScsiFindAdapter</strong> routine. The port driver gets some of the information for this structure from the miniport driver's <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> structure. The miniport driver's <strong>HwScsiFindAdapter</strong> routine is responsible for determining whether the miniport driver can support the HBA and, if so, for filling in the pertinent remaining information in the PORT_CONFIGURATION_INFORMATION structure.</p>

<blockquote>
  <p>[!NOTE]
  The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Use the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models instead.</p>
</blockquote>

<h2 id="members">Members</h2>

<h3 id="length"><code>Length</code></h3>

<p>Specifies the size of this structure in bytes. In effect, this member, which is always initialized by the OS-specific port driver, indicates the version of this structure used by the port driver.</p>

<h3 id="systemiobusnumber"><code>SystemIoBusNumber</code></h3>

<p>Specifies the system-assigned number of the I/O bus to which the HBA is connected. The OS-specific port driver always initializes this member. Its value is system-assigned because the platform might have several I/O buses of the given <strong>AdapterInterfaceType</strong>.</p>

<h3 id="adapterinterfacetype"><code>AdapterInterfaceType</code></h3>

<p>Identifies the I/O bus interface. The OS-specific port driver always sets this member to the value specified by the miniport driver in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure.</p>

<h3 id="businterruptlevel"><code>BusInterruptLevel</code></h3>

<p>Specifies the bus-relative interrupt request level. The OS-specific port driver makes no assumptions about the HBA's interrupt usage, so the default value is zero. Depending on the given <strong>AdapterInterfaceType</strong> and HBA, the value set for this member can correspond to the IRQL for the bus, such as for <strong>Isa</strong> and <strong>MicroChannel</strong> type buses. Drivers of <strong>Eisa</strong> HBAs must set this value to the bus-relative IRQL for the HBA if the adapter is configured for level-sensitive interrupts.</p>

<h3 id="businterruptvector"><code>BusInterruptVector</code></h3>

<p>Specifies the bus-relative vector returned by the HBA. The OS-specific port driver makes no assumptions about the HBA's interrupt usage, so the default value is zero. This member is irrelevant to drivers that set up the <strong>BusInterruptLevel</strong> member for their HBAs. It is pertinent for HBAs on types of I/O buses that use interrupt vectors, such as <strong>PCIBus</strong>.</p>

<h3 id="interruptmode"><code>InterruptMode</code></h3>

<p>Specifies whether the HBA uses <strong>LevelSensitive</strong> or <strong>Latched</strong> (sometimes called "edge-triggered") interrupts. The OS-specific port driver initializes this member to an appropriate value for the bus and the device--for example, <strong>LevelSensitive</strong> for <strong>PCIBus</strong>. Drivers of <strong>Eisa</strong> HBAs must reset this value if the adapter is configured for level-sensitive interrupts, as must drivers of HBAs on I/O buses that use level-sensitive interrupts, such as <strong>MicroChannel</strong> type buses.</p>

<h3 id="maximumtransferlength"><code>MaximumTransferLength</code></h3>

<p>Specifies the maximum number of bytes the HBA can transfer in a single transfer operation. By default, the value of this member is SP_UNINITIALIZED_VALUE, which indicates an unlimited maximum transfer size. If its HBA has more limited transfer support, a miniport driver must reset this member according to the HBA's transfer capacity. If a miniport driver's HwScsiInterrupt routine cannot disable interrupts on the HBA, this member can be adjusted during driver development to ensure that time spent in that miniport driver's ISR does not cause the mouse to "jump" or serial/parallel throughput to drop to a user-noticeable level.</p>

<h3 id="numberofphysicalbreaks"><code>NumberOfPhysicalBreaks</code></h3>

<p>Specifies the maximum number of breaks between address ranges that a data buffer can have if the HBA supports scatter/gather. In other words, the number of scatter/gather lists minus one. By default, the value of this member is SP_UNINITIALIZED_VALUE, which indicates the HBA can support an unlimited number of physical discontinuities. If the port driver sets a value for this member, the miniport driver can adjust the value lower but no higher. If this member is SP_UNINITIALIZED_VALUE, the miniport driver must reset this member according to the HBA's scatter/gather capacity, with zero representing no scatter/gather support.</p>

<h3 id="dmachannel"><code>DmaChannel</code></h3>

<p>Specifies the DMA channel used by a subordinate HBA. By default, the value of this member is SP_UNINITIALIZED_VALUE. If the HBA uses a system DMA controller and the given <strong>AdapterInterfaceType</strong> is any value except <strong>MicroChannel</strong>, the miniport driver must reset this member.</p>

<h3 id="dmaport"><code>DmaPort</code></h3>

<p>Specifies the DMA port used by a subordinate HBA. By default, the value of this member is SP_UNINITIALIZED_VALUE. If the HBA uses a system DMA controller and the given <strong>AdapterInterfaceType</strong> is <strong>MicroChannel</strong>, the miniport driver must set this member.</p>

<h3 id="dmawidth"><code>DmaWidth</code></h3>

<p>Specifies the width of DMA transfers if the HBA uses DMA. By default, the value of this member is zero. If its HBA does DMA, the miniport driver must reset this member to one of the following: <strong>Width8Bits</strong>, <strong>Width16Bits</strong>, or <strong>Width32Bits</strong>.</p>

<h3 id="dmaspeed"><code>DmaSpeed</code></h3>

<p>Specifies the DMA data-transfer speed for <strong>Eisa</strong> HBAs. By default, the value of this member specifies compatibility timing. Acceptable values for this member are any of the following: <strong>Compatible</strong>, <strong>TypeA</strong>, <strong>TypeB</strong>, or <strong>TypeC</strong>.</p>

<h3 id="alignmentmask"><code>AlignmentMask</code></h3>

<p>Contains a mask indicating the alignment restrictions for buffers required by the HBA for transfer operations. Valid mask values are also restricted by characteristics of the memory managers on different versions of Windows. The mask values that are permitted under Windows 95 or Windows 98 are 0 (byte aligned), 1 (word aligned) or 3 (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> aligned). Under Windows NT and Windows 2000 the valid mask values are 0 (byte aligned), 1 (word aligned), 3 (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> aligned) and 7 (double <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> aligned). The miniport driver should set this mask if the HBA supports scatter/gather.</p>

<h3 id="numberofaccessranges"><code>NumberOfAccessRanges</code></h3>

<p>Specifies the number of <strong>AccessRanges</strong> elements in the array, described next. The OS-specific port driver always sets this member to the value passed in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>.</p>

<h3 id="accessranges"><code>AccessRanges</code></h3>

<h3 id="reserved"><code>Reserved</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="numberofbuses"><code>NumberOfBuses</code></h3>

<p>Specifies the number of SCSI buses controlled by the HBA. By default, the value of this member is zero.</p>

<h3 id="initiatorbusid8"><code>InitiatorBusId[8]</code></h3>

<p>Indicates the initiator bus ID. If the input <strong>InitiatorBusId</strong>[0] has the value zero, the miniport driver can assign a default value if its HBA does not require the use of particular value(s) determined by querying the HBA. Otherwise, the miniport driver should use any nonzero value assigned by the port driver if possible. Every miniport driver must update <strong>InitiatorBusId</strong> specifications to match what its HBA uses, if necessary querying the HBA to determine the appropriate values(s).</p>

<p>A miniport driver must set an entry for each SCSI bus supported by the HBA, as indicated by the value of <strong>NumberOfBuses</strong>.</p>

<h3 id="scattergather"><code>ScatterGather</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA supports scatter/gather. When <strong>FALSE</strong> the HBA does not support scatter/gather. By default, the value of this member is <strong>FALSE</strong>.</p>

<h3 id="master"><code>Master</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA is a bus master. When <strong>FALSE</strong>, the HBA is not a bus master. By default, the value of this member is <strong>FALSE</strong>.</p>

<h3 id="cachesdata"><code>CachesData</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA caches data or maintains cached state on the peripherals. When <strong>FALSE</strong> the HBA does not cache data or maintain cached state on the peripherals. By default, the value of this member is <strong>FALSE</strong>. If this is reset to <strong>TRUE</strong>, the OS-specific port driver notifies the miniport driver when certain system events occur, such as file system cache flushes and system shutdown. For example, if a controller on the bus mirrors two disks, the miniport driver would normally set this member to <strong>TRUE</strong>.</p>

<h3 id="adapterscansdown"><code>AdapterScansDown</code></h3>

<p>Indicates when <strong>TRUE</strong> that the BIOS for the HBA scans for SCSI bus targets from seven to zero. When <strong>FALSE</strong>, the BIOS for the HBA looks for SCSI bus targets, starting with an ID zero and scanning upwards to (but not including) <strong>MaximumTargetIds</strong>. By default, the value of <strong>AdapterScansDown</strong> is <strong>FALSE</strong>.</p>

<h3 id="atdiskprimaryclaimed"><code>AtdiskPrimaryClaimed</code></h3>

<p>Indicates when <strong>TRUE</strong> that the primary "AT" (WD1003-compatible) disk address range, 0x1F0 to 0x1FF, has been claimed in the registry by another driver for its device. The OS-specific port driver always initializes this member. If the input value of this member is <strong>TRUE</strong>, a miniport driver should assume that an already loaded driver has claimed the device range. If the input value is <strong>FALSE</strong>, a miniport driver can claim the address range for an HBA that emulates an "AT" disk controller and reset this member to <strong>TRUE</strong>, thereby preventing access to this range by the "AT" disk driver or subsequently loaded miniport drivers.</p>

<h3 id="atdisksecondaryclaimed"><code>AtdiskSecondaryClaimed</code></h3>

<p>Indicates when <strong>TRUE</strong> that the secondary AT disk address range, 0x170 to 0x17F has been claimed in the registry by another driver for its device. When <strong>FALSE</strong> the secondary AT disk address range has not been claimed in the registry by another driver. The OS-specific port driver always initializes this member. Miniport drivers should treat this member as for <strong>AtdiskPrimaryClaimed</strong>.</p>

<h3 id="dma32bitaddresses"><code>Dma32BitAddresses</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA has 32 address lines and can access memory with physical addresses greater than 0x00FFFFFF. When <strong>FALSE</strong> the HBA has either a number of DMA address lines other than 32. By default, the value of this member is <strong>FALSE</strong>. If the miniport driver sets <strong>Dma64BitAddresses</strong>, this member must be <strong>FALSE</strong>.</p>

<h3 id="demandmode"><code>DemandMode</code></h3>

<p>Indicates when <strong>TRUE</strong> that the system DMA controller should be programmed for demand-mode rather than single-cycle operations. If the HBA is not a subordinate device, this member should be <strong>FALSE</strong>.</p>

<h3 id="mapbuffers"><code>MapBuffers</code></h3>

<p>Indicates when <strong>TRUE</strong> that data buffers must be mapped to system virtual address ranges. When <strong>FALSE</strong> the data buffers do not have to be mapped to system virtual addresses. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls. If <strong>FALSE</strong>, the miniport driver must not access <strong>Srb.DataBuffer</strong> directly.</p>

<h3 id="needphysicaladdresses"><code>NeedPhysicalAddresses</code></h3>

<p>Indicates when <strong>TRUE</strong> that the miniport driver must translate virtual addresses to physical addresses, as required by the HBA. When <strong>FALSE</strong>, the miniport driver does not have to translate virtual addresses to physical addresses. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls.</p>

<h3 id="taggedqueuing"><code>TaggedQueuing</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA supports queuing of multiple requests with SCSI tags. When <strong>FALSE</strong>, the HBA does not support SCSI-tagged queuing. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls.</p>

<h3 id="autorequestsense"><code>AutoRequestSense</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA supports auto request sense. When <strong>FALSE</strong> the HBA does not support auto request sense. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls. This member must be set to <strong>TRUE</strong> before the driver of a bus-master HBA calls <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h3 id="multiplerequestperlu"><code>MultipleRequestPerLu</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA supports multiple requests per logical unit. When <strong>FALSE</strong> the HBA does not support multiple requests per logical unit. The mechanism by which the adapter caches the requests is adapter-defined. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls.</p>

<h3 id="receiveevent"><code>ReceiveEvent</code></h3>

<p>Indicates when <strong>TRUE</strong> that the HBA supports SCSI receive-event operations. When <strong>FALSE</strong> the HBA does not support SCSI receive-event operations. The OS-specific port driver always sets this member to the value passed in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. A miniport driver can reset this value for any particular HBA it controls.</p>

<h3 id="realmodeinitialized"><code>RealModeInitialized</code></h3>

<p>Indicates when <strong>TRUE</strong> that an (x86-only) real-mode driver has already initialized the HBA. When <strong>FALSE</strong> the HBA has not been previously initialized by a real-mode driver. The OS-dependent port driver always initializes this member. If this is set to <strong>TRUE</strong>, the miniport driver must not initialize its HBA if the driver's initialization sequence is identical to real-mode HBA initialization; not reinitializing the HBA in these circumstances makes the miniport driver load much faster. The value of this member is irrelevant to any miniport driver that always initializes its HBA while running in protected mode on x86-based platforms and to all miniport drivers for which it is immaterial whether they are running on a CISC- or RISC-based platform.</p>

<h3 id="bufferaccessscsiportcontrolled"><code>BufferAccessScsiPortControlled</code></h3>

<p>Indicates when <strong>TRUE</strong> that the miniport driver always calls <strong>ScsiPort*Xxx</strong>* to access data buffers and/or request-sense information in SRBs, thereby allowing the OS-specific port driver to optimize I/O request processing. When <strong>FALSE</strong> the miniport driver does not have to call <strong>ScsiPort*Xxx</strong>* routines to access data buffers or request-sense information. Setting this member to <strong>FALSE</strong> can degrade the I/O performance of the HBA. Calling routines other than the <strong>ScsiPort*Xxx</strong>* makes a miniport driver nonportable across Microsoft operating systems.</p>

<h3 id="maximumnumberoftargets"><code>MaximumNumberOfTargets</code></h3>

<p>Specifies the number of target peripherals the HBA can control. By default, the value of this member is SCSI_MAXIMUM_TARGETS, according to the SCSI standard. A miniport driver can reset this member to a lesser value if the HBA has more limited capabilities or to a greater value, indicating that the HBA has wide-SCSI or Fibre Channel capabilities. This value is limited to SCSI_MAXIMUM_TARGETS_PER_BUS.</p>

<h3 id="reserveduchars2"><code>ReservedUchars[2]</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="slotnumber"><code>SlotNumber</code></h3>

<p>Specifies the slot number of an HBA with matching values to the <strong>VendorId</strong> and <strong>DeviceId</strong> that were specified in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a> structure when the miniport driver called <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>.</p>

<h3 id="businterruptlevel2"><code>BusInterruptLevel2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="businterruptvector2"><code>BusInterruptVector2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="interruptmode2"><code>InterruptMode2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="dmachannel2"><code>DmaChannel2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="dmaport2"><code>DmaPort2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="dmawidth2"><code>DmaWidth2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="dmaspeed2"><code>DmaSpeed2</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="deviceextensionsize"><code>DeviceExtensionSize</code></h3>

<p>Specifies the size in bytes required by a miniport driver for its per-HBA device extension to handle data transfers larger than 64K, which might require larger scatter/gather lists than the size defined in the registry for this driver.</p>

<h3 id="specificluextensionsize"><code>SpecificLuExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-logical-unit-storage, if any, to handle data transfers larger than 64K. Leave this member set to zero if the miniport driver does not maintain per-LU information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h3 id="srbextensionsize"><code>SrbExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-request storage, if any, to handle data transfers larger than 64K. Set this member before calling <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong> to change the size of per-request storage based on <strong>NumberOfPhysicalBreaks</strong>. Leave this member set to zero if the miniport driver does not maintain per-SRB information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h3 id="dma64bitaddresses"><code>Dma64BitAddresses</code></h3>

<p>Indicates that the HBA is able to access addresses greater than 4 GB, or 0x0FFFFFFFF if <strong>Dma64BitAddresses</strong> contains a value of SCSI_DMA64_MINIPORT_SUPPORTED. Prior to Windows 2000 the ScsiPort set this value based on the contents of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a>. This is no longer the case. In Windows 2000 the value of <strong>Dma64BitAddresses</strong> is determined by the miniport driver callback <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)"><strong>HwScsiFindAdapter</strong></a> alone. If the operating system supports a 64-bit address space, the port driver passes a value of SCSI_DMA64_SYSTEM_SUPPORTED to the miniport driver in this member. If the HBA described by PORT_CONFIGURATION_INFORMATION also supports address spaces greater than 32-bits then the port/miniport driver is required to support full 64-bit addressing, and the miniport driver's callback <strong>HwScsiFindAdapter</strong> indicates this by assigning a value of SCSI_DMA64_MINIPORT_SUPPORTED to <strong>Dma64BitAddresses</strong>, writing over any previous value assigned by the port driver. The correct value must be assigned to the <strong>Dma64BitAddresses</strong> member before the miniport driver calls <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h3 id="resettargetsupported"><code>ResetTargetSupported</code></h3>

<p>Obsolete. ScsiPort driver no longer sends SRB_FUNCTION_RESET_DEVICE requests to its miniport drivers. Do not use this member.</p>

<h3 id="maximumnumberoflogicalunits"><code>MaximumNumberOfLogicalUnits</code></h3>

<p>Specifies the maximum number of logical units per target the HBA can control. By default, the value of this member is SCSI_MAXIMUM_LOGICAL_UNITS. A miniport driver can reset this member to a lesser value if the HBA has more limited capabilities or to a greater value, indicating that the HBA has SCSI-3 capabilities.</p>

<h3 id="wmidataprovider"><code>WmiDataProvider</code></h3>

<p>Indicates when <strong>TRUE</strong> that the miniport driver responds to Windows Management Instrumentation (WMI) requests. When <strong>FALSE</strong> the miniport driver does not respond to Windows Management Instrumentation (WMI) requests. By default, the value of this member is <strong>FALSE</strong>.</p>

<h2 id="remarks">Remarks</h2>

<p>The specific members initialized depend on the HBA miniport driver and on the configuration information available to the OS-specific port driver. The OS-specific port driver sets default values in all members for which it cannot supply configuration information to the miniport driver's <strong>HwScsiFindAdapter</strong> routine.</p>

<p>All HBA miniport drivers should have at least one set of defaults to use for relevant members if the OS-specific port driver does not pass in all initialized values.</p>

<p>The <strong>HwScsiFindAdapter</strong> routine must update all members relevant to an HBA that the driver supports.</p>

<p>Windows NT storage class drivers, which load later than miniport drivers, depend on the information supplied by each miniport driver's <strong>HwScsiFindAdapter</strong> routine to set up their subsequent I/O requests. For example, the <strong>MaximumTransferLength</strong> and <strong>NumberOfPhysicalBreaks</strong> values supplied by each miniport driver control whether a class driver must split large transfer requests into a set of partial transfers to suit the limits of the HBA.</p>

<p>The <strong>Dma64BitAddresses</strong> member of PORT_CONFIGURATION_INFORMATION should no longer be thought of as a BOOLEAN value. A value of SCSI_DMA64_SYSTEM_SUPPORTED indicates that the port/miniport driver is required to support 64-bit addressing, but the <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong> routine still interprets any nonzero value of <strong>Dma64BitAddresses</strong> as indicating that 64-bit support is required. This means that <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong> still functions properly when called by a legacy driver that assigns BOOLEAN values to <strong>Dma64BitAddresses</strong>.</p>

<p>In addition to <strong>Dma64BitAddresses</strong>, both PORT_CONFIGURATION_INFORMATION and <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> have a pair of members called <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> whose values must now be handled differently. The miniport driver must calculate the initial values of <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> in <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> based on the assumption that the HBA is capable of receiving 32-bit addresses, regardless of what the controller can actually support. The default values for <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> in PORT_CONFIGURATION_INFORMATION will also be based on an assumption of 32-bit addressing, since the values in PORT_CONFIGURATION_INFORMATION are derived from the values in <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a>.</p>

<p>This means that if the miniport driver needs additional space in either the LUN extension or the SRB extension in order to handle 64 bit physical addresses, it must modify the values for <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> in PORT_CONFIGURATION_INFORMATION to account for this before passing PORT_CONFIGURATION_INFORMATION to <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">ACCESS_RANGE</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data"><strong>HW_INITIALIZATION_DATA (SCSI)</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)"><strong>HwScsiFindAdapter</strong></a></p>

<p><strong><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></strong></p>

<p><strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong></p>

<p><strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong></p>

<p><strong><a href="scsiportvalidaterange" title="SCSIPORT_API BOOLEAN ScsiPortValidateRange(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortValidateRange</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_port_configuration_information.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_port_configuration_information)</h1>
</div>
<div class="ntdoc-description">
<h1>PORT_CONFIGURATION_INFORMATION structure (storport.h)</h1>

<h2>Description</h2>

<p><strong>PORT_CONFIGURATION_INFORMATION</strong> contains configuration information for a host bus adapter (HBA).</p>

<h2>Members</h2>

<h3><code>Length</code></h3>

<p>Size, in bytes, of the <strong>PORT_CONFIGURATION_INFORMATION</strong> structure. Initialized by the Storport driver, this member also serves as the structure version.</p>

<h3><code>SystemIoBusNumber</code></h3>

<p>System-assigned number of the I/O bus to which the HBA is connected. Miniport drivers must not modify this member. Its value is system-assigned because the platform might have several I/O buses of the specified <strong>AdapterInterfaceType</strong>.</p>

<h3><code>AdapterInterfaceType</code></h3>

<p>The I/O bus interface. Storport initializes this member to the value specified by the miniport driver in the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure. Miniport drivers must not modify this member.</p>

<h3><code>BusInterruptLevel</code></h3>

<p>The bus-relative interrupt request level. Storport makes no assumptions about the HBA's interrupt usage, so the default value is zero. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>BusInterruptVector</code></h3>

<p>The bus-relative vector returned by the HBA. Storport makes no assumptions about the HBA's interrupt usage, so the default value is zero. This member is irrelevant to drivers that set up the <strong>BusInterruptLevel</strong> member for their HBAs. It is pertinent for HBAs on types of I/O buses that use interrupt vectors, such as <strong>PCIBus</strong>. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>InterruptMode</code></h3>

<p>Specifies whether the HBA uses <strong>LevelSensitive</strong> or <strong>Latched</strong> (sometimes called "edge-triggered") interrupts. Storport initializes this member to an appropriate value for the bus and the device--for example, <strong>LevelSensitive</strong> for <strong>PCIBus</strong>. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>MaximumTransferLength</code></h3>

<p>Maximum number of bytes the HBA can transfer in a single transfer operation. By default, the value of this member is SP_UNINITIALIZED_VALUE, which indicates an unlimited maximum transfer size. If its HBA has more limited transfer support, a miniport driver must reset this member according to the HBA's transfer capacity. If a miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_interrupt"><em>HwStorInterrupt</em></a> routine cannot disable interrupts on the HBA, this member can be adjusted during driver development to ensure that time spent in that miniport driver's ISR does not degrade overall system performance.</p>

<h3><code>NumberOfPhysicalBreaks</code></h3>

<p>Maximum number of physical pages the storage adapter can manage in a single transfer (in other words, the extent of its scatter/gather support). By default, the value of this member is 0x11. The miniport driver must reset this member according to the storage adapter's capability.</p>

<h3><code>DmaChannel</code></h3>

<p>The DMA channel used by a subordinate HBA. By default, the value of this member is SP_UNINITIALIZED_VALUE. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>DmaPort</code></h3>

<p>The DMA port used by a subordinate HBA. By default, the value of this member is SP_UNINITIALIZED_VALUE. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>DmaWidth</code></h3>

<p>Width of DMA transfers if the HBA uses DMA. By default, the value of this member is zero. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>DmaSpeed</code></h3>

<p>The DMA data-transfer speed for <strong>Eisa</strong> HBAs. Storport initializes this member and miniport drivers must not modify it.</p>

<h3><code>AlignmentMask</code></h3>

<p>Mask indicating the alignment restrictions for buffers required by the HBA for transfer operations. Some example valid mask values are 0 (byte aligned), 1 (word aligned), 3 (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> aligned) and 7 (double <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> aligned). The miniport driver should set this mask if the HBA supports scatter/gather. The following allowed alignment mask values are defined in wdm.h:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="file_byte_alignment" title="#define FILE_BYTE_ALIGNMENT 0x00000000">FILE_BYTE_ALIGNMENT</a> (0x00000000)</td>
  <td>Data is byte aligned (no alignment requirements for the device)</td>
</tr>
<tr>
  <td><a href="file_word_alignment" title="#define FILE_WORD_ALIGNMENT 0x00000001">FILE_WORD_ALIGNMENT</a> (0x00000001)</td>
  <td>Data must be aligned on a 2-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_long_alignment" title="#define FILE_LONG_ALIGNMENT 0x00000003">FILE_LONG_ALIGNMENT</a> (0x00000003)</td>
  <td>Data must be aligned on a 4-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_quad_alignment" title="#define FILE_QUAD_ALIGNMENT 0x00000007">FILE_QUAD_ALIGNMENT</a> (0x00000007)</td>
  <td>Data must be aligned on an 8-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_octa_alignment" title="#define FILE_OCTA_ALIGNMENT 0x0000000f">FILE_OCTA_ALIGNMENT</a> (0x0000000f)</td>
  <td>Data must be aligned on a 16-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_32_byte_alignment" title="#define FILE_32_BYTE_ALIGNMENT 0x0000001f">FILE_32_BYTE_ALIGNMENT</a> (0x0000001f)</td>
  <td>Data must be aligned on a 32-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_64_byte_alignment" title="#define FILE_64_BYTE_ALIGNMENT 0x0000003f">FILE_64_BYTE_ALIGNMENT</a> (0x0000003f)</td>
  <td>Data must be aligned on a 64-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_128_byte_alignment" title="#define FILE_128_BYTE_ALIGNMENT 0x0000007f">FILE_128_BYTE_ALIGNMENT</a> (0x0000007f)</td>
  <td>Data must be aligned on a 128-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_256_byte_alignment" title="#define FILE_256_BYTE_ALIGNMENT 0x000000ff">FILE_256_BYTE_ALIGNMENT</a> (0x000000ff)</td>
  <td>Data must be aligned on a 256-byte boundary.</td>
</tr>
<tr>
  <td><a href="file_512_byte_alignment" title="#define FILE_512_BYTE_ALIGNMENT 0x000001ff">FILE_512_BYTE_ALIGNMENT</a> (0x000001ff)</td>
  <td>Data must be aligned on a 512-byte boundary.</td>
</tr>
</tbody>
</table>

<h3><code>NumberOfAccessRanges</code></h3>

<p>Specifies the number of <strong>AccessRanges</strong> elements in the array.</p>

<h3><code>AccessRanges</code></h3>

<p>Pointer to an array of <strong><a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">ACCESS_RANGE</a></strong>-type elements. Storport allocates memory for the access ranges and initializes this member. Miniport drivers must not modify this member.</p>

<h3><code>MiniportDumpData</code></h3>

<p>Pointer to a dump context used during a crashdump or a hibernation.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for system use (pre-Windows 8).</p>

<h3><code>NumberOfBuses</code></h3>

<p>Number of buses controlled by the adapter. By default, the value of this member is zero. This member has a maximum value of SCSI_MAXIMUM_BUSES_PER_ADAPTER. This member is available starting in Windows 8.</p>

<h3><code>InitiatorBusId</code></h3>

<p>The initiator bus ID. If the input <strong>InitiatorBusId[0]</strong> has the value SP_UNINITIALIZED_VALUE, the miniport driver can assign a default value if its HBA does not require the use of particular value(s) determined by querying the HBA. Otherwise, the miniport driver should use any nonzero value assigned by the port driver if possible. Typically, this value is bounded by the value set for <strong>MaximumNumberOfTargets</strong>.</p>

<h3><code>ScatterGather</code></h3>

<p>When <strong>TRUE</strong>, the HBA supports scatter/gather. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support scatter/gather. Miniport drivers that work with Storport must not modify this value. (NOTE: in Windows versions prior to Windows Server 2008 R2 and Windows 7, this member is set to FALSE. In this case, miniport drivers must set this member to <strong>TRUE</strong>. Not setting this member to <strong>TRUE</strong> will cause the HBA device to fail to start.)</p>

<h3><code>Master</code></h3>

<p>When <strong>TRUE</strong>, the HBA is a master bus. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support bus-mastering DMA. Miniport drivers that work with Storport must not modify this value. (NOTE: in Windows versions prior to Windows Server 2008 R2 and Windows 7, this member is set to FALSE. In this case, miniport drivers must set this member to <strong>TRUE</strong>. Not setting this member to <strong>TRUE</strong> will cause the HBA device to fail to start.)</p>

<h3><code>CachesData</code></h3>

<p>When <strong>TRUE</strong>, the HBA caches data or maintains cached state on the peripherals. When <strong>FALSE</strong>, the HBA does not cache data or maintain cached state on the peripherals. By default, the value of this member is <strong>FALSE</strong>. If this is reset to <strong>TRUE</strong>, Storport notifies the miniport driver when certain system events occur, such as file system cache flushes.</p>

<h3><code>AdapterScansDown</code></h3>

<p>Storport ignores this member.</p>

<h3><code>AtdiskPrimaryClaimed</code></h3>

<p>Storport does not use this member, and its miniport drivers must not set it.</p>

<h3><code>AtdiskSecondaryClaimed</code></h3>

<p>Storport does not use this member, and its miniport drivers must not set it.</p>

<h3><code>Dma32BitAddresses</code></h3>

<p>When <strong>TRUE</strong>, the HBA has 32 address lines and can access memory with physical addresses greater than 0x00FFFFFF. Storport initializes this member to <strong>TRUE</strong>, because its miniport drivers must support bus-width DMA. Miniport drivers must not modify this value since this is the default DMA addressing if a value for <strong>Dma64BitAddresses</strong> is not set. NOTE: If only 32-bit addresses are supported by the device hardware, then <strong>Dma64BitAddresses</strong> must be set to 0.</p>

<h3><code>DemandMode</code></h3>

<p>Indicates whether the system DMA controller should be programmed for demand-mode rather than single-cycle operations. Storport initializes this member to <strong>FALSE</strong>, because it does not support subordinate-mode DMA. Miniport drivers must not modify this value.</p>

<h3><code>MapBuffers</code></h3>

<p>Indicates whether Storport maps SRB data buffer addresses to system virtual addresses. The miniport driver sets this member to one of the following values to control mapping for SRB data buffer addresses.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STOR_MAP_NO_BUFFERS</td>
  <td>Maps the buffer only for SRB_FUNCTION_IO_CONTROL and SRB_FUNCTION_WMI.</td>
</tr>
<tr>
  <td>STOR_MAP_ALL_BUFFERS</td>
  <td>Obsolete. This value has the same effect as STOR_MAP_NON_READ_WRITE_BUFFERS.</td>
</tr>
<tr>
  <td>STOR_MAP_NON_READ_WRITE_BUFFERS</td>
  <td>Maps the buffer for all IO except for read and write requests.</td>
</tr>
<tr>
  <td>STOR_MAP_ALL_BUFFERS_INCLUDING_READ_WRITE</td>
  <td>Maps the buffer for all IO including read and write requests. Miniports supporting boot must handle a read or write request of <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a> in length. These read or write requests must always complete successfully. Storport may fail to map the buffer under low system memory conditions. In this case, the DataBuffer member in the SRB will be NULL.</td>
</tr>
</tbody>
</table>

<h3><code>NeedPhysicalAddresses</code></h3>

<p>When <strong>TRUE</strong>, the miniport driver must translate virtual addresses to physical addresses, as required by the HBA. Storport initializes this member to TRUE, because its miniport drivers must support scatter/gather lists. Miniport must not modify this value.</p>

<h3><code>TaggedQueuing</code></h3>

<p>When <strong>TRUE</strong>, the HBA supports queuing of multiple requests with SCSI tags. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support tagged-queuing. Miniport drivers must not modify this value.</p>

<h3><code>AutoRequestSense</code></h3>

<p>When <strong>TRUE</strong>, the HBA supports auto request sense. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support auto-request sense. Miniport drivers must not modify this value.</p>

<h3><code>MultipleRequestPerLu</code></h3>

<p>When <strong>TRUE</strong>, the HBA supports multiple requests per logical unit. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support multiple requests issued to a logical unit at time. Miniport drivers must not modify this value.</p>

<h3><code>ReceiveEvent</code></h3>

<p>Storport does not use this member, and its miniport drivers must not set it.</p>

<h3><code>RealModeInitialized</code></h3>

<p>Storport does not use this member, and its miniport drivers must not set it.</p>

<h3><code>BufferAccessScsiPortControlled</code></h3>

<p>Storport does not use this member, and its miniport drivers must not set it.</p>

<h3><code>MaximumNumberOfTargets</code></h3>

<p>Number of target peripherals the adapter can control. By default, the value of this member is SCSI_MAXIMUM_TARGETS_PER_BUS. A miniport driver can reset this member to a lesser value if the HBA has more limited capabilities or to a greater value, indicating that the HBA has extended bus capabilities. The maximum value for this member is 255.</p>

<h3><code>SrbType</code></h3>

<p>Type of SRBs to be sent to the miniport driver. Available starting in Windows 8. This is set to one of the following values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_TYPE_SCSI_REQUEST_BLOCK</td>
  <td>The miniport driver receives standard SRBs.</td>
</tr>
<tr>
  <td>SRB_TYPE_STORAGE_REQUEST_BLOCK</td>
  <td>The miniport driver receives extended SRBs.</td>
</tr>
</tbody>
</table>

<h3><code>AddressType</code></h3>

<p>Address type used between Storport and the miniport driver. Available starting in Windows 8. This can be set to the following value:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STORAGE_ADDRESS_TYPE_BTL8</td>
  <td>Bus, Target, and LUN (BTL) 8-bit addressing.</td>
</tr>
</tbody>
</table>

<h3><code>ReservedUchars</code></h3>

<p>Reserved for system use (pre-Windows 8).</p>

<h3><code>SlotNumber</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>BusInterruptLevel2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>BusInterruptVector2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>InterruptMode2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>DmaChannel2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>DmaPort2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>DmaWidth2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>DmaSpeed2</code></h3>

<p>Reserved for use by Storport. Miniport drivers must not modify this member.</p>

<h3><code>DeviceExtensionSize</code></h3>

<p>Size, in bytes, required by the miniport driver for its per-adapter device extension. A miniport driver uses its device extension as storage for driver-determined HBA information. The operating system-specific port driver initializes each device extension one time, when it first allocates the extension, and fills it with zeros. It passes a pointer to the HBA-specific device extension in every call to a miniport driver. The given size does not include any miniport driver-requested per-logical-unit storage. The size of per-logical-unit storage is specified via the <strong>SpecificLuExtensionSize</strong> field, described later in this topic.</p>

<p>Storport does not follow SCSIPort's model (which re-initializes the device extension whenever the adapter is stopped and thus subsequent calls to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)"><em>HwScsiFindAdapter</em></a> receive a zeroed-out device extension). Rather, Storport resets the device extension to zero only when it is first allocated, so only the first call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><em>HwStorFindAdapter</em></a> for a given adapter receives a zeroed-out device extension. Subsequent calls to <em>HwStorFindAdapter</em> and other miniport functions receive the device extension as last modified by the miniport driver. This allows the miniport driver to maintain knowledge about the state of the adapter between Plug and Play (PnP) stops and restarts, possibly enabling the miniport driver to optimize its initialization procedure.</p>

<h3><code>SpecificLuExtensionSize</code></h3>

<p>Size in bytes required by the miniport driver for its per-logical-unit-storage, if any, to handle data transfers larger than 64K. Storport initializes this member to the value in the same member of the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure sent in the <strong><a href="storportinitialize" title="STORPORT_API ULONG StorPortInitialize(&#10;  [in]           PVOID                   Argument1,&#10;  [in]           PVOID                   Argument2,&#10;  [in]           _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in, optional] PVOID                   HwContext&#10;);">StorPortInitialize</a></strong> routine.</p>

<p>Set this member to zero if the miniport driver does not maintain per-LU information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="storportgetuncachedextension" title="STORPORT_API PVOID StorPortGetUncachedExtension(&#10;  PVOID                           HwDeviceExtension,&#10;  PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  ULONG                           NumberOfBytes&#10;);">StorPortGetUncachedExtension</a></strong>.</p>

<h3><code>SrbExtensionSize</code></h3>

<p>Size in bytes required by the miniport driver for its per-request storage, if any, to handle data transfers larger than 64K. Storport initializes this member to the value in the same member of the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure sent in the <strong><a href="storportinitialize" title="STORPORT_API ULONG StorPortInitialize(&#10;  [in]           PVOID                   Argument1,&#10;  [in]           PVOID                   Argument2,&#10;  [in]           _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in, optional] PVOID                   HwContext&#10;);">StorPortInitialize</a></strong> routine.</p>

<p>Set this member before calling <strong><a href="storportgetuncachedextension" title="STORPORT_API PVOID StorPortGetUncachedExtension(&#10;  PVOID                           HwDeviceExtension,&#10;  PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  ULONG                           NumberOfBytes&#10;);">StorPortGetUncachedExtension</a></strong> to change the size of per-request storage based on <strong>NumberOfPhysicalBreaks</strong>. Set this member to zero if the miniport driver does not maintain per-SRB information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a></strong>.</p>

<h3><code>Dma64BitAddresses</code></h3>

<p>If the device hardware supports only 32 bit addresses, then <strong>Dma64BitAddresses</strong> must be set to 0. If the device supports 64 bit addresses, this field indicates whether the HBA is able to access addresses greater than 4 GB.</p>

<p>Storport adapters are required to support bus-width DMA. Therefore, on a 64-bit or PAE machine, Storport initializes <strong>Dma64BitAddresses</strong> to SCSI_DMA64_SYSTEM_SUPPORTED indicating that the adapter can access the full range of addresses. When miniport drivers detect this value, they must return one of the values in the following table in the same member to indicate to the port driver that the miniport driver supports 64-bit DMA. If the miniport fails to do this, it might severely degrade the performance of the adapter.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SCSI_DMA64_MINIPORT_SUPPORTED</td>
  <td>The miniport driver supports 64-bit physical addresses for I/O transfers.</td>
</tr>
<tr>
  <td>SCSI_DMA64_MINIPORT_FULL64BIT_SUPPORTED</td>
  <td>The miniport driver supports full 64-bit addressing. This indicates that I/O requests may have physical addresses &gt; 4GB. The uncached extension, SenseInfo, and Srb Extension may exist above 4GB. Allocations are restricted to 4GB boundary alignment in order to prevent them from crossing a 4GB boundary.</td>
</tr>
<tr>
  <td>SCSI_DMA64_MINIPORT_FULL64BIT_NO_BOUNDARY_REQ_SUPPORTED</td>
  <td>The miniport driver supports full 64-bit addressing. This indicates that I/O requests may have physical addresses &gt; 4GB. The uncached extension, SenseInfo, and Srb Extension may exist above 4GB. Allocations have no boundary alignment requirement.</td>
</tr>
<tr>
  <td>SCSI_DMA64_MINIPORT_64BIT_ONE_4GB_SUPPORTED</td>
  <td>The miniport driver support 64-bit addressing in a single 4GB region. This indicates that I/O requests, uncached extension, SenseInfo, and Srb Extension may have physical addresses &gt; 4GB in a single 4GB region.</td>
</tr>
</tbody>
</table>

<h3><code>ResetTargetSupported</code></h3>

<p>Obsolete. Do not use this member.</p>

<h3><code>MaximumNumberOfLogicalUnits</code></h3>

<p>Maximum number of logical units per target that the HBA can control. By default, the value of this member is SCSI_MAXIMUM_LOGICAL_UNITS. A miniport driver can reset this member to a lesser value if the HBA has more limited capabilities or to a greater value, indicating that the HBA has extended capabilities. The maximum value for this member is SCSI_MAXIMUM_LUNS_PER_TARGET.</p>

<h3><code>WmiDataProvider</code></h3>

<p>When <strong>TRUE</strong>, the miniport driver responds to Windows Management Instrumentation (WMI) requests. Storport initializes this member to <strong>TRUE</strong> because its miniport drivers must support WMI. Additionally, miniport drivers for fibre channel adapters are expected to support the SAN Management HBA API through WMI, and miniport drivers for host-based RAID adapters are required to support the RAID Management Interface.</p>

<p>Miniport drivers must not modify this value.</p>

<h3><code>SynchronizationModel</code></h3>

<p>The I/O synchronization model that the miniport driver supports. Possible values are as follows:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>StorSynchronizeFullDuplex</strong></td>
  <td>The miniport supports full-duplex mode.</td>
</tr>
<tr>
  <td><strong>StorSynchronizeHalfDuplex</strong></td>
  <td>The miniport supports half-duplex mode.</td>
</tr>
</tbody>
</table>

<h3><code>HwMSInterruptRoutine</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_message_signaled_interrupt_routine"><em>HwMSInterruptRoutine</em></a> routine, which is required for any miniport driver of an HBA that generates message signaled interrupts (MSIs). A miniport driver sets this member to <strong>NULL</strong> if the HBA does not generate MSIs.</p>

<h3><code>InterruptSynchronizationMode</code></h3>

<p>An <strong><a href="interrupt_synchronization_mode" title="typedef enum _INTERRUPT_SYNCHRONIZATION_MODE {&#10;  InterruptSupportNone,&#10;  InterruptSynchronizeAll,&#10;  InterruptSynchronizePerMessage&#10;} INTERRUPT_SYNCHRONIZATION_MODE;">INTERRUPT_SYNCHRONIZATION_MODE</a></strong> value that specifies the interrupt synchronization mode. The interrupt synchronization mode determines how the port driver synchronizes message signaled interrupts.</p>

<h3><code>DumpRegion</code></h3>

<p>A <strong><a href="memory_region" title="typedef struct _MEMORY_REGION {&#10;  PUCHAR           VirtualBase;&#10;  PHYSICAL_ADDRESS PhysicalBase;&#10;  ULONG            Length;&#10;} MEMORY_REGION, *PMEMORY_REGION;">MEMORY_REGION</a></strong> structure that describes a region of physically contiguous memory that miniport drivers can use during a crash dump or hibernation.</p>

<h3><code>RequestedDumpBufferSize</code></h3>

<p>Size in bytes of the uncached extension to be allocated for use during dump/hibernation.</p>

<h3><code>VirtualDevice</code></h3>

<p>When TRUE, there is no real hardware behind this device (for example, no DMA object, interrupt, I/O ports). Storport behaves differently in some circumstances when it supports a "virtual" miniport instead of a miniport that is controlling real hardware.</p>

<h3><code>DumpMode</code></h3>

<p>Indicates the use of the miniport during dump mode. It can have one of the following values.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>DUMP_MODE_CRASH</td>
  <td>The miniport in dump mode is used for a crashdump.</td>
</tr>
<tr>
  <td>DUMP_MODE_HIBER</td>
  <td>The miniport in dump mode is used for a hibernation.</td>
</tr>
<tr>
  <td>DUMP_MODE_MARK_MEMORY</td>
  <td>The miniport in dump mode is used for marking required memory.</td>
</tr>
<tr>
  <td>DUMP_MODE_RESUME</td>
  <td>The miniport in dump mode is used for a resume from hibernation.</td>
</tr>
</tbody>
</table>

<h3><code>DmaAddressWidth</code></h3>

<p>The width of an adapter's DMA address. Miniports must specify STOR_ADAPTER_DMA_ADDRESS_WIDTH_SPECIFIED in <strong>FeatureSupport</strong> when providing this value. The specified value must be (0 &lt; <strong>DmaAddressWidth</strong> &lt;= 64). This field can be used starting in Windows 10, version 2004.</p>

<h3><code>ExtendedFlags1</code></h3>

<p>Reserved for system use.</p>

<h3><code>MaxNumberOfIO</code></h3>

<p>Maximum number of outstanding I/O operations supported by the HBA. The default is set to 1000 by Storport. If the HBA does not support 1000 outstanding I/O operations, the miniport should adjust this to an appropriate smaller value.</p>

<p>If the HBA can support more than 1000 outstanding I/O operations, the miniport can increase this member to any value supported by the adapter hardware. To allow more than 1000 outstanding I/O operations, the HBA must support one of the following 64-bit DMA addressing methods, set in the <strong>Dma64BitAddresses</strong> field:</p>

<ul>
<li>SCSI_DMA64_MINIPORT_FULL64BIT_SUPPORTED</li>
<li>SCSI_DMA64_MINIPORT_FULL64BIT_NO_BOUNDARY_REQ_SUPPORTED</li>
<li>SCSI_DMA64_MINIPORT_64BIT_ONE_4GB_SUPPORTED</li>
</ul>

<h3><code>MaxIOsPerLun</code></h3>

<p>Maximum number of I/O requests supported on a LUN. Storport will set this to a default value of 255. If a LUN does not support 255 outstanding I/O requests, the miniport should adjust this member to an appropriate smaller value. This member must be &lt;= <strong>MaxNumberOfIO</strong>. To support <strong>MaxIOsPerLun</strong> &gt; 255, the <strong>SrbType</strong> field must be set to <strong>SRB_TYPE_STORAGE_REQUEST_BLOCK</strong>. Available starting in Windows 8.</p>

<h3><code>InitialLunQueueDepth</code></h3>

<p>The initial LUN I/O queue depth. Storport set this to a default value of 20 for physical miniports and to 250 for virtual miniports. This member adjusts the initial queue depth for all LUNs on the adapter. The queue depth for an individual LUN is set by calling <strong><a href="storportsetdevicequeuedepth" title="STORPORT_API BOOLEAN StorPortSetDeviceQueueDepth(&#10;  [in] PVOID HwDeviceExtension,&#10;  [in] UCHAR PathId,&#10;  [in] UCHAR TargetId,&#10;  [in] UCHAR Lun,&#10;  [in] ULONG Depth&#10;);">StorPortSetDeviceQueueDepth</a></strong>. This member is typically set to the same value as <strong>MaxIOsPerLun</strong>. Available starting in Windows 8.</p>

<h3><code>BusResetHoldTime</code></h3>

<p>The amount of time, in microseconds, to pause the adapter after a reset is detected. Set this value to 0 if no wait time is needed after a bus reset. Available starting in Windows 8.</p>

<h3><code>FeatureSupport</code></h3>

<p>Storport features requested for the adapter. Available starting in Windows 8. A miniport driver can set this member to be a bitwise mask of any of the following values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STOR_ADAPTER_FEATURE_DEVICE_TELEMETRY 0x00000001</td>
  <td>The miniport driver supports storage device telemetry.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_FEATURE_STOP_UNIT_DURING_POWER_DOWN 0x00000002</td>
  <td>The miniport requests to receive the STOP_UNIT command during system shutdown.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_UNCACHED_EXTENSION_NUMA_NODE_PREFERRED 0x00000004</td>
  <td>The miniport driver wants UncachedExtension to be allocated from adapter NUMA node.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_DMA_V3_PREFERRED 0x00000008</td>
  <td>The miniport driver prefers to use DMA V3 kernel API for the adapter.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_FEATURE_ABORT_COMMAND 0x00000010</td>
  <td>The miniport driver supports the ability to abort an outstanding command via SRB_FUNCTION_ABORT_COMMAND.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_FEATURE_RICH_TEMPERATURE_THRESHOLD 0x00000020</td>
  <td>The adapter supports richer temperature threshold information than defined in SCSI SPC4 spec.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_DMA_ADDRESS_WIDTH_SPECIFIED 0x00000040</td>
  <td>The miniport driver specified the DMA address width in <strong>DmaAddressWidth</strong> for the adapter. This value was added in Windows 10, version 2004.</td>
</tr>
<tr>
  <td>STOR_ADAPTER_FEATURE_UNIQUE_QUEUEING_TAG 0x00000080</td>
  <td>The miniport driver supports unique queueing tags for I/O operations. This value was added in Windows 11, version 24H2.</td>
</tr>
</tbody>
</table>

<h2>Remarks</h2>

<p>The Storport driver allocates and initializes this structure, supplies as much HBA-specific configuration information as possible, and passes the structure to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><em>HwStorFindAdapter</em></a> routine. Storport does not support non-PnP devices, so <em>HwStorFindAdapter</em> does not search for the adapter. Its principal function is to initialize <strong>PORT_CONFIGURATION_INFORMATION</strong>.</p>

<h2>See also</h2>

<p><strong><a href="access_range" title="typedef struct _ACCESS_RANGE {&#10;  SCSI_PHYSICAL_ADDRESS RangeStart;&#10;  ULONG                 RangeLength;&#10;  BOOLEAN               RangeInMemory;&#10;} ACCESS_RANGE, *PACCESS_RANGE;">ACCESS_RANGE</a></strong></p>

<p><strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_message_signaled_interrupt_routine"><em>HwMSInterruptRoutine</em></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><em>HwStorFindAdapter</em></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_interrupt"><em>HwStorInterrupt</em></a></p>

<p><strong><a href="interrupt_synchronization_mode" title="typedef enum _INTERRUPT_SYNCHRONIZATION_MODE {&#10;  InterruptSupportNone,&#10;  InterruptSynchronizeAll,&#10;  InterruptSynchronizePerMessage&#10;} INTERRUPT_SYNCHRONIZATION_MODE;">INTERRUPT_SYNCHRONIZATION_MODE</a></strong></p>

<p><strong><a href="memory_region" title="typedef struct _MEMORY_REGION {&#10;  PUCHAR           VirtualBase;&#10;  PHYSICAL_ADDRESS PhysicalBase;&#10;  ULONG            Length;&#10;} MEMORY_REGION, *PMEMORY_REGION;">MEMORY_REGION</a></strong></p>

<p><strong><a href="storportgetuncachedextension" title="STORPORT_API PVOID StorPortGetUncachedExtension(&#10;  PVOID                           HwDeviceExtension,&#10;  PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  ULONG                           NumberOfBytes&#10;);">StorPortGetUncachedExtension</a></strong></p>

<p><strong><a href="storportinitialize" title="STORPORT_API ULONG StorPortInitialize(&#10;  [in]           PVOID                   Argument1,&#10;  [in]           PVOID                   Argument2,&#10;  [in]           _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in, optional] PVOID                   HwContext&#10;);">StorPortInitialize</a></strong></p>

<p><strong><a href="storportsetdevicequeuedepth" title="STORPORT_API BOOLEAN StorPortSetDeviceQueueDepth(&#10;  [in] PVOID HwDeviceExtension,&#10;  [in] UCHAR PathId,&#10;  [in] UCHAR TargetId,&#10;  [in] UCHAR Lun,&#10;  [in] ULONG Depth&#10;);">StorPortSetDeviceQueueDepth</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_port_configuration_information">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_port_configuration_information.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-strmini-_port_configuration_information)</h1>
</div>
<div class="ntdoc-description">
<h1>_PORT_CONFIGURATION_INFORMATION structure (strmini.h)</h1>

<h2>Description</h2>

<p>PORT_CONFIGURATION_INFORMATION describes the hardware settings of a streaming minidriver's device. The class driver fills in most members with information provided by the operating system.</p>

<h2>Members</h2>

<h3><code>SizeOfThisPacket</code></h3>

<p>The size of this structure, in bytes. The class driver fills in this member.</p>

<h3><code>HwDeviceExtension</code></h3>

<p>Pointer to the minidriver's device extension. The minidriver may use this buffer to record private information global to the minidriver. The minidriver sets the size of this buffer in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> structure it passes when it registers itself via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nf-strmini-streamclassregisteradapter">StreamClassRegisterMinidriver</a>. The class driver also passes pointers to this buffer in the <strong>HwDeviceExtension</strong> member of the <a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">HW_STREAM_OBJECT</a>, <a href="hw_stream_request_block" title="typedef struct _HW_STREAM_REQUEST_BLOCK {&#10;  ULONG                           SizeOfThisPacket;&#10;  SRB_COMMAND                     Command;&#10;  NTSTATUS                        Status;&#10;  PHW_STREAM_OBJECT               StreamObject;&#10;  PVOID                           HwDeviceExtension;&#10;  PVOID                           SRBExtension;&#10;  union {&#10;    PKSSTREAM_HEADER                       DataBufferArray;&#10;    PHW_STREAM_DESCRIPTOR                  StreamBuffer;&#10;    KSSTATE                                StreamState;&#10;    PSTREAM_TIME_REFERENCE                 TimeReference;&#10;    PSTREAM_PROPERTY_DESCRIPTOR            PropertyInfo;&#10;    PKSDATAFORMAT                          OpenFormat;&#10;    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;&#10;    HANDLE                                 MasterClockHandle;&#10;    DEVICE_POWER_STATE                     DeviceState;&#10;    PSTREAM_DATA_INTERSECT_INFO            IntersectInfo;&#10;    PVOID                                  MethodInfo;&#10;    LONG                                   FilterTypeIndex;&#10;...">HW_STREAM_REQUEST_BLOCK</a>, and <a href="hw_time_context" title="typedef struct _HW_TIME_CONTEXT {&#10;  struct _HW_DEVICE_EXTENSION *HwDeviceExtension;&#10;  struct _HW_STREAM_OBJECT    *HwStreamObject;&#10;  TIME_FUNCTION               Function;&#10;  ULONGLONG                   Time;&#10;  ULONGLONG                   SystemTime;&#10;} HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;">HW_TIME_CONTEXT</a> structures it passes to the minidriver.</p>

<h3><code>ClassDeviceObject</code></h3>

<p>Points to the class-driver-provided functional device object (FDO) for the driver's device.</p>

<h3><code>PhysicalDeviceObject</code></h3>

<p>Points to the device object for the driver at the top of the driver stack when the class driver attaches to the driver stack. Drivers use this member when calling <a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a> to communicate with the driver stack. The <strong>RealPhysicalDeviceObject</strong> member points to the actual PDO for the driver's device.</p>

<h3><code>SystemIoBusNumber</code></h3>

<p>The class driver fills in this member with the system bus ID number of the device. Bus 0 is the primary system bus.</p>

<h3><code>AdapterInterfaceType</code></h3>

<p>Specifies the type of system bus the device is connected to. Possible values include <strong>Isa</strong>, <strong>Eisa</strong>, <strong>MicroChannel</strong>, <strong>PCIBus</strong>, and <strong>PCMCIABus</strong>.</p>

<h3><code>BusInterruptLevel</code></h3>

<p>The class driver fills in this member with the IRQL for interrupts on this bus.</p>

<h3><code>BusInterruptVector</code></h3>

<p>The class driver fills in this member with the interrupt vector used by the device.</p>

<h3><code>InterruptMode</code></h3>

<p>The class driver fills in this member with the interrupt mode, either Latched or LevelSensitive.</p>

<h3><code>DmaChannel</code></h3>

<p>If the device connects to the ISA bus, the class driver fills in this member with the DMA channel of the device.</p>

<h3><code>NumberOfAccessRanges</code></h3>

<p>The number of entries in the <strong>AccessRanges</strong> array.</p>

<h3><code>AccessRanges</code></h3>

<p>The number of entries in the <strong>AccessRanges</strong> array.</p>

<h3><code>StreamDescriptorSize</code></h3>

<p>The minidriver fills in this member with the size of its <a href="hw_stream_descriptor" title="typedef struct _HW_STREAM_DESCRIPTOR {&#10;  HW_STREAM_HEADER      StreamHeader;&#10;  HW_STREAM_INFORMATION StreamInfo;&#10;} HW_STREAM_DESCRIPTOR, *PHW_STREAM_DESCRIPTOR;">HW_STREAM_DESCRIPTOR</a> structure.</p>

<h3><code>Irp</code></h3>

<p>Pointer to the PnP device start <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that triggered this SRB_INITIALIZE_DEVICE request.</p>

<h3><code>InterruptObject</code></h3>

<p>If the device uses interrupts, the class driver fills in this member with a pointer to the associated Interrupt object.</p>

<h3><code>DmaAdapterObject</code></h3>

<p>If the device uses DMA, the class driver fills in this member with a pointer to the associated DmaAdapter object.</p>

<h3><code>RealPhysicalDeviceObject</code></h3>

<p>Pointer to the PDO for the driver's device.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for system use. Do not use.</p>

<h2>Remarks</h2>

<p>Most of the members of PORT_CONFIGURATION_INFORMATION provide information to the minidriver about its use of hardware resources, such as its interrupt vector and the IRQL for its interrupts.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_port_configuration_information">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/strmini/ns-strmini-_port_configuration_information.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
