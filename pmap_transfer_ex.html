<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PMAP_TRANSFER_EX - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PMAP_TRANSFER_EX - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PMAP_TRANSFER_EX - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PMAP_TRANSFER_EX PmapTransferEx;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PmapTransferEx(
  [in]            PDMA_ADAPTER DmaAdapter,
  [in]            <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a> Mdl,
  [in]            PVOID MapRegisterBase,
  [in]            <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Offset,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DeviceOffset,
  [in, out]       PULONG Length,
  [in]            BOOLEAN WriteToDevice,
  [out, optional] <a href="scatter_gather_list" title="typedef struct _SCATTER_GATHER_LIST {&#10;  ULONG                  NumberOfElements;&#10;  ULONG_PTR              Reserved;&#10;  SCATTER_GATHER_ELEMENT Elements[];&#10;} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;">PSCATTER_GATHER_LIST</a> ScatterGatherBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ScatterGatherBufferLength,
  [in, optional]  PDMA_COMPLETION_ROUTINE DmaCompletionRoutine,
  [in, optional]  PVOID CompletionContext
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pmap_transfer_ex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pmap_transfer_ex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wdm-pmap_transfer_ex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>PMAP_TRANSFER_EX callback function</h1>
<h2>Description</h2>
<p>The <strong>MapTransferEx</strong> routine sets up map registers to map the physical addresses in a scatter/gather list to the logical addresses that are required to do a DMA transfer.</p>
<h2>Parameters</h2>
<h3><code>DmaAdapter</code> [in]</h3>
<p>A pointer to a <a href="padapter_object" title="typedef struct _DMA_ADAPTER {&#10;  USHORT          Version;&#10;  USHORT          Size;&#10;  PDMA_OPERATIONS DmaOperations;&#10;} *PADAPTER_OBJECT, DMA_ADAPTER, *PDMA_ADAPTER;">DMA_ADAPTER</a> structure. This structure is the adapter object that represents the driver's bus-master DMA device or system DMA channel. The caller obtained this pointer from a previous call to the <a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a> routine.</p>
<h3><code>Mdl</code> [in]</h3>
<p>A pointer to an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain that describes the physical page layout for a collection of locked-down buffers in virtual memory. The scatter/gather list for the DMA transfer will use the region of this memory that is specified by the <em>Offset</em> and <em>Length</em> parameters. For more information about <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chains, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-mdls">Using MDLs</a>.</p>
<h3><code>MapRegisterBase</code> [in]</h3>
<p>A handle to the map registers that are allocated for the adapter object. The caller previously obtained this handle from the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pallocate_adapter_channel_ex">AllocateAdapterChannelEx</a> routine.</p>
<h3><code>Offset</code> [in]</h3>
<p>A byte offset from the start of the memory that is described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain. This offset specifies the start of the I/O data buffer that is used for the DMA transfer. If a scatter/gather list is supplied to the caller, this offset determines the starting address of the first buffer fragment in the list. If the MDLs in the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain describe a total of N bytes of memory, valid values of <em>Offset</em> are in the range 0 to N–1. For more information, see Remarks.</p>
<h3><code>DeviceOffset</code> [in]</h3>
<p>The byte offset of the target device's data register or FIFO from the device's base address. This parameter applies to devices that have multiple FIFOs that can be accessed by a system DMA controller. This parameter is used only for system DMA transfers. For bus-master transfers, set this parameter to zero.</p>
<h3><code>Length</code> [in, out]</h3>
<p>A pointer to a variable that contains the length, in bytes, of the I/O data buffer that is used for the DMA transfer. On entry, this variable contains the length requested by the calling driver. Before returning, the routine writes the actual length of the mapped buffer to this variable. The value of <strong>Length* on return from **MapTransferEx</strong> indicates how many bytes were mapped. If the number of map registers and the scatter/gather buffer size are sufficient to map the entire length requested by the caller, the input and output values of **Length* are identical. If the MDLs in the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain describe a total of N bytes of memory, valid values of <em>*Length</em> are in the range 0 to N–<em>Offset</em>.</p>
<h3><code>WriteToDevice</code> [in]</h3>
<p>The direction of the DMA transfer. Set this parameter to <strong>TRUE</strong> for a write operation, which transfers data to the device from memory. Set this parameter to <strong>FALSE</strong> for a read operation, which transfers data from the device to memory.</p>
<h3><code>ScatterGatherBuffer</code> [out, optional]</h3>
<p>A pointer to a caller-allocated buffer into which the routine writes the scatter/gather list for the DMA transfer. This list begins with a <a href="scatter_gather_list" title="typedef struct _SCATTER_GATHER_LIST {&#10;  ULONG                  NumberOfElements;&#10;  ULONG_PTR              Reserved;&#10;  SCATTER_GATHER_ELEMENT Elements[];&#10;} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;">SCATTER_GATHER_LIST</a> structure, which is immediately followed by a <strong>SCATTER_GATHER_ELEMENT</strong> array. For a driver that uses a bus-master DMA device, <em>ScatterGatherBuffer</em> is a required parameter. For a driver that uses a system DMA controller, the <em>ScatterGatherBuffer</em> parameter is optional and can be <strong>NULL</strong>. For more information, see Remarks.</p>
<h3><code>ScatterGatherBufferLength</code> [in]</h3>
<p>The size, in bytes, of the buffer that the <em>ScatterGatherBuffer</em> parameter points to. The allocated buffer size must be large enough to contain the scatter/gather list, plus internal data that the operating system stores in this buffer. To determine the required buffer size, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pget_dma_transfer_info">GetDmaTransferInfo</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcalculate_scatter_gather_list_size">CalculateScatterGatherList</a> routine. If <em>ScatterGatherBuffer</em> is <strong>NULL</strong>, set <em>ScatterGatherBufferLength</em> to zero.</p>
<h3><code>DmaCompletionRoutine</code> [in, optional]</h3>
<p>A pointer to a caller-supplied <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-dma_completion_routine">DmaCompletionRoutine</a> routine to be called when the DMA transfer completes. This routine is called if the target device uses a system DMA controller that generates a DMA-completion interrupt. The <em>DmaCompletionRoutine</em> routine is called at DISPATCH_LEVEL after the DMA transfer completes. For a system DMA adapter, this parameter is optional and can be <strong>NULL</strong>. For a bus-master adapter, set this parameter to <strong>NULL</strong>.</p>
<h3><code>CompletionContext</code> [in, optional]</h3>
<p>The driver-determined context for the <em>DmaCompletionRoutine</em> routine. This context is supplied as the <em>CompletionContext</em> parameter to the <em>DmaCompletionRoutine</em> routine. If the <em>DmaCompletionRoutine</em> parameter is <strong>NULL</strong>, set <em>CompletionContext</em> to <strong>NULL</strong>.</p>
<h2>Return value</h2>
<p><strong>MapTransferEx</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the call is successful. Possible error return values include the following status codes.</p>
<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>STATUS_INVALID_PARAMETERS</strong></td>
  <td>The routine failed due to invalid parameter values passed by the caller.</td>
</tr>
<tr>
  <td><strong>STATUS_BUFFER_TOO_SMALL</strong></td>
  <td>The caller-supplied buffer in <em>ScatterGatherBuffer</em> is too small to contain the scatter/gather list.</td>
</tr>
<tr>
  <td><strong>STATUS_INSUFFICIENT_RESOURCES</strong></td>
  <td>The routine failed to allocate resources required for the DMA transfer.</td>
</tr>
<tr>
  <td><strong>STATUS_CANCELLED</strong></td>
  <td>This transfer was canceled.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p><strong>MapTransferEx</strong> <em>is not a system routine that can be called directly by name. This routine can be called only by pointer from the address returned in a</em> <a href="dma_operations" title="typedef struct _DMA_OPERATIONS {&#10;  ULONG                                   Size;&#10;  PPUT_DMA_ADAPTER                        PutDmaAdapter;&#10;  PALLOCATE_COMMON_BUFFER                 AllocateCommonBuffer;&#10;  PFREE_COMMON_BUFFER                     FreeCommonBuffer;&#10;  PALLOCATE_ADAPTER_CHANNEL               AllocateAdapterChannel;&#10;  PFLUSH_ADAPTER_BUFFERS                  FlushAdapterBuffers;&#10;  PFREE_ADAPTER_CHANNEL                   FreeAdapterChannel;&#10;  PFREE_MAP_REGISTERS                     FreeMapRegisters;&#10;  PMAP_TRANSFER                           MapTransfer;&#10;  PGET_DMA_ALIGNMENT                      GetDmaAlignment;&#10;  PREAD_DMA_COUNTER                       ReadDmaCounter;&#10;  PGET_SCATTER_GATHER_LIST                GetScatterGatherList;&#10;  PPUT_SCATTER_GATHER_LIST                PutScatterGatherList;&#10;  PCALCULATE_SCATTER_GATHER_LIST_SIZE     CalculateScatterGatherList;&#10;  PBUILD_SCATTER_GATHER_LIST              BuildScatterGatherList;&#10;  PBUILD_MDL_FROM_SCATTER_GATHER_LIST     BuildMdlFromScatterGatherList;&#10;  PGET_DMA_ADAPTER_INFO                   GetDmaAdapterInfo;&#10;  PGET_DMA_TRANSFER_INFO                  GetDmaTransferInfo;&#10;  PINITIALIZE_DMA_TRANSFER_CONTEXT        InitializeDmaTransferContext;&#10;...">DMA_OPERATIONS</a> <em>structure.</em> Drivers obtain the address of this routine by calling <a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a> with the <strong>Version</strong> member of the <em>DeviceDescription</em> parameter set to DEVICE_DESCRIPTION_VERSION3. If <strong><a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a></strong> returns <strong>NULL</strong>, the routine is not available on your platform.</p>
<p>For a transfer that uses a system DMA controller, the caller can, as an option, supply a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-dma_completion_routine">DmaCompletionRoutine</a> callback routine that is called when the transfer finishes. The operating system schedules this callback in response to the DMA completion interrupt from the system DMA controller.</p>
<p>The number of map registers that can be set up by <strong>MapTransferEx</strong> cannot exceed the maximum that the driver obtained from <a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a>.</p>
<p>The <em>Mdl</em>, <em>Offset</em>, and <em>Length</em> parameters describe the I/O data buffer for the requested DMA transfer. The number of allocated map registers might not be sufficient to map all of the memory in this buffer, or the scatter/gather buffer pointed to by <em>ScatterGatherBuffer</em> might not be large enough to describe the entire buffer. <strong>MapTransferEx</strong> writes an output value to <em>*Length</em> to tell the driver how much of the buffer memory for the requested DMA transfer was mapped by the routine. The routine writes a scatter/gather list to the buffer pointed to by <em>ScatterGatherBuffer</em>. This list describes the buffer fragments that were successfully mapped by the routine.</p>
<p>If a call to <strong>MapTransferEx</strong> is successful, <strong>MapTransferEx</strong> writes the <em>*Length</em> output value before it returns. If the caller specifies a <em>DmaCompletionRoutine</em>, the updated <em>*Length</em> output value is always written before the <em>DmaCompletionRoutine</em> runs. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-the-maptransferex-routine">Multiple calls to MapTransferEx</a>.</p>
<p>The <em>Offset</em> parameter specifies the starting offset in the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain that describes the memory in the I/O data buffer. For example, assume that the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain contains two MDLs, <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₁ and <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₂, and that <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₁ describes N₁ bytes of memory, and <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₂ describes N₂ bytes. If <em>Offset</em> = N, where N₁ &lt; N &lt; N₁ + N₂, the buffer contains none of the memory described by <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₁, and starts at an offset of N - N₁ bytes in the memory described by <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>₂.</p>
<p>If the transfer uses a system DMA controller, the caller can set <em>ScatterGatherBuffer</em> = NULL, in which case <strong>MapTransferEx</strong> uses an internally allocated, default buffer to hold the scatter/gather list. The default buffer is guaranteed to be large enough to contain a scatter/gather list of at least one element. If the default buffer is used for a scatter/gather transfer of many elements, many calls to <strong>MapTransferEx</strong> might be required complete the transfer. If the DMA controller hardware supports scatter/gather transfers, the use of the default buffer might degrade performance.</p>
<p>If <em>ScatterGatherBuffer</em> is non-NULL and <em>ScatterGatherBufferSize</em> specifies a size that is too small to contain a scatter/gather list of at least one element, <strong>MapTransferEx</strong> fails and returns STATUS_INVALID_PARAMETER.</p>
<p><strong>MapTransferEx</strong> is an extended version of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pmap_transfer">MapTransfer</a> routine. The extended version has these advantages:</p>
<ul>
<li><strong>MapTransferEx</strong> can process all of the buffer fragments in an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain in one call, but <strong>MapTransfer</strong> can process only one physically contiguous buffer fragment per call.</li>
<li><strong>MapTransferEx</strong> can generate an entire scatter/gather list in one call, but <strong>MapTransfer</strong> can generate only one scatter/gather list element per call.</li>
<li><strong>MapTransferEx</strong> can map all of the buffer fragments in a scatter/gather list in one call, but <strong>MapTransfer</strong> can map only one physically contiguous buffer fragment per call.</li>
<li><strong>MapTransferEx</strong> requires only the starting offset for the entire scatter/gather list, but <strong>MapTransfer</strong> requires a starting virtual address for each physically contiguous buffer fragment.</li>
<li>A <strong>MapTransferEx</strong> call can map a buffer that extends through one or more MDLs, but a <strong>MapTransfer</strong> call can map only one physically contiguous buffer fragment in the memory that is described by an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</li>
<li>For a system DMA transfer, <strong>MapTransferEx</strong> enables the caller to supply a <em>DmaCompletionRoutine</em> callback routine to receive notification after the transfer completes, but <strong>MapTransfer</strong> does not provide a way to notify the caller when a DMA transfer completes.</li>
</ul>
<p>Each successful call to <strong>MapTransferEx</strong> must be followed by a corresponding call to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pflush_adapter_buffers_ex">FlushAdapterBuffersEx</a> routine. The <strong>FlushAdapterBuffersEx</strong> call that follows a <strong>MapTransferEx</strong> call must occur before the next <strong>MapTransferEx</strong> call occurs. The <strong>FlushAdapterBuffersEx</strong> call is required even if a call to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcancel_mapped_transfer">CancelMappedTransfer</a> routine succeeds in canceling the mapped transfer requested by the preceding <strong>MapTransferEx</strong> call.</p>
<p>For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-the-maptransferex-routine">Using the MapTransferEx Routine</a>.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pallocate_adapter_channel_ex">AllocateAdapterChannelEx</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcalculate_scatter_gather_list_size">CalculateScatterGatherList</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pcancel_mapped_transfer">CancelMappedTransfer</a></p>
<p><a href="padapter_object" title="typedef struct _DMA_ADAPTER {&#10;  USHORT          Version;&#10;  USHORT          Size;&#10;  PDMA_OPERATIONS DmaOperations;&#10;} *PADAPTER_OBJECT, DMA_ADAPTER, *PDMA_ADAPTER;">DMA_ADAPTER</a></p>
<p><a href="dma_operations" title="typedef struct _DMA_OPERATIONS {&#10;  ULONG                                   Size;&#10;  PPUT_DMA_ADAPTER                        PutDmaAdapter;&#10;  PALLOCATE_COMMON_BUFFER                 AllocateCommonBuffer;&#10;  PFREE_COMMON_BUFFER                     FreeCommonBuffer;&#10;  PALLOCATE_ADAPTER_CHANNEL               AllocateAdapterChannel;&#10;  PFLUSH_ADAPTER_BUFFERS                  FlushAdapterBuffers;&#10;  PFREE_ADAPTER_CHANNEL                   FreeAdapterChannel;&#10;  PFREE_MAP_REGISTERS                     FreeMapRegisters;&#10;  PMAP_TRANSFER                           MapTransfer;&#10;  PGET_DMA_ALIGNMENT                      GetDmaAlignment;&#10;  PREAD_DMA_COUNTER                       ReadDmaCounter;&#10;  PGET_SCATTER_GATHER_LIST                GetScatterGatherList;&#10;  PPUT_SCATTER_GATHER_LIST                PutScatterGatherList;&#10;  PCALCULATE_SCATTER_GATHER_LIST_SIZE     CalculateScatterGatherList;&#10;  PBUILD_SCATTER_GATHER_LIST              BuildScatterGatherList;&#10;  PBUILD_MDL_FROM_SCATTER_GATHER_LIST     BuildMdlFromScatterGatherList;&#10;  PGET_DMA_ADAPTER_INFO                   GetDmaAdapterInfo;&#10;  PGET_DMA_TRANSFER_INFO                  GetDmaTransferInfo;&#10;  PINITIALIZE_DMA_TRANSFER_CONTEXT        InitializeDmaTransferContext;&#10;...">DMA_OPERATIONS</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-dma_completion_routine">DmaCompletionRoutine</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pflush_adapter_buffers_ex">FlushAdapterBuffersEx</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pget_dma_transfer_info">GetDmaTransferInfo</a></p>
<p><a href="iogetdmaadapter" title="_DMA_ADAPTER * IoGetDmaAdapter(&#10;  [in, optional] PDEVICE_OBJECT      PhysicalDeviceObject,&#10;  [in]           _DEVICE_DESCRIPTION *DeviceDescription,&#10;  [out]          PULONG              NumberOfMapRegisters&#10;);">IoGetDmaAdapter</a></p>
<p><a href="scatter_gather_list" title="typedef struct _SCATTER_GATHER_LIST {&#10;  ULONG                  NumberOfElements;&#10;  ULONG_PTR              Reserved;&#10;  SCATTER_GATHER_ELEMENT Elements[];&#10;} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;">SCATTER_GATHER_LIST</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-pmap_transfer_ex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nc-wdm-pmap_transfer_ex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
