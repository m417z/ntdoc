<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="SMARTCARD_EXTENSION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>SMARTCARD_EXTENSION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            SMARTCARD_EXTENSION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// smclib.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SMARTCARD_EXTENSION {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     Version;
  <a href="vendor_attr" title="typedef struct _VENDOR_ATTR {&#10;  struct {&#10;    USHORT Length;&#10;    UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];&#10;  } VendorName;&#10;  struct {&#10;    USHORT Length;&#10;    UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];&#10;  } IfdType;&#10;  ULONG  UnitNo;&#10;  struct {&#10;    USHORT BuildNumber;&#10;    UCHAR  VersionMinor;&#10;    UCHAR  VersionMajor;&#10;  } IfdVersion;&#10;  struct {&#10;    USHORT Length;&#10;    UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];&#10;  } IfdSerialNo;&#10;  ULONG  Reserved[25];&#10;...">VENDOR_ATTR</a>               VendorAttr;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>(                 *ReaderFunction[16];
  <a href="scard_card_capabilities" title="typedef struct _SCARD_CARD_CAPABILITIES {&#10;  BOOLEAN                InversConvention;&#10;  ULONG                  etu;&#10;  struct {&#10;    UCHAR Buffer[64];&#10;    UCHAR Length;&#10;  } ATR;&#10;  struct {&#10;    UCHAR Buffer[16];&#10;    UCHAR Length;&#10;  } HistoricalChars;&#10;  PCLOCK_RATE_CONVERSION ClockRateConversion;&#10;  PBIT_RATE_ADJUSTMENT   BitRateAdjustment;&#10;  UCHAR                  Fl;&#10;  UCHAR                  Dl;&#10;  UCHAR                  II;&#10;  UCHAR                  P;&#10;  UCHAR                  N;&#10;  ULONG                  GT;&#10;  struct {&#10;...">SCARD_CARD_CAPABILITIES</a>   CardCapabilities;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     LastError;
  struct {
    PULONG Information;
    PUCHAR RequestBuffer;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  RequestBufferLength;
    PUCHAR ReplyBuffer;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  ReplyBufferLength;
  } IoRequest;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     MajorIoControlCode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     MinorIoControlCode;
  <a href="os_dep_data" title="typedef struct _OS_DEP_DATA {&#10;  PDEVICE_OBJECT DeviceObject;&#10;  PIRP           CurrentIrp;&#10;  PIRP           NotificationIrp;&#10;  KMUTANT        Mutex;&#10;  KSPIN_LOCK     SpinLock;&#10;  struct {&#10;    BOOLEAN    Removed;&#10;    LONG       RefCount;&#10;    KEVENT     RemoveEvent;&#10;    LIST_ENTRY TagList;&#10;  } RemoveLock;&#10;  PDEVICE_OBJECT DebugDeviceObject;&#10;} OS_DEP_DATA, *POS_DEP_DATA;">POS_DEP_DATA</a>              OsData;
  <a href="scard_reader_capabilities" title="typedef struct _SCARD_READER_CAPABILITIES {&#10;  ULONG                    SupportedProtocols;&#10;  ULONG                    Reserved;&#10;  ULONG                    ReaderType;&#10;  ULONG                    MechProperties;&#10;  ULONG                    CurrentState;&#10;  ULONG                    Channel;&#10;  struct {&#10;    ULONG Default;&#10;    ULONG Max;&#10;  } CLKFrequency;&#10;  struct {&#10;    ULONG Default;&#10;    ULONG Max;&#10;  } DataRate;&#10;  ULONG                    MaxIFSD;&#10;  ULONG                    PowerMgmtSupport;&#10;  ULONG                    CardConfiscated;&#10;  struct {&#10;    PULONG List;&#10;...">SCARD_READER_CAPABILITIES</a> ReaderCapabilities;
  PREADER_EXTENSION         ReaderExtension;
  <a href="smartcard_reply" title="typedef struct _SMARTCARD_REPLY {&#10;  PUCHAR Buffer;&#10;  ULONG  BufferSize;&#10;  ULONG  BufferLength;&#10;} SMARTCARD_REPLY, *PSMARTCARD_REPLY;">SMARTCARD_REPLY</a>           SmartcardReply;
  <a href="smartcard_request" title="typedef struct _SMARTCARD_REQUEST {&#10;  PUCHAR Buffer;&#10;  ULONG  BufferSize;&#10;  ULONG  BufferLength;&#10;} SMARTCARD_REQUEST, *PSMARTCARD_REQUEST;">SMARTCARD_REQUEST</a>         SmartcardRequest;
  <a href="t0_data" title="typedef struct _T0_DATA {&#10;  ULONG Lc;&#10;  ULONG Le;&#10;} T0_DATA, *PT0_DATA;">T0_DATA</a>                   T0;
  <a href="t1_data" title="typedef struct _T1_DATA {&#10;  UCHAR   IFSC;&#10;  UCHAR   IFSD;&#10;  ULONG   BytesReceived;&#10;  ULONG   BytesSent;&#10;  ULONG   BytesToSend;&#10;  UCHAR   LastError;&#10;  BOOLEAN MoreData;&#10;  UCHAR   NAD;&#10;  ULONG   OriginalState;&#10;  UCHAR   Resend;&#10;  UCHAR   Resynch;&#10;  UCHAR   RSN;&#10;  UCHAR   SSN;&#10;  ULONG   State;&#10;  UCHAR   Wtx;&#10;  PUCHAR  ReplyData;&#10;  BOOLEAN WaitForReply;&#10;  UCHAR   InfBytesSent;&#10;  UCHAR   Reserved[10 - sizeof(PUCHAR)- sizeof(BOOLEAN)- sizeof(UCHAR)];&#10;...">T1_DATA</a>                   T1;
  PPERF_INFO                PerfInfo;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     Reserved[25 - sizeof(PPERF_INFO)];
} *PSMARTCARD_EXTENSION, SMARTCARD_EXTENSION;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/smclib/ns-smclib-_smartcard_extension">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/smartcard_extension.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-smclib-_smartcard_extension)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_smartcard_extension-structure">_SMARTCARD_EXTENSION structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>SMARTCARD_EXTENSION</strong> structure is used by both the smart card reader driver and the smart card driver library to access all other smart card data structures.</p>

<h2 id="members">Members</h2>

<h3 id="version"><code>Version</code></h3>

<p>Indicates the version of this structure.</p>

<h3 id="vendorattr"><code>VendorAttr</code></h3>

<p>Contains information that identifies the reader driver, such as the vendor name, unit number, and serial number.</p>

<h3 id="readerfunction"><code>ReaderFunction</code></h3>

<p>The line in the syntax block should read <code><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> (*ReaderFunction[16])(PSMARTCARD_EXTENSION);</code></p>

<p>A pointer to an array of callback functions for readers. The callback functions that a vendor-supplied reader driver can implement. A reader driver makes these callback functions available for the smart card library routine, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff548939(v=vs.85)">SmartcardDeviceControl</a>, to call by storing pointers to them in the smart card device extension.</p>

<p><em>RDF_ATR_PARSE</em></p>

<p><em>RDF_CARD_EJECT</em></p>

<p><em>RDF_CARD_POWER</em></p>

<p><em>RDF_CARD_TRACKING</em></p>

<p><em>RDF_IOCTL_VENDOR</em></p>

<p><em>RDF_READER_SWALLOW</em></p>

<p><em>RDF_SET_PROTOCOL</em></p>

<p><em>RDF_TRANSMIT</em></p>

<p>For more information, see Remarks.</p>

<h3 id="cardcapabilities"><code>CardCapabilities</code></h3>

<p>Contains capabilities of the inserted smart card.</p>

<h3 id="lasterror"><code>LastError</code></h3>

<p>Not used.</p>

<h3 id="iorequest"><code>IoRequest</code></h3>

<p>A structure with the following members:</p>

<h3 id="iorequestinformation"><code>IoRequest.Information</code></h3>

<p>Contains the number of bytes returned.</p>

<h3 id="iorequestrequestbuffer"><code>IoRequest.RequestBuffer</code></h3>

<p>A pointer to the data in the user's I/O request to be sent to the card.</p>

<h3 id="iorequestrequestbufferlength"><code>IoRequest.RequestBufferLength</code></h3>

<p>Indicates the number of bytes to send to the card.</p>

<h3 id="iorequestreplybuffer"><code>IoRequest.ReplyBuffer</code></h3>

<p>A pointer to the buffer that holds the data that is returned by the I/O request.</p>

<h3 id="iorequestreplybufferlength"><code>IoRequest.ReplyBufferLength</code></h3>

<p>Indicates the number of bytes of the data that are returned by the I/O request.</p>

<h3 id="majoriocontrolcode"><code>MajorIoControlCode</code></h3>

<p>Contains the major I/O control code.</p>

<h3 id="minoriocontrolcode"><code>MinorIoControlCode</code></h3>

<p>Contains the minor I/O control code.</p>

<h3 id="osdata"><code>OsData</code></h3>

<p>Contains information that is specific to the operating system and the driver type.</p>

<h3 id="readercapabilities"><code>ReaderCapabilities</code></h3>

<p>Contains the capabilities of the keyboard reader.</p>

<h3 id="readerextension"><code>ReaderExtension</code></h3>

<p>Contains data that is specific to the smart card reader.</p>

<h3 id="smartcardreply"><code>SmartcardReply</code></h3>

<p>Contains data that comes from the reader.</p>

<h3 id="smartcardrequest"><code>SmartcardRequest</code></h3>

<p>Contains the current command and the data that is sent to the smart card.</p>

<h3 id="t0"><code>T0</code></h3>

<p>Contains the data for use with the T=0 protocol.</p>

<h3 id="t1"><code>T1</code></h3>

<p>Contains the data that is used with the T=1 protocol.</p>

<h3 id="perfinfo"><code>PerfInfo</code></h3>

<h3 id="reserved"><code>Reserved</code></h3>

<p>Reserved for system use.</p>

<h2 id="remarks">Remarks</h2>

<p>This structure is passed to all callback functions.</p>

<p>Individual callback functions are identified by a series of constant values that should be used as indexes into the <strong>ReaderFunction</strong> array.</p>

<table>
<thead>
<tr>
  <th>Index</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>RDF_ATR_PARSE</td>
  <td>Optional. The RDF_ATR_PARSE parse function parses an answer-to-reset (ATR) for the smart card driver library when the driver library is unable to recognize or parse the smart card driver library.</td>
</tr>
<tr>
  <td>RDF_CARD_EJECT</td>
  <td>Optional. RDF_CARD_EJECT callback function<br><br>The RDF_CARD_EJECT callback function ejects an inserted smart card from the reader.</td>
</tr>
<tr>
  <td>RDF_CARD_POWER</td>
  <td>The RDF_CARD_POWER callback function resets or turns off an inserted smart card.It is mandatory for smart card reader drivers to implement this callback function. <br><br>On input, the structure pointed to by <strong>SmartcardExtension</strong> should have the following member values: <br><br><strong>MajorIoControlCode</strong><br><br>Should have a value of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff548907(v=vs.85)">IOCTL_SMARTCARD_POWER</a>.<br><br><strong>IoRequest.ReplyBufferLength</strong><br><br>Should contain the length of the buffer.<br><br><strong>MinorIoControlCode</strong><br><br>Should have one of the following minor codes:<br><br>SCARD_COLD_RESET<br><br>Performs a cold reset of the smart card.<br><br>SCARD_WARM_RESET<br><br>Performs a warm reset of the smart card.<br><br>SCARD_POWER_DOWN<br><br>Turns off smart card power.<br><br>On output, the structure pointed to by *<em>SmartcardExtension</em>* should have the following values:<br><br><strong>IoRequest.ReplyBuffer</strong><br><br>Receives the ATR that is returned by the smart card. In addition, you must transfer the ATR to <em>SmartcardExtension->CardCapabilities.ATR.Buffer</em> so that the library can parse the ATR.<br><br><strong>IoRequest.Information</strong><br><br>Receives the length of the ATR.<br><br><strong>CardCapabilities.ATR.Length</strong><br><br>Contains the length of the ATR.</td>
</tr>
<tr>
  <td>RDF_CARD_TRACKING</td>
  <td>The RDF_CARD_TRACKING callback function installs an event handler to track every time a card is inserted in or removed from a card reader.It is mandatory for smart card reader drivers to implement this callback function. <br><br>Upon receiving an <a rel="noopener" target="_blank" href="ioctl_smartcard_is_present">IOCTL_SMARTCARD_IS_PRESENT</a> request, the driver library determines if the smart card is already present. If the smart card is present, the driver library completes the request with a status of <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. If there is no smart card present, the driver library calls the reader driver's smart card tracking callback function, and the reader driver starts looking for the smart card. After initiating smart card tracking, the driver library marks the request as having a status of STATUS_PENDING. <br><br>The driver library completes the request.<br><br><strong>WDM Device Drivers</strong><br><br>The corresponding WDM driver library adds a pointer to the request in <strong>SmartcardExtension->OsData->NotificationIrp</strong>. The reader driver must complete the request as soon as it detects that a smart card has been inserted or removed. The reader driver completes the request by calling <a rel="noopener" target="_blank" href="iofcompleterequest">IoCompleteRequest</a>, after which, the reader driver must set the <strong>NotificationIrp</strong> member of <strong>SmartcardExtension -> OsData</strong> back to <strong>NULL</strong> to inform the driver library that the reader driver can accept further smart card tracking requests. <br><br>Because this call can have an indefinite duration and the caller can terminate the request before it is complete, it is important to mark this <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> as cancelable.<br><br><code>MyDriverCardSupervision( SmartcardExtension,  OtherParameters) // //    This function is called whenever the card status changes //    For example, the card has been inserted or the card has been removed // {     if (SmartcardExtension-&gt;OsData-&gt;NotificationOverlappedData != NULL){&lt;br&gt;&lt;br&gt;        SmartcardCompleteCardTracking(SmartcardExtension);     }     //     // Do additional tasks     // }</code></td>
</tr>
<tr>
  <td>RDF_IOCTL_VENDOR</td>
  <td>The RDF_IOCTL_VENDOR callback function performs vendor-specific IOCTL operations.It is optional for smart card reader drivers to implement this callback function. <br><br>On input, the caller must pass the following values to the function:<br><br><strong>SmartcardExtension->MajorIoControlCode</strong><br><br>Contains a vendor-specific IOCTL code. Refer to the macro SCARD_CTL_CODE in *Winsmcrd.h* for information about how to define a vendor-specific IOCTL code. Note that the code must be between 2048 and 4095.<br><br><strong>SmartcardExtension->IoRequest.RequestBuffer</strong><br><br>A pointer to the user's input buffer.<br><br><strong>SmartcardExtension->IoRequest.RequestBufferLength</strong><br><br>The size, in bytes, of the user's input buffer.<br><br><strong>SmartcardExtension->IoRequest.ReplyBuffer</strong><br><br>A pointer to the user's output buffer.<br><br><strong>SmartcardExtension->IoRequest.ReplyBufferLength</strong><br><br>The size, in bytes, of the user's output buffer.<br><br><strong>SmartcardExtension->IoRequest.Information</strong><br><br>The value supplied by the request. Must be set to the number of bytes returned.<br><br>As with all other IOCTLs, a user-mode application dispatches a vendor-defined IOCTL to a smart card reader device by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function. When the IOCTL is vendor-defined, however, the application must first open the reader device for "overlapped" (that is, asynchronous) access. The application must also define an OVERLAPPED structure and pass it to the system in the last argument of <strong>DeviceIoControl</strong> (The OVERLAPPED structure is also described in the Windows SDK documentation.). When the operating system calls the driver's I/O control dispatch routine, it passes a DIOCPARAMETERS structure to the driver. The <strong>lpoOverlapped</strong> member of the DIOCPARAMETERS structure contains a pointer to the OVERLAPPED structure.</td>
</tr>
<tr>
  <td>RDF_READER_SWALLOW</td>
  <td>The RDF_READER_SWALLOW callback function performs a mechanical swallow, which is what happens when the smart card is fully inserted into the smart card reader.It is optional for smart card reader drivers to implement this callback function.</td>
</tr>
<tr>
  <td>RDF_SET_PROTOCOL</td>
  <td>The RDF_SET_PROTOCOL callback function selects a transmission protocol for the inserted smart card.Smart card reader drivers must implement this callback function. <br><br>On input, the caller must pass the following values to the function:<br><br><strong>SmartcardExtension->MajorIoControlCode</strong><br><br>Contains <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff548909(v=vs.85)">IOCTL_SMARTCARD_SET_PROTOCOL</a>.<br><br><strong>SmartcardExtension->MinorIoControlCode</strong><br><br>Contains a bitwise OR of one or more protocols than the caller accepts. The driver must select a protocol that the inserted smart card supports. We recommend that the T = 1 protocol is given precedence over the T = 0 protocol. <br><br></td>
  <td>Value</td>
  <td>Meaning</td>
  <td></td>
  <td>---</td>
  <td>---</td>
  <td></td>
  <td>SCARD_PROTOCOL_RAW</td>
  <td>Selects the raw protocol.</td>
  <td></td>
  <td>SCARD_PROTOCOL_T0</td>
  <td>Selects the ISO T = 0 protocol.</td>
  <td></td>
  <td>SCARD_PROTOCOL_T1</td>
  <td>Selects the ISO T = 1 protocol.</td>
  <td><br><br><strong>SmartcardExtension->IoRequest.ReplyBufferLength</strong><br><br>Contains the length of the reply buffer.<br><br><strong>SmartcardExtension->CardCapabilities.PtsData</strong><br><br>Contains the required parameters to perform the PTS request. For more information, see <a rel="noopener" target="_blank" href="pts_data">PTS_DATA</a>.<br><br>The request returns the following values:<br><br><strong>SmartcardExtension->IoRequest.ReplyBuffer</strong><br><br>Contains the selected protocol.<br><br><strong>SmartcardExtension->IoRequest.Information</strong><br><br>Set to <strong>sizeof</strong>(<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>).<br><br>The caller can supply a mask of acceptable protocols. The driver's set protocol callback routine selects one of the protocols in the mask and returns the selected protocol in <strong>SmartcardExtension->IoRequest.ReplyBuffer</strong>.</td>
</tr>
<tr>
  <td>RDF_TRANSMIT</td>
  <td>The RDF_TRANSMIT callback function performs data transmissions.Smart card reader drivers must implement this callback function. <br><br>On input, the caller must pass the following values to the function:<br><br>**SmartcardExtension->MajorIoControlCode**<br><br>Contains <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff548911(v=vs.85)">IOCTL_SMARTCARD_TRANSMIT</a>.<br><br>**SmartcardExtension->IoRequest.RequestBuffer**<br><br>A pointer to an <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure followed by data to transmit to the card.<br><br>**SmartcardExtension->IoRequest.RequestBufferLength**<br><br>The number of bytes to transmit to the card.<br><br>**SmartcardExtension->IoRequest.ReplyBufferLength**<br><br>The size, in bytes, of the reply buffer.<br><br>The request returns the following values:<br><br>**SmartcardExtension->IoRequest.ReplyBuffer**<br><br>A pointer to the buffer that receives the <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure, plus the result of the card.<br><br>**SmartcardExtension->IoRequest.Information**<br><br>Receives the actual number of bytes returned by the smart card, plus the size of the <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure. For a definition of the <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure, see <a href="ioctl_smartcard_transmit" title="// CTL_CODE(0x0031, 0x005, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_SMARTCARD_TRANSMIT 0x00310014">IOCTL_SMARTCARD_TRANSMIT</a>.<br><br>When this function is called, **SmartcardExtension->IoRequest.RequestBuffer** points to an <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure followed by the data to transmit.<br><br><code>cpp typedef <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">struct _SCARD_IO_REQUEST</a>{ <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> dwProtocol; // Protocol identifier <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbPciLength; // Protocol Control Information Length } <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a>, *<a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">PSCARD_IO_REQUEST</a>, *LPSCARD_IO_REQUEST;</code><br><br>The **dwProtocol** member must contain the protocol identifier that is returned by a call to <a href="ioctl_smartcard_set_protocol" title="// CTL_CODE(0x0031, 0x00c, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_SMARTCARD_SET_PROTOCOL 0x00310030">IOCTL_SMARTCARD_SET_PROTOCOL</a>. <br><br>The <strong>cbPciLength</strong> member contains the size, in bytes, of the <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure. The size of this structure is usually 8 bytes. <br><br>The <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure is followed by (protocol) data to transmit to the card. Depending on the protocol to use for the transmission, the library offers several support functions. For more information about these support functions, see SmartcardT0Request (WDM) and SmartcardT1Request (WDM). <br><br><em>RequestBuffer</em> and <em>ReplyBuffer</em> point to the same system buffer. If you use the library function <em>SmartcardxxRequest</em> and <em>SmartcardxxReply</em>, you will not overwrite the input buffer. If you do not use these functions, make a copy of the <em>RequestBuffer</em> before you start transmissions.<br><br>You must copy the <a href="scard_io_request" title="typedef struct _SCARD_IO_REQUEST {&#10;  DWORD dwProtocol;&#10;  DWORD cbPciLength;&#10;} SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;">SCARD_IO_REQUEST</a> structure to the <em>ReplyBuffer</em> parameter, followed by the data received from the card. Again, if you use the <em>SmartcardxxRequest</em> and <em>SmartcardxxReply</em> functions, the library will copy the structure for you.</td>
</tr>
</tbody>
</table>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/smclib/ns-smclib-_smartcard_extension">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/smclib/ns-smclib-_smartcard_extension.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
