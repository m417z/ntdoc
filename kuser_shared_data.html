<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="KUSER_SHARED_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>KUSER_SHARED_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            KUSER_SHARED_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTEXAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)

</span><span class="ntdoc-code-intro">/**
 * The KUSER_SHARED_DATA structure contains information shared with user-mode.
 *
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data
 */
</span><span class="ntdoc-code-body">typedef struct _KUSER_SHARED_DATA
{
    //
    // Current low 32-bit of tick count and tick count multiplier.
    //
    // N.B. The tick count is updated each time the clock ticks.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountLowDeprecated;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountMultiplier;

    //
    // Current 64-bit interrupt time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> InterruptTime;

    //
    // Current 64-bit system time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> SystemTime;

    //
    // Current 64-bit time zone bias.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TimeZoneBias;

    //
    // Support image magic number range for the host system.
    //
    // N.B. This is an inclusive range.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberLow;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberHigh;

    //
    // Copy of system root in unicode.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a> API for
    //      an accurate result.
    //

    WCHAR NtSystemRoot[260];

    //
    // Maximum stack trace depth if tracing enabled.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaxStackTraceDepth;

    //
    // Crypto exponent value.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CryptoExponent;

    //
    // Time zone ID.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeZoneId;

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LargePageMinimum;

    //
    // This value controls the AIT Sampling rate.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AitSamplingValue;

    //
    // This value controls switchback processing.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AppCompatFlag;

    //
    // Current Kernel Root RNG state seed version
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> RNGSeedVersion;

    //
    // This value controls assertion failure handling.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GlobalValidationRunlevel;

    volatile <a href="long" title="typedef long LONG;">LONG</a> TimeZoneBiasStamp;

    //
    // The shared collective build number undecorated with C or F.
    // GetVersionEx hides the real number
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtBuildNumber;

    //
    // Product type.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a> API for
    //      an accurate result.
    //

    <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a> NtProductType;
    BOOLEAN ProductTypeIsValid;
    BOOLEAN Reserved0[1];
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> NativeProcessorArchitecture;

    //
    // The NT Version.
    //
    // N. B. Note that each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the
    //       process is running with an altered view of the system version,
    //       the following two fields are used to correctly identify the
    //       version
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMajorVersion;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMinorVersion;

    //
    // Processor features.
    //

    BOOLEAN ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];

    //
    // Reserved fields - do not use.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaximumUserModeAddressDeprecated; // Deprecated, use SystemBasicInformation instead.
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemRangeStartDeprecated; // Deprecated, use SystemRangeStartInformation instead.

    //
    // Time slippage while in debugger.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeSlip;

    //
    // Alternative system architecture, e.g., NEC PC98xx on x86.
    //

    <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;

    //
    // Boot sequence, incremented for each boot attempt by the OS loader.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BootId;

    //
    // If the system is an evaluation unit, the following field contains the
    // date and time that the evaluation unit expires. A value of 0 indicates
    // that there is no expiration. A non-zero value is the UTC absolute time
    // that the system expires.
    //

    LARGE_INTEGER SystemExpirationDate;

    //
    // Suite support.
    //
    // N.B. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for
    //      an accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SuiteMask;

    //
    // TRUE if a kernel debugger is connected/enabled.
    //

    BOOLEAN KdDebuggerEnabled;

    //
    // Mitigation policies.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
        };
    };

    //
    // Measured duration of a single processor yield, in cycles. This is used by
    // lock packages to determine how many times to spin waiting for a state
    // change before blocking.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> CyclesPerYield;

    //
    // Current console session Id. Always zero on non-TS systems.
    //
    // N.B. This field must be accessed via the <a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a> API for an
    //      accurate result.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveConsoleId;

    //
    // Force-dismounts cause handles to become invalid. Rather than always
    // probe handles, a serial number of dismounts is maintained that clients
    // can use to see if they need to probe handles.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DismountCount;

    //
    // This field indicates the status of the 64-bit COM+ package on the
    // system. It indicates whether the Intermediate Language (IL) COM+
    // images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ComPlusPackage;

    //
    // Time in tick count for system-wide last user input across all terminal
    // sessions. For MP performance, it is not updated all the time (e.g. once
    // a minute per session). It is used for idle detection.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LastSystemRITEventTickCount;

    //
    // Number of physical pages in the system. This can dynamically change as
    // physical memory can be added or removed from a running system.  This
    // cell is too small to hold the non-truncated value on very large memory
    // machines so code that needs the full value should access
    // FullNumberOfPhysicalPages instead.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfPhysicalPages;

    //
    // True if the system was booted in safe boot mode.
    //

    BOOLEAN SafeBootMode;

    //
    // Virtualization flags.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;

#if defined(_ARM64_)

        //
        // N.B. Keep this bitfield in sync with the one in arc.w.
        //

        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> : 6;
        };

#endif

    };

    //
    // Reserved (available for reuse).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved12[2];

    //
    // This is a packed bitfield that contains various flags concerning
    // the system state. They must be manipulated using interlocked
    // operations.
    //
    // N.B. DbgMultiSessionSku must be accessed via the <a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>
    //      API for an accurate result
    //

    union
    {
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
        struct
        {
            //
            // The following bit fields are for the debugger only. Do not use.
            // Use the bit definitions instead.
            //

            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled            : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled             : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled    : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled   : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku        : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSplitTokenEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgShadowAdminEnabled     : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits                 : 19;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DataFlagsPad[1];

    //
    // Depending on the processor, the code for fast system call will differ,
    // Stub code is provided pointers below to access the appropriate code.
    //
    // N.B. The following field is only used on 32-bit systems.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TestRetInstruction;

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> QpcFrequency;

    //
    // On AMD64, this value is initialized to a nonzero value if the system
    // operates with an altered view of the system service call mechanism.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemCall;

    //
    // Reserved field - do not use. Used to be UserCetAvailableEnvironments.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved2;

    //
    // Full 64 bit version of the number of physical pages in the system.
    // This can dynamically change as physical memory can be added or removed
    // from a running system.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> FullNumberOfPhysicalPages;

    //
    // Reserved, available for reuse.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> SystemCallPad[1];

    //
    // The 64-bit tick count.
    //

    union
    {
        volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
        volatile <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> TickCountQuad;
        struct
        {
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME3;

    //
    // Cookie for encoding pointers system wide.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Cookie;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CookiePad[1];

    //
    // Client id of the process having the focus in the current
    // active console session id.
    //
    // N.B. This field must be accessed via the
    //      <a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a> API for an accurate result.
    //

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> ConsoleSessionForegroundProcessId;

    //
    // N.B. The following data is used to implement the precise time
    //      services. It is aligned on a 64-byte cache-line boundary and
    //      arranged in the order of typical accesses.
    //
    // Placeholder for the (internal) time update lock.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TimeUpdateLock;

    //
    // The performance counter value used to establish the current system time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineSystemTimeQpc;

    //
    // The performance counter value used to compute the last interrupt time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineInterruptTimeQpc;

    //
    // The scaled number of system time seconds represented by a single
    // performance count (this value may vary to achieve time synchronization).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcSystemTimeIncrement;

    //
    // The scaled number of interrupt time seconds represented by a single
    // performance count (this value is constant after the system is booted).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcInterruptTimeIncrement;

    //
    // The scaling shift count applied to the performance counter system time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcSystemTimeIncrementShift;

    //
    // The scaling shift count applied to the performance counter interrupt time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcInterruptTimeIncrementShift;

    //
    // The count of unparked processors.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UnparkedProcessorCount;

    //
    // A bitmask of enclave features supported on this system.
    //
    // N.B. This field must be accessed via the <a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a> API for an
    //      accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EnclaveFeatureMask[4];

    //
    // Current coverage round for telemetry based coverage.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryCoverageRound;

    //
    // The following field is used for ETW user mode global logging
    // (UMGL).
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UserModeGlobalLogger[16];

    //
    // Settings that can enable the use of Image File Execution Options
    // from HKCU in addition to the original HKLM.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ImageFileExecutionOptions;

    //
    // Generation of the kernel structure holding system language information
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LangGenerationCount;

    //
    // Reserved (available for reuse).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Reserved4;

    //
    // Current 64-bit interrupt time bias in 100ns units.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> InterruptTimeBias;

    //
    // Current 64-bit performance counter bias, in performance counter units
    // before the shift is applied.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcBias;

    //
    // Number of active processors and groups.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveProcessorCount;
    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ActiveGroupCount;

    //
    // Reserved (available for re-use).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved9;

    union
    {
        <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
        struct
        {
            //
            // A bitfield indicating whether performance counter queries can
            // read the counter directly (bypassing the system call) and flags.
            //

            volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;

            //
            // Reserved, leave as zero for backward compatibility. Was shift
            // applied to the raw counter value to derive QPC count.
            //

            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
        };
    };

    //
    // Reserved for future use.
    //

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    //
    // Extended processor state configuration (AMD64 and x86).
    //

    XSTATE_CONFIGURATION XState;

    //
    // <a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a>
    //

    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> FeatureConfigurationChangeStamp;

    //
    // Spare (available for re-use).
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Spare;

    //
    // This field holds a mask that is used in the process of authenticating pointers in user mode.
    // It helps in determining which bits of the pointer are used for authentication in user mode.
    //

    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> UserPointerAuthMask;

    //
    // Extended processor state configuration (ARM64). The reserved space for
    // other architectures is not available for reuse.
    //

#if defined(_ARM64_)
    XSTATE_CONFIGURATION XStateArm64;
#else
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved10[210];
#endif
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
</span><span class="ntdoc-code-footer">
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/d9393a49b3707fc786047a2ca5ae4afefd760b30/phnt/include/ntexapi.h#L6925">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntddk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _KUSER_SHARED_DATA {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountLowDeprecated;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountMultiplier;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  InterruptTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  SystemTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  TimeZoneBias;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberLow;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberHigh;
  WCHAR                         NtSystemRoot[260];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         MaxStackTraceDepth;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CryptoExponent;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeZoneId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LargePageMinimum;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AitSamplingValue;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AppCompatFlag;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     RNGSeedVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         GlobalValidationRunlevel;
  <a href="long" title="typedef long LONG;">LONG</a>                          TimeZoneBiasStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtBuildNumber;
  <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a>               NtProductType;
  BOOLEAN                       ProductTypeIsValid;
  BOOLEAN                       Reserved0[1];
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        NativeProcessorArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMajorVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMinorVersion;
  BOOLEAN                       ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeSlip;
  <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         BootId;
  LARGE_INTEGER                 SystemExpirationDate;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SuiteMask;
  BOOLEAN                       KdDebuggerEnabled;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
    };
  };
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        CyclesPerYield;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveConsoleId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DismountCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ComPlusPackage;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LastSystemRITEventTickCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NumberOfPhysicalPages;
  BOOLEAN                       SafeBootMode;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
    };
  };
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved12[2];
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits : 21;
    } DUMMYSTRUCTNAME2;
  } DUMMYUNIONNAME2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DataFlagsPad[1];
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TestRetInstruction;
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      QpcFrequency;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SystemCall;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved2;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     FullNumberOfPhysicalPages;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     SystemCallPad[1];
  union {
    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>      TickCountQuad;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Cookie;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CookiePad[1];
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      ConsoleSessionForegroundProcessId;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TimeUpdateLock;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineSystemTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineInterruptTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcSystemTimeIncrement;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcInterruptTimeIncrement;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcSystemTimeIncrementShift;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcInterruptTimeIncrementShift;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UnparkedProcessorCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         EnclaveFeatureMask[4];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TelemetryCoverageRound;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UserModeGlobalLogger[16];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ImageFileExecutionOptions;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LangGenerationCount;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     Reserved4;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     InterruptTimeBias;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcBias;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveProcessorCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         ActiveGroupCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved9;
  union {
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
    };
  };
  LARGE_INTEGER                 TimeZoneBiasEffectiveStart;
  LARGE_INTEGER                 TimeZoneBiasEffectiveEnd;
  XSTATE_CONFIGURATION          XState;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  FeatureConfigurationChangeStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Spare;
  <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>                       UserPointerAuthMask;
  XSTATE_CONFIGURATION          XStateArm64;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved10[210];
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<p>This structure is partially <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">documented in Windows Driver Kit</a>. However, as verified on 2025-09, almost all Microsoft documentation for this structure is either outdated, useless, or downright incorrect.  </p>
<h1>Introduction</h1>
<p>KUSER_SHARED_DATA structure defines layout of the memory region, shared between kernelmode and usermode. It occupies a single physical page, mapped in oskernel at fixed address <code>0xFFFF'F780'0000'0000</code> (0xFFFFF78000000000), and in all but the <em>Minimal</em> processes at <code>0x7FFE'0000</code> (0x7FFE0000). Since win11 23H2, the fixed virtual address in kernel is read-only; <code>nt!MmWriteableSharedUserData</code> holds a randomized virtual address of the writeable kernelmode mapping.</p>
<h1>Definition</h1>
<p>Here is the full definition, with all fields properly documented.<br />
It has been enriched with field offsets and five special sigils to help you quickly assess each item.  </p>
<p>Legend:<br />
ùçå - field fixed at boot and won't change at runtime<br />
‚ùï - changes often (e.g. secondwise)<br />
‚ó∑ - changes rarely (e.g. hourly)<br />
üëã ‚Äì can be changed by usermode applications at runtime<br />
‚ôª ‚Äì field is either reserved, or deprecated, or it has no real reason to be in kuser and should be moved elsewhere</p>
<pre><code>struct _KUSER_SHARED_DATA
{
// Unused, deprecated for more than 20 years. Always zero.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountLowDeprecated;                   // 000 ùçå‚ôª

// Number of milliseconds per ostick, left-shifted by 0x18.
// Mirrors nt!ExpTickCountMultiplier, derived directly from nt!KeMaximumIncrement. Across all archs, value is
// clamped to a max of 0x0FA00000 (1/64 s, or 15.625 ms). And in fact, you'll almost never see anything else there,
// except maybe 0x0F99A027 on some old systems (~15.600 ms, or 15.600099980831146 ms exactly).
// GetTickCount() =&gt; (ü°óTickCountMultiplier √ó ü°ìTickCountQuad) &gt;&gt; 0x18.
// Duration of an ostick is fixed at boot time, stored in nt!KeMaximumIncrement. Not to be confused with the clock
// tick duration, nt!KeTimeIncrement, which can change at runtime (in ü°ìInterruptTime description right below).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountMultiplier;                      // 004 ùçå

// Number of centums (100 ns units) since system start. Value monotonically increases. Includes sleep/hibernation
// time and the like (the "bias"); i.e. value jumps forward on wakeup. For raw uptime, subtract ü°ìInterruptTimeBias.
// Updated on each clock interrupt on the clock owner processor. Current update period is nt!KeTimeIncrement,
// adjustable via <a href="ntsettimerresolution" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetTimerResolution(&#10;    _In_ ULONG DesiredTime,&#10;    _In_ BOOLEAN SetResolution,&#10;    _Out_ PULONG ActualTime&#10;    );">NtSetTimerResolution</a> (aka timeBeginPeriod), in the hardcoded range [0.5 ms, 15.625 ms].
// Actual adjustable range can be smaller; set at boot as [nt!KeMinimumIncrement, nt!KeMaximumIncrement].
// See ü°ìTickCountQuad description on how to change this field initial value from 0 to up to 49.71 days.
// Coherence of this field vs ü°ìSystemTime, ü°ìTickCountQuad, and certain others is ensured via ü°ìTimeUpdateLock.
volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> InterruptTime;            // 008 ‚ùï changes each clock interrupt

// UTC System Time. Number of centums since 1601-01-01, exactly. It's a perfectly raw value; any conversions or
// adjustments (like leap days or leap seconds) ought to be done on the higher level.
// Coherence of this field vs ü°ëInterruptTime, ü°ìTickCountQuad, and certain others is ensured via ü°ìTimeUpdateLock.
// Clients not in the server silo with SeSystemtime privilege can set it via <a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a> to any value in range
// [0, 2‚Å∂¬π+2¬≥¬≤), which is [1601-01-01, 8907-12-05 18:49:10]. Note regular users don't have SeSystemtime by default.
volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> SystemTime;               // 014 ‚ùïüëã changes each clock interrupt + adjustable

// Current 64-bit time zone bias. Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBias.
// It's the value you *subtract* from ü°ëSystemTime to get Local Time. It's already pre-adjusted for daylight saving.
// E.g. for Pacific Time (-08:00) value will be 7:00 in Summer (0x3AAC5ED800 == 7√ó3600√ó10‚Å∑).
// See ü°ìTimeZoneBiasEffectiveStart description for when this field is considered valid.
// Coherence of this field vs the ü°ìTimeZoneBiasEffective* values ensured via ü°ìTimeZoneBiasStamp.
// Clients with SeTimeZone privilege can set bias using SystemTimeZoneInformation/SystemDynamicTimeZoneInformation
// infoclasses. Range is ¬±2¬≥¬π seconds (¬±68 years), granularity 1 minute. Regular users on client OS versions
// DO have SeTimeZone privilege by default; on server OS versions they don't. Note timezone info is stored under
// CCS\Control\TimeZoneInformation key; using timezone infoclasses grants users limited writeability to that key.
volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TimeZoneBias;             // 020 ‚ó∑üëã changes at runtime (~twice a year), manually adjustable

// Fixed values, set at boot (in nt!InitBootProcessor). Both fields are the same: 0x8664 for x64, 0xAA64 for ARM64.
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidimagenumberlow" title="#define GlobalDataIdImageNumberLow 4 // KUSER_SHARED_DATA-&gt;ImageNumberLow">GlobalDataIdImageNumberLow</a>/<a href="globaldataidimagenumberhigh" title="#define GlobalDataIdImageNumberHigh 5 // KUSER_SHARED_DATA-&gt;ImageNumberHigh">GlobalDataIdImageNumberHigh</a>[=4/5]).
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberLow;                          // 02C ùçå
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberHigh;                         // 02E ùçå

// Win32 system root path, e.g. "C:\Windows" ‚Äì without quotes, without trailing slash.
// First wchar is adjustable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidntsystemrootdrive" title="#define GlobalDataIdNtSystemRootDrive 15 // KUSER_SHARED_DATA-&gt;NtSystemRoot // RtlGetNtSystemRoot">GlobalDataIdNtSystemRootDrive</a>[=15]).
// OS receives path from the osloader (winload.efi), in LoaderBlock.NtBootPathName. But LoaderBlock path has
// no drive letter, so it's retrieved from the MountPointManager via <a href="ioctl_mountmgr_boot_dl_assignment" title="#define IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT CTL_CODE(MOUNTMGRCONTROLTYPE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since WIN7">IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT</a>.
// Silo-aware: <a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtSystemRoot.
WCHAR NtSystemRoot[0x104];                      // 030 ùçå‚ôª used now, but really shouldn't be in kuser

// "Maximum stack trace depth if tracing is enabled".
// Appears to be deprecated, unused, always zero.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaxStackTraceDepth;                       // 238 ùçå‚ôª

// Crypto exponent for yolocrypto. Unused, always zero. In the past could be non-zero only for "internal" OS builds.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CryptoExponent;                           // 23C ùçå‚ôª

// Time zone ID, TIME_ZONE_ID_*. Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneId.
// 0: *_UNKNOWN (aka neither, DST not used), 1: *_STANDARD (winter), 2: *_DAYLIGHT (summer).
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidtimezoneid" title="#define GlobalDataIdTimeZoneId 6 // KUSER_SHARED_DATA-&gt;TimeZoneId">GlobalDataIdTimeZoneId</a>[=6]).
// ‚ö†Ô∏è Unlike ü°ëTimeZoneBias and ü°ìTimeZoneBiasEffective*, this field is NOT protected via ü°ìTimeZoneBiasStamp; it is
// set before starting the ü°ìTimeZoneBiasStamp update sequence. For coherence between this and other timezone
// fields: read this first, then others, then read this field again and ensure it hasn't changed.
// Indirectly adjustable by clients with SeTimeZone privilege, together with ü°ëTimeZoneBias.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeZoneId;                               // 240 ‚ó∑üëã changes at runtime ~twice a year, manually adjustable

// Minimum size of a large page, in bytes. Determined by the CPU. On boot nt!MiInitSystem sets it to hardcoded 2 MB.
// It seems the only purpose of this field is to simplify implementation of exported kernelbase!GetLargePageMinimum.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LargePageMinimum;                         // 244 ùçå‚ôª used now, but really shouldn't be in kuser

// AIT sampling rate. TL note: AIT means App Impact Telemetry. Related to KIT, Kernel Impact Telemetry.
// Related to ETW provider MS_Windows_AIT_Provider and exported api nt!KitLogFeatureUsage. Most likely deprecated.
// Set during boot in nt!KitpInitAitSampleRate from CCS\Control\Session Manager\AppCompatCache‚ÇÑRate, unless it's
// a safeboot. By default there is nothing in registry, so normally this field is 0.
// Can be adjusted by holders of SeProfileSingleProcess privilege: <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemAitSamplingValue).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AitSamplingValue;                         // 248 üëã‚ôª

// "This value controls switchback processing".
// Seemingly deprecated, unused, and always 0. But there's an active <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a> field of similar name: <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.AppCompatFlags.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AppCompatFlag;                            // 24C ùçå‚ôª

// Number of times since boot CNG.sys has reseeded its entropy pool.
// Reseed can be triggered via exported cng!<a href="entropypooltriggerreseedforium" title="VOID EntropyPoolTriggerReseedForIum(&#10;  BOOLEAN fPerformCallbacks&#10;);">EntropyPoolTriggerReseedForIum</a>, but it mostly auto-reseeds at these
// intervals after the previous auto-reseed, in seconds: 1, 3, 9, 27, 81, 243, 729, 2187, 3600, 3600, 3600,..
// I.e. interval triples till it hits one hour (but there's about 5 extra reseeds at system start).
// On boot you'll often see 8 here; +27s: 9; +81s more: 10; after 6/18/55/115 minutes of uptime: 11/12/13/14; etc.
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidrngseedversion" title="#define GlobalDataIdRngSeedVersion 1 // KUSER_SHARED_DATA-&gt;RngSeedVersion">GlobalDataIdRngSeedVersion</a>[=1]).
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> RNGSeedVersion;                       // 250 ‚ó∑ incremented periodically (every hour on average)

// Set of flags to control assert failures handling. Read on boot from CCS\Control\ValidationRunLevels‚ÇÑGlobal. See
// VRL_* flags in sdk; from oskernel view the only bit is VRL_ENABLE_KERNEL_BREAKS, it only affects debug OS builds.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GlobalValidationRunlevel;                 // 258 ùçå‚ôª

// Sequence number/lock for timezone data: ü°ëTimeZoneBias, ü°ìTimeZoneBiasEffectiveStart, ü°ìTimeZoneBiasEffectiveEnd.
// When value is odd, the set of fields is being updated. See "Cross-fields coherence via sequence numbers" below
// for details. Clients without any privileges can increment it by two via <a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a>(null, null).
// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasStamp.
volatile <a href="long" title="typedef long LONG;">LONG</a> TimeZoneBiasStamp;                // 25C ‚ó∑üëã changes at runtime rarely (e.g. daily), +manual adjust

// Mirrors exported nt!NtBuildNumber, but with its higher nibble zeroed.
// For nt!NtBuildNumber, higher nibble is 0xC in Checked (debug) builds, or 0xF in Free (release) builds.
// Initially set to a hardcoded value for current ntoskrnl, equal to the "real" value in FixedFileVersionInfo (e.g.
// 19041); during boot re-set to a dword from registry (e.g. 19045). This field (or rather the nt!NtBuildNumber it's
// derived from) has modest usage throughout the system, but it does affect codepaths. Goes into <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.NtBuildNumber.
// Reg path for win10: HKLM\Software\Microsoft\Windows NT\CurrentVersion\EditionVersion‚ÇÑEditionBuildNumber.
// For WS2022/win11: HKLM\SYSTEM\Software\Microsoft\BuildLayers\&lt;SubkeyWithValue.IsTopLevel==1&gt;‚ÇÑBuildNumber.
// "The shared collective build number undecorated with C or F." ‚Äì original WDK gem, kept for posterity.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtBuildNumber;                            // 260 ùçå

// Product type: client (e.g. Windows 10) VS server (e.g. Windows Server 2022) VS domain controller server.
// 1/NtProductWinNt: client OS; 2/NtProductLanManNt: Windows Server in DC role; 3/NtProductServer: Windows Server.
// Set on boot in nt!MiMemoryLicense, from nt!MmRegistryState.ProductType: CCS\Control\ProductOptions‚ÇÑProductType.
// Silo-aware: <a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtProductType.
<a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a> NtProductType;                  // 264 ùçå

// Tells APIs they can use ü°ëNtProductType field instead of querying that info from registry.
// Normally it's 1, except during system install ("SystemSetupInProgress").
BOOLEAN ProductTypeIsValid;                     // 268 ùçå‚ôª

// Zero.
BOOLEAN Reserved0[1];                           // 269 ùçå‚ôª

// PROCESSOR_ARCHITECTURE_* constant, e.g. 9 for PROCESSOR_ARCHITECTURE_AMD64, 12 for _ARM64.
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> NativeProcessorArchitecture;             // 26A ùçå‚ôª; shouldn't be in kuser; wow/sxs should use regular api

// OS Version, set at boot to fixed values (in nt!InitBootProcessor). E.g. win7: 6 major, 1 minor.
// Usual values: 5.1, 5.2, 6.0, 6.1, 6.2, 6.3; hardcoded to 10.0 since win10, stays as such in win11.
// Unlike ü°ëNtBuildNumber, adjusting MajorVersion &amp; MinorVersion in registry does NOT affect these fields.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMajorVersion;                           // 26C ùçå
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMinorVersion;                           // 270 ùçå

// Processor and/or OS features. See PF_* flags. Unfortunately, one whole byte used per flag.
// Used by kernelbase!IsProcessorFeaturePresent (via ntdll!<a href="rtlisprocessorfeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsProcessorFeaturePresent(&#10;    _In_ ULONG ProcessorFeature&#10;    );">RtlIsProcessorFeaturePresent</a>).
// ‚ö†Ô∏è Older OS versions may not set all expected flags, even if feature is actually supported by CPU and OS.
BOOLEAN ProcessorFeatures[0x40];                // 274 ùçå; 0x40 is <a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>

// Obsolete, dnu: always 0x7FFEFFFF on 64-bit OS. On 32-bit OS mirrors MM_HIGHEST_USER_ADDRESS (sensible with /3GB).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved1;                                // 2B4 ùçå‚ôª; aka MaximumUserModeAddressDeprecated

// Obsolete, dnu: always 0x80000000 on 64-bit OS. On 32-bit OS mirrors MmSystemRangeStart.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved3;                                // 2B8 ùçå‚ôª; aka SystemRangeStartDeprecated

// "Time slippage while in debugger".
// So, supposedly "time wasted debugging", but there's strong indication this field is obsolete and always zero.
volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeSlip;                        // 2BC ùçå‚ôª; *most likely* fixed at boot to 0 and doesn't change

// Always zero. Previously: "alternative system architecture, e.g., NEC PC98xx on x86".
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AlternativeArchitecture;                  // 2C0 ùçå‚ôª; type is 2-const enum <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a>

// Number of boots since OS install (really, boot attempts). Osloader (winload.efi) reads \Windows\bootstat.dat
// (BSD_BOOT_STATUS_DATA.LastBootId`0x34), increments and resaves it; passes value through LoaderBlock for
// nt!InitBootProcessor, which stores it here. Filepath is changeable via BsdLogPath; ntoskrnl reduplicates it
// from the loader block into CCS\Control‚ÇõOsBootstatPath.
// Hyper-V docker containers run with BootId == 1; at least some Windows Sandbox instances run with BootId == 2.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BootId;                                   // 2C4 ùçå

// Value of ü°ëSystemTime when system expires. Normally 0, which means no expiration. Not related to activation.
// Evaluation OS versions have real value here. Used by winver.exe directly, and by win32k*.sys to paint watermark.
// Set during boot from data returned by nt!ExGetExpirationDate() [<a href="ntquerylicensevalue" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryLicenseValue(&#10;    _In_ PCUNICODE_STRING ValueName,&#10;    _Out_opt_ PULONG Type,&#10;    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,&#10;    _In_ ULONG DataSize,&#10;    _Out_ PULONG ResultDataSize&#10;    );">ZwQueryLicenseValue</a>("Kernel-ExpirationDate")].
LARGE_INTEGER SystemExpirationDate;             // 2C8 ùçå

// VER_SUITE_* mask, i.e. (1 &lt;&lt; <a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::*). E.g. if bit16 set, it's Windows Phone (<a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::PhoneNT == 16).
// Over time got sidelined; mostly you'll see just the minimum: 0x110 == VER_SUITE_TERMINAL|VER_SUITE_SINGLEUSERTS.
// Silo-aware: <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.SuiteMask.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SuiteMask;                                // 2D0 ùçå

// Kernel Debugger status bitmask. Value can change dynamically into any state (e.g. 1 -&gt; 3 -&gt; 0 -&gt; 3 -&gt; 1 -&gt; ...).
// Bit0 mirrors exported boolean nt!KdDebuggerEnabled (debugger enabled, but not necessarily connected).
// Bit1 is negation of the exported bool nt!KdDebuggerNotPresent (that is: when bit1 is 1, KD is connected/active).
// üîé Example: booted with "bcdedit /debug on", but w/o KD running: field=1 (enabled, not connected);
// then launched KD on host: guest OS connects to KD, field changes 1-&gt;3 (active); run "kdbgctrl -d" on guest, aka
// <a href="ntsystemdebugcontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSystemDebugControl(&#10;    _In_ SYSDBG_COMMAND Command,&#10;    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtSystemDebugControl</a>(SysDbgDisableKernelDebugger): field changes 3-&gt;0 (forcing KD disconnect until dbg events).
// Can also change 0-&gt;1/3 with kdbgctrl as long as nt!KdPitchDebugger is false (i.e. "/debug on" is true).
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidkddebuggerenabled" title="#define GlobalDataIdKdDebuggerEnabled 10 // KUSER_SHARED_DATA-&gt;KdDebuggerEnabled">GlobalDataIdKdDebuggerEnabled</a>[=10]), done by kdxxx/kdnet.dll.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> KdDebuggerEnabled;                        // 2D4 ‚ó∑üëã may change if debugger connected; manually adjustable

union
{
// Minor subset of system mitigations.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;                   // 2D5 ùçå
struct
{
// NX_SUPPORT_POLICY_* values. Only meaningful for 32-bit x86 processes. From "bcdedit /set nx VALUE".
// Applied at process startup via <a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessExecuteFlags).
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy: 2;

// SEH_VALIDATION_POLICY_* values. Only meaningful for 32-bit x86 processes. Set on boot from
// CCS\Control\Session Manager‚ÇÑDisableExceptionChainValidation. App IFEO value with the same name trumps it.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy: 2;

// Determines what kinds of devices are illegal to have Current Working Directory searched for dlls. From
// CCS\Control\Session Manager‚ÇÑCWDIllegalInDLLSearch. App-specific IFEO value with the same name trumps it.
// 0: any allowed; 1: WebDav; 2: any Remote device; 3: all devices illegal, never use CWD (-1 in registry).
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls: 2;

// Zero.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved: 2;
};
};

// Measured duration of "pause" (x86) or "yield" (ARM) instructions, in TSC (rdtsc) cycles. Determines how many
// times to spin, e.g. in RtlBackoff (both rings). Early at boot set to 10, then ‚Äì at later boot stages ‚Äì updated
// with data from nt!ExpComputeCyclesPerYield. Example: 0x0D, 0x18, 0x84. Measured values can vary boot to boot! OS
// clamps value in range [1, 0xFFFF]. So if value is 0, the OS is simply too old to use it: older than win10 1903.
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> CyclesPerYield;                          // 2D6 ùçå

// Current physical console Session Id. RDP sessions ignored. During boot it's 0. Right after the boot it may stay
// 0 (Hyper-V docker container), change to 1 (normal box, Logon Screen), or to -1 (Windows Sandbox, kind of RDP).
// Note Hyper-V Manager *basic* sessions are "physical", but *enhanced* sessions are RDP; thus in enhanced sessions
// you'll observe some "leftover" here, but really it'll be the "physical" basic session LogonUI.exe is running in.
// When the physical box (or its equivalent) is locked, value *may* change; happens when LogonUI.exe is created in
// a new session, which is the case if there are already several user sessions (physical or RDP).
// Field set by win32kbase.sys and win32kfull.sys; they use dedicated exported api, nt!RtlSetActiveConsoleId.
// Silo-aware: <a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ActiveConsoleId.
volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveConsoleId;                 // 2D8 ‚ó∑üëã sort of changeable by physically present users

// Force-dismounting volumes makes affected handles refer to "invalid" files/volumes/directories; if app wants to
// ensure handles "validity" for some reason (race condition notwithstanding), but doesn't want to always issue
// <a href="fsctl_is_volume_mounted" title="// CTL_CODE(0x0009, 0x00a, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_IS_VOLUME_MOUNTED 0x00090028">FSCTL_IS_VOLUME_MOUNTED</a> ioctl (0x090028), it can simply check sameness of this field.
// OS changes this value ‚Äì interlocked-increments it ‚Äì on two occasions:
// 1) well-behaved filesystem driver invoked exported nt!FsRtlDismountComplete;
// 2) OS received <a href="fsctl_dismount_volume" title="// CTL_CODE(0x0009, 0x008, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_DISMOUNT_VOLUME 0x00090020">FSCTL_DISMOUNT_VOLUME</a> (0x090020) via <a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a>/<a href="ntdeviceiocontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDeviceIoControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG IoControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtDeviceIoControlFile</a> (+=1 or +=2 per call).
volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DismountCount;                   // 2DC ‚ó∑üëã changes at runtime on dismounts (rare), +manually

// Lazy-mirrors HKLM\SOFTWARE\Microsoft\.NETFramework‚ÇÑEnable64Bit. Value is a bitfield with only bit0 defined:
// COMPLUS_ENABLE_64BIT. When set, it makes system run suitable 32-bit MSIL images as native 64-bit processes (so
// one can observe 32-bit PE images run as 64-bit processes). Registry value is normally 1, but this field initially
// set to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a>, making engaged code use <a href="ntquerysysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQuerySystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtQuerySystemInformation</a>(SystemComPlusPackage) to query reg value and
// update this field. NtSet(SystemComPlusPackage) updates registry and this field, but needs registry write access.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ComPlusPackage;                           // 2E0 ‚ó∑üëã‚ôª normally changes once at runtime; manually adjustable

// Snapshot of GetTickCount() ms at the moment of the last user input, across all terminal sessions (including RDP).
// Used for e.g. idle detection. Updated by win32kbase!CitpLastInputUpdate at most *once per second*.
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidlastsystemriteventtickcount" title="#define GlobalDataIdLastSystemRITEventTickCount 13 // KUSER_SHARED_DATA-&gt;LastSystemRITEventTickCount">GlobalDataIdLastSystemRITEventTickCount</a>[=13]).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LastSystemRITEventTickCount;              // 2E4 ‚ùïüëã updates every second as long as some users provide input

// OS-visible total RAM size, in pages, clamped to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a> (16 TB RAM). Since win11 24H2, extended 64-bit field is
// also available: ü°ìFullNumberOfPhysicalPages. Both fields can change if RAM is added or removed.
// Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfPhysicalPages;                    // 2E8 ‚ó∑ fixed at boot, but might [rarely] change at runtime

// True if booted in safe boot mode ("SAFEBOOT:" present in the OS load options).
BOOLEAN SafeBootMode;                           // 2EC ùçå

union
{
// Copy of nt!KiVirtFlags, made in KiInitializeKernel based on MSR_IA32_FEATURE_CONTROL and/or VM_CR MSR.
// bit0: vmx/svm enableable, bit1: enableablement locked (MSR_IA32_FEATURE_CONTROL.lock is true). Bits are 0
// when: Hyper-V is running (regardless of partition); or VMX is off (in bios, or VM VBS-compatibility off).
// Bits form mask 3 or 1 when: Hyper-V is NOT running, and VMX is on (in bios, or VM VBS-compatibility ON).
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;                  // 2ED ùçå
#if defined(_M_ARM64)
// Set during boot to exact copy of byte LoaderBlock.Extension.VirtualizationFlags.
struct
{
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2: 1;
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported: 1;
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>: 6;
};
#endif
};

// Zero. "Available for reuse".
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved12[2];                            // 2EE ùçå‚ôª

// Various system state flags, SHARED_GLOBAL_FLAGS_*. System adjusts them using interlocked operations.
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(GlobalDataIdSharedDataFlags[=14]) in a special way:
// bit *index* is bits [0..29] of the input dword; bit 30 to *set* the bit, and/or bit31 to *clear* the bit.
union
{
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;                      // 2F0 ‚ó∑üëã certain flags may change at runtime
struct
{
// Process with SetTcb privilege can (re-)register one global alpc error port via SystemErrorPortInformation
// system infoclass (-&gt; nt!DbgkRegisterErrorPort). When that happens, system sets this bit. When registrar
// process exits, or if port somehow disconnects, system unregisters port and clears this bit. In practice,
// this bit indicates whether WerSvc is currently running (it registers \WindowsErrorReportingServicePort).
// Note processes in silo can register error port too, but it'll be silo-specific; this bit won't be set.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent       : 1;    //  0/0001 ‚ó∑üëã

// Following 3 flags, together with new ü°ìDbgShadowAdminEnabled, form basis for <a href="rtl_elevation_flags" title="typedef struct _RTL_ELEVATION_FLAGS&#10;{&#10;    union&#10;    {&#10;        ULONG Flags;&#10;        struct&#10;        {&#10;            ULONG ElevationEnabled : 1;&#10;            ULONG VirtualizationEnabled : 1;&#10;            ULONG InstallerDetectEnabled : 1;&#10;            ULONG AdminApprovalModeType : 2;&#10;            ULONG ReservedBits : 27;&#10;        };&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a> struct,
// returned by <a href="rtlqueryelevationflags" title="NTSYSAPI&#10;NTSTATUS&#10;NTAPI&#10;RtlQueryElevationFlags(&#10;    _Out_ PRTL_ELEVATION_FLAGS Flags&#10;    );">RtlQueryElevationFlags</a> api (in both usermode and kernelmode). Fields set on boot from reg
// data at HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System, they won't update until reboot
// even if registry values change. Bad type or size of reg data, or a missing value, yields 1 (not 0).
// However, if CCS\Control\LsaInformation‚ÇÑUACInstalled is 0, all 4 flags will be set to 0.
// 
// policy: "UAC: Turn on Admin Approval Mode", aka "UAC: Run all administrators in Admin Approval Mode".
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled       : 1;    //  1/0002 ùçå, reg value‚ÇÑ: "EnableLUA"
// policy: "UAC: Virtualize file and registry write failures to per-user locations".
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled            : 1;    //  2/0004 ùçå, reg value‚ÇÑ: "EnableVirtualization"
// policy: "UAC: Detect application installations and prompt for elevation".
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;    //  3/0008 ùçå, reg value‚ÇÑ: "EnableInstallerDetection"

// Indicates if Last Known Good is enabled. This bit mirrors nt!CmpLKGEnabled, initialized at boot to
// CCS\Control\Session Manager\Configuration Manager\LastKnownGood‚ÇÑEnabled. Most often it's 0.
// This bit is NOT directly related to "DisableLKG" reg value‚ÇÑ set by <a href="ntdisablelastknowngood" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDisableLastKnownGood(&#10;    VOID&#10;    );">NtDisableLastKnownGood</a>.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled             : 1;    //  4/0010 ùçå

// Indicates if new processors can be added at runtime. This bit mirrors exported "almost read-only" value
// nt!KeDynamicPartitioningSupported, initialized at boot; value depends on sku and licensing. Normally
// it's 0 for client systems, and can be 1 for servers. However: it's always zero in Hyper-V root partition.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled    : 1;    //  5/0020 ùçå

// Dynamic value, managed by ConDrv.sys (the console driver). When true, console attach/allocation routines
// in usermode take different road. Normally value is 0. But if any process with SeTcb privilege asks for
// brokerage via request to \Device\ConDrv\Broker, this bit becomes 1 (until all broker objects are gone).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled   : 1;    //  6/0040 üëã

// True when SecureBoot is enabled. Initialized during boot. Matches simultaneously set value in the
// volatile "State" subkey: CCS\Control\SecureBoot\State‚ÇÑUEFISecureBootEnabled.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled      : 1;    //  7/0080 ùçå

// Indicates that OS supports multiple sessions. For regular OS it's always 1, even for "single-user sku".
// It's 0 only for Hyper-V docker containers; even then, OS still uses separate session for user processes.
// Cleared bit entails serious security lax across OS (user ‚•µ admin) due to "WIN://ISMULTISESSIONSKU"
// conditional ACEs (mainly for registry keys), and regular checks in both modes via <a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>.
// Bit is zeroed only if: CCS\Control\Session Manager‚ÇÑNumberOfInitialSessions &lt; 2 (default 2), AND
// "ext-ms-win-session-wtsapi32-l1-1-0" apiset fails to resolve to proper dll.
// Silo-aware: ntdll!<a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.IsMultiSessionSku.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku        : 1;    //  8/0100 ùçå

// Probably indicates that multiple users can share a session (lightweight user separation?). Often gets
// checked when ü°ëDbgMultiSessionSku is 0. Set at boot to mirror nt!RtlpMultiUsersInSessionSupported,
// from CCS\Control\Session Manager‚ÇÑMultiUsersInSessionSupported. Default is 0.
// Accessible via exported ntdll!<a href="rtlismultiusersinsessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiUsersInSessionSku(&#10;    VOID&#10;    );">RtlIsMultiUsersInSessionSku</a>.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;    //  9/0200 ùçå

// Indicates if state separation is enabled. It's hard to enable it for a regular OS, so normally it's 0.
// State separation is a facility to use different, configurable paths to some registry hives, some
// registry keys, and some files. This bit set at boot time to mirror nt!CmStateSeparationEnabled, from
// CCS\Control\StateSeparation\Policy‚ÇÑEnabled.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;    // 10/0400 ùçå

// Relatively new flag, even though concept of split token itself is old.
// Likely requires at least win11 25H2. Not set in win11 24H2 and before.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSplitTokenEnabled      : 1;    // 11/0800 ùçå

// Part of <a href="rtl_elevation_flags" title="typedef struct _RTL_ELEVATION_FLAGS&#10;{&#10;    union&#10;    {&#10;        ULONG Flags;&#10;        struct&#10;        {&#10;            ULONG ElevationEnabled : 1;&#10;            ULONG VirtualizationEnabled : 1;&#10;            ULONG InstallerDetectEnabled : 1;&#10;            ULONG AdminApprovalModeType : 2;&#10;            ULONG ReservedBits : 27;&#10;        };&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a>.
// Likely requires at least win11 25H2. Not set in win11 24H2 and before.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgShadowAdminEnabled     : 1;    // 12/1000 ùçå, reg value: "TypeOfAdminApprovalMode"

<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits                 : 19;   // 13/~1FFF ùçå‚ôª
} DUMMYSTRUCTNAME2;
} DUMMYUNIONNAME2;

// Zero.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DataFlagsPad[1];                          // 2F4 ùçå‚ôª

// On x64 contains 0xC3 ("ret"), 0 on ARM64. 32-bit x86 code can jump here to check if DEP is enabled: this page is
// not executable, but if DEP is effectively off, OS will remove its NX bit for the process on exec attempt, sparing
// the app STATUS_ACCESS_VIOLATION. That won't affect 64-bit processes: they implicitly have DEP enabled, always.
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TestRetInstruction;                   // 2F8 ùçå‚ôª

// Frequency of the high-resolution counter, ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() and nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>().
// Value from such counter is known simply as "Qpc". ü°óQpcFrequency = (Qpc‚ÇÅ - Qpc‚ÇÄ), where (t‚ÇÅ - t‚ÇÄ) == 1 s.
// 
// What counter is actually used determined by the _REGISTERED_TIMER struct pointed to by nt!HalpPerformanceCounter.
// Timer type is normally TimerProcessor (rdtsc/TSC_DEADLINE_MSR) [or TimerHypervisor, or TimerGit, ‚©Ø rdtsc].
// For TimerProcessor OS scales tsc values used for Qpc to 10 MHz == 10‚Å∑ Hz == 0x989680 (since win10 1809).
// For TimerHypervisor the frequency simply set to 10 MHz in the first place. Thus 0x989680 is what you'd normally
// see there. Duration of each Qpc tick in such case is, naturally, 10‚Åª‚Å∑ seconds ‚Äì exactly one centum (100 ns).
// This field gets set once at boot time together with various other ü°ìQpc* fields, in nt!KiSetupTimeIncrement.
<a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> QpcFrequency;                          // 300 ùçå

// Normally 0. Contains 1 if int2E is preferable to syscall (x64 only). Set to 1 when: nt!KiSystemCallSelector
// AND  NtQuery(SystemIsolatedUserModeInformation).HvciEnabled  AND  cpuid(0x40000004).eax.UseIntForMbecSystemCalls.
// Note int2E IDT entry is special: its DPL is 0 (disallowed for usermode) when nt!KiSystemCallSelector == 0. And
// the latter mirrors the LoaderBlock.Extension.VsmConfigured bit (hypercall code page for VSM mapped by winload).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemCall;                               // 308 ùçå

// Zero. "Reserved field ‚Äì do not use. Used to be UserCetAvailableEnvironments".
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved2;                                // 30C ùçå‚ôª

// OS-visible total RAM size, in pages. For comparison, ü°ëNumberOfPhysicalPages holds 32-bit value of such, clamped
// to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a> (16 TB RAM). Both values can change if RAM is added or removed; this larger field is updated first.
// Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.
// ‚ö†Ô∏è WARNING ‚ö†Ô∏è: field available since win11 24H2. On previous systems this location contains 0.
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> FullNumberOfPhysicalPages;            // 310 ‚ó∑ fixed at boot, but might [rarely] change at runtime

// Zero. "Available for reuse".
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> SystemCallPad[1];                     // 318 ùçå‚ôª

// Number of osticks since boot, incremented with fixed-at-boot frequency. This value is NOT ms, it's "osticks",
// which can be translated into ms (most often single ostick is 15.625 ms); see ü°ëTickCountMultiplier.
// Value updated by the clock owner processor, together with ü°ëInterruptTime (just usually not as often). And just
// like ü°ëInterruptTime, this value includes sleep/hibernation time and the like (i.e. it jumps forward on wakeup).
// Coherence of this field with ü°ëSystemTime, ü°ëInterruptTime, and certain others ensured via ü°ìTimeUpdateLock.
// 
// ‚ö†Ô∏è To change initial value of this field, set CCS\Control\Session Manager\Executive‚ÇÑTickcountRolloverDelay to
// the NEGATIVE desired time, in ms. E.g. to start from ‚âà8 osticks, set reg data to -125 ms (0xFFFF'FF83); that'll
// also set ü°ëInterruptTime and ü°ìInterruptTimeBias initial values to 1250000. Adjustable range: up to 49.71 days.
union
{
volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
volatile <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> TickCountQuad;             // 320 ‚ùï incremented by one every 15.625 ms (virtually all systems)
struct
{
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];                  // 32C ùçå‚ôª
} DUMMYSTRUCTNAME;
} DUMMYUNIONNAME3;

// Cookie for encoding usermode pointers system-wide. Not related to the stack GS cookie, nor to the ProcessCookie
// infoclass. Exported ntdll!<a href="rtlencodesystempointer" title="_Ret_maybenull_&#10;NTSYSAPI&#10;PVOID&#10;NTAPI&#10;RtlEncodeSystemPointer(&#10;    _In_opt_ PVOID Ptr&#10;    );">RtlEncodeSystemPointer</a> uses this field: encoded_ptr = rotr(orig_ptr ^ Cookie, Cookie).
// Set once per boot to a good random value, on the first usermode thread creation, in nt!PspNotifyThreadCreation.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Cookie;                                   // 330 ùçå

// Zero. Could have been higher part of the cookie to encode more bits, but unfortunately this field is unused.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CookiePad[1];                             // 334 ùçå‚ôª

// Process ID (pid) of the process with focus in the current physical console. RDP sessions ignored. Edge cases when
// value is zero: Windows Sandbox (as it's RDP), and Hyper-V docker containers (as they are gui-less, so no focus).
// Hyper-V Manager *enhanced* sessions are RDP too, in such sessions you'll observe some "leftover" value, normally
// the pid of the LogonUI.exe running in the "physical" *basic* session. Similar to ü°ëActiveConsoleId.
// When the physical box (or its equivalent) is locked, focused app is normally LogonUI.exe; pid here reflects that.
// ‚ö†Ô∏è Process death is not tracked ‚Äì there might be brief periods when this field contains id of an already
// terminated process, or even id of some new, unrelated process due to pid reuse (very brief and rare).
// To set this field win32kfull.sys uses dedicated exported api: nt!RtlSetConsoleSessionForegroundProcessId.
// Silo-aware: <a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ConsoleSessionForegroundProcessId.
volatile <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> ConsoleSessionForegroundProcessId;    // 338 ‚ùïüëã physical user controls it; üêû added "volatile"

// Sequence number/lock for time-related fields.
// When value is odd, set of fields is being updated. See "Cross-fields coherence via sequence numbers" below for
// details. List of protected fields, in currently utilized update order (not everything listed is always updated):
// ü°ëSystemTime, ü°ëInterruptTime, ü°ìBaselineSystemTimeQpc, ü°ìBaselineInterruptTimeQpc , [ü°ëTickCountQuad].
// And on the rare "time-only" codepath we have slightly different update order and 2 more fields:
// ü°ìBaselineSystemTimeQpc, ü°ëSystemTime, ü°ìQpcSystemTimeIncrement, ü°ìQpcSystemTimeIncrementShift.
volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TimeUpdateLock;              // 340 ‚ùï changes twice each clock interrupt; üêû added "volatile"

// Value retrieved via nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>() right before the ü°ëSystemTime field update, and used to
// compute new value of ü°ëSystemTime. Associated subfractional parts accumulator: nt!KiSystemTimeErrorAccumulator.
volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineSystemTimeQpc;       // 348 ‚ùï updates together with ü°ëSystemTime; üêû added "volatile"

// Value retrieved via nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>() right before the ü°ëInterruptTime field update, and used to
// compute new value of ü°ëInterruptTime. Since on the "system tick" codepath ü°ëInterruptTime and ü°ëSystemTime are
// updated together, this field most often holds very same Qpc value as ü°ëBaselineSystemTimeQpc.
// Associated subfractional parts accumulator: nt!KiInterruptTimeErrorAccumulator.
volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineInterruptTimeQpc;    // 350 ‚ùï updates together with ü°ëInterruptTime; üêû added "volatile"

// Fractional part of the Multiplier for computing new ü°ëSystemTime: SystemTime += QpcDelta √ó Multiplier.
// This field might change at runtime to speedup/slowdown the clock; that avoids sudden time jumps during timesync.
// Such clockrate change does NOT affect performance: rate of ü°ëInterruptTime and osticks/GetTickCount is constant.
// It's common to see value 0x8000'0000'0000'0000 here; with fixed scaler of -0x40 that's effectively 0.5.
// See "Time updates via Qpc deltas and increments" below for details on the System Time computation.
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcSystemTimeIncrement;               // 358 ‚ó∑ might change at runtime for a bit (supposedly rare)

// Fractional part of the Multiplier for computing new ü°ëInterruptTime: InterruptTime += QpcDelta √ó Multiplier.
// Set once during boot, in nt!KiSetupTimeIncrement. Remains constant afterwards.
// It's common to see value 0x8000'0000'0000'0000 here; with fixed scaler of -0x40 that's effectively 0.5.
// See "Time updates via Qpc deltas and increments" below for details on the Interrupt Time computation.
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcInterruptTimeIncrement;            // 360 ùçå

// Extra scaling bits for computing new ü°ëSystemTime; scaler = -0x40 + ü°óQpcSystemTimeIncrementShift.
// Just like with ü°ëQpcSystemTimeIncrement, this field *might change* at runtime to speedup or slowdown the clock.
// It's common to see value 1 here; when const-scaled ü°ëQpcSystemTimeIncrement is effectively 0.5, these two
// fields basically cancel each other out. See "Time updates via Qpc deltas and increments" below for details.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcSystemTimeIncrementShift;              // 368 ‚ó∑ might change at runtime for a bit (supposedly rare)

// Extra scaling bits for computing new ü°ëInterruptTime; scaler = -0x40 + ü°óQpcInterruptTimeIncrementShift.
// Just like with ü°ëQpcInterruptTimeIncrement, this field *set once* during boot, in nt!KiSetupTimeIncrement.
// It's common to see value 1 here; when const-scaled ü°ëQpcInterruptTimeIncrement is effectively 0.5, these two
// fields basically cancel each other out. See "Time updates via Qpc deltas and increments" below for details.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcInterruptTimeIncrementShift;           // 369 ùçå

// Number of "powered on" [logical] processors. Each SMT core counts as a separate processor.
// This value can swing a lot at runtime as OS parks CPUs to save power. Always ‚â§ ü°ìActiveProcessorCount.
// Most often used to avoid spins in locks when there's only one running processor (by user and kernel mode alike).
volatile <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UnparkedProcessorCount;         // 36A ‚ùï may change a lot at runtime; üêû added "volatile"

// Bitmask of enclave features supported on this system. Used by ntdll!<a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a>.
// Out of the whole 128-bit value, only 3 bits seem to be currently defined.
// bit1/bit2: SGX1/SGX2 leaf funcs enabled (and locked in that state).
// bit8: 1 if LoaderBlock-&gt;Extension.IumEnabled (can be 1 in root and non-root partitions; 0 if Hyper-V is off).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EnclaveFeatureMask[4];                    // 36C ùçå‚ôª

// Current coverage round for telemetry based coverage (sequence number).
// Set to 1 at boot in nt!EtwpInitializeCoverage ‚Äì and most of the time stays like that. One way to increment this
// value: end the coverage round via <a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessTelemetryCoverage, {.LastCoveredRound=-4});
// however, that needs enabled Administrators group in client's token.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryCoverageRound;                   // 37C üëã

// Used for ETW UMGL (user-mode global logging). Indices are ETW_UMGL_INDEX_* constants (see nt!EtwpUmglProviders):
// <a href="etw_umgl_index_heap" title="#define ETW_UMGL_INDEX_HEAP 0">ETW_UMGL_INDEX_HEAP</a> = 0 (nt!<a href="heapguid" title="DEFINE_GUID( /* 222962ab-6180-4b88-a825-346b75f2a24a */&#10;    HeapGuid,&#10;    0x222962ab,&#10;    0x6180,&#10;    0x4b88,&#10;    0xa8, 0x25, 0x34, 0x6b, 0x75, 0xf2, 0xa2, 0x4a&#10;    );">HeapGuid</a>), <a href="etw_umgl_index_critsec" title="#define ETW_UMGL_INDEX_CRITSEC 1">ETW_UMGL_INDEX_CRITSEC</a> = 1 (nt!<a href="critsecguid" title="DEFINE_GUID( /* 3AC66736-CC59-4cff-8115-8DF50E39816B */&#10;    CritSecGuid,&#10;    0x3ac66736,&#10;    0xcc59,&#10;    0x4cff,&#10;    0x81, 0x15, 0x8d, 0xf5, 0xe, 0x39, 0x81, 0x6b&#10;    );">CritSecGuid</a>), etc.
// Each <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> is actually a 2-byte <a href="etw_umgl_key" title="typedef struct _ETW_UMGL_KEY&#10;{&#10;    UCHAR LoggerId;&#10;    UCHAR Flags;&#10;} ETW_UMGL_KEY, *PETW_UMGL_KEY;">ETW_UMGL_KEY</a> structure: byte0 is LoggerId, byte1 is "MatchAnyKeyword" Flags.
// <a href="nttracecontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtTraceControl(&#10;    _In_ ETWTRACECONTROLCODE FunctionCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtTraceControl</a>(EtwSendDataBlock) -&gt; ... -&gt; nt!EtwpEnableDisableSpecialGuids() -&gt; nt!EtwpEnableDisableUMGL().
// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.UserModeGlobalLogger. See ETW_UMGL_* macro and defines for more.
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UserModeGlobalLogger[0x10];              // 380 üëã limited adjustability, specific conditions required

// When bit0 is set, "GlobalFlag" bits <a href="flg_application_verifier" title="#define FLG_APPLICATION_VERIFIER 0x00000100 // u">FLG_APPLICATION_VERIFIER</a>|<a href="flg_heap_page_allocs" title="#define FLG_HEAP_PAGE_ALLOCS 0x02000000 // u">FLG_HEAP_PAGE_ALLOCS</a> (0x0200'0100) will be read
// from HKCU IFEO (as long as both flagsü°ï absent in HKLM IFEO, and it's not a secure process). These two verifier
// bits are read by ntdll during process init, saved in <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.GlobalFlags.
// This field does NOT affect other IFEO values or GlobalFlag bits; they're still read from HKLM and PE LoadConfig.
// Bit0 initialized during boot in nt!VerifierInitSystem, from bit0 of nt!ViImageExecutionOptions (in turn, from
// CCS\Control\Session Manager‚ÇÑImageExecutionOptions). This entire field can be adjusted at runtime by clients with
// SeTcb privilege, via <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemImageFileExecutionOptionsInformation).
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ImageFileExecutionOptions;                // 3A0 üëã‚ôª changeable at runtime (but normally static)

// Sequence number of the nt!MUIRegistryInfo structure, which holds UI languages info. Starts at 0 during boot.
// Only changes when usermode calls <a href="ntgetmuiregistryinfo" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtGetMUIRegistryInfo(&#10;    _In_ ULONG Flags,&#10;    _Inout_ PULONG DataSize,&#10;    _Out_ PVOID Data&#10;    );">NtGetMUIRegistryInfo</a>(Flags |= 8); that increments this field, and also assigns
// updated value to nt!MUIRegistryInfo.Generation (when nt!MUIRegistryInfo exists). Normally the first and only
// increment is done by the first Winlogon.exe. No rights nor privileges required to perform such increment.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LangGenerationCount;                      // 3A4 üëã changeable at runtime (but mostly static)

// Zero. "Available for reuse".
<a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Reserved4;                            // 3A8 ùçå‚ôª

// Under certain conditions (e.g. after hibernation), OS makes ü°ëInterruptTime to jump forward (OS "biases" it).
// This field accumulates all such adjustments, enabling clients to get unadulterated Interrupt Time.
// To get such unadulterated Unbiased Interrupt Time, take ü°ëInterruptTime, and subtract ü°óInterruptTimeBias from it.
// 
// ‚ö†Ô∏è Field is NOT protected via ü°ëTimeUpdateLock. To ensure coherence between this field and ü°ëInterruptTime,
// read this value first, then ü°ëInterruptTime, then this value again ‚Äì and check it hasn't changed.
// Note ntdll!<a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a> does a bit more: it wraps that sequence into a pair of reads of exported
// ntdll!RtlpFreezeTimeBias [where OS accumulates Deep Freeze time for current process], and subtracts that too.
//
// Updated on these paths:
// 1) nt!KeAdjustInterruptTime. Mostly on exit from sleep/hibernate; also if "TickcountRolloverDelay" ü°ë used.
// 2) nt!KiAdjustTimersAfterDripsExit. DRIPS is Deepest Runtime Idle Platform State. Tricky: only increments
// if OS spent more than nt!KeTimerRebaseThresholdOnDripsExit consecutive seconds in the current DRIPS state.
// That var is from CCS\Control\Power‚ÇÑTimerRebaseThresholdOnDripsExit; by default it's 45 seconds.
volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> InterruptTimeBias;           // 3B0 ‚ó∑üëã rare updates on power events; "manual" via timed sleep

// Somewhat similar to ü°ëInterruptTimeBias. Accumulates bias for the Qpc value. But there's important difference:
// ü°ëInterruptTime already incorporates bias, so client-oriented api <a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a> has to *subtract*
// ü°ëInterruptTimeBias; but raw Qpc value does NOT incorporate bias, so <a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a> has to *add*
// ü°óQpcBias! Yes, it's almost like OS devs mixed up bias inclusion cases to do some extra math on hot codepaths.
//
// Unit is ü°ëQpcFrequency‚Åª¬π seconds. When nt!HalpPerformanceCounter type is Processor or Hypervisor,
// frequency is 10 MHz; making the unit exactly one centum (100 ns), same as ü°ëInterruptTimeBias.
// Updated in nt!HalpTimerPropagateQpcBiasUpdate, on rare power-related events, like sleep/hibernation.
// For TimerHypervisor and TimerGit, bias value comes directly from REGISTERED_TIMER.TimeBias. For TimerProcessor
// that same TimeBias field is scaled to 10 MHz first.
// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcbias" title="#define GlobalDataIdQpcBias 18 // KUSER_SHARED_DATA-&gt;QpcBias">GlobalDataIdQpcBias</a>[=18]).
volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcBias;                     // 3B8 ‚ó∑üëã rare updates on power events; "manual" via timed sleep

// Number of [logical] processors in the system. Each SMT core counts as a separate processor. Field name is mildly
// confusing (and digging deeper only makes it worse). Value mirrors unexported nt!KeNumberProcessors; don't mistake
// it for the *exported* "KeNumberProcessors", which is actually nt!KeNumberProcessorsGroup0 variable (¬ø‚∏Æ?).
// Also don't mix it up with nt!KeMaximumProcessorsü°ñ, nor with nt!KeActiveProcessors (set of <a href="kaffinity_ex" title="typedef struct _KAFFINITY_EX&#10;{&#10;    USHORT Count;&#10;    USHORT Size;&#10;    ULONG Reserved;&#10;    union&#10;    {&#10;        ULONG_PTR Bitmap[1];&#10;        ULONG_PTR StaticBitmap[32];&#10;    } DUMMYUNIONNAME;&#10;} KAFFINITY_EX, *PKAFFINITY_EX;">KAFFINITY_EX</a> masks).
// ‚Æû TLDR: just drop "Active" from the name. Use ü°ëUnparkedProcessorCount for count of CPUs actually running atm.
// Field set during boot. On some server SKUs you can add CPUs dynamically: on such systems this value may increase
// at runtime. But it will never decrease, and will never exceed nt!KeMaximumProcessors during current boot session.
// Absolute max # of processors: ws2022/win11: 0x800 (2048) [confirmed 24H2]; win10 22H2: 0x500 (1280).
volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveProcessorCount;            // 3C0 ‚ó∑ rare increments at runtime possible; üêû added "volatile"

// Number of processor groups in the system. Mirrors nt!KiActiveGroups.
// On some server SKUs you can add CPUs dynamically: on such systems this value may increase at runtime.
// Note you can force-split CPUs into multiple groups on boot: "bcdedit /set GroupSize 2" to get N groups with 2
// CPUs each. Absolute max # of CPU groups for any OS is 0x20 (32) [confirmed 24H2].
volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ActiveGroupCount;                // 3C4 ‚ó∑ rare increments possible

// Zero. "Available for reuse".
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved9;                                // 3C5 ùçå‚ôª

// Modern OS treats this union as bitmask/flags governing ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() behavior.
// See SHARED_GLOBAL_FLAGS_QPC_BYPASS_* flags. Only 7 bits are in use, all overlaid with ü°óQpcBypassEnabled byte.
//   0/0001: _ENABLED: usermode code can bypass <a href="ntqueryperformancecounter" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter,&#10;    _Out_opt_ PLARGE_INTEGER PerformanceFrequency&#10;    );">NtQueryPerformanceCounter</a> syscall, retrieve Qpc perfcounter by
//     transforming rdtsc/rdtscp value or ARM64_CNTVCT_EL0 register. When this bit is 0, all others are zeroed too.
//     On x86 you can force bit to 0 with "bcdedit /set UsePlatformClock yes" (don't mixup with "UsePlatformTick").
//   1/0002: _USE_HV_PAGE: use bias and multiplier from HV_REFERENCE_TSC_PAGE struct (aka "huser", the page you get
//     via SystemHypervisorSharedPageInformation infoclass). It's the most common case; hypervisor is NOT required.
//   2/0004: _DISABLE_32BIT: 32-bit code (wow64) should not attempt to bypass the syscall.
//   3/0008: ‚Äì unused.
//   4/0010: _USE_MFENCE: "mfence" instruction before rdtsc. For AMD CPUs where rdtscp can't be used.
//           Kernel mode may use (KPRCB.CpuVendor == CPU_AMD) instead. But rdtscp (bit7 ü°ì) always outweighs it.
//   5/0020: _USE_LFENCE: "lfence" instruction before rdtsc. For Intel CPUs where rdtscp can't be used.
//           Kernel mode may use (KPRCB.CpuVendor == CPU_INTEL) instead. But rdtscp (bit7 ü°ì) always outweighs it.
//   6/0040: _A73_ERRATA: read ARM64_CNTVCT_EL0 twice (barrier'd); if bit32 changed, use the first reading.
//   7/0080: _USE_RDTSCP: instead of rdtsc, use [partially serializing] "rdtscp". For CPUs since Nehalem.
//           Kernel mode may disregard it and use ü°ëProcessorFeatures[PF_RDTSCP_INSTRUCTION_AVAILABLE] instead.
// 
// Severely simplified pseudocode for qpc retrieval in <a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a> (assuming syscall bypass enabled):
//   tsc = rdtsc()   [or rdtscp(), or ReadStatusReg(ARM64_CNTVCT_EL0)]
//   qpc = kuser.QpcBias + (kuser.QpcData &amp; _USE_HV_PAGE)? tsc √ó huser.TscScale √ó 2‚Åª‚Å∂‚Å¥ + huser.TscOffset: tsc
union
{
// Entire field settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcdata" title="#define GlobalDataIdQpcData 17 // KUSER_SHARED_DATA-&gt;QpcData">GlobalDataIdQpcData</a>[=17]).
<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;                             // 3C6 ‚ó∑
struct
{
// Bitflags governing ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() behavior, described above.
// On old OS [before win10 1709, RS3] it was a bool, that role is now taken by bit0.
// This byte settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(QpcBypassEnabled[=16]).
volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;        // 3C6 ‚ó∑ won't really change, except possibly on OS live migration

// Zero. Unused on modern OS. On old OS [before win10 1709, RS3] it was used as a bitshift value for the
// raw perfcounter: ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() =&gt; (rdtsc() + ü°ëQpcBias) &gt;&gt; ü°óQpcShift [before 1709].
// But that made Qpc rate very different across systems; nowadays OS uses much more precise scaling.
<a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcShift;                         // 3C7 ùçå‚ôª
};
};

// Pair (ü°óTimeZoneBiasEffectiveStart, ü°óTimeZoneBiasEffectiveEnd) form a range for ü°ëSystemTime when
// ü°ëTimeZoneBias is valid. That is, if ü°ëSystemTime is in that range, LocalTime = (ü°ëSystemTime - ü°ëTimeZoneBias).
// That's true regardless of DST (it's already included in ü°ëTimeZoneBias). If both range ends are 0, the range
// spans *all* time. For time outside the range, local time has to be computed manually.
// Fields can be updated at runtime (e.g. when range end is reached, or timezone changed).
// Coherence in relation to ü°ëTimeZoneBias during fields update ensured via ü°ëTimeZoneBiasStamp.
// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveStart, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveEnd.
// 
// Normally, ü°óTimeZoneBiasEffectiveStart is equal to the snapshot of ü°ëSystemTime at one of these moments:
// a) system boot + 5..15 seconds; b) system date/time change; c) timezone change; d) crossing the DST line (i.e.
// ü°ëSystemTime reached ü°óTimeZoneBiasEffectiveEnd, so the new range has to be established).
// ü°óTimeZoneBiasEffectiveEnd updated together with ü°óTimeZoneBiasEffectiveStart. It's set to either the next DST
// line or to (end of year + ü°ëTimeZoneBias), whichever is earlier.
// Adjustable ‚Äì within a certain amount ‚Äì by clients with SeTimeZone privilege, together with ü°ëTimeZoneBias.
LARGE_INTEGER TimeZoneBiasEffectiveStart;       // 3C8 ‚ó∑üëã
LARGE_INTEGER TimeZoneBiasEffectiveEnd;         // 3D0 ‚ó∑üëã

// Extended processor state configuration.
// Initialized once at boot in nt!KiInitializeXSaveConfiguration, based on features actually supported by cpu,
// and features disabled via LoaderBlock ("bcdedit /set xsaveDisable|xsavePolicy|xsaveRemoveFeature"). Since
// win11 24H2, ARM64 oskernel tries to ignore this field, uses its own ü°ìXStateArm64 instead. But even though ARM64
// doesn't init it, XState.EnabledFeatures still used sometimes (e.g. nt!PopHandleNextState) due to bugs/leftovers.
XSTATE_CONFIGURATION XState;                    // 3D8 ùçå‚ôª used now, but really should not be in kuser

// Mirrors global value read via exported nt!<a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a> (part of nt!CmFcSystemManager).
// Starts at 1 at boot, increments each time feature config changes. However, there is so called
// "SwapReferenceIndex" (RtlGetSwapReferenceIndex), changing which might bring in parallel global value.
// This field is what's referred to as <a href="rtl_feature_change_stamp" title="typedef ULONGLONG RTL_FEATURE_CHANGE_STAMP, *PRTL_FEATURE_CHANGE_STAMP;">RTL_FEATURE_CHANGE_STAMP</a>/ChangeStamp in structures for
// <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemFeatureConfigurationInformation). Note these are NOT "Optional Windows Features";
// rather these are A/B features (and ongoing security fix "features"), adjustable via e.g. opensource ViveTool.
// ‚ö†Ô∏è Size of ü°ëXState increased by 0x10 in WS2022, changing this field offset from 0x710 to 0x720.
<a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> FeatureConfigurationChangeStamp;   // 720; offset is 0x710 on win10 22H2 and earlier OS

// Zero.
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Spare;                                    // 72C ùçå‚ôª

// Mirrors nt!KePointerAuthMask. Only used for ARM64, zero on x64. Initialized once at boot.
// Contains a mask to apply to a pointer value to extract authentication "PAC" bits together with a sign
// bit (highest bit preceding the PAC). If PAC is not used, or PAC size is not exactly 8 bits, value is simply
// zero (confirmed win11 24H2 and earlier). So the only values possible are 0 and 0xFF80'0000'0000'0000 [2025-08].
<a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a> UserPointerAuthMask;                     // 730 ùçå available since win11 22H2

// Following fields are there since win11 24H2.
#ifdef _M_ARM64
// Extended processor state configuration specifically for ARM64.
// ARM64 OS kernels before win11 24H2 were less greedy and simply used ü°ëXState.
XSTATE_CONFIGURATION XStateArm64;               // 738 ùçå‚ôª used now, but really should not be in kuser
#else
// "The reserved space for other architectures is not available for reuse".
<a href="uint" title="typedef unsigned int UINT;">UINT</a> Reserved10[0xD2];                          // 738 ùçå‚ôª
#endif
};  // struct _KUSER_SHARED_DATA, size: 0xA80
</code></pre>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ntddk-kuser_shared_data)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>
<p>This topic describes the <strong>KUSER_SHARED_DATA</strong> structure.</p>
<h2>Members</h2>
<h3><code>TickCountLowDeprecated</code></h3>
<p>Current low 32-bit of tick count.</p>
<h3><code>TickCountMultiplier</code></h3>
<p>Tick count multiplier.</p>
<h3><code>InterruptTime</code></h3>
<p>Current 64-bit interrupt time in 100ns units.</p>
<h3><code>SystemTime</code></h3>
<p>Current 64-bit system time in 100ns units.</p>
<h3><code>TimeZoneBias</code></h3>
<p>Current 64-bit time zone bias.</p>
<h3><code>ImageNumberLow</code></h3>
<p>Low image magic number for the host system.</p>
<h3><code>ImageNumberHigh</code></h3>
<p>High image magic number for the host system.</p>
<h3><code>NtSystemRoot[260]</code></h3>
<p>Copy of system root in unicode. This field must be accessed via the <strong><a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a></strong> API for an accurate result.</p>
<h3><code>MaxStackTraceDepth</code></h3>
<p>Maximum stack trace depth if tracing enabled.</p>
<h3><code>CryptoExponent</code></h3>
<p>Crypto exponent value.</p>
<h3><code>TimeZoneId</code></h3>
<p>Time zone ID.</p>
<h3><code>LargePageMinimum</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>LargePageMinimum</strong>.</p>
<h3><code>AitSamplingValue</code></h3>
<p>This value controls the AIT sampling rate.</p>
<h3><code>AppCompatFlag</code></h3>
<p>This value controls switchback processing.</p>
<h3><code>RNGSeedVersion</code></h3>
<p>Current kernel root RNG state seed version.</p>
<h3><code>GlobalValidationRunlevel</code></h3>
<p>This value controls assertion failure handling.</p>
<h3><code>TimeZoneBiasStamp</code></h3>
<p>Defines the <strong><a href="long" title="typedef long LONG;">LONG</a></strong> member <strong>TimeZoneBiasStamp</strong>.</p>
<h3><code>NtBuildNumber</code></h3>
<p>The shared collective build number undecorated with C or F. <strong>GetVersionEx</strong> hides the real number.</p>
<h3><code>NtProductType</code></h3>
<p>Product type. This field must be accessed via the <strong><a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a></strong> API for an accurate result.</p>
<h3><code>ProductTypeIsValid</code></h3>
<p>Defines the <strong>BOOLEAN</strong> member <strong>ProductTypeIsValid</strong>.</p>
<h3><code>Reserved0[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>NativeProcessorArchitecture</code></h3>
<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member <strong>NativeProcessorArchitecture</strong>.</p>
<h3><code>NtMajorVersion</code></h3>
<p>The NT major version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>
<h3><code>NtMinorVersion</code></h3>
<p>The NT minor version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>
<h3><code>ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>]</code></h3>
<p>Processor features.</p>
<h3><code>Reserved1</code></h3>
<p>Reserved for future use.</p>
<h3><code>Reserved3</code></h3>
<p>Reserved for future use.</p>
<h3><code>TimeSlip</code></h3>
<p>Time slippage while in debugger.</p>
<h3><code>AlternativeArchitecture</code></h3>
<p>Alternative system architecture. For example, NEC PC98xx on x86.</p>
<h3><code>BootId</code></h3>
<p>Boot sequence, incremented for each boot attempt by the OS loader.</p>
<h3><code>SystemExpirationDate</code></h3>
<p>If the system is an evaluation unit, the following field contains the date and time that the evaluation unit expires. A value of 0 indicates that there is no expiration. A non-zero value is the UTC absolute time that the system expires.</p>
<h3><code>SuiteMask</code></h3>
<p>Suite support. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for an accurate result.</p>
<h3><code>KdDebuggerEnabled</code></h3>
<p>TRUE if a kernel debugger is connected/enabled.</p>
<h3><code>MitigationPolicies</code></h3>
<p>Mitigation policies.</p>
<h3><code>NXSupportPolicy</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>NXSupportPolicy</strong>.</p>
<h3><code>SEHValidationPolicy</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>SEHValidationPolicy</strong>.</p>
<h3><code>CurDirDevicesSkippedForDlls</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>CurDirDevicesSkippedForDlls</strong>.</p>
<h3><code>Reserved</code></h3>
<p>Reserved for future use.</p>
<h3><code>CyclesPerYield</code></h3>
<p>Measured duration of a single processor yield, in cycles. This is used by lock packages to determine how many times to spin waiting for a state change before blocking.</p>
<h3><code>ActiveConsoleId</code></h3>
<p>Current console session Id. Always zero on non-TS systems. This field must be accessed via the <strong><a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a></strong> API for an accurate result.</p>
<h3><code>DismountCount</code></h3>
<p>Force-dismounts cause handles to become invalid. Rather than always probe handles, a serial number of dismounts is maintained that clients can use to see if they need to probe handles.</p>
<h3><code>ComPlusPackage</code></h3>
<p>This field indicates the status of the 64-bit COM+ package on the system. It indicates whether the Intermediate Language (IL) COM+ images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.</p>
<h3><code>LastSystemRITEventTickCount</code></h3>
<p>Time in tick count for system-wide last user input across all terminal sessions. For MP performance, it is not updated all the time (for example, once a minute per session). It is used for idle detection.</p>
<h3><code>NumberOfPhysicalPages</code></h3>
<p>Number of physical pages in the system. This can dynamically change as physical memory can be added or removed from a running system.</p>
<h3><code>SafeBootMode</code></h3>
<p>True if the system was booted in safe boot mode.</p>
<h3><code>VirtualizationFlags</code></h3>
<p>Virtualization flags.</p>
<h3><code>ArchStartedInEl2</code></h3>
<p>Keep this bitfield in sync with the one in arc.w.</p>
<h3><code>QcSlIsSupported</code></h3>
<p>Keep this bitfield in sync with the one in arc.w.</p>
<h3><code>Reserved12[2]</code></h3>
<p>Reserved for future use.</p>
<h3><code>DUMMYUNIONNAME2</code></h3>
<p>This is a packed bitfield that contains various flags concerning the system state. They must be manipulated using interlocked operations. <strong>DbgMultiSessionSku</strong> must be accessed via the <strong><a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a></strong> API for an accurate result.</p>
<h3><code>DUMMYUNIONNAME2.SharedDataFlags</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>SharedDataFlags</strong>.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2</code></h3>
<p>Defines the <strong>DUMMYSTRUCTNAME2</strong> structure.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgErrorPortPresent</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgElevationEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgVirtEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgInstallerDetectEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgLkgEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgDynProcessorEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgConsoleBrokerEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgSecureBootEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiSessionSku</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiUsersInSessionSku</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgStateSeparationEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.SpareBits</code></h3>
<p>For the debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DataFlagsPad[1]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>DataFlagsPad</strong>.</p>
<h3><code>TestRetInstruction</code></h3>
<p>Depending on the processor, the code for fast system call will differ. This field is only used on 32-bit systems.</p>
<h3><code>QpcFrequency</code></h3>
<p>Defines the <strong><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></strong> member <strong>QpcFrequency</strong>.</p>
<h3><code>SystemCall</code></h3>
<p>On AMD64, this value is initialized to a nonzero value if the system operates with an altered view of the system service call mechanism.</p>
<h3><code>Reserved2</code></h3>
<p>Reserved for future use.</p>
<h3><code>FullNumberOfPhysicalPages</code></h3>
<p>Reserved for future use.</p>
<h3><code>SystemCallPad[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>DUMMYUNIONNAME3</code></h3>
<p>The 64-bit tick count.</p>
<h3><code>DUMMYUNIONNAME3.TickCount</code></h3>
<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>TickCount</strong>.</p>
<h3><code>DUMMYUNIONNAME3.TickCountQuad</code></h3>
<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>TickCountQuad</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME</code></h3>
<p>Defines <strong>DUMMYSTRUCTNAME</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.ReservedTickCountOverlay[3]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>ReservedTickCountOverlay</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.TickCountPad[1]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>TickCountPad</strong>.</p>
<h3><code>Cookie</code></h3>
<p>Cookie for encoding pointers system wide.</p>
<h3><code>CookiePad[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>ConsoleSessionForegroundProcessId</code></h3>
<p>Client id of the process having the focus in the current active console session id. This field must be accessed via the <strong><a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a></strong> API for an accurate result.</p>
<h3><code>TimeUpdateLock</code></h3>
<p>Placeholder for the (internal) time update lock. This data is used to implement the precise time services. It is aligned on a 64-byte cache-line boundary and arranged in the order of typical accesses.</p>
<h3><code>BaselineSystemTimeQpc</code></h3>
<p>The performance counter value used to establish the current system time.</p>
<h3><code>BaselineInterruptTimeQpc</code></h3>
<p>The performance counter value used to compute the last interrupt time.</p>
<h3><code>QpcSystemTimeIncrement</code></h3>
<p>The scaled number of system time seconds represented by a single performance count (this value may vary to achieve time synchronization).</p>
<h3><code>QpcInterruptTimeIncrement</code></h3>
<p>The scaled number of interrupt time seconds represented by a single performance count (this value is constant after the system is booted).</p>
<h3><code>QpcSystemTimeIncrementShift</code></h3>
<p>The scaling shift count applied to the performance counter system time increment.</p>
<h3><code>QpcInterruptTimeIncrementShift</code></h3>
<p>The scaling shift count applied to the performance counter interrupt time increment.</p>
<h3><code>UnparkedProcessorCount</code></h3>
<p>The count of unparked processors.</p>
<h3><code>EnclaveFeatureMask[4]</code></h3>
<p>A bitmask of enclave features supported on this system. This field must be accessed via the <strong><a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a></strong> API for an accurate result.</p>
<h3><code>TelemetryCoverageRound</code></h3>
<p>Current coverage round for telemetry based coverage.</p>
<h3><code>UserModeGlobalLogger[16]</code></h3>
<p>The following field is used for ETW user mode global logging (UMGL).</p>
<h3><code>ImageFileExecutionOptions</code></h3>
<p>Settings that can enable the use of Image File Execution Options from HKCU in addition to the original HKLM.</p>
<h3><code>LangGenerationCount</code></h3>
<p>Generation of the kernel structure holding system language information.</p>
<h3><code>Reserved4</code></h3>
<p>Reserved for future use.</p>
<h3><code>InterruptTimeBias</code></h3>
<p>Current 64-bit interrupt time bias in 100ns units.</p>
<h3><code>QpcBias</code></h3>
<p>Current 64-bit performance counter bias, in performance counter units before the shift is applied.</p>
<h3><code>ActiveProcessorCount</code></h3>
<p>Number of active processors.</p>
<h3><code>ActiveGroupCount</code></h3>
<p>Number of active groups.</p>
<h3><code>Reserved9</code></h3>
<p>Reserved for future use.</p>
<h3><code>QpcData</code></h3>
<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member QpcData.</p>
<h3><code>QpcBypassEnabled</code></h3>
<p>A boolean indicating whether performance counter queries can read the counter directly (bypassing the system call).</p>
<h3><code>QpcReserved</code></h3>
<p>Reserved for future use.</p>
<h3><code>TimeZoneBiasEffectiveStart</code></h3>
<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveStart</strong>.</p>
<h3><code>TimeZoneBiasEffectiveEnd</code></h3>
<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveEnd</strong>.</p>
<h3><code>XState</code></h3>
<p>Extended processor state configuration.</p>
<h3><code>FeatureConfigurationChangeStamp</code></h3>
<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>FeatureConfigurationChangeStamp</strong>.</p>
<h3><code>Spare</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>Spare</strong>.</p>
<h3><code>UserPointerAuthMask</code></h3>
<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>UserPointerAuthMask</strong>.</p>
<h2>Remarks</h2>
<h2>See also</h2>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddk/ns-ntddk-kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
