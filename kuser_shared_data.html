<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="KUSER_SHARED_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>KUSER_SHARED_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            KUSER_SHARED_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTEXAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)

</span><span class="ntdoc-code-intro language-cpp">/**
 * The KUSER_SHARED_DATA structure contains information shared with user-mode.
 *
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data
 */
</span><span class="ntdoc-code-body language-cpp">typedef struct _KUSER_SHARED_DATA
{
    //
    // Current low 32-bit of tick count and tick count multiplier.
    //
    // N.B. The tick count is updated each time the clock ticks.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountLowDeprecated;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountMultiplier;

    //
    // Current 64-bit interrupt time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> InterruptTime;

    //
    // Current 64-bit system time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> SystemTime;

    //
    // Current 64-bit time zone bias.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TimeZoneBias;

    //
    // Support image magic number range for the host system.
    //
    // N.B. This is an inclusive range.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberLow;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberHigh;

    //
    // Copy of system root in unicode.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a> API for
    //      an accurate result.
    //

    WCHAR NtSystemRoot[260];

    //
    // Maximum stack trace depth if tracing enabled.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaxStackTraceDepth;

    //
    // Crypto exponent value.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CryptoExponent;

    //
    // Time zone ID.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeZoneId;

    //
    // Minimum size of a large page on the system, in bytes.
    //
    // N.B. Returned by GetLargePageMinimum() function.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LargePageMinimum;

    //
    // This value controls the Application Impact Telemetry (AIT) Sampling rate.
    //
    // This value determines how frequently the system records AIT events,
    // which are used by the Application Experience and compatibility
    // subsystems to evaluate application behavior, performance, and
    // potential compatibility issues.
    //
    // Lower values increase sampling frequency, while higher values reduce it.
    // The kernel updates this field as part of its internal telemetry and
    // heuristics logic.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AitSamplingValue;

    //
    // This value controls Application Compatibility (AppCompat) switchback processing.
    //

    union
    {
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AppCompatFlag;
        struct
        {
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SwitchbackEnabled : 1;    // Basic switchback processing
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ExtendedHeuristics : 1;   // Extended switchback heuristics
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryFallback : 1;    // Telemetry-driven fallback
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved : 29;
        } AppCompatFlags;
    };

    //
    // Current Kernel Root RNG state seed version
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> RNGSeedVersion;

    //
    // This value controls assertion failure handling.
    //
    // Historically (prior to Windows 10), this value was also used by
    // Code Integrity (CI), AppLocker, and related security components to
    // determine the minimum validation requirements for executable images,
    // drivers, and privileged operations.
    //
    // In modern Windows versions, this field is used primarily by the kernel&#x27;s
    // diagnostic and validation infrastructure to decide how assertion failures
    // should be handled (e.g., logging, debugger break-in, or bugcheck).

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GlobalValidationRunlevel;

    //
    // Monotonic stamp incremented by the kernel whenever the system&#x27;s
    // time zone bias value changes.
    //
    // N.B. This field must be accessed via the <a href="rtlgetsystemtimeandbias" title="NTSYSAPI&#10;KSYSTEM_TIME&#10;NTAPI&#10;RtlGetSystemTimeAndBias(&#10;    _Out_ KSYSTEM_TIME TimeZoneBias,&#10;    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveStart,&#10;    _Out_opt_ PLARGE_INTEGER TimeZoneBiasEffectiveEnd&#10;    );">RtlGetSystemTimeAndBias</a> API for
    //      an accurate result.
    // This value is read before and after accessing the bias fields to determine
    // whether the time zone data changed during the read. If the stamp differs,
    // the caller must re-read the bias values to ensure consistency.
    //

    volatile <a href="long" title="typedef long LONG;">LONG</a> TimeZoneBiasStamp;

    //
    // The shared collective build number undecorated with C or F.
    // GetVersionEx hides the real number
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtBuildNumber;

    //
    // Product type.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a> API for
    //      an accurate result.
    //

    <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a> NtProductType;
    BOOLEAN ProductTypeIsValid;
    BOOLEAN Reserved0[1];

    //
    // Native hardware processor architecture of the running system.
    //
    // N.B. User-mode components read this field to determine the true system
    // architecture, especially in WOW64 scenarios where the process architecture
    // differs from the native one.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> NativeProcessorArchitecture;

    //
    // The NT Version.
    //
    // N. B. Note that each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the
    //       process is running with an altered view of the system version,
    //       the following two fields are used to correctly identify the
    //       version
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMajorVersion;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMinorVersion;

    //
    // Processor features.
    //

    BOOLEAN ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];

    //
    // Reserved fields - do not use.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaximumUserModeAddressDeprecated; // Deprecated, use SystemBasicInformation instead.
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemRangeStartDeprecated; // Deprecated, use SystemRangeStartInformation instead.

    //
    // Time slippage while in debugger.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeSlip;

    //
    // Alternative system architecture, e.g., NEC PC98xx on x86.
    //

    <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;

    //
    // Boot sequence, incremented for each boot attempt by the OS loader.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BootId;

    //
    // If the system is an evaluation unit, the following field contains the
    // date and time that the evaluation unit expires. A value of 0 indicates
    // that there is no expiration. A non-zero value is the UTC absolute time
    // that the system expires.
    //

    LARGE_INTEGER SystemExpirationDate;

    //
    // Suite support.
    //
    // N.B. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for
    //      an accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SuiteMask;

    //
    // TRUE if a kernel debugger is connected/enabled.
    //

    BOOLEAN KdDebuggerEnabled;

    //
    // Mitigation policies.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
        };
    };

    //
    // Measured duration of a single processor yield, in cycles. This is used by
    // lock packages to determine how many times to spin waiting for a state
    // change before blocking.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> CyclesPerYield;

    //
    // Current console session Id. Always zero on non-TS systems.
    //
    // N.B. This field must be accessed via the <a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a> API for an
    //      accurate result.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveConsoleId;

    //
    // Force-dismounts cause handles to become invalid. Rather than always
    // probe handles, a serial number of dismounts is maintained that clients
    // can use to see if they need to probe handles.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DismountCount;

    //
    // This field indicates the status of the 64-bit COM+ package on the
    // system. It indicates whether the Intermediate Language (IL) COM+
    // images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ComPlusPackage;

    //
    // Time in tick count for system-wide last user input across all terminal
    // sessions. For MP performance, it is not updated all the time (e.g. once
    // a minute per session). It is used for idle detection.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LastSystemRITEventTickCount;

    //
    // Number of physical pages in the system. This can dynamically change as
    // physical memory can be added or removed from a running system.  This
    // cell is too small to hold the non-truncated value on very large memory
    // machines so code that needs the full value should access
    // FullNumberOfPhysicalPages instead.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfPhysicalPages;

    //
    // True if the system was booted in safe boot mode.
    //

    BOOLEAN SafeBootMode;

    //
    // Virtualization flags.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;

#if defined(_ARM64_)

        //
        // N.B. Keep this bitfield in sync with the one in arc.w.
        //

        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> : 6;
        };

#endif

    };

    //
    // Reserved (available for reuse).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved12[2];

    //
    // This is a packed bitfield that contains various flags concerning
    // the system state. They must be manipulated using interlocked
    // operations.
    //
    // N.B. DbgMultiSessionSku must be accessed via the <a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>
    //      API for an accurate result
    //

    union
    {
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
        struct
        {
            //
            // The following bit fields are for the debugger only. Do not use.
            // Use the bit definitions instead.
            //

            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled            : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled             : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled    : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled   : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku        : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSplitTokenEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgShadowAdminEnabled     : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits                 : 19;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;

    //
    // Reserved padding field to preserve structure alignment and compatibility.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DataFlagsPad[1];

    //
    // Depending on the processor, the code for fast system call will differ,
    // Stub code is provided pointers below to access the appropriate code.
    //
    // N.B. The following field is only used on 32-bit systems.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TestRetInstruction;

    //
    // Query-performance counter (QPC) frequency, in counts per second.
    //
    // N.B. This value represents the fixed frequency of the system&#x27;s high-resolution
    // performance counter. It is used by user-mode time routines to convert QPC
    // ticks into elapsed time without requiring a system call. The frequency is
    // constant for the lifetime of the system and reflects the hardware or
    // virtualized timer source selected by the kernel.
    //

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> QpcFrequency;

    //
    // On AMD64, this value is initialized to a nonzero value if the system
    // operates with an altered view of the system service call mechanism.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemCall;

    //
    // Reserved field - do not use. Used to be UserCetAvailableEnvironments.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved2;

    //
    // Full 64 bit version of the number of physical pages in the system.
    // This can dynamically change as physical memory can be added or removed
    // from a running system.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> FullNumberOfPhysicalPages;

    //
    // Reserved, available for reuse.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> SystemCallPad[1];

    //
    // The 64-bit tick count.
    //

    union
    {
        volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
        volatile <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> TickCountQuad;
        struct
        {
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME3;

    //
    // Cookie for encoding pointers system wide.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Cookie;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CookiePad[1];

    //
    // Client id of the process having the focus in the current
    // active console session id.
    //
    // N.B. This field must be accessed via the
    //      <a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a> API for an accurate result.
    //

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> ConsoleSessionForegroundProcessId;

    //
    // N.B. The following data is used to implement the precise time
    //      services. It is aligned on a 64-byte cache-line boundary and
    //      arranged in the order of typical accesses.
    //
    // Placeholder for the (internal) time update lock.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TimeUpdateLock;

    //
    // The performance counter value used to establish the current system time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineSystemTimeQpc;

    //
    // The performance counter value used to compute the last interrupt time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineInterruptTimeQpc;

    //
    // The scaled number of system time seconds represented by a single
    // performance count (this value may vary to achieve time synchronization).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcSystemTimeIncrement;

    //
    // The scaled number of interrupt time seconds represented by a single
    // performance count (this value is constant after the system is booted).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcInterruptTimeIncrement;

    //
    // The scaling shift count applied to the performance counter system time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcSystemTimeIncrementShift;

    //
    // The scaling shift count applied to the performance counter interrupt time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcInterruptTimeIncrementShift;

    //
    // The count of unparked processors.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UnparkedProcessorCount;

    //
    // A bitmask of enclave features supported on this system.
    //
    // N.B. This field must be accessed via the <a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a> API for an
    //      accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EnclaveFeatureMask[4];

    //
    // Current coverage round for telemetry based coverage.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryCoverageRound;

    //
    // The following field is used for ETW user mode global logging
    // (UMGL).
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UserModeGlobalLogger[16];

    //
    // Settings that can enable the use of Image File Execution Options
    // from HKCU in addition to the original HKLM.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ImageFileExecutionOptions;

    //
    // Generation of the kernel structure holding system language information
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LangGenerationCount;

    //
    // Reserved (available for reuse).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Reserved4;

    //
    // Current 64-bit interrupt time bias in 100ns units.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> InterruptTimeBias;

    //
    // Current 64-bit performance counter bias, in performance counter units
    // before the shift is applied.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcBias;

    //
    // Number of active logical processors.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveProcessorCount;

    //
    // Number of active processor groups.
    //
    // N.B. This value is volatile because group membership and processor
    // availability may change dynamically due to hot-add, hot-remove,
    // or power management events.
    //

    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ActiveGroupCount;

    //
    // Reserved (available for re-use).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved9;

    union
    {
        <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
        struct
        {
            //
            // A bitfield indicating whether performance counter queries can
            // read the counter directly (bypassing the system call) and flags.
            //

            union
            {

                volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;

                struct
                {
                    //
                    // QPC may bypass the syscall and use a fast user-mode path.
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> BypassAllowed : 1;

                    //
                    // Hypervisor-assisted QPC conversion.
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> HypervisorAssist : 1;

                    //
                    // Reserved/unused
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved_2_3 : 2;

                    //
                    // MFENCE before RDTSC in relevant paths.
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> UseMfence : 1;

                    //
                    // LFENCE before RDTSC in relevant paths.
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> UseLfence : 1;

                    //
                    // Reserved/unused
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved_6 : 1;

                    //
                    // RDTSCP instead of RDTSC in the fast path.
                    //
                    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> UseRdtscp : 1;
                };
            };

            //
            // Reserved, leave as zero for backward compatibility. Was shift
            // applied to the raw counter value to derive QPC count.
            //

            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
        };
    };

    //
    // Reserved for future use.
    //

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    //
    // Extended processor state configuration (AMD64 and x86).
    //

    XSTATE_CONFIGURATION XState;

    //
    // <a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a>
    //

    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> FeatureConfigurationChangeStamp;

    //
    // Spare (available for re-use).
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Spare;

    //
    // This field holds a mask that is used in the process of authenticating pointers in user mode.
    // It helps in determining which bits of the pointer are used for authentication in user mode.
    //

    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> UserPointerAuthMask;

    //
    // Extended processor state configuration (ARM64). The reserved space for
    // other architectures is not available for reuse.
    //

#if defined(_ARM64_)
    XSTATE_CONFIGURATION XStateArm64;
#else
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved10[210];
#endif
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
</span><span class="ntdoc-code-footer language-cpp">
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/cc4793e6bec630c14918c05cea0cf33d71b274e3/phnt/include/ntexapi.h#L7133">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntddk.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">typedef struct _KUSER_SHARED_DATA {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountLowDeprecated;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountMultiplier;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  InterruptTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  SystemTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  TimeZoneBias;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberLow;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberHigh;
  WCHAR                         NtSystemRoot[260];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         MaxStackTraceDepth;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CryptoExponent;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeZoneId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LargePageMinimum;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AitSamplingValue;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AppCompatFlag;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     RNGSeedVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         GlobalValidationRunlevel;
  <a href="long" title="typedef long LONG;">LONG</a>                          TimeZoneBiasStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtBuildNumber;
  <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a>               NtProductType;
  BOOLEAN                       ProductTypeIsValid;
  BOOLEAN                       Reserved0[1];
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        NativeProcessorArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMajorVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMinorVersion;
  BOOLEAN                       ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeSlip;
  <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         BootId;
  LARGE_INTEGER                 SystemExpirationDate;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SuiteMask;
  BOOLEAN                       KdDebuggerEnabled;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
    };
  };
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        CyclesPerYield;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveConsoleId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DismountCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ComPlusPackage;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LastSystemRITEventTickCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NumberOfPhysicalPages;
  BOOLEAN                       SafeBootMode;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
    };
  };
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved12[2];
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits : 21;
    } DUMMYSTRUCTNAME2;
  } DUMMYUNIONNAME2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DataFlagsPad[1];
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TestRetInstruction;
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      QpcFrequency;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SystemCall;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved2;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     FullNumberOfPhysicalPages;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     SystemCallPad[1];
  union {
    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>      TickCountQuad;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Cookie;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CookiePad[1];
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      ConsoleSessionForegroundProcessId;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TimeUpdateLock;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineSystemTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineInterruptTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcSystemTimeIncrement;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcInterruptTimeIncrement;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcSystemTimeIncrementShift;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcInterruptTimeIncrementShift;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UnparkedProcessorCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         EnclaveFeatureMask[4];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TelemetryCoverageRound;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UserModeGlobalLogger[16];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ImageFileExecutionOptions;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LangGenerationCount;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     Reserved4;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     InterruptTimeBias;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcBias;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveProcessorCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         ActiveGroupCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved9;
  union {
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
    };
  };
  LARGE_INTEGER                 TimeZoneBiasEffectiveStart;
  LARGE_INTEGER                 TimeZoneBiasEffectiveEnd;
  XSTATE_CONFIGURATION          XState;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  FeatureConfigurationChangeStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Spare;
  <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>                       UserPointerAuthMask;
  XSTATE_CONFIGURATION          XStateArm64;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved10[210];
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<p>This structure is partially <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">documented in Windows Driver Kit</a>. However, as verified on 2025-09, almost all Microsoft documentation for this structure is either outdated, useless, or downright incorrect.</p>
<h1>Introduction</h1>
<p>KUSER_SHARED_DATA structure defines layout of the memory region, shared between kernelmode and usermode. It occupies a single physical page, mapped in oskernel at fixed address <code>0xFFFF'F780'0000'0000</code> (0xFFFFF78000000000), and in all but the <em>Minimal</em> processes at <code>0x7FFE'0000</code> (0x7FFE0000). Since win11 23H2, the fixed virtual address in kernel is read-only; <code>nt!MmWriteableSharedUserData</code> holds a randomized virtual address of the writeable kernelmode mapping.</p>
<h1>Definition</h1>
<p>Here is the full definition, with all fields properly documented.<br />
It has been enriched with field offsets and five special sigils to help you quickly assess each item.</p>
<p>Legend:<br />
ùçå - field fixed at boot and won't change at runtime<br />
‚ùï - changes often (e.g. secondwise)<br />
‚ó∑ - changes rarely (e.g. hourly)<br />
üëã ‚Äì can be changed by usermode applications at runtime<br />
‚ôª ‚Äì field is either reserved, or deprecated, or it has no real reason to be in kuser and should be moved elsewhere</p>
<h2><code>TickCountLowDeprecated</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x000</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountLowDeprecated;
</code></pre>
<p>Unused, deprecated for more than 20 years. Always zero.</p>
<h2><code>TickCountMultiplier</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x004</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountMultiplier;
</code></pre>
<p>Number of milliseconds per ostick, left-shifted by 0x18. Mirrors <code>nt!ExpTickCountMultiplier</code>, derived directly from <code>nt!KeMaximumIncrement</code>. Across all archs, value is clamped to a max of 0x0FA00000 (1/64 s, or 15.625 ms). And in fact, you'll almost never see anything else there, except maybe 0x0F99A027 on some old systems (~15.600 ms, or 15.600099980831146 ms exactly). <code>GetTickCount()</code> =&gt; <code>(ü°óTickCountMultiplier √ó ü°ìTickCountQuad) &gt;&gt; 0x18</code>. Duration of an ostick is fixed at boot time, stored in <code>nt!KeMaximumIncrement</code>. Not to be confused with the clock tick duration, <code>nt!KeTimeIncrement</code>, which can change at runtime (in ü°ìInterruptTime description right below).</p>
<h2><code>InterruptTime</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x008</td>
<td>‚ùï</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> InterruptTime;
</code></pre>
<p><em>changes each clock interrupt</em></p>
<p>Number of centums (100 ns units) since system start. Value monotonically increases. Includes sleep/hibernation time and the like (the &quot;bias&quot;); i.e. value jumps forward on wakeup. For raw uptime, subtract ü°ìInterruptTimeBias. Updated on each clock interrupt on the clock owner processor. Current update period is <code>nt!KeTimeIncrement</code>, adjustable via <code><a href="ntsettimerresolution" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetTimerResolution(&#10;    _In_ ULONG DesiredTime,&#10;    _In_ BOOLEAN SetResolution,&#10;    _Out_ PULONG ActualTime&#10;    );">NtSetTimerResolution</a></code> (aka <code>timeBeginPeriod</code>), in the hardcoded range [0.5 ms, 15.625 ms]. Actual adjustable range can be smaller; set at boot as [<code>nt!KeMinimumIncrement</code>, <code>nt!KeMaximumIncrement</code>]. See ü°ìTickCountQuad description on how to change this field initial value from 0 to up to 49.71 days. Coherence of this field vs ü°ìSystemTime, ü°ìTickCountQuad, and certain others is ensured via ü°ìTimeUpdateLock.</p>
<h2><code>SystemTime</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x014</td>
<td>‚ùï üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> SystemTime;
</code></pre>
<p><em>changes each clock interrupt + adjustable</em></p>
<p>UTC System Time. Number of centums since 1601-01-01, exactly. It's a perfectly raw value; any conversions or adjustments (like leap days or leap seconds) ought to be done on the higher level. Coherence of this field vs ü°ëInterruptTime, ü°ìTickCountQuad, and certain others is ensured via ü°ìTimeUpdateLock. Clients not in the server silo with SeSystemtime privilege can set it via <code><a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a></code> to any value in range [0, 2‚Å∂¬π+2¬≥¬≤), which is [1601-01-01, 8907-12-05 18:49:10].</p>
<p>Note regular users don't have SeSystemtime by default.</p>
<h2><code>TimeZoneBias</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x020</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TimeZoneBias;
</code></pre>
<p><em>changes at runtime (~twice a year), manually adjustable</em></p>
<p>Current 64-bit time zone bias.</p>
<p>Silo-aware: <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBias</code>.</p>
<p>It's the value you <em>subtract</em> from ü°ëSystemTime to get Local Time. It's already pre-adjusted for daylight saving. E.g. for Pacific Time (-08:00) value will be 7:00 in Summer (0x3AAC5ED800 == 7√ó3600√ó10‚Å∑). See ü°ìTimeZoneBiasEffectiveStart description for when this field is considered valid. Coherence of this field vs the ü°ìTimeZoneBiasEffective* values ensured via ü°ìTimeZoneBiasStamp. Clients with SeTimeZone privilege can set bias using <code>SystemTimeZoneInformation</code>/<code>SystemDynamicTimeZoneInformation</code> infoclasses. Range is ¬±2¬≥¬π seconds (¬±68 years), granularity 1 minute. Regular users on client OS versions DO have SeTimeZone privilege by default; on server OS versions they don't.</p>
<p>Note timezone info is stored under <code>CCS\Control\TimeZoneInformation</code> key; using timezone infoclasses grants users limited writeability to that key.</p>
<h2><code>ImageNumberLow</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x02C</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberLow;
</code></pre>
<p>Fixed values, set at boot (in <code>nt!InitBootProcessor</code>). Both fields are the same: 0x8664 for x64, 0xAA64 for ARM64. Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidimagenumberlow" title="#define GlobalDataIdImageNumberLow 4 // KUSER_SHARED_DATA-&gt;ImageNumberLow">GlobalDataIdImageNumberLow</a>/<a href="globaldataidimagenumberhigh" title="#define GlobalDataIdImageNumberHigh 5 // KUSER_SHARED_DATA-&gt;ImageNumberHigh">GlobalDataIdImageNumberHigh</a>[=4/5])</code>.</p>
<h2><code>ImageNumberHigh</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x02E</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberHigh;
</code></pre>
<p>See <code>ImageNumberLow</code> above.</p>
<h2><code>NtSystemRoot</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x030</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">WCHAR NtSystemRoot[0x104];
</code></pre>
<p><em>used now, but really shouldn't be in kuser</em></p>
<p>Win32 system root path, e.g. &quot;C:\Windows&quot; ‚Äì without quotes, without trailing slash. First wchar is adjustable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidntsystemrootdrive" title="#define GlobalDataIdNtSystemRootDrive 15 // KUSER_SHARED_DATA-&gt;NtSystemRoot // RtlGetNtSystemRoot">GlobalDataIdNtSystemRootDrive</a>[=15])</code>. OS receives path from the osloader (<code>winload.efi</code>), in <code>LoaderBlock.NtBootPathName</code>. But <code>LoaderBlock</code> path has no drive letter, so it's retrieved from the <code>MountPointManager</code> via <code><a href="ioctl_mountmgr_boot_dl_assignment" title="#define IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT CTL_CODE(MOUNTMGRCONTROLTYPE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since WIN7">IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT</a></code>.</p>
<p>Silo-aware: <code><a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtSystemRoot</code>.</p>
<h2><code>MaxStackTraceDepth</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x238</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaxStackTraceDepth;
</code></pre>
<p>&quot;Maximum stack trace depth if tracing is enabled&quot;. Appears to be deprecated, unused, always zero.</p>
<h2><code>CryptoExponent</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x23C</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CryptoExponent;
</code></pre>
<p>Crypto exponent for yolocrypto. Unused, always zero. In the past could be non-zero only for &quot;internal&quot; OS builds.</p>
<h2><code>TimeZoneId</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x240</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeZoneId;
</code></pre>
<p><em>changes at runtime ~twice a year, manually adjustable</em></p>
<p>Time zone ID, <code>TIME_ZONE_ID_*</code>.</p>
<p>Silo-aware: <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneId</code>.</p>
<p>Values:</p>
<ul>
<li>0: *_UNKNOWN (aka neither, DST not used)</li>
<li>1: *_STANDARD (winter)</li>
<li>2: *_DAYLIGHT (summer)</li>
</ul>
<p>Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidtimezoneid" title="#define GlobalDataIdTimeZoneId 6 // KUSER_SHARED_DATA-&gt;TimeZoneId">GlobalDataIdTimeZoneId</a>[=6])</code>.</p>
<p>‚ö†Ô∏è Unlike ü°ëTimeZoneBias and ü°ìTimeZoneBiasEffective*, this field is NOT protected via ü°ìTimeZoneBiasStamp; it is set before starting the ü°ìTimeZoneBiasStamp update sequence. For coherence between this and other timezone fields: read this first, then others, then read this field again and ensure it hasn't changed. Indirectly adjustable by clients with SeTimeZone privilege, together with ü°ëTimeZoneBias.</p>
<h2><code>LargePageMinimum</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x244</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LargePageMinimum;
</code></pre>
<p><em>used now, but really shouldn't be in kuser</em></p>
<p>Minimum size of a large page, in bytes. Determined by the CPU. On boot <code>nt!MiInitSystem</code> sets it to hardcoded 2 MB. It seems the only purpose of this field is to simplify implementation of exported <code>kernelbase!GetLargePageMinimum</code>.</p>
<h2><code>AitSamplingValue</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x248</td>
<td>üëã ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AitSamplingValue;
</code></pre>
<p>AIT sampling rate. TL note: AIT means App Impact Telemetry. Related to KIT, Kernel Impact Telemetry. Related to ETW provider <code>MS_Windows_AIT_Provider</code> and exported api <code>nt!KitLogFeatureUsage</code>. Most likely deprecated. Set during boot in <code>nt!KitpInitAitSampleRate</code> from <code>CCS\Control\Session Manager\AppCompatCache‚ÇÑRate</code>, unless it's a safeboot. By default there is nothing in registry, so normally this field is 0. Can be adjusted by holders of SeProfileSingleProcess privilege: <code><a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemAitSamplingValue)</code>.</p>
<h2><code>AppCompatFlag</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x24C</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AppCompatFlag;
</code></pre>
<p>&quot;This value controls switchback processing&quot;. Seemingly deprecated, unused, and always 0. But there's an active <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a> field of similar name: <code><a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.AppCompatFlags</code>.</p>
<h2><code>RNGSeedVersion</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x250</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> RNGSeedVersion;
</code></pre>
<p><em>incremented periodically (every hour on average)</em></p>
<p>Number of times since boot <code>CNG.sys</code> has reseeded its entropy pool. Reseed can be triggered via exported <code>cng!<a href="entropypooltriggerreseedforium" title="VOID EntropyPoolTriggerReseedForIum(&#10;  BOOLEAN fPerformCallbacks&#10;);">EntropyPoolTriggerReseedForIum</a></code>, but it mostly auto-reseeds at these intervals after the previous auto-reseed, in seconds: 1, 3, 9, 27, 81, 243, 729, 2187, 3600, 3600, 3600,.. I.e. interval triples till it hits one hour (but there's about 5 extra reseeds at system start). On boot you'll often see 8 here; +27s: 9; +81s more: 10; after 6/18/55/115 minutes of uptime: 11/12/13/14; etc. Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidrngseedversion" title="#define GlobalDataIdRngSeedVersion 1 // KUSER_SHARED_DATA-&gt;RngSeedVersion">GlobalDataIdRngSeedVersion</a>[=1])</code>.</p>
<h2><code>GlobalValidationRunlevel</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x258</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GlobalValidationRunlevel;
</code></pre>
<p>Set of flags to control assert failures handling. Read on boot from <code>CCS\Control\ValidationRunLevels‚ÇÑGlobal</code>. See <code>VRL_*</code> flags in sdk; from oskernel view the only bit is <code>VRL_ENABLE_KERNEL_BREAKS</code>, it only affects debug OS builds.</p>
<h2><code>TimeZoneBiasStamp</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x25C</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="long" title="typedef long LONG;">LONG</a> TimeZoneBiasStamp;
</code></pre>
<p><em>changes at runtime rarely (e.g. daily), +manual adjust</em></p>
<p>Sequence number/lock for timezone data: ü°ëTimeZoneBias, ü°ìTimeZoneBiasEffectiveStart, ü°ìTimeZoneBiasEffectiveEnd. When value is odd, the set of fields is being updated. See &quot;Cross-fields coherence via sequence numbers&quot; below for details. Clients without any privileges can increment it by two via <code><a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a>(null, null)</code>.</p>
<p>Silo-aware: <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasStamp</code>.</p>
<h2><code>NtBuildNumber</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x260</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtBuildNumber;
</code></pre>
<p>Mirrors exported <code>nt!NtBuildNumber</code>, but with its higher nibble zeroed. For <code>nt!NtBuildNumber</code>, higher nibble is 0xC in Checked (debug) builds, or 0xF in Free (release) builds. Initially set to a hardcoded value for current <code>ntoskrnl</code>, equal to the &quot;real&quot; value in <code>FixedFileVersionInfo</code> (e.g. 19041); during boot re-set to a dword from registry (e.g. 19045). This field (or rather the <code>nt!NtBuildNumber</code> it's derived from) has modest usage throughout the system, but it does affect codepaths. Goes into <code><a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.NtBuildNumber</code>. Reg path for win10: <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\EditionVersion‚ÇÑEditionBuildNumber</code>. For WS2022/win11: <code>HKLM\SYSTEM\Software\Microsoft\BuildLayers\&lt;SubkeyWithValue.IsTopLevel==1&gt;‚ÇÑBuildNumber</code>. &quot;The shared collective build number undecorated with C or F.&quot; ‚Äì original WDK gem, kept for posterity.</p>
<h2><code>NtProductType</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x264</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a> NtProductType;
</code></pre>
<p>Product type: client (e.g. Windows 10) VS server (e.g. Windows Server 2022) VS domain controller server.</p>
<ul>
<li>1/NtProductWinNt: client OS</li>
<li>2/NtProductLanManNt: Windows Server in DC role</li>
<li>3/NtProductServer: Windows Server</li>
</ul>
<p>Set on boot in <code>nt!MiMemoryLicense</code>, from <code>nt!MmRegistryState</code>.ProductType: <code>CCS\Control\ProductOptions‚ÇÑProductType</code>.</p>
<p>Silo-aware: <code><a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtProductType</code>.</p>
<h2><code>ProductTypeIsValid</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x268</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">BOOLEAN ProductTypeIsValid;
</code></pre>
<p>Tells APIs they can use ü°ëNtProductType field instead of querying that info from registry. Normally it's 1, except during system install (&quot;SystemSetupInProgress&quot;).</p>
<h2><code>Reserved0</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x269</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">BOOLEAN Reserved0[1];
</code></pre>
<p>Zero.</p>
<h2><code>NativeProcessorArchitecture</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x26A</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> NativeProcessorArchitecture;
</code></pre>
<p><em>shouldn't be in kuser; wow/sxs should use regular api</em></p>
<p><code>PROCESSOR_ARCHITECTURE_*</code> constant, e.g. 9 for <code>PROCESSOR_ARCHITECTURE_AMD64</code>, 12 for _ARM64.</p>
<h2><code>NtMajorVersion</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x26C</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMajorVersion;
</code></pre>
<p>OS Version, set at boot to fixed values (in <code>nt!InitBootProcessor</code>). E.g. win7: 6 major, 1 minor. Usual values: 5.1, 5.2, 6.0, 6.1, 6.2, 6.3; hardcoded to 10.0 since win10, stays as such in win11. Unlike ü°ëNtBuildNumber, adjusting MajorVersion &amp; MinorVersion in registry does NOT affect these fields.</p>
<h2><code>NtMinorVersion</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x270</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMinorVersion;
</code></pre>
<p>See <code>NtMajorVersion</code> above.</p>
<h2><code>ProcessorFeatures</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x274</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">BOOLEAN ProcessorFeatures[0x40];
</code></pre>
<p><em>0x40 is <a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a></em></p>
<p>Processor and/or OS features. See <code>PF_*</code> flags. Unfortunately, one whole byte used per flag. Used by <code>kernelbase!IsProcessorFeaturePresent</code> (via <code>ntdll!<a href="rtlisprocessorfeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsProcessorFeaturePresent(&#10;    _In_ ULONG ProcessorFeature&#10;    );">RtlIsProcessorFeaturePresent</a></code>).</p>
<p>‚ö†Ô∏è Older OS versions may not set all expected flags, even if feature is actually supported by CPU and OS.</p>
<h2><code>Reserved1</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2B4</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved1;
</code></pre>
<p><em>aka MaximumUserModeAddressDeprecated</em></p>
<p>Obsolete, dnu: always 0x7FFEFFFF on 64-bit OS. On 32-bit OS mirrors <code>MM_HIGHEST_USER_ADDRESS</code> (sensible with /3GB).</p>
<h2><code>Reserved3</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2B8</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved3;
</code></pre>
<p><em>aka SystemRangeStartDeprecated</em></p>
<p>Obsolete, dnu: always 0x80000000 on 64-bit OS. On 32-bit OS mirrors MmSystemRangeStart.</p>
<h2><code>TimeSlip</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2BC</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeSlip;
</code></pre>
<p><em><strong>most likely</strong> fixed at boot to 0 and doesn't change</em></p>
<p>&quot;Time slippage while in debugger&quot;. So, supposedly &quot;time wasted debugging&quot;, but there's strong indication this field is obsolete and always zero.</p>
<h2><code>AlternativeArchitecture</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2C0</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AlternativeArchitecture;
</code></pre>
<p><em>type is 2-const enum <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a></em></p>
<p>Always zero. Previously: &quot;alternative system architecture, e.g., NEC PC98xx on x86&quot;.</p>
<h2><code>BootId</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2C4</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BootId;
</code></pre>
<p>Number of boots since OS install (really, boot attempts). Osloader (<code>winload.efi</code>) reads <code>\Windows\bootstat.dat</code> (<code>BSD_BOOT_STATUS_DATA.LastBootId`0x34</code>), increments and resaves it; passes value through LoaderBlock for <code>nt!InitBootProcessor</code>, which stores it here. Filepath is changeable via <code>BsdLogPath</code>; <code>ntoskrnl</code> reduplicates it from the loader block into <code>CCS\Control‚ÇõOsBootstatPath</code>. Hyper-V docker containers run with BootId == 1; at least some Windows Sandbox instances run with BootId == 2.</p>
<h2><code>SystemExpirationDate</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2C8</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">LARGE_INTEGER SystemExpirationDate;
</code></pre>
<p>Value of ü°ëSystemTime when system expires. Normally 0, which means no expiration. Not related to activation. Evaluation OS versions have real value here. Used by <code>winver.exe</code> directly, and by <code>win32k*.sys</code> to paint watermark. Set during boot from data returned by <code>nt!ExGetExpirationDate()</code> [<a href="ntquerylicensevalue" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryLicenseValue(&#10;    _In_ PCUNICODE_STRING ValueName,&#10;    _Out_opt_ PULONG Type,&#10;    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,&#10;    _In_ ULONG DataSize,&#10;    _Out_ PULONG ResultDataSize&#10;    );">ZwQueryLicenseValue</a>(&quot;Kernel-ExpirationDate&quot;)].</p>
<h2><code>SuiteMask</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2D0</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SuiteMask;
</code></pre>
<p><code>VER_SUITE_*</code> mask, i.e. (1 &lt;&lt; <code><a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::*</code>). E.g. if bit16 set, it's Windows Phone (<code><a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::PhoneNT</code> == 16). Over time got sidelined; mostly you'll see just the minimum: 0x110 == <code>VER_SUITE_TERMINAL</code>|<code>VER_SUITE_SINGLEUSERTS</code>.</p>
<p>Silo-aware: <code><a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.SuiteMask</code>.</p>
<h2><code>KdDebuggerEnabled</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2D4</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> KdDebuggerEnabled;
</code></pre>
<p><em>may change if debugger connected; manually adjustable</em></p>
<p>Kernel Debugger status bitmask. Value can change dynamically into any state (e.g. 1 -&gt; 3 -&gt; 0 -&gt; 3 -&gt; 1 -&gt; ...). Bit0 mirrors exported boolean <code>nt!KdDebuggerEnabled</code> (debugger enabled, but not necessarily connected). Bit1 is negation of the exported bool <code>nt!KdDebuggerNotPresent</code> (that is: when bit1 is 1, KD is connected/active). üîé Example: booted with <code>bcdedit /debug on</code>, but w/o KD running: field=1 (enabled, not connected); then launched KD on host: guest OS connects to KD, field changes 1-&gt;3 (active); run <code>kdbgctrl -d</code> on guest, aka <code><a href="ntsystemdebugcontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSystemDebugControl(&#10;    _In_ SYSDBG_COMMAND Command,&#10;    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtSystemDebugControl</a>(SysDbgDisableKernelDebugger)</code>: field changes 3-&gt;0 (forcing KD disconnect until dbg events). Can also change 0-&gt;1/3 with <code>kdbgctrl</code> as long as <code>nt!KdPitchDebugger</code> is false (i.e. &quot;/debug on&quot; is true). Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidkddebuggerenabled" title="#define GlobalDataIdKdDebuggerEnabled 10 // KUSER_SHARED_DATA-&gt;KdDebuggerEnabled">GlobalDataIdKdDebuggerEnabled</a>[=10])</code>, done by <code>kdxxx</code>/<code>kdnet.dll</code>.</p>
<h2><code>MitigationPolicies</code> (in union)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2D5</td>
<td>ùçå</td>
<td>Part of union at 0x2D5</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
</code></pre>
<p>Minor subset of system mitigations.</p>
<h2><code>NXSupportPolicy</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2D5</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy: 2;
</code></pre>
<p><code>NX_SUPPORT_POLICY_*</code> values. Only meaningful for 32-bit x86 processes. From <code>bcdedit /set nx VALUE</code>. Applied at process startup via <code><a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessExecuteFlags)</code>.</p>
<h2><code>SEHValidationPolicy</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2D5</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy: 2;
</code></pre>
<p><code>SEH_VALIDATION_POLICY_*</code> values. Only meaningful for 32-bit x86 processes. Set on boot from <code>CCS\Control\Session Manager‚ÇÑDisableExceptionChainValidation</code>. App IFEO value with the same name trumps it.</p>
<h2><code>CurDirDevicesSkippedForDlls</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2D5</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls: 2;
</code></pre>
<p>Determines what kinds of devices are illegal to have Current Working Directory searched for dlls. From <code>CCS\Control\Session Manager‚ÇÑCWDIllegalInDLLSearch</code>. App-specific IFEO value with the same name trumps it.</p>
<p>Values:</p>
<ul>
<li>0: any allowed</li>
<li>1: WebDav</li>
<li>2: any Remote device</li>
<li>3: all devices illegal, never use CWD (-1 in registry)</li>
</ul>
<h2><code>Reserved</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2D5</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved: 2;
</code></pre>
<p>Zero.</p>
<h2><code>CyclesPerYield</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2D6</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> CyclesPerYield;
</code></pre>
<p>Measured duration of <code>pause</code> (x86) or <code>yield</code> (ARM) instructions, in TSC (<code>rdtsc</code>) cycles. Determines how many times to spin, e.g. in <code>RtlBackoff</code> (both rings). Early at boot set to 10, then ‚Äì at later boot stages ‚Äì updated with data from <code>nt!ExpComputeCyclesPerYield</code>. Example: 0x0D, 0x18, 0x84. Measured values can vary boot to boot! OS clamps value in range [1, 0xFFFF]. So if value is 0, the OS is simply too old to use it: older than win10 1903.</p>
<h2><code>ActiveConsoleId</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2D8</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveConsoleId;
</code></pre>
<p><em>sort of changeable by physically present users</em></p>
<p>Current physical console Session Id. RDP sessions ignored. During boot it's 0. Right after the boot it may stay 0 (Hyper-V docker container), change to 1 (normal box, Logon Screen), or to -1 (Windows Sandbox, kind of RDP).</p>
<p>Note Hyper-V Manager <em>basic</em> sessions are &quot;physical&quot;, but <em>enhanced</em> sessions are RDP; thus in enhanced sessions you'll observe some &quot;leftover&quot; here, but really it'll be the &quot;physical&quot; basic session <code>LogonUI.exe</code> is running in. When the physical box (or its equivalent) is locked, value <em>may</em> change; happens when <code>LogonUI.exe</code> is created in a new session, which is the case if there are already several user sessions (physical or RDP). Field set by <code>win32kbase.sys</code> and <code>win32kfull.sys</code>; they use dedicated exported api, <code>nt!RtlSetActiveConsoleId</code>.</p>
<p>Silo-aware: <code><a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ActiveConsoleId</code>.</p>
<h2><code>DismountCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2DC</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DismountCount;
</code></pre>
<p><em>changes at runtime on dismounts (rare), +manually</em></p>
<p>Force-dismounting volumes makes affected handles refer to &quot;invalid&quot; files/volumes/directories; if app wants to ensure handles &quot;validity&quot; for some reason (race condition notwithstanding), but doesn't want to always issue <code><a href="fsctl_is_volume_mounted" title="// CTL_CODE(0x0009, 0x00a, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_IS_VOLUME_MOUNTED 0x00090028">FSCTL_IS_VOLUME_MOUNTED</a></code> ioctl (0x090028), it can simply check sameness of this field. OS changes this value ‚Äì interlocked-increments it ‚Äì on two occasions:</p>
<ol>
<li>Well-behaved filesystem driver invoked exported <code>nt!FsRtlDismountComplete</code>.</li>
<li>OS received <code><a href="fsctl_dismount_volume" title="// CTL_CODE(0x0009, 0x008, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_DISMOUNT_VOLUME 0x00090020">FSCTL_DISMOUNT_VOLUME</a></code> (0x090020) via <code><a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a></code>/<code><a href="ntdeviceiocontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDeviceIoControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG IoControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtDeviceIoControlFile</a></code> (+=1 or +=2 per call).</li>
</ol>
<h2><code>ComPlusPackage</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2E0</td>
<td>‚ó∑ üëã ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ComPlusPackage;
</code></pre>
<p><em>normally changes once at runtime; manually adjustable</em></p>
<p>Lazy-mirrors <code>HKLM\SOFTWARE\Microsoft\.NETFramework‚ÇÑEnable64Bit</code>. Value is a bitfield with only bit0 defined: <code>COMPLUS_ENABLE_64BIT</code>. When set, it makes system run suitable 32-bit MSIL images as native 64-bit processes (so one can observe 32-bit PE images run as 64-bit processes). Registry value is normally 1, but this field initially set to <code><a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a></code>, making engaged code use <code><a href="ntquerysysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQuerySystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtQuerySystemInformation</a>(SystemComPlusPackage)</code> to query reg value and update this field. <code><a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemComPlusPackage)</code> updates registry and this field, but needs registry write access.</p>
<h2><code>LastSystemRITEventTickCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2E4</td>
<td>‚ùï üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LastSystemRITEventTickCount;
</code></pre>
<p><em>updates every second as long as some users provide input</em></p>
<p>Snapshot of <code>GetTickCount()</code> ms at the moment of the last user input, across all terminal sessions (including RDP). Used for e.g. idle detection. Updated by <code>win32kbase!CitpLastInputUpdate</code> at most <em>once per second</em>. Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidlastsystemriteventtickcount" title="#define GlobalDataIdLastSystemRITEventTickCount 13 // KUSER_SHARED_DATA-&gt;LastSystemRITEventTickCount">GlobalDataIdLastSystemRITEventTickCount</a>[=13])</code>.</p>
<h2><code>NumberOfPhysicalPages</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2E8</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfPhysicalPages;
</code></pre>
<p><em>fixed at boot, but might [rarely] change at runtime</em></p>
<p>OS-visible total RAM size, in pages, clamped to <code><a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a></code> (16 TB RAM). Since win11 24H2, extended 64-bit field is also available: ü°ìFullNumberOfPhysicalPages. Both fields can change if RAM is added or removed. Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.</p>
<h2><code>SafeBootMode</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2EC</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">BOOLEAN SafeBootMode;
</code></pre>
<p>True if booted in safe boot mode (&quot;SAFEBOOT:&quot; present in the OS load options).</p>
<h2><code>VirtualizationFlags</code> (in union)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2ED</td>
<td>ùçå</td>
<td>Part of union at 0x2ED</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;
</code></pre>
<p>Copy of <code>nt!KiVirtFlags</code>, made in KiInitializeKernel based on <code>MSR_IA32_FEATURE_CONTROL</code> and/or <code>VM_CR</code> MSR.</p>
<ul>
<li>bit0: vmx/svm enableable</li>
<li>bit1: enableablement locked (<code>MSR_IA32_FEATURE_CONTROL.lock</code> is true)</li>
</ul>
<p>Bits are 0 when: Hyper-V is running (regardless of partition); or VMX is off (in bios, or VM VBS-compatibility off). Bits form mask 3 or 1 when: Hyper-V is NOT running, and VMX is on (in bios, or VM VBS-compatibility ON).</p>
<h2><code>ArchStartedInEl2</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2ED</td>
<td>defined(_M_ARM64)</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2: 1;
</code></pre>
<h2><code>QcSlIsSupported</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2ED</td>
<td>defined(_M_ARM64)</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported: 1;
</code></pre>
<h2><code>Reserved12</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2EE</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved12[2];
</code></pre>
<p>Zero. &quot;Available for reuse&quot;.</p>
<h2><code>SharedDataFlags</code> (in union)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2F0</td>
<td>‚ó∑ üëã</td>
<td>Part of union at 0x2F0</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
</code></pre>
<p><em>certain flags may change at runtime</em></p>
<h2><code>DbgErrorPortPresent</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>0</td>
<td>0001</td>
<td>‚ó∑üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent: 1;
</code></pre>
<p>Process with SeTcb privilege can (re-)register one global alpc error port via <code>SystemErrorPortInformation</code> system infoclass (-&gt; <code>nt!DbgkRegisterErrorPort</code>). When that happens, system sets this bit. When registrar process exits, or if port somehow disconnects, system unregisters port and clears this bit. In practice, this bit indicates whether <code>WerSvc</code> is currently running (it registers <code>\WindowsErrorReportingServicePort</code>).</p>
<p>Note processes in silo can register error port too, but it'll be silo-specific; this bit won't be set.</p>
<h2><code>DbgElevationEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>1</td>
<td>0002</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled: 1;
</code></pre>
<p><em>reg value‚ÇÑ: &quot;EnableLUA&quot;</em></p>
<p>Following 3 flags, together with new ü°ìDbgShadowAdminEnabled, form basis for <code><a href="rtl_elevation_flags" title="typedef struct _RTL_ELEVATION_FLAGS&#10;{&#10;    union&#10;    {&#10;        ULONG Flags;&#10;        struct&#10;        {&#10;            ULONG ElevationEnabled : 1;&#10;            ULONG VirtualizationEnabled : 1;&#10;            ULONG InstallerDetectEnabled : 1;&#10;            ULONG AdminApprovalModeType : 2;&#10;            ULONG ReservedBits : 27;&#10;        };&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a></code> struct, returned by <code><a href="rtlqueryelevationflags" title="NTSYSAPI&#10;NTSTATUS&#10;NTAPI&#10;RtlQueryElevationFlags(&#10;    _Out_ PRTL_ELEVATION_FLAGS Flags&#10;    );">RtlQueryElevationFlags</a></code> api (in both usermode and kernelmode). Fields set on boot from reg data at <code>HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System</code>, they won't update until reboot even if registry values change. Bad type or size of reg data, or a missing value, yields 1 (not 0). However, if <code>CCS\Control\LsaInformation‚ÇÑUACInstalled</code> is 0, all 4 flags will be set to 0. Policy: &quot;UAC: Turn on Admin Approval Mode&quot;, aka &quot;UAC: Run all administrators in Admin Approval Mode&quot;.</p>
<h2><code>DbgVirtEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>2</td>
<td>0004</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled: 1;
</code></pre>
<p><em>reg value‚ÇÑ: &quot;EnableVirtualization&quot;</em></p>
<p>policy: &quot;UAC: Virtualize file and registry write failures to per-user locations&quot;.</p>
<h2><code>DbgInstallerDetectEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>3</td>
<td>0008</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled: 1;
</code></pre>
<p><em>reg value‚ÇÑ: &quot;EnableInstallerDetection&quot;</em></p>
<p>policy: &quot;UAC: Detect application installations and prompt for elevation&quot;.</p>
<h2><code>DbgLkgEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>4</td>
<td>0010</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled: 1;
</code></pre>
<p>Indicates if Last Known Good is enabled. This bit mirrors <code>nt!CmpLKGEnabled</code>, initialized at boot to <code>CCS\Control\Session Manager\Configuration Manager\LastKnownGood‚ÇÑEnabled</code>. Most often it's 0. This bit is NOT directly related to &quot;DisableLKG&quot; reg value‚ÇÑ set by <code><a href="ntdisablelastknowngood" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDisableLastKnownGood(&#10;    VOID&#10;    );">NtDisableLastKnownGood</a></code>.</p>
<h2><code>DbgDynProcessorEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>5</td>
<td>0020</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled: 1;
</code></pre>
<p>Indicates if new processors can be added at runtime. This bit mirrors exported &quot;almost read-only&quot; value <code>nt!KeDynamicPartitioningSupported</code>, initialized at boot; value depends on sku and licensing. Normally it's 0 for client systems, and can be 1 for servers. However: it's always zero in Hyper-V root partition.</p>
<h2><code>DbgConsoleBrokerEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>6</td>
<td>0040</td>
<td>üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled: 1;
</code></pre>
<p>Dynamic value, managed by <code>ConDrv.sys</code> (the console driver). When true, console attach/allocation routines in usermode take different road. Normally value is 0. But if any process with SeTcb privilege asks for brokerage via request to <code>\Device\ConDrv\Broker</code>, this bit becomes 1 (until all broker objects are gone).</p>
<h2><code>DbgSecureBootEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>7</td>
<td>0080</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled: 1;
</code></pre>
<p>True when SecureBoot is enabled. Initialized during boot. Matches simultaneously set value in the volatile &quot;State&quot; subkey: <code>CCS\Control\SecureBoot\State‚ÇÑUEFISecureBootEnabled</code>.</p>
<h2><code>DbgMultiSessionSku</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>8</td>
<td>0100</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku: 1;
</code></pre>
<p>Indicates that OS supports multiple sessions. For regular OS it's always 1, even for &quot;single-user sku&quot;. It's 0 only for Hyper-V docker containers; even then, OS still uses separate session for user processes. Cleared bit entails serious security lax across OS (user ‚•µ admin) due to &quot;WIN://ISMULTISESSIONSKU&quot; conditional ACEs (mainly for registry keys), and regular checks in both modes via <code><a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a></code>.</p>
<p>Bit is zeroed only if:</p>
<ul>
<li><code>CCS\Control\Session Manager‚ÇÑNumberOfInitialSessions</code> &lt; 2 (default 2), AND</li>
<li>&quot;ext-ms-win-session-wtsapi32-l1-1-0&quot; apiset fails to resolve to proper dll</li>
</ul>
<p>Silo-aware: <code>ntdll!<a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.IsMultiSessionSku</code>.</p>
<h2><code>DbgMultiUsersInSessionSku</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>9</td>
<td>0200</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku: 1;
</code></pre>
<p>Probably indicates that multiple users can share a session (lightweight user separation?). Often gets checked when ü°ëDbgMultiSessionSku is 0. Set at boot to mirror <code>nt!RtlpMultiUsersInSessionSupported</code>, from <code>CCS\Control\Session Manager‚ÇÑMultiUsersInSessionSupported</code>. Default is 0. Accessible via exported <code>ntdll!<a href="rtlismultiusersinsessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiUsersInSessionSku(&#10;    VOID&#10;    );">RtlIsMultiUsersInSessionSku</a></code>.</p>
<h2><code>DbgStateSeparationEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>10</td>
<td>0400</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled: 1;
</code></pre>
<p>Indicates if state separation is enabled. It's hard to enable it for a regular OS, so normally it's 0. State separation is a facility to use different, configurable paths to some registry hives, some registry keys, and some files. This bit set at boot time to mirror <code>nt!CmStateSeparationEnabled</code>, from <code>CCS\Control\StateSeparation\Policy‚ÇÑEnabled</code>.</p>
<h2><code>DbgSplitTokenEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>11</td>
<td>0800</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSplitTokenEnabled: 1;
</code></pre>
<p>Relatively new flag, even though concept of split token itself is old. Likely requires at least win11 25H2. Not set in win11 24H2 and before.</p>
<h2><code>DbgShadowAdminEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>12</td>
<td>1000</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgShadowAdminEnabled: 1;
</code></pre>
<p><em>reg value: &quot;TypeOfAdminApprovalMode&quot;</em></p>
<p>Part of <code><a href="rtl_elevation_flags" title="typedef struct _RTL_ELEVATION_FLAGS&#10;{&#10;    union&#10;    {&#10;        ULONG Flags;&#10;        struct&#10;        {&#10;            ULONG ElevationEnabled : 1;&#10;            ULONG VirtualizationEnabled : 1;&#10;            ULONG InstallerDetectEnabled : 1;&#10;            ULONG AdminApprovalModeType : 2;&#10;            ULONG ReservedBits : 27;&#10;        };&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a></code>. Likely requires at least win11 25H2. Not set in win11 24H2 and before.</p>
<h2><code>SpareBits</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Context</th>
<th>Bit</th>
<th>Value</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitfield in struct at 0x2F0</td>
<td>13</td>
<td>~1FFF</td>
<td>ùçå‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits: 19;
</code></pre>
<h2><code>DataFlagsPad</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2F4</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DataFlagsPad[1];
</code></pre>
<p>Zero.</p>
<h2><code>TestRetInstruction</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x2F8</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TestRetInstruction;
</code></pre>
<p>On x64 contains 0xC3 (&quot;ret&quot;), 0 on ARM64. 32-bit x86 code can jump here to check if DEP is enabled: this page is not executable, but if DEP is effectively off, OS will remove its NX bit for the process on exec attempt, sparing the app <code>STATUS_ACCESS_VIOLATION</code>. That won't affect 64-bit processes: they implicitly have DEP enabled, always.</p>
<h2><code>QpcFrequency</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x300</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> QpcFrequency;
</code></pre>
<p>Frequency of the high-resolution counter, <code>ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>()</code> and <code>nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>()</code>. Value from such counter is known simply as &quot;Qpc&quot;. ü°óQpcFrequency = (Qpc‚ÇÅ - Qpc‚ÇÄ), where (t‚ÇÅ - t‚ÇÄ) == 1 s. What counter is actually used determined by the <code>_REGISTERED_TIMER</code> struct pointed to by <code>nt!HalpPerformanceCounter</code>. Timer type is normally <code>TimerProcessor</code> (<code>rdtsc</code>/<code>TSC_DEADLINE_MSR</code>) [or <code>TimerHypervisor</code>, or <code>TimerGit</code>, ‚©Ø <code>rdtsc</code>]. For <code>TimerProcessor</code> OS scales tsc values used for Qpc to 10 MHz == 10‚Å∑ Hz == 0x989680 (since win10 1809). For <code>TimerHypervisor</code> the frequency simply set to 10 MHz in the first place. Thus 0x989680 is what you'd normally see there. Duration of each Qpc tick in such case is, naturally, 10‚Åª‚Å∑ seconds ‚Äì exactly one centum (100 ns). This field gets set once at boot time together with various other ü°ìQpc* fields, in <code>nt!KiSetupTimeIncrement</code>.</p>
<h2><code>SystemCall</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x308</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemCall;
</code></pre>
<p>Normally 0. Contains 1 if <code>int2E</code> is preferable to <code>syscall</code> (x64 only). Set to 1 when: <code>nt!KiSystemCallSelector</code> AND <code>NtQuery(SystemIsolatedUserModeInformation).HvciEnabled</code> AND <code>cpuid(0x40000004).eax.UseIntForMbecSystemCalls</code>.</p>
<p>Note <code>int2E</code> IDT entry is special: its DPL is 0 (disallowed for usermode) when <code>nt!KiSystemCallSelector</code> == 0. And the latter mirrors the <code>LoaderBlock.Extension.VsmConfigured</code> bit (hypercall code page for VSM mapped by <code>winload</code>).</p>
<h2><code>Reserved2</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x30C</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved2;
</code></pre>
<p>Zero. &quot;Reserved field ‚Äì do not use. Used to be UserCetAvailableEnvironments&quot;.</p>
<h2><code>FullNumberOfPhysicalPages</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x310</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> FullNumberOfPhysicalPages;
</code></pre>
<p><em>fixed at boot, but might [rarely] change at runtime</em></p>
<p>OS-visible total RAM size, in pages. For comparison, ü°ëNumberOfPhysicalPages holds 32-bit value of such, clamped to <code><a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a></code> (16 TB RAM). Both values can change if RAM is added or removed; this larger field is updated first. Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.</p>
<p>‚ö†Ô∏è WARNING ‚ö†Ô∏è: field available since win11 24H2. On previous systems this location contains 0.</p>
<h2><code>SystemCallPad</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x318</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> SystemCallPad[1];
</code></pre>
<p>Zero. &quot;Available for reuse&quot;.</p>
<h2><code>TickCountQuad</code> (in union)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x320</td>
<td>‚ùï</td>
<td>Part of union at 0x320</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> TickCountQuad;
</code></pre>
<p><em>incremented by one every 15.625 ms (virtually all systems)</em></p>
<h2><code>TickCountPad</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x32C</td>
<td>ùçå ‚ôª</td>
<td>Part of struct at 0x320</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
</code></pre>
<h2><code>Cookie</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x330</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Cookie;
</code></pre>
<p>Cookie for encoding usermode pointers system-wide. Not related to the stack GS cookie, nor to the <code>ProcessCookie</code> infoclass. Exported <code>ntdll!<a href="rtlencodesystempointer" title="_Ret_maybenull_&#10;NTSYSAPI&#10;PVOID&#10;NTAPI&#10;RtlEncodeSystemPointer(&#10;    _In_opt_ PVOID Ptr&#10;    );">RtlEncodeSystemPointer</a></code> uses this field: <code>encoded_ptr = rotr(orig_ptr ^ Cookie, Cookie)</code>. Set once per boot to a good random value, on the first usermode thread creation, in <code>nt!PspNotifyThreadCreation</code>.</p>
<h2><code>CookiePad</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x334</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CookiePad[1];
</code></pre>
<p>Zero. Could have been higher part of the cookie to encode more bits, but unfortunately this field is unused.</p>
<h2><code>ConsoleSessionForegroundProcessId</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x338</td>
<td>‚ùï üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> ConsoleSessionForegroundProcessId;
</code></pre>
<p><em>physical user controls it; üêû added &quot;volatile&quot;</em></p>
<p>Process ID (pid) of the process with focus in the current physical console. RDP sessions ignored. Edge cases when value is zero: Windows Sandbox (as it's RDP), and Hyper-V docker containers (as they are gui-less, so no focus). Hyper-V Manager <em>enhanced</em> sessions are RDP too, in such sessions you'll observe some &quot;leftover&quot; value, normally the pid of the <code>LogonUI.exe</code> running in the &quot;physical&quot; <em>basic</em> session. Similar to ü°ëActiveConsoleId. When the physical box (or its equivalent) is locked, focused app is normally <code>LogonUI.exe</code>; pid here reflects that.</p>
<p>‚ö†Ô∏è Process death is not tracked ‚Äì there might be brief periods when this field contains id of an already terminated process, or even id of some new, unrelated process due to pid reuse (very brief and rare). To set this field <code>win32kfull.sys</code> uses dedicated exported api: <code>nt!RtlSetConsoleSessionForegroundProcessId</code>.</p>
<p>Silo-aware: <code><a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a></code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ConsoleSessionForegroundProcessId</code>.</p>
<h2><code>TimeUpdateLock</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x340</td>
<td>‚ùï</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TimeUpdateLock;
</code></pre>
<p><em>changes twice each clock interrupt; üêû added &quot;volatile&quot;</em></p>
<p>Sequence number/lock for time-related fields. When value is odd, set of fields is being updated. See &quot;Cross-fields coherence via sequence numbers&quot; below for details. List of protected fields, in currently utilized update order (not everything listed is always updated): ü°ëSystemTime, ü°ëInterruptTime, ü°ìBaselineSystemTimeQpc, ü°ìBaselineInterruptTimeQpc , [ü°ëTickCountQuad]. And on the rare &quot;time-only&quot; codepath we have slightly different update order and 2 more fields: ü°ìBaselineSystemTimeQpc, ü°ëSystemTime, ü°ìQpcSystemTimeIncrement, ü°ìQpcSystemTimeIncrementShift.</p>
<h2><code>BaselineSystemTimeQpc</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x348</td>
<td>‚ùï</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineSystemTimeQpc;
</code></pre>
<p><em>updates together with ü°ëSystemTime; üêû added &quot;volatile&quot;</em></p>
<p>Value retrieved via <code>nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>()</code> right before the ü°ëSystemTime field update, and used to compute new value of ü°ëSystemTime. Associated subfractional parts accumulator: <code>nt!KiSystemTimeErrorAccumulator</code>.</p>
<h2><code>BaselineInterruptTimeQpc</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x350</td>
<td>‚ùï</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineInterruptTimeQpc;
</code></pre>
<p><em>updates together with ü°ëInterruptTime; üêû added &quot;volatile&quot;</em></p>
<p>Value retrieved via <code>nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>()</code> right before the ü°ëInterruptTime field update, and used to compute new value of ü°ëInterruptTime. Since on the &quot;system tick&quot; codepath ü°ëInterruptTime and ü°ëSystemTime are updated together, this field most often holds very same Qpc value as ü°ëBaselineSystemTimeQpc. Associated subfractional parts accumulator: <code>nt!KiInterruptTimeErrorAccumulator</code>.</p>
<h2><code>QpcSystemTimeIncrement</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x358</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcSystemTimeIncrement;
</code></pre>
<p><em>might change at runtime for a bit (supposedly rare)</em></p>
<p>Fractional part of the Multiplier for computing new ü°ëSystemTime: <code>SystemTime += QpcDelta √ó Multiplier</code>. This field might change at runtime to speedup/slowdown the clock; that avoids sudden time jumps during timesync. Such clockrate change does NOT affect performance: rate of ü°ëInterruptTime and osticks/<code>GetTickCount()</code> is constant. It's common to see value 0x8000'0000'0000'0000 here; with fixed scaler of -0x40 that's effectively 0.5. See &quot;Time updates via Qpc deltas and increments&quot; below for details on the System Time computation.</p>
<h2><code>QpcInterruptTimeIncrement</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x360</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcInterruptTimeIncrement;
</code></pre>
<p>Fractional part of the Multiplier for computing new ü°ëInterruptTime: InterruptTime += QpcDelta √ó Multiplier. Set once during boot, in <code>nt!KiSetupTimeIncrement</code>. Remains constant afterwards. It's common to see value 0x8000'0000'0000'0000 here; with fixed scaler of -0x40 that's effectively 0.5. See &quot;Time updates via Qpc deltas and increments&quot; below for details on the Interrupt Time computation.</p>
<h2><code>QpcSystemTimeIncrementShift</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x368</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcSystemTimeIncrementShift;
</code></pre>
<p><em>might change at runtime for a bit (supposedly rare)</em></p>
<p>Extra scaling bits for computing new ü°ëSystemTime; scaler = -0x40 + ü°óQpcSystemTimeIncrementShift. Just like with ü°ëQpcSystemTimeIncrement, this field <em>might change</em> at runtime to speedup or slowdown the clock. It's common to see value 1 here; when const-scaled ü°ëQpcSystemTimeIncrement is effectively 0.5, these two fields basically cancel each other out. See &quot;Time updates via Qpc deltas and increments&quot; below for details.</p>
<h2><code>QpcInterruptTimeIncrementShift</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x369</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcInterruptTimeIncrementShift;
</code></pre>
<p>Extra scaling bits for computing new ü°ëInterruptTime; scaler = -0x40 + ü°óQpcInterruptTimeIncrementShift. Just like with ü°ëQpcInterruptTimeIncrement, this field <em>set once</em> during boot, in <code>nt!KiSetupTimeIncrement</code>. It's common to see value 1 here; when const-scaled ü°ëQpcInterruptTimeIncrement is effectively 0.5, these two fields basically cancel each other out. See &quot;Time updates via Qpc deltas and increments&quot; below for details.</p>
<h2><code>UnparkedProcessorCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x36A</td>
<td>‚ùï</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UnparkedProcessorCount;
</code></pre>
<p><em>may change a lot at runtime; üêû added &quot;volatile&quot;</em></p>
<p>Number of &quot;powered on&quot; [logical] processors. Each SMT core counts as a separate processor. This value can swing a lot at runtime as OS parks CPUs to save power. Always ‚â§ ü°ìActiveProcessorCount. Most often used to avoid spins in locks when there's only one running processor (by user and kernel mode alike).</p>
<h2><code>EnclaveFeatureMask</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x36C</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EnclaveFeatureMask[4];
</code></pre>
<p>Bitmask of enclave features supported on this system. Used by <code>ntdll!<a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a></code>. Out of the whole 128-bit value, only 3 bits seem to be currently defined:</p>
<ul>
<li>bit1/bit2: SGX1/SGX2 leaf funcs enabled (and locked in that state)</li>
<li>bit8: 1 if <code>LoaderBlock-&gt;Extension.IumEnabled</code> (can be 1 in root and non-root partitions; 0 if Hyper-V is off)</li>
</ul>
<h2><code>TelemetryCoverageRound</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x37C</td>
<td>üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryCoverageRound;
</code></pre>
<p>Current coverage round for telemetry based coverage (sequence number). Set to 1 at boot in <code>nt!EtwpInitializeCoverage</code> ‚Äì and most of the time stays like that. One way to increment this value: end the coverage round via <code><a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessTelemetryCoverage, {.LastCoveredRound=-4})</code>; however, that needs enabled Administrators group in client's token.</p>
<h2><code>UserModeGlobalLogger</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x380</td>
<td>üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UserModeGlobalLogger[0x10];
</code></pre>
<p><em>limited adjustability, specific conditions required</em></p>
<p>Used for ETW UMGL (user-mode global logging). Indices are <code>ETW_UMGL_INDEX_*</code> constants (see <code>nt!EtwpUmglProviders</code>): <code><a href="etw_umgl_index_heap" title="#define ETW_UMGL_INDEX_HEAP 0">ETW_UMGL_INDEX_HEAP</a></code> = 0 (<code>nt!<a href="heapguid" title="DEFINE_GUID( /* 222962ab-6180-4b88-a825-346b75f2a24a */&#10;    HeapGuid,&#10;    0x222962ab,&#10;    0x6180,&#10;    0x4b88,&#10;    0xa8, 0x25, 0x34, 0x6b, 0x75, 0xf2, 0xa2, 0x4a&#10;    );">HeapGuid</a></code>), <code><a href="etw_umgl_index_critsec" title="#define ETW_UMGL_INDEX_CRITSEC 1">ETW_UMGL_INDEX_CRITSEC</a></code> = 1 (<code>nt!<a href="critsecguid" title="DEFINE_GUID( /* 3AC66736-CC59-4cff-8115-8DF50E39816B */&#10;    CritSecGuid,&#10;    0x3ac66736,&#10;    0xcc59,&#10;    0x4cff,&#10;    0x81, 0x15, 0x8d, 0xf5, 0xe, 0x39, 0x81, 0x6b&#10;    );">CritSecGuid</a></code>), etc. Each <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> is actually a 2-byte <code><a href="etw_umgl_key" title="typedef struct _ETW_UMGL_KEY&#10;{&#10;    UCHAR LoggerId;&#10;    UCHAR Flags;&#10;} ETW_UMGL_KEY, *PETW_UMGL_KEY;">ETW_UMGL_KEY</a></code> structure: byte0 is LoggerId, byte1 is &quot;MatchAnyKeyword&quot; Flags. <code><a href="nttracecontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtTraceControl(&#10;    _In_ ETWTRACECONTROLCODE FunctionCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtTraceControl</a>(EtwSendDataBlock)</code> -&gt; ... -&gt; <code>nt!EtwpEnableDisableSpecialGuids()</code> -&gt; <code>nt!EtwpEnableDisableUMGL()</code>.</p>
<p>Silo-aware: <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.UserModeGlobalLogger</code>. See <code>ETW_UMGL_*</code> macro and defines for more.</p>
<h2><code>ImageFileExecutionOptions</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3A0</td>
<td>üëã ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ImageFileExecutionOptions;
</code></pre>
<p><em>changeable at runtime (but normally static)</em></p>
<p>When bit0 is set, &quot;GlobalFlag&quot; bits <code><a href="flg_application_verifier" title="#define FLG_APPLICATION_VERIFIER 0x00000100 // u">FLG_APPLICATION_VERIFIER</a></code>|<code><a href="flg_heap_page_allocs" title="#define FLG_HEAP_PAGE_ALLOCS 0x02000000 // u">FLG_HEAP_PAGE_ALLOCS</a></code> (0x0200'0100) will be read from HKCU IFEO (as long as both flagsü°ï absent in HKLM IFEO, and it's not a secure process). These two verifier bits are read by <code>ntdll</code> during process init, saved in <code><a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.GlobalFlags</code>. This field does NOT affect other IFEO values or GlobalFlag bits; they're still read from HKLM and PE <code>LoadConfig</code>. Bit0 initialized during boot in <code>nt!VerifierInitSystem</code>, from bit0 of <code>nt!ViImageExecutionOptions</code> (in turn, from <code>CCS\Control\Session Manager‚ÇÑImageExecutionOptions</code>). This entire field can be adjusted at runtime by clients with SeTcb privilege, via <code><a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemImageFileExecutionOptionsInformation)</code>.</p>
<h2><code>LangGenerationCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3A4</td>
<td>üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LangGenerationCount;
</code></pre>
<p><em>changeable at runtime (but mostly static)</em></p>
<p>Sequence number of the <code>nt!MUIRegistryInfo</code> structure, which holds UI languages info. Starts at 0 during boot. Only changes when usermode calls <code><a href="ntgetmuiregistryinfo" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtGetMUIRegistryInfo(&#10;    _In_ ULONG Flags,&#10;    _Inout_ PULONG DataSize,&#10;    _Out_ PVOID Data&#10;    );">NtGetMUIRegistryInfo</a>(Flags |= 8)</code>; that increments this field, and also assigns updated value to <code>nt!MUIRegistryInfo</code>.Generation (when <code>nt!MUIRegistryInfo</code> exists). Normally the first and only increment is done by the first <code>Winlogon.exe</code>. No rights nor privileges required to perform such increment.</p>
<h2><code>Reserved4</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3A8</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Reserved4;
</code></pre>
<p>Zero. &quot;Available for reuse&quot;.</p>
<h2><code>InterruptTimeBias</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3B0</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> InterruptTimeBias;
</code></pre>
<p><em>rare updates on power events; &quot;manual&quot; via timed sleep</em></p>
<p>Under certain conditions (e.g. after hibernation), OS makes ü°ëInterruptTime to jump forward (OS &quot;biases&quot; it). This field accumulates all such adjustments, enabling clients to get unadulterated Interrupt Time. To get such unadulterated Unbiased Interrupt Time, take ü°ëInterruptTime, and subtract ü°óInterruptTimeBias from it.</p>
<p>‚ö†Ô∏è Field is NOT protected via ü°ëTimeUpdateLock. To ensure coherence between this field and ü°ëInterruptTime, read this value first, then ü°ëInterruptTime, then this value again ‚Äì and check it hasn't changed.</p>
<p>Note <code>ntdll!<a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a></code> does a bit more: it wraps that sequence into a pair of reads of exported <code>ntdll!RtlpFreezeTimeBias</code> [where OS accumulates Deep Freeze time for current process], and subtracts that too.</p>
<p>Updated on these paths:</p>
<ol>
<li><code>nt!KeAdjustInterruptTime</code>. Mostly on exit from sleep/hibernate; also if <code>TickcountRolloverDelay</code> ü°ë used.</li>
<li><code>nt!KiAdjustTimersAfterDripsExit</code>. DRIPS is Deepest Runtime Idle Platform State. Tricky: only increments if OS spent more than <code>nt!KeTimerRebaseThresholdOnDripsExit</code> consecutive seconds in the current DRIPS state. That var is from <code>CCS\Control\Power‚ÇÑTimerRebaseThresholdOnDripsExit</code>; by default it's 45 seconds.</li>
</ol>
<h2><code>QpcBias</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3B8</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcBias;
</code></pre>
<p><em>rare updates on power events; &quot;manual&quot; via timed sleep</em></p>
<p>Somewhat similar to ü°ëInterruptTimeBias. Accumulates bias for the Qpc value. But there's important difference: ü°ëInterruptTime already incorporates bias, so client-oriented api <code><a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a></code> has to <em>subtract</em> ü°ëInterruptTimeBias; but raw Qpc value does NOT incorporate bias, so <code><a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a></code> has to <em>add</em> ü°óQpcBias! Yes, it's almost like OS devs mixed up bias inclusion cases to do some extra math on hot codepaths. Unit is ü°ëQpcFrequency‚Åª¬π seconds. When <code>nt!HalpPerformanceCounter</code> type is Processor or Hypervisor, frequency is 10 MHz; making the unit exactly one centum (100 ns), same as ü°ëInterruptTimeBias. Updated in <code>nt!HalpTimerPropagateQpcBiasUpdate</code>, on rare power-related events, like sleep/hibernation. For <code>TimerHypervisor</code> and <code>TimerGit</code>, bias value comes directly from <code>REGISTERED_TIMER.TimeBias</code>. For <code>TimerProcessor</code> that same <code>TimeBias</code> field is scaled to 10 MHz first. Settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcbias" title="#define GlobalDataIdQpcBias 18 // KUSER_SHARED_DATA-&gt;QpcBias">GlobalDataIdQpcBias</a>[=18])</code>.</p>
<h2><code>ActiveProcessorCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C0</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveProcessorCount;
</code></pre>
<p><em>rare increments at runtime possible; üêû added &quot;volatile&quot;</em></p>
<p>Number of [logical] processors in the system. Each SMT core counts as a separate processor. Field name is mildly confusing (and digging deeper only makes it worse). Value mirrors unexported <code>nt!KeNumberProcessors</code>; don't mistake it for the <em>exported</em> &quot;KeNumberProcessors&quot;, which is actually <code>nt!KeNumberProcessorsGroup0</code> variable (¬ø‚∏Æ?). Also don't mix it up with <code>nt!KeMaximumProcessors</code>ü°ñ, nor with <code>nt!KeActiveProcessors</code> (set of <code><a href="kaffinity_ex" title="typedef struct _KAFFINITY_EX&#10;{&#10;    USHORT Count;&#10;    USHORT Size;&#10;    ULONG Reserved;&#10;    union&#10;    {&#10;        ULONG_PTR Bitmap[1];&#10;        ULONG_PTR StaticBitmap[32];&#10;    } DUMMYUNIONNAME;&#10;} KAFFINITY_EX, *PKAFFINITY_EX;">KAFFINITY_EX</a></code> masks). ‚Æû TLDR: just drop &quot;Active&quot; from the name. Use ü°ëUnparkedProcessorCount for count of CPUs actually running atm. Field set during boot. On some server SKUs you can add CPUs dynamically: on such systems this value may increase at runtime. But it will never decrease, and will never exceed <code>nt!KeMaximumProcessors</code> during current boot session. Absolute max # of processors: ws2022/win11: 0x800 (2048) [confirmed 24H2]; win10 22H2: 0x500 (1280).</p>
<h2><code>ActiveGroupCount</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C4</td>
<td>‚ó∑</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ActiveGroupCount;
</code></pre>
<p><em>rare increments possible</em></p>
<p>Number of processor groups in the system. Mirrors <code>nt!KiActiveGroups</code>. On some server SKUs you can add CPUs dynamically: on such systems this value may increase at runtime.</p>
<p>Note you can force-split CPUs into multiple groups on boot: <code>bcdedit /set GroupSize 2</code> to get N groups with 2 CPUs each. Absolute max # of CPU groups for any OS is 0x20 (32) [confirmed 24H2].</p>
<h2><code>Reserved9</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C5</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved9;
</code></pre>
<p>Zero. &quot;Available for reuse&quot;.</p>
<h2><code>QpcData</code> (in union)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C6</td>
<td>‚ó∑</td>
<td>Part of union at 0x3C6</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
</code></pre>
<p>Entire field settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcdata" title="#define GlobalDataIdQpcData 17 // KUSER_SHARED_DATA-&gt;QpcData">GlobalDataIdQpcData</a>[=17])</code>.</p>
<h2><code>QpcBypassEnabled</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C6</td>
<td>‚ó∑</td>
<td>Part of struct at 0x3C6</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;
</code></pre>
<p><em>won't really change, except possibly on OS live migration</em></p>
<p>Bitflags governing <code>ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>()</code> behavior, described above. On old OS [before win10 1709, RS3] it was a bool, that role is now taken by bit0. This byte settable in kernel mode via <code><a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(QpcBypassEnabled[=16])</code>.</p>
<h2><code>QpcShift</code> (in struct)</h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C7</td>
<td>ùçå ‚ôª</td>
<td>Part of struct at 0x3C6</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcShift;
</code></pre>
<p>Zero. Unused on modern OS. On old OS [before win10 1709, RS3] it was used as a bitshift value for the raw perfcounter: <code>ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>()</code> =&gt; <code>(rdtsc() + ü°ëQpcBias) &gt;&gt; ü°óQpcShift</code> [before 1709]. But that made Qpc rate very different across systems; nowadays OS uses much more precise scaling.</p>
<h2><code>TimeZoneBiasEffectiveStart</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3C8</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">LARGE_INTEGER TimeZoneBiasEffectiveStart;
</code></pre>
<p>Pair (ü°óTimeZoneBiasEffectiveStart, ü°óTimeZoneBiasEffectiveEnd) form a range for ü°ëSystemTime when ü°ëTimeZoneBias is valid. That is, if ü°ëSystemTime is in that range, LocalTime = (ü°ëSystemTime - ü°ëTimeZoneBias). That's true regardless of DST (it's already included in ü°ëTimeZoneBias). If both range ends are 0, the range spans <em>all</em> time. For time outside the range, local time has to be computed manually. Fields can be updated at runtime (e.g. when range end is reached, or timezone changed). Coherence in relation to ü°ëTimeZoneBias during fields update ensured via ü°ëTimeZoneBiasStamp.</p>
<p>Silo-aware: <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveStart</code>, <code><a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveEnd</code>.</p>
<p>Normally, ü°óTimeZoneBiasEffectiveStart is equal to the snapshot of ü°ëSystemTime at one of these moments:</p>
<ul>
<li>system boot + 5..15 seconds</li>
<li>system date/time change</li>
<li>timezone change</li>
<li>crossing the DST line (i.e. ü°ëSystemTime reached ü°óTimeZoneBiasEffectiveEnd, so the new range has to be established)</li>
</ul>
<p>ü°óTimeZoneBiasEffectiveEnd updated together with ü°óTimeZoneBiasEffectiveStart. It's set to either the next DST line or to (end of year + ü°ëTimeZoneBias), whichever is earlier. Adjustable ‚Äì within a certain amount ‚Äì by clients with SeTimeZone privilege, together with ü°ëTimeZoneBias.</p>
<h2><code>TimeZoneBiasEffectiveEnd</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3D0</td>
<td>‚ó∑ üëã</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">LARGE_INTEGER TimeZoneBiasEffectiveEnd;
</code></pre>
<p>See <code>TimeZoneBiasEffectiveStart</code> above.</p>
<h2><code>XState</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x3D8</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">XSTATE_CONFIGURATION XState;
</code></pre>
<p><em>used now, but really should not be in kuser</em></p>
<p>Extended processor state configuration. Initialized once at boot in <code>nt!KiInitializeXSaveConfiguration</code>, based on features actually supported by cpu, and features disabled via <code>LoaderBlock</code> (<code>bcdedit /set xsaveDisable|xsavePolicy|xsaveRemoveFeature</code>). Since win11 24H2, ARM64 oskernel tries to ignore this field, uses its own ü°ìXStateArm64 instead. But even though ARM64 doesn't init it, <code>XState.EnabledFeatures</code> still used sometimes (e.g. <code>nt!PopHandleNextState</code>) due to bugs/leftovers.</p>
<h2><code>FeatureConfigurationChangeStamp</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x720</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> FeatureConfigurationChangeStamp;
</code></pre>
<p><em>offset is 0x710 on win10 22H2 and earlier OS</em></p>
<p>Mirrors global value read via exported <code>nt!<a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a></code> (part of <code>nt!CmFcSystemManager</code>). Starts at 1 at boot, increments each time feature config changes. However, there is so called &quot;SwapReferenceIndex&quot; (<code>RtlGetSwapReferenceIndex</code>), changing which might bring in parallel global value. This field is what's referred to as <code><a href="rtl_feature_change_stamp" title="typedef ULONGLONG RTL_FEATURE_CHANGE_STAMP, *PRTL_FEATURE_CHANGE_STAMP;">RTL_FEATURE_CHANGE_STAMP</a></code>/<code>ChangeStamp</code> in structures for <code><a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemFeatureConfigurationInformation)</code>.</p>
<p>Note these are NOT &quot;Optional Windows Features&quot;; rather these are A/B features (and ongoing security fix &quot;features&quot;), adjustable via e.g. opensource ViveTool.</p>
<p>‚ö†Ô∏è Size of ü°ëXState increased by 0x10 in WS2022, changing this field offset from 0x710 to 0x720.</p>
<h2><code>Spare</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x72C</td>
<td>ùçå ‚ôª</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Spare;
</code></pre>
<p>Zero.</p>
<h2><code>UserPointerAuthMask</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x730</td>
<td>ùçå</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a> UserPointerAuthMask;
</code></pre>
<p><em>available since win11 22H2</em></p>
<p>Mirrors <code>nt!KePointerAuthMask</code>. Only used for ARM64, zero on x64. Initialized once at boot. Contains a mask to apply to a pointer value to extract authentication &quot;PAC&quot; bits together with a sign bit (highest bit preceding the PAC). If PAC is not used, or PAC size is not exactly 8 bits, value is simply zero (confirmed win11 24H2 and earlier). So the only values possible are 0 and 0xFF80'0000'0000'0000 [2025-08].</p>
<h2><code>XStateArm64</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x738</td>
<td>ùçå ‚ôª</td>
<td>ARM64 only</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp">XSTATE_CONFIGURATION XStateArm64;
</code></pre>
<p><em>used now, but really should not be in kuser</em></p>
<p>Following fields are there since win11 24H2. Extended processor state configuration specifically for ARM64. ARM64 OS kernels before win11 24H2 were less greedy and simply used ü°ëXState.</p>
<h2><code>Reserved10</code></h2>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Sigils</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x738</td>
<td>ùçå ‚ôª</td>
<td>Non-ARM64</td>
</tr>
</tbody>
</table>
<pre><code class="language-cpp"><a href="uint" title="typedef unsigned int UINT;">UINT</a> Reserved10[0xD2];
</code></pre>
<p>&quot;The reserved space for other architectures is not available for reuse&quot;.</p>
<h2>Structure End</h2>
<p>Total size: 0xA80</p>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ntddk-kuser_shared_data)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>
<p>This topic describes the <strong>KUSER_SHARED_DATA</strong> structure.</p>
<h2>Members</h2>
<h3><code>TickCountLowDeprecated</code></h3>
<p>Current low 32-bit of tick count.</p>
<h3><code>TickCountMultiplier</code></h3>
<p>Tick count multiplier.</p>
<h3><code>InterruptTime</code></h3>
<p>Current 64-bit interrupt time in 100ns units.</p>
<h3><code>SystemTime</code></h3>
<p>Current 64-bit system time in 100ns units.</p>
<h3><code>TimeZoneBias</code></h3>
<p>Current 64-bit time zone bias.</p>
<h3><code>ImageNumberLow</code></h3>
<p>Low image magic number for the host system.</p>
<h3><code>ImageNumberHigh</code></h3>
<p>High image magic number for the host system.</p>
<h3><code>NtSystemRoot[260]</code></h3>
<p>Copy of system root in unicode. This field must be accessed via the <strong><a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a></strong> API for an accurate result.</p>
<h3><code>MaxStackTraceDepth</code></h3>
<p>Maximum stack trace depth if tracing enabled.</p>
<h3><code>CryptoExponent</code></h3>
<p>Crypto exponent value.</p>
<h3><code>TimeZoneId</code></h3>
<p>Time zone ID.</p>
<h3><code>LargePageMinimum</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>LargePageMinimum</strong>.</p>
<h3><code>AitSamplingValue</code></h3>
<p>This value controls the AIT sampling rate.</p>
<h3><code>AppCompatFlag</code></h3>
<p>This value controls switchback processing.</p>
<h3><code>RNGSeedVersion</code></h3>
<p>Current kernel root RNG state seed version.</p>
<h3><code>GlobalValidationRunlevel</code></h3>
<p>This value controls assertion failure handling.</p>
<h3><code>TimeZoneBiasStamp</code></h3>
<p>Defines the <strong><a href="long" title="typedef long LONG;">LONG</a></strong> member <strong>TimeZoneBiasStamp</strong>.</p>
<h3><code>NtBuildNumber</code></h3>
<p>The shared collective build number undecorated with C or F. <strong>GetVersionEx</strong> hides the real number.</p>
<h3><code>NtProductType</code></h3>
<p>Product type. This field must be accessed via the <strong><a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a></strong> API for an accurate result.</p>
<h3><code>ProductTypeIsValid</code></h3>
<p>Defines the <strong>BOOLEAN</strong> member <strong>ProductTypeIsValid</strong>.</p>
<h3><code>Reserved0[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>NativeProcessorArchitecture</code></h3>
<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member <strong>NativeProcessorArchitecture</strong>.</p>
<h3><code>NtMajorVersion</code></h3>
<p>The NT major version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>
<h3><code>NtMinorVersion</code></h3>
<p>The NT minor version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>
<h3><code>ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>]</code></h3>
<p>Processor features.</p>
<h3><code>Reserved1</code></h3>
<p>Reserved for future use.</p>
<h3><code>Reserved3</code></h3>
<p>Reserved for future use.</p>
<h3><code>TimeSlip</code></h3>
<p>Time slippage while in debugger.</p>
<h3><code>AlternativeArchitecture</code></h3>
<p>Alternative system architecture. For example, NEC PC98xx on x86.</p>
<h3><code>BootId</code></h3>
<p>Boot sequence, incremented for each boot attempt by the OS loader.</p>
<h3><code>SystemExpirationDate</code></h3>
<p>If the system is an evaluation unit, the following field contains the date and time that the evaluation unit expires. A value of 0 indicates that there is no expiration. A non-zero value is the UTC absolute time that the system expires.</p>
<h3><code>SuiteMask</code></h3>
<p>Suite support. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for an accurate result.</p>
<h3><code>KdDebuggerEnabled</code></h3>
<p>TRUE if a kernel debugger is connected/enabled.</p>
<h3><code>MitigationPolicies</code></h3>
<p>Mitigation policies.</p>
<h3><code>NXSupportPolicy</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>NXSupportPolicy</strong>.</p>
<h3><code>SEHValidationPolicy</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>SEHValidationPolicy</strong>.</p>
<h3><code>CurDirDevicesSkippedForDlls</code></h3>
<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>CurDirDevicesSkippedForDlls</strong>.</p>
<h3><code>Reserved</code></h3>
<p>Reserved for future use.</p>
<h3><code>CyclesPerYield</code></h3>
<p>Measured duration of a single processor yield, in cycles. This is used by lock packages to determine how many times to spin waiting for a state change before blocking.</p>
<h3><code>ActiveConsoleId</code></h3>
<p>Current console session Id. Always zero on non-TS systems. This field must be accessed via the <strong><a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a></strong> API for an accurate result.</p>
<h3><code>DismountCount</code></h3>
<p>Force-dismounts cause handles to become invalid. Rather than always probe handles, a serial number of dismounts is maintained that clients can use to see if they need to probe handles.</p>
<h3><code>ComPlusPackage</code></h3>
<p>This field indicates the status of the 64-bit COM+ package on the system. It indicates whether the Intermediate Language (IL) COM+ images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.</p>
<h3><code>LastSystemRITEventTickCount</code></h3>
<p>Time in tick count for system-wide last user input across all terminal sessions. For MP performance, it is not updated all the time (for example, once a minute per session). It is used for idle detection.</p>
<h3><code>NumberOfPhysicalPages</code></h3>
<p>Number of physical pages in the system. This can dynamically change as physical memory can be added or removed from a running system.</p>
<h3><code>SafeBootMode</code></h3>
<p>True if the system was booted in safe boot mode.</p>
<h3><code>VirtualizationFlags</code></h3>
<p>Virtualization flags.</p>
<h3><code>ArchStartedInEl2</code></h3>
<p>Keep this bitfield in sync with the one in arc.w.</p>
<h3><code>QcSlIsSupported</code></h3>
<p>Keep this bitfield in sync with the one in arc.w.</p>
<h3><code>Reserved12[2]</code></h3>
<p>Reserved for future use.</p>
<h3><code>DUMMYUNIONNAME2</code></h3>
<p>This is a packed bitfield that contains various flags concerning the system state. They must be manipulated using interlocked operations. <strong>DbgMultiSessionSku</strong> must be accessed via the <strong><a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a></strong> API for an accurate result.</p>
<h3><code>DUMMYUNIONNAME2.SharedDataFlags</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>SharedDataFlags</strong>.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2</code></h3>
<p>Defines the <strong>DUMMYSTRUCTNAME2</strong> structure.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgErrorPortPresent</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgElevationEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgVirtEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgInstallerDetectEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgLkgEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgDynProcessorEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgConsoleBrokerEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgSecureBootEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiSessionSku</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiUsersInSessionSku</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgStateSeparationEnabled</code></h3>
<p>For debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.SpareBits</code></h3>
<p>For the debugger only. Do not use. Use the bit definitions instead.</p>
<h3><code>DataFlagsPad[1]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>DataFlagsPad</strong>.</p>
<h3><code>TestRetInstruction</code></h3>
<p>Depending on the processor, the code for fast system call will differ. This field is only used on 32-bit systems.</p>
<h3><code>QpcFrequency</code></h3>
<p>Defines the <strong><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></strong> member <strong>QpcFrequency</strong>.</p>
<h3><code>SystemCall</code></h3>
<p>On AMD64, this value is initialized to a nonzero value if the system operates with an altered view of the system service call mechanism.</p>
<h3><code>Reserved2</code></h3>
<p>Reserved for future use.</p>
<h3><code>FullNumberOfPhysicalPages</code></h3>
<p>Reserved for future use.</p>
<h3><code>SystemCallPad[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>DUMMYUNIONNAME3</code></h3>
<p>The 64-bit tick count.</p>
<h3><code>DUMMYUNIONNAME3.TickCount</code></h3>
<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>TickCount</strong>.</p>
<h3><code>DUMMYUNIONNAME3.TickCountQuad</code></h3>
<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>TickCountQuad</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME</code></h3>
<p>Defines <strong>DUMMYSTRUCTNAME</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.ReservedTickCountOverlay[3]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>ReservedTickCountOverlay</strong>.</p>
<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.TickCountPad[1]</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>TickCountPad</strong>.</p>
<h3><code>Cookie</code></h3>
<p>Cookie for encoding pointers system wide.</p>
<h3><code>CookiePad[1]</code></h3>
<p>Reserved for future use.</p>
<h3><code>ConsoleSessionForegroundProcessId</code></h3>
<p>Client id of the process having the focus in the current active console session id. This field must be accessed via the <strong><a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a></strong> API for an accurate result.</p>
<h3><code>TimeUpdateLock</code></h3>
<p>Placeholder for the (internal) time update lock. This data is used to implement the precise time services. It is aligned on a 64-byte cache-line boundary and arranged in the order of typical accesses.</p>
<h3><code>BaselineSystemTimeQpc</code></h3>
<p>The performance counter value used to establish the current system time.</p>
<h3><code>BaselineInterruptTimeQpc</code></h3>
<p>The performance counter value used to compute the last interrupt time.</p>
<h3><code>QpcSystemTimeIncrement</code></h3>
<p>The scaled number of system time seconds represented by a single performance count (this value may vary to achieve time synchronization).</p>
<h3><code>QpcInterruptTimeIncrement</code></h3>
<p>The scaled number of interrupt time seconds represented by a single performance count (this value is constant after the system is booted).</p>
<h3><code>QpcSystemTimeIncrementShift</code></h3>
<p>The scaling shift count applied to the performance counter system time increment.</p>
<h3><code>QpcInterruptTimeIncrementShift</code></h3>
<p>The scaling shift count applied to the performance counter interrupt time increment.</p>
<h3><code>UnparkedProcessorCount</code></h3>
<p>The count of unparked processors.</p>
<h3><code>EnclaveFeatureMask[4]</code></h3>
<p>A bitmask of enclave features supported on this system. This field must be accessed via the <strong><a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a></strong> API for an accurate result.</p>
<h3><code>TelemetryCoverageRound</code></h3>
<p>Current coverage round for telemetry based coverage.</p>
<h3><code>UserModeGlobalLogger[16]</code></h3>
<p>The following field is used for ETW user mode global logging (UMGL).</p>
<h3><code>ImageFileExecutionOptions</code></h3>
<p>Settings that can enable the use of Image File Execution Options from HKCU in addition to the original HKLM.</p>
<h3><code>LangGenerationCount</code></h3>
<p>Generation of the kernel structure holding system language information.</p>
<h3><code>Reserved4</code></h3>
<p>Reserved for future use.</p>
<h3><code>InterruptTimeBias</code></h3>
<p>Current 64-bit interrupt time bias in 100ns units.</p>
<h3><code>QpcBias</code></h3>
<p>Current 64-bit performance counter bias, in performance counter units before the shift is applied.</p>
<h3><code>ActiveProcessorCount</code></h3>
<p>Number of active processors.</p>
<h3><code>ActiveGroupCount</code></h3>
<p>Number of active groups.</p>
<h3><code>Reserved9</code></h3>
<p>Reserved for future use.</p>
<h3><code>QpcData</code></h3>
<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member QpcData.</p>
<h3><code>QpcBypassEnabled</code></h3>
<p>A boolean indicating whether performance counter queries can read the counter directly (bypassing the system call).</p>
<h3><code>QpcReserved</code></h3>
<p>Reserved for future use.</p>
<h3><code>TimeZoneBiasEffectiveStart</code></h3>
<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveStart</strong>.</p>
<h3><code>TimeZoneBiasEffectiveEnd</code></h3>
<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveEnd</strong>.</p>
<h3><code>XState</code></h3>
<p>Extended processor state configuration.</p>
<h3><code>FeatureConfigurationChangeStamp</code></h3>
<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>FeatureConfigurationChangeStamp</strong>.</p>
<h3><code>Spare</code></h3>
<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>Spare</strong>.</p>
<h3><code>UserPointerAuthMask</code></h3>
<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>UserPointerAuthMask</strong>.</p>
<h2>Remarks</h2>
<h2>See also</h2>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddk/ns-ntddk-kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
