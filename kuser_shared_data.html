<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="KUSER_SHARED_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>KUSER_SHARED_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            KUSER_SHARED_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTEXAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)

</span><span class="ntdoc-code-intro">/**
 * The KUSER_SHARED_DATA structure contains information shared with user-mode.
 *
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data
 */
</span><span class="ntdoc-code-body">typedef struct _KUSER_SHARED_DATA
{
    //
    // Current low 32-bit of tick count and tick count multiplier.
    //
    // N.B. The tick count is updated each time the clock ticks.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountLowDeprecated;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountMultiplier;

    //
    // Current 64-bit interrupt time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> InterruptTime;

    //
    // Current 64-bit system time in 100ns units.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> SystemTime;

    //
    // Current 64-bit time zone bias.
    //

    volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TimeZoneBias;

    //
    // Support image magic number range for the host system.
    //
    // N.B. This is an inclusive range.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberLow;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ImageNumberHigh;

    //
    // Copy of system root in unicode.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a> API for
    //      an accurate result.
    //

    WCHAR NtSystemRoot[260];

    //
    // Maximum stack trace depth if tracing enabled.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaxStackTraceDepth;

    //
    // Crypto exponent value.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CryptoExponent;

    //
    // Time zone ID.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeZoneId;

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LargePageMinimum;

    //
    // This value controls the AIT Sampling rate.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AitSamplingValue;

    //
    // This value controls switchback processing.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AppCompatFlag;

    //
    // Current Kernel Root RNG state seed version
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> RNGSeedVersion;

    //
    // This value controls assertion failure handling.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GlobalValidationRunlevel;

    volatile <a href="long" title="typedef long LONG;">LONG</a> TimeZoneBiasStamp;

    //
    // The shared collective build number undecorated with C or F.
    // GetVersionEx hides the real number
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtBuildNumber;

    //
    // Product type.
    //
    // N.B. This field must be accessed via the <a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a> API for
    //      an accurate result.
    //

    <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a> NtProductType;
    BOOLEAN ProductTypeIsValid;
    BOOLEAN Reserved0[1];
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> NativeProcessorArchitecture;

    //
    // The NT Version.
    //
    // N. B. Note that each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the
    //       process is running with an altered view of the system version,
    //       the following two fields are used to correctly identify the
    //       version
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMajorVersion;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NtMinorVersion;

    //
    // Processor features.
    //

    BOOLEAN ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];

    //
    // Reserved fields - do not use.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> MaximumUserModeAddressDeprecated; // Deprecated, use SystemBasicInformation instead.
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemRangeStartDeprecated; // Deprecated, use SystemRangeStartInformation instead.

    //
    // Time slippage while in debugger.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeSlip;

    //
    // Alternative system architecture, e.g., NEC PC98xx on x86.
    //

    <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;

    //
    // Boot sequence, incremented for each boot attempt by the OS loader.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BootId;

    //
    // If the system is an evaluation unit, the following field contains the
    // date and time that the evaluation unit expires. A value of 0 indicates
    // that there is no expiration. A non-zero value is the UTC absolute time
    // that the system expires.
    //

    LARGE_INTEGER SystemExpirationDate;

    //
    // Suite support.
    //
    // N.B. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for
    //      an accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SuiteMask;

    //
    // TRUE if a kernel debugger is connected/enabled.
    //

    BOOLEAN KdDebuggerEnabled;

    //
    // Mitigation policies.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
        };
    };

    //
    // Measured duration of a single processor yield, in cycles. This is used by
    // lock packages to determine how many times to spin waiting for a state
    // change before blocking.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> CyclesPerYield;

    //
    // Current console session Id. Always zero on non-TS systems.
    //
    // N.B. This field must be accessed via the <a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a> API for an
    //      accurate result.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveConsoleId;

    //
    // Force-dismounts cause handles to become invalid. Rather than always
    // probe handles, a serial number of dismounts is maintained that clients
    // can use to see if they need to probe handles.
    //

    volatile <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DismountCount;

    //
    // This field indicates the status of the 64-bit COM+ package on the
    // system. It indicates whether the Intermediate Language (IL) COM+
    // images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ComPlusPackage;

    //
    // Time in tick count for system-wide last user input across all terminal
    // sessions. For MP performance, it is not updated all the time (e.g. once
    // a minute per session). It is used for idle detection.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LastSystemRITEventTickCount;

    //
    // Number of physical pages in the system. This can dynamically change as
    // physical memory can be added or removed from a running system.  This
    // cell is too small to hold the non-truncated value on very large memory
    // machines so code that needs the full value should access
    // FullNumberOfPhysicalPages instead.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfPhysicalPages;

    //
    // True if the system was booted in safe boot mode.
    //

    BOOLEAN SafeBootMode;

    //
    // Virtualization flags.
    //

    union
    {
        <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;

#if defined(_ARM64_)

        //
        // N.B. Keep this bitfield in sync with the one in arc.w.
        //

        struct
        {
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> : 6;
        };

#endif

    };

    //
    // Reserved (available for reuse).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved12[2];

    //
    // This is a packed bitfield that contains various flags concerning
    // the system state. They must be manipulated using interlocked
    // operations.
    //
    // N.B. DbgMultiSessionSku must be accessed via the <a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>
    //      API for an accurate result
    //

    union
    {
        <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
        struct
        {
            //
            // The following bit fields are for the debugger only. Do not use.
            // Use the bit definitions instead.
            //

            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled       : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled            : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled             : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled    : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled   : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku        : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSplitTokenEnabled      : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgShadowAdminEnabled     : 1;
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits                 : 19;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DataFlagsPad[1];

    //
    // Depending on the processor, the code for fast system call will differ,
    // Stub code is provided pointers below to access the appropriate code.
    //
    // N.B. The following field is only used on 32-bit systems.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TestRetInstruction;

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> QpcFrequency;

    //
    // On AMD64, this value is initialized to a nonzero value if the system
    // operates with an altered view of the system service call mechanism.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemCall;

    //
    // Reserved field - do not use. Used to be UserCetAvailableEnvironments.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved2;

    //
    // Full 64 bit version of the number of physical pages in the system.
    // This can dynamically change as physical memory can be added or removed
    // from a running system.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> FullNumberOfPhysicalPages;

    //
    // Reserved, available for reuse.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> SystemCallPad[1];

    //
    // The 64-bit tick count.
    //

    union
    {
        volatile <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
        volatile <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> TickCountQuad;
        struct
        {
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME3;

    //
    // Cookie for encoding pointers system wide.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Cookie;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CookiePad[1];

    //
    // Client id of the process having the focus in the current
    // active console session id.
    //
    // N.B. This field must be accessed via the
    //      <a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a> API for an accurate result.
    //

    <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a> ConsoleSessionForegroundProcessId;

    //
    // N.B. The following data is used to implement the precise time
    //      services. It is aligned on a 64-byte cache-line boundary and
    //      arranged in the order of typical accesses.
    //
    // Placeholder for the (internal) time update lock.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> TimeUpdateLock;

    //
    // The performance counter value used to establish the current system time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineSystemTimeQpc;

    //
    // The performance counter value used to compute the last interrupt time.
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BaselineInterruptTimeQpc;

    //
    // The scaled number of system time seconds represented by a single
    // performance count (this value may vary to achieve time synchronization).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcSystemTimeIncrement;

    //
    // The scaled number of interrupt time seconds represented by a single
    // performance count (this value is constant after the system is booted).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcInterruptTimeIncrement;

    //
    // The scaling shift count applied to the performance counter system time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcSystemTimeIncrementShift;

    //
    // The scaling shift count applied to the performance counter interrupt time
    // increment.
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcInterruptTimeIncrementShift;

    //
    // The count of unparked processors.
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UnparkedProcessorCount;

    //
    // A bitmask of enclave features supported on this system.
    //
    // N.B. This field must be accessed via the <a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a> API for an
    //      accurate result.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EnclaveFeatureMask[4];

    //
    // Current coverage round for telemetry based coverage.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TelemetryCoverageRound;

    //
    // The following field is used for ETW user mode global logging
    // (UMGL).
    //

    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> UserModeGlobalLogger[16];

    //
    // Settings that can enable the use of Image File Execution Options
    // from HKCU in addition to the original HKLM.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ImageFileExecutionOptions;

    //
    // Generation of the kernel structure holding system language information
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> LangGenerationCount;

    //
    // Reserved (available for reuse).
    //

    <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Reserved4;

    //
    // Current 64-bit interrupt time bias in 100ns units.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> InterruptTimeBias;

    //
    // Current 64-bit performance counter bias, in performance counter units
    // before the shift is applied.
    //

    volatile <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> QpcBias;

    //
    // Number of active processors and groups.
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActiveProcessorCount;
    volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ActiveGroupCount;

    //
    // Reserved (available for re-use).
    //

    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved9;

    union
    {
        <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
        struct
        {
            //
            // A bitfield indicating whether performance counter queries can
            // read the counter directly (bypassing the system call) and flags.
            //

            volatile <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;

            //
            // Reserved, leave as zero for backward compatibility. Was shift
            // applied to the raw counter value to derive QPC count.
            //

            <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
        };
    };

    //
    // Reserved for future use.
    //

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    //
    // Extended processor state configuration (AMD64 and x86).
    //

    XSTATE_CONFIGURATION XState;

    //
    // <a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a>
    //

    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> FeatureConfigurationChangeStamp;

    //
    // Spare (available for re-use).
    //

    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Spare;

    //
    // This field holds a mask that is used in the process of authenticating pointers in user mode.
    // It helps in determining which bits of the pointer are used for authentication in user mode.
    //

    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a> UserPointerAuthMask;

    //
    // Extended processor state configuration (ARM64). The reserved space for
    // other architectures is not available for reuse.
    //

#if defined(_ARM64_)
    XSTATE_CONFIGURATION XStateArm64;
#else
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Reserved10[210];
#endif
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
</span><span class="ntdoc-code-footer">
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/3d935379c6ac1f147cc4e3b25bed778f0d140c69/phnt/include/ntexapi.h#L6467">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntddk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _KUSER_SHARED_DATA {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountLowDeprecated;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TickCountMultiplier;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  InterruptTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  SystemTime;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  TimeZoneBias;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberLow;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        ImageNumberHigh;
  WCHAR                         NtSystemRoot[260];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         MaxStackTraceDepth;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CryptoExponent;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeZoneId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LargePageMinimum;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AitSamplingValue;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         AppCompatFlag;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     RNGSeedVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         GlobalValidationRunlevel;
  <a href="long" title="typedef long LONG;">LONG</a>                          TimeZoneBiasStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtBuildNumber;
  <a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a>               NtProductType;
  BOOLEAN                       ProductTypeIsValid;
  BOOLEAN                       Reserved0[1];
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        NativeProcessorArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMajorVersion;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NtMinorVersion;
  BOOLEAN                       ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TimeSlip;
  <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a> AlternativeArchitecture;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         BootId;
  LARGE_INTEGER                 SystemExpirationDate;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SuiteMask;
  BOOLEAN                       KdDebuggerEnabled;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> MitigationPolicies;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> NXSupportPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> SEHValidationPolicy : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> CurDirDevicesSkippedForDlls : 2;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Reserved : 2;
    };
  };
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        CyclesPerYield;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveConsoleId;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DismountCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ComPlusPackage;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LastSystemRITEventTickCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         NumberOfPhysicalPages;
  BOOLEAN                       SafeBootMode;
  union {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> VirtualizationFlags;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ArchStartedInEl2 : 1;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QcSlIsSupported : 1;
    };
  };
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved12[2];
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SharedDataFlags;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgErrorPortPresent : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgElevationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgVirtEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgInstallerDetectEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgLkgEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgDynProcessorEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgConsoleBrokerEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgSecureBootEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgMultiUsersInSessionSku : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> DbgStateSeparationEnabled : 1;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SpareBits : 21;
    } DUMMYSTRUCTNAME2;
  } DUMMYUNIONNAME2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         DataFlagsPad[1];
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TestRetInstruction;
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      QpcFrequency;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         SystemCall;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved2;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     FullNumberOfPhysicalPages;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     SystemCallPad[1];
  union {
    <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a> TickCount;
    <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>      TickCountQuad;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ReservedTickCountOverlay[3];
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TickCountPad[1];
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME3;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Cookie;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         CookiePad[1];
  <a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a>                      ConsoleSessionForegroundProcessId;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     TimeUpdateLock;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineSystemTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     BaselineInterruptTimeQpc;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcSystemTimeIncrement;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcInterruptTimeIncrement;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcSystemTimeIncrementShift;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         QpcInterruptTimeIncrementShift;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UnparkedProcessorCount;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         EnclaveFeatureMask[4];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         TelemetryCoverageRound;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                        UserModeGlobalLogger[16];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ImageFileExecutionOptions;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         LangGenerationCount;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     Reserved4;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     InterruptTimeBias;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                     QpcBias;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         ActiveProcessorCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         ActiveGroupCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                         Reserved9;
  union {
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> QpcData;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcBypassEnabled;
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> QpcReserved;
    };
  };
  LARGE_INTEGER                 TimeZoneBiasEffectiveStart;
  LARGE_INTEGER                 TimeZoneBiasEffectiveEnd;
  XSTATE_CONFIGURATION          XState;
  <a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a>                  FeatureConfigurationChangeStamp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Spare;
  <a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a>                       UserPointerAuthMask;
  XSTATE_CONFIGURATION          XStateArm64;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                         Reserved10[210];
} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<p>This structure is partially <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">documented in Windows Driver Kit</a>. However, as verified on 2025-09, almost all Microsoft documentation for this structure is either outdated, useless, or downright incorrect.  </p>

<h1 id="introduction">Introduction</h1>

<p>KUSER_SHARED_DATA structure defines layout of the memory region, shared between kernelmode and usermode. It occupies a single physical page, mapped in oskernel at fixed address <code>0xFFFF'F780'0000'0000</code> (0xFFFFF78000000000), and in all but the _Minimal_ processes at <code>0x7FFE'0000</code> (0x7FFE0000). Since win11 23H2, the fixed virtual address in kernel is read-only; <code>nt!MmWriteableSharedUserData</code> holds a randomized virtual address of the writeable kernelmode mapping.</p>

<h1 id="definition">Definition</h1>

<p>Here is the full definition, with all fields properly documented.<br />
It has been enriched with field offsets and five special sigils to help you quickly assess each item.  </p>

<p>Legend:<br />
𝍌 - field fixed at boot and won't change at runtime<br />
❕ - changes often (e.g. secondwise)<br />
◷ - changes rarely (e.g. hourly)<br />
👋 – can be changed by usermode applications at runtime<br />
♻ – field is either reserved, or deprecated, or it has no real reason to be in kuser and should be moved elsewhere</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_KUSER_SHARED_DATA</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Unused, deprecated for more than 20 years. Always zero.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TickCountLowDeprecated</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 000 𝍌♻</span>

<span class="w">    </span><span class="c1">// Number of milliseconds per ostick, left-shifted by 0x18.</span>
<span class="w">    </span><span class="c1">// Mirrors nt!ExpTickCountMultiplier, derived directly from nt!KeMaximumIncrement. Across all archs, value is</span>
<span class="w">    </span><span class="c1">// clamped to a max of 0x0FA00000 (1/64 s, or 15.625 ms). And in fact, you&#39;ll almost never see anything else there,</span>
<span class="w">    </span><span class="c1">// except maybe 0x0F99A027 on some old systems (~15.600 ms, or 15.600099980831146 ms exactly).</span>
<span class="w">    </span><span class="c1">// GetTickCount() =&gt; (🡗TickCountMultiplier × 🡓TickCountQuad) &gt;&gt; 0x18.</span>
<span class="w">    </span><span class="c1">// Duration of an ostick is fixed at boot time, stored in nt!KeMaximumIncrement. Not to be confused with the clock</span>
<span class="w">    </span><span class="c1">// tick duration, nt!KeTimeIncrement, which can change at runtime (in 🡓InterruptTime description right below).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TickCountMultiplier</span><span class="p">;</span><span class="w">                      </span><span class="c1">// 004 𝍌</span>

<span class="w">    </span><span class="c1">// Number of centums (100 ns units) since system start. Value monotonically increases. Includes sleep/hibernation</span>
<span class="w">    </span><span class="c1">// time and the like (the &quot;bias&quot;); i.e. value jumps forward on wakeup. For raw uptime, subtract 🡓InterruptTimeBias.</span>
<span class="w">    </span><span class="c1">// Updated on each clock interrupt on the clock owner processor. Current update period is nt!KeTimeIncrement,</span>
<span class="w">    </span><span class="c1">// adjustable via <a href="ntsettimerresolution" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetTimerResolution(&#10;    _In_ ULONG DesiredTime,&#10;    _In_ BOOLEAN SetResolution,&#10;    _Out_ PULONG ActualTime&#10;    );">NtSetTimerResolution</a> (aka timeBeginPeriod), in the hardcoded range [0.5 ms, 15.625 ms].</span>
<span class="w">    </span><span class="c1">// Actual adjustable range can be smaller; set at boot as [nt!KeMinimumIncrement, nt!KeMaximumIncrement].</span>
<span class="w">    </span><span class="c1">// See 🡓TickCountQuad description on how to change this field initial value from 0 to up to 49.71 days.</span>
<span class="w">    </span><span class="c1">// Coherence of this field vs 🡓SystemTime, 🡓TickCountQuad, and certain others is ensured via 🡓TimeUpdateLock.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></span><span class="w"> </span><span class="n">InterruptTime</span><span class="p">;</span><span class="w">            </span><span class="c1">// 008 ❕ changes each clock interrupt</span>

<span class="w">    </span><span class="c1">// UTC System Time. Number of centums since 1601-01-01, exactly. It&#39;s a perfectly raw value; any conversions or</span>
<span class="w">    </span><span class="c1">// adjustments (like leap days or leap seconds) ought to be done on the higher level.</span>
<span class="w">    </span><span class="c1">// Coherence of this field vs 🡑InterruptTime, 🡓TickCountQuad, and certain others is ensured via 🡓TimeUpdateLock.</span>
<span class="w">    </span><span class="c1">// Clients not in the server silo with SeSystemtime privilege can set it via <a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a> to any value in range</span>
<span class="w">    </span><span class="c1">// [0, 2⁶¹+2³²), which is [1601-01-01, 8907-12-05 18:49:10]. Note regular users don&#39;t have SeSystemtime by default.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></span><span class="w"> </span><span class="n">SystemTime</span><span class="p">;</span><span class="w">               </span><span class="c1">// 014 ❕👋 changes each clock interrupt + adjustable</span>

<span class="w">    </span><span class="c1">// Current 64-bit time zone bias. Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBias.</span>
<span class="w">    </span><span class="c1">// It&#39;s the value you *subtract* from 🡑SystemTime to get Local Time. It&#39;s already pre-adjusted for daylight saving.</span>
<span class="w">    </span><span class="c1">// E.g. for Pacific Time (-08:00) value will be 7:00 in Summer (0x3AAC5ED800 == 7×3600×10⁷).</span>
<span class="w">    </span><span class="c1">// See 🡓TimeZoneBiasEffectiveStart description for when this field is considered valid.</span>
<span class="w">    </span><span class="c1">// Coherence of this field vs the 🡓TimeZoneBiasEffective* values ensured via 🡓TimeZoneBiasStamp.</span>
<span class="w">    </span><span class="c1">// Clients with SeTimeZone privilege can set bias using SystemTimeZoneInformation/SystemDynamicTimeZoneInformation</span>
<span class="w">    </span><span class="c1">// infoclasses. Range is ±2³¹ seconds (±68 years), granularity 1 minute. Regular users on client OS versions</span>
<span class="w">    </span><span class="c1">// DO have SeTimeZone privilege by default; on server OS versions they don&#39;t. Note timezone info is stored under</span>
<span class="w">    </span><span class="c1">// CCS\Control\TimeZoneInformation key; using timezone infoclasses grants users limited writeability to that key.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></span><span class="w"> </span><span class="n">TimeZoneBias</span><span class="p">;</span><span class="w">             </span><span class="c1">// 020 ◷👋 changes at runtime (~twice a year), manually adjustable</span>

<span class="w">    </span><span class="c1">// Fixed values, set at boot (in nt!InitBootProcessor). Both fields are the same: 0x8664 for x64, 0xAA64 for ARM64.</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidimagenumberlow" title="#define GlobalDataIdImageNumberLow 4 // KUSER_SHARED_DATA-&gt;ImageNumberLow">GlobalDataIdImageNumberLow</a>/<a href="globaldataidimagenumberhigh" title="#define GlobalDataIdImageNumberHigh 5 // KUSER_SHARED_DATA-&gt;ImageNumberHigh">GlobalDataIdImageNumberHigh</a>[=4/5]).</span>
<span class="w">    </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">ImageNumberLow</span><span class="p">;</span><span class="w">                          </span><span class="c1">// 02C 𝍌</span>
<span class="w">    </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">ImageNumberHigh</span><span class="p">;</span><span class="w">                         </span><span class="c1">// 02E 𝍌</span>

<span class="w">    </span><span class="c1">// Win32 system root path, e.g. &quot;C:\Windows&quot; – without quotes, without trailing slash.</span>
<span class="w">    </span><span class="c1">// First wchar is adjustable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidntsystemrootdrive" title="#define GlobalDataIdNtSystemRootDrive 15 // KUSER_SHARED_DATA-&gt;NtSystemRoot // RtlGetNtSystemRoot">GlobalDataIdNtSystemRootDrive</a>[=15]).</span>
<span class="w">    </span><span class="c1">// OS receives path from the osloader (winload.efi), in LoaderBlock.NtBootPathName. But LoaderBlock path has</span>
<span class="w">    </span><span class="c1">// no drive letter, so it&#39;s retrieved from the MountPointManager via <a href="ioctl_mountmgr_boot_dl_assignment" title="#define IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT CTL_CODE(MOUNTMGRCONTROLTYPE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS) // since WIN7">IOCTL_MOUNTMGR_BOOT_DL_ASSIGNMENT</a>.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtSystemRoot.</span>
<span class="w">    </span><span class="n">WCHAR</span><span class="w"> </span><span class="n">NtSystemRoot</span><span class="p">[</span><span class="mh">0x104</span><span class="p">];</span><span class="w">                      </span><span class="c1">// 030 𝍌♻ used now, but really shouldn&#39;t be in kuser</span>

<span class="w">    </span><span class="c1">// &quot;Maximum stack trace depth if tracing is enabled&quot;.</span>
<span class="w">    </span><span class="c1">// Appears to be deprecated, unused, always zero.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">MaxStackTraceDepth</span><span class="p">;</span><span class="w">                       </span><span class="c1">// 238 𝍌♻</span>

<span class="w">    </span><span class="c1">// Crypto exponent for yolocrypto. Unused, always zero. In the past could be non-zero only for &quot;internal&quot; OS builds.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">CryptoExponent</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 23C 𝍌♻</span>

<span class="w">    </span><span class="c1">// Time zone ID, TIME_ZONE_ID_*. Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneId.</span>
<span class="w">    </span><span class="c1">// 0: *_UNKNOWN (aka neither, DST not used), 1: *_STANDARD (winter), 2: *_DAYLIGHT (summer).</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidtimezoneid" title="#define GlobalDataIdTimeZoneId 6 // KUSER_SHARED_DATA-&gt;TimeZoneId">GlobalDataIdTimeZoneId</a>[=6]).</span>
<span class="w">    </span><span class="c1">// ⚠️ Unlike 🡑TimeZoneBias and 🡓TimeZoneBiasEffective*, this field is NOT protected via 🡓TimeZoneBiasStamp; it is</span>
<span class="w">    </span><span class="c1">// set before starting the 🡓TimeZoneBiasStamp update sequence. For coherence between this and other timezone</span>
<span class="w">    </span><span class="c1">// fields: read this first, then others, then read this field again and ensure it hasn&#39;t changed.</span>
<span class="w">    </span><span class="c1">// Indirectly adjustable by clients with SeTimeZone privilege, together with 🡑TimeZoneBias.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TimeZoneId</span><span class="p">;</span><span class="w">                               </span><span class="c1">// 240 ◷👋 changes at runtime ~twice a year, manually adjustable</span>

<span class="w">    </span><span class="c1">// Minimum size of a large page, in bytes. Determined by the CPU. On boot nt!MiInitSystem sets it to hardcoded 2 MB.</span>
<span class="w">    </span><span class="c1">// It seems the only purpose of this field is to simplify implementation of exported kernelbase!GetLargePageMinimum.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">LargePageMinimum</span><span class="p">;</span><span class="w">                         </span><span class="c1">// 244 𝍌♻ used now, but really shouldn&#39;t be in kuser</span>

<span class="w">    </span><span class="c1">// AIT sampling rate. TL note: AIT means App Impact Telemetry. Related to KIT, Kernel Impact Telemetry.</span>
<span class="w">    </span><span class="c1">// Related to ETW provider MS_Windows_AIT_Provider and exported api nt!KitLogFeatureUsage. Most likely deprecated.</span>
<span class="w">    </span><span class="c1">// Set during boot in nt!KitpInitAitSampleRate from CCS\Control\Session Manager\AppCompatCache₄Rate, unless it&#39;s</span>
<span class="w">    </span><span class="c1">// a safeboot. By default there is nothing in registry, so normally this field is 0.</span>
<span class="w">    </span><span class="c1">// Can be adjusted by holders of SeProfileSingleProcess privilege: <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemAitSamplingValue).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">AitSamplingValue</span><span class="p">;</span><span class="w">                         </span><span class="c1">// 248 👋♻</span>

<span class="w">    </span><span class="c1">// &quot;This value controls switchback processing&quot;.</span>
<span class="w">    </span><span class="c1">// Seemingly deprecated, unused, and always 0. But there&#39;s an active <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a> field of similar name: <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.AppCompatFlags.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">AppCompatFlag</span><span class="p">;</span><span class="w">                            </span><span class="c1">// 24C 𝍌♻</span>

<span class="w">    </span><span class="c1">// Number of times since boot CNG.sys has reseeded its entropy pool.</span>
<span class="w">    </span><span class="c1">// Reseed can be triggered via exported cng!<a href="entropypooltriggerreseedforium" title="VOID EntropyPoolTriggerReseedForIum(&#10;  BOOLEAN fPerformCallbacks&#10;);">EntropyPoolTriggerReseedForIum</a>, but it mostly auto-reseeds at these</span>
<span class="w">    </span><span class="c1">// intervals after the previous auto-reseed, in seconds: 1, 3, 9, 27, 81, 243, 729, 2187, 3600, 3600, 3600,..</span>
<span class="w">    </span><span class="c1">// I.e. interval triples till it hits one hour (but there&#39;s about 5 extra reseeds at system start).</span>
<span class="w">    </span><span class="c1">// On boot you&#39;ll often see 8 here; +27s: 9; +81s more: 10; after 6/18/55/115 minutes of uptime: 11/12/13/14; etc.</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidrngseedversion" title="#define GlobalDataIdRngSeedVersion 1 // KUSER_SHARED_DATA-&gt;RngSeedVersion">GlobalDataIdRngSeedVersion</a>[=1]).</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">RNGSeedVersion</span><span class="p">;</span><span class="w">                       </span><span class="c1">// 250 ◷ incremented periodically (every hour on average)</span>

<span class="w">    </span><span class="c1">// Set of flags to control assert failures handling. Read on boot from CCS\Control\ValidationRunLevels₄Global. See</span>
<span class="w">    </span><span class="c1">// VRL_* flags in sdk; from oskernel view the only bit is VRL_ENABLE_KERNEL_BREAKS, it only affects debug OS builds.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">GlobalValidationRunlevel</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 258 𝍌♻</span>

<span class="w">    </span><span class="c1">// Sequence number/lock for timezone data: 🡑TimeZoneBias, 🡓TimeZoneBiasEffectiveStart, 🡓TimeZoneBiasEffectiveEnd.</span>
<span class="w">    </span><span class="c1">// When value is odd, the set of fields is being updated. See &quot;Cross-fields coherence via sequence numbers&quot; below</span>
<span class="w">    </span><span class="c1">// for details. Clients without any privileges can increment it by two via <a href="ntsetsystemtime" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemTime(&#10;    _In_opt_ PLARGE_INTEGER SystemTime,&#10;    _Out_opt_ PLARGE_INTEGER PreviousTime&#10;    );">NtSetSystemTime</a>(null, null).</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasStamp.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="long" title="typedef long LONG;">LONG</a></span><span class="w"> </span><span class="n">TimeZoneBiasStamp</span><span class="p">;</span><span class="w">                </span><span class="c1">// 25C ◷👋 changes at runtime rarely (e.g. daily), +manual adjust</span>

<span class="w">    </span><span class="c1">// Mirrors exported nt!NtBuildNumber, but with its higher nibble zeroed.</span>
<span class="w">    </span><span class="c1">// For nt!NtBuildNumber, higher nibble is 0xC in Checked (debug) builds, or 0xF in Free (release) builds.</span>
<span class="w">    </span><span class="c1">// Initially set to a hardcoded value for current ntoskrnl, equal to the &quot;real&quot; value in FixedFileVersionInfo (e.g.</span>
<span class="w">    </span><span class="c1">// 19041); during boot re-set to a dword from registry (e.g. 19045). This field (or rather the nt!NtBuildNumber it&#39;s</span>
<span class="w">    </span><span class="c1">// derived from) has modest usage throughout the system, but it does affect codepaths. Goes into <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.NtBuildNumber.</span>
<span class="w">    </span><span class="c1">// Reg path for win10: HKLM\Software\Microsoft\Windows NT\CurrentVersion\EditionVersion₄EditionBuildNumber.</span>
<span class="w">    </span><span class="c1">// For WS2022/win11: HKLM\SYSTEM\Software\Microsoft\BuildLayers\&lt;SubkeyWithValue.IsTopLevel==1&gt;₄BuildNumber.</span>
<span class="w">    </span><span class="c1">// &quot;The shared collective build number undecorated with C or F.&quot; – original WDK gem, kept for posterity.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">NtBuildNumber</span><span class="p">;</span><span class="w">                            </span><span class="c1">// 260 𝍌</span>

<span class="w">    </span><span class="c1">// Product type: client (e.g. Windows 10) VS server (e.g. Windows Server 2022) VS domain controller server.</span>
<span class="w">    </span><span class="c1">// 1/NtProductWinNt: client OS; 2/NtProductLanManNt: Windows Server in DC role; 3/NtProductServer: Windows Server.</span>
<span class="w">    </span><span class="c1">// Set on boot in nt!MiMemoryLicense, from nt!MmRegistryState.ProductType: CCS\Control\ProductOptions₄ProductType.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.NtProductType.</span>
<span class="w">    </span><span class="n"><a href="nt_product_type" title="typedef enum _NT_PRODUCT_TYPE&#10;{&#10;    NtProductWinNt = 1,&#10;    NtProductLanManNt,&#10;    NtProductServer&#10;} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;">NT_PRODUCT_TYPE</a></span><span class="w"> </span><span class="n">NtProductType</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 264 𝍌</span>

<span class="w">    </span><span class="c1">// Tells APIs they can use 🡑NtProductType field instead of querying that info from registry.</span>
<span class="w">    </span><span class="c1">// Normally it&#39;s 1, except during system install (&quot;SystemSetupInProgress&quot;).</span>
<span class="w">    </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="n">ProductTypeIsValid</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 268 𝍌♻</span>

<span class="w">    </span><span class="c1">// Zero.</span>
<span class="w">    </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="n">Reserved0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">                           </span><span class="c1">// 269 𝍌♻</span>

<span class="w">    </span><span class="c1">// PROCESSOR_ARCHITECTURE_* constant, e.g. 9 for PROCESSOR_ARCHITECTURE_AMD64, 12 for _ARM64.</span>
<span class="w">    </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">NativeProcessorArchitecture</span><span class="p">;</span><span class="w">             </span><span class="c1">// 26A 𝍌♻; shouldn&#39;t be in kuser; wow/sxs should use regular api</span>

<span class="w">    </span><span class="c1">// OS Version, set at boot to fixed values (in nt!InitBootProcessor). E.g. win7: 6 major, 1 minor.</span>
<span class="w">    </span><span class="c1">// Usual values: 5.1, 5.2, 6.0, 6.1, 6.2, 6.3; hardcoded to 10.0 since win10, stays as such in win11.</span>
<span class="w">    </span><span class="c1">// Unlike 🡑NtBuildNumber, adjusting MajorVersion &amp; MinorVersion in registry does NOT affect these fields.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">NtMajorVersion</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 26C 𝍌</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">NtMinorVersion</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 270 𝍌</span>

<span class="w">    </span><span class="c1">// Processor and/or OS features. See PF_* flags. Unfortunately, one whole byte used per flag.</span>
<span class="w">    </span><span class="c1">// Used by kernelbase!IsProcessorFeaturePresent (via ntdll!<a href="rtlisprocessorfeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsProcessorFeaturePresent(&#10;    _In_ ULONG ProcessorFeature&#10;    );">RtlIsProcessorFeaturePresent</a>).</span>
<span class="w">    </span><span class="c1">// ⚠️ Older OS versions may not set all expected flags, even if feature is actually supported by CPU and OS.</span>
<span class="w">    </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="n">ProcessorFeatures</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span><span class="w">                </span><span class="c1">// 274 𝍌; 0x40 is <a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a></span>

<span class="w">    </span><span class="c1">// Obsolete, dnu: always 0x7FFEFFFF on 64-bit OS. On 32-bit OS mirrors MM_HIGHEST_USER_ADDRESS (sensible with /3GB).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Reserved1</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 2B4 𝍌♻; aka MaximumUserModeAddressDeprecated</span>

<span class="w">    </span><span class="c1">// Obsolete, dnu: always 0x80000000 on 64-bit OS. On 32-bit OS mirrors MmSystemRangeStart.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Reserved3</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 2B8 𝍌♻; aka SystemRangeStartDeprecated</span>

<span class="w">    </span><span class="c1">// &quot;Time slippage while in debugger&quot;.</span>
<span class="w">    </span><span class="c1">// So, supposedly &quot;time wasted debugging&quot;, but there&#39;s strong indication this field is obsolete and always zero.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TimeSlip</span><span class="p">;</span><span class="w">                        </span><span class="c1">// 2BC 𝍌♻; *most likely* fixed at boot to 0 and doesn&#39;t change</span>

<span class="w">    </span><span class="c1">// Always zero. Previously: &quot;alternative system architecture, e.g., NEC PC98xx on x86&quot;.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">AlternativeArchitecture</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 2C0 𝍌♻; type is 2-const enum <a href="alternative_architecture_type" title="typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE&#10;{&#10;    StandardDesign,&#10;    NEC98x86,&#10;    EndAlternatives&#10;} ALTERNATIVE_ARCHITECTURE_TYPE;">ALTERNATIVE_ARCHITECTURE_TYPE</a></span>

<span class="w">    </span><span class="c1">// Number of boots since OS install (really, boot attempts). Osloader (winload.efi) reads \Windows\bootstat.dat</span>
<span class="w">    </span><span class="c1">// (BSD_BOOT_STATUS_DATA.LastBootId`0x34), increments and resaves it; passes value through LoaderBlock for</span>
<span class="w">    </span><span class="c1">// nt!InitBootProcessor, which stores it here. Filepath is changeable via BsdLogPath; ntoskrnl reduplicates it</span>
<span class="w">    </span><span class="c1">// from the loader block into CCS\ControlₛOsBootstatPath.</span>
<span class="w">    </span><span class="c1">// Hyper-V docker containers run with BootId == 1; at least some Windows Sandbox instances run with BootId == 2.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">BootId</span><span class="p">;</span><span class="w">                                   </span><span class="c1">// 2C4 𝍌</span>

<span class="w">    </span><span class="c1">// Value of 🡑SystemTime when system expires. Normally 0, which means no expiration. Not related to activation.</span>
<span class="w">    </span><span class="c1">// Evaluation OS versions have real value here. Used by winver.exe directly, and by win32k*.sys to paint watermark.</span>
<span class="w">    </span><span class="c1">// Set during boot from data returned by nt!ExGetExpirationDate() [<a href="ntquerylicensevalue" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryLicenseValue(&#10;    _In_ PCUNICODE_STRING ValueName,&#10;    _Out_opt_ PULONG Type,&#10;    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,&#10;    _In_ ULONG DataSize,&#10;    _Out_ PULONG ResultDataSize&#10;    );">ZwQueryLicenseValue</a>(&quot;Kernel-ExpirationDate&quot;)].</span>
<span class="w">    </span><span class="n">LARGE_INTEGER</span><span class="w"> </span><span class="n">SystemExpirationDate</span><span class="p">;</span><span class="w">             </span><span class="c1">// 2C8 𝍌</span>

<span class="w">    </span><span class="c1">// VER_SUITE_* mask, i.e. (1 &lt;&lt; <a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::*). E.g. if bit16 set, it&#39;s Windows Phone (<a href="suite_type" title="typedef enum _SUITE_TYPE&#10;{&#10;    SmallBusiness,&#10;    Enterprise,&#10;    BackOffice,&#10;    CommunicationServer,&#10;    TerminalServer,&#10;    SmallBusinessRestricted,&#10;    EmbeddedNT,&#10;    DataCenter,&#10;    SingleUserTS,&#10;    Personal,&#10;    Blade,&#10;    EmbeddedRestricted,&#10;    SecurityAppliance,&#10;    StorageServer,&#10;    ComputeServer,&#10;    WHServer,&#10;    PhoneNT,&#10;    MaxSuiteType&#10;...">SUITE_TYPE</a>::PhoneNT == 16).</span>
<span class="w">    </span><span class="c1">// Over time got sidelined; mostly you&#39;ll see just the minimum: 0x110 == VER_SUITE_TERMINAL|VER_SUITE_SINGLEUSERTS.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.SuiteMask.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">SuiteMask</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 2D0 𝍌</span>

<span class="w">    </span><span class="c1">// Kernel Debugger status bitmask. Value can change dynamically into any state (e.g. 1 -&gt; 3 -&gt; 0 -&gt; 3 -&gt; 1 -&gt; ...).</span>
<span class="w">    </span><span class="c1">// Bit0 mirrors exported boolean nt!KdDebuggerEnabled (debugger enabled, but not necessarily connected).</span>
<span class="w">    </span><span class="c1">// Bit1 is negation of the exported bool nt!KdDebuggerNotPresent (that is: when bit1 is 1, KD is connected/active).</span>
<span class="w">    </span><span class="c1">// 🔎 Example: booted with &quot;bcdedit /debug on&quot;, but w/o KD running: field=1 (enabled, not connected);</span>
<span class="w">    </span><span class="c1">// then launched KD on host: guest OS connects to KD, field changes 1-&gt;3 (active); run &quot;kdbgctrl -d&quot; on guest, aka</span>
<span class="w">    </span><span class="c1">// <a href="ntsystemdebugcontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSystemDebugControl(&#10;    _In_ SYSDBG_COMMAND Command,&#10;    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtSystemDebugControl</a>(SysDbgDisableKernelDebugger): field changes 3-&gt;0 (forcing KD disconnect until dbg events).</span>
<span class="w">    </span><span class="c1">// Can also change 0-&gt;1/3 with kdbgctrl as long as nt!KdPitchDebugger is false (i.e. &quot;/debug on&quot; is true).</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidkddebuggerenabled" title="#define GlobalDataIdKdDebuggerEnabled 10 // KUSER_SHARED_DATA-&gt;KdDebuggerEnabled">GlobalDataIdKdDebuggerEnabled</a>[=10]), done by kdxxx/kdnet.dll.</span>
<span class="w">    </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">KdDebuggerEnabled</span><span class="p">;</span><span class="w">                        </span><span class="c1">// 2D4 ◷👋 may change if debugger connected; manually adjustable</span>

<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Minor subset of system mitigations.</span>
<span class="w">        </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">MitigationPolicies</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 2D5 𝍌</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// NX_SUPPORT_POLICY_* values. Only meaningful for 32-bit x86 processes. From &quot;bcdedit /set nx VALUE&quot;.</span>
<span class="w">            </span><span class="c1">// Applied at process startup via <a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessExecuteFlags).</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">NXSupportPolicy</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// SEH_VALIDATION_POLICY_* values. Only meaningful for 32-bit x86 processes. Set on boot from</span>
<span class="w">            </span><span class="c1">// CCS\Control\Session Manager₄DisableExceptionChainValidation. App IFEO value with the same name trumps it.</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">SEHValidationPolicy</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Determines what kinds of devices are illegal to have Current Working Directory searched for dlls. From</span>
<span class="w">            </span><span class="c1">// CCS\Control\Session Manager₄CWDIllegalInDLLSearch. App-specific IFEO value with the same name trumps it.</span>
<span class="w">            </span><span class="c1">// 0: any allowed; 1: WebDav; 2: any Remote device; 3: all devices illegal, never use CWD (-1 in registry).</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">CurDirDevicesSkippedForDlls</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Zero.</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">Reserved</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Measured duration of &quot;pause&quot; (x86) or &quot;yield&quot; (ARM) instructions, in TSC (rdtsc) cycles. Determines how many</span>
<span class="w">    </span><span class="c1">// times to spin, e.g. in RtlBackoff (both rings). Early at boot set to 10, then – at later boot stages – updated</span>
<span class="w">    </span><span class="c1">// with data from nt!ExpComputeCyclesPerYield. Example: 0x0D, 0x18, 0x84. Measured values can vary boot to boot! OS</span>
<span class="w">    </span><span class="c1">// clamps value in range [1, 0xFFFF]. So if value is 0, the OS is simply too old to use it: older than win10 1903.</span>
<span class="w">    </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">CyclesPerYield</span><span class="p">;</span><span class="w">                          </span><span class="c1">// 2D6 𝍌</span>

<span class="w">    </span><span class="c1">// Current physical console Session Id. RDP sessions ignored. During boot it&#39;s 0. Right after the boot it may stay</span>
<span class="w">    </span><span class="c1">// 0 (Hyper-V docker container), change to 1 (normal box, Logon Screen), or to -1 (Windows Sandbox, kind of RDP).</span>
<span class="w">    </span><span class="c1">// Note Hyper-V Manager *basic* sessions are &quot;physical&quot;, but *enhanced* sessions are RDP; thus in enhanced sessions</span>
<span class="w">    </span><span class="c1">// you&#39;ll observe some &quot;leftover&quot; here, but really it&#39;ll be the &quot;physical&quot; basic session LogonUI.exe is running in.</span>
<span class="w">    </span><span class="c1">// When the physical box (or its equivalent) is locked, value *may* change; happens when LogonUI.exe is created in</span>
<span class="w">    </span><span class="c1">// a new session, which is the case if there are already several user sessions (physical or RDP).</span>
<span class="w">    </span><span class="c1">// Field set by win32kbase.sys and win32kfull.sys; they use dedicated exported api, nt!RtlSetActiveConsoleId.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ActiveConsoleId.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">ActiveConsoleId</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 2D8 ◷👋 sort of changeable by physically present users</span>

<span class="w">    </span><span class="c1">// Force-dismounting volumes makes affected handles refer to &quot;invalid&quot; files/volumes/directories; if app wants to</span>
<span class="w">    </span><span class="c1">// ensure handles &quot;validity&quot; for some reason (race condition notwithstanding), but doesn&#39;t want to always issue</span>
<span class="w">    </span><span class="c1">// <a href="fsctl_is_volume_mounted" title="// CTL_CODE(0x0009, 0x00a, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_IS_VOLUME_MOUNTED 0x00090028">FSCTL_IS_VOLUME_MOUNTED</a> ioctl (0x090028), it can simply check sameness of this field.</span>
<span class="w">    </span><span class="c1">// OS changes this value – interlocked-increments it – on two occasions:</span>
<span class="w">    </span><span class="c1">// 1) well-behaved filesystem driver invoked exported nt!FsRtlDismountComplete;</span>
<span class="w">    </span><span class="c1">// 2) OS received <a href="fsctl_dismount_volume" title="// CTL_CODE(0x0009, 0x008, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_DISMOUNT_VOLUME 0x00090020">FSCTL_DISMOUNT_VOLUME</a> (0x090020) via <a href="ntfscontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFsControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG FsControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtFsControlFile</a>/<a href="ntdeviceiocontrolfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDeviceIoControlFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG IoControlCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength&#10;    );">NtDeviceIoControlFile</a> (+=1 or +=2 per call).</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DismountCount</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 2DC ◷👋 changes at runtime on dismounts (rare), +manually</span>

<span class="w">    </span><span class="c1">// Lazy-mirrors HKLM\SOFTWARE\Microsoft\.NETFramework₄Enable64Bit. Value is a bitfield with only bit0 defined:</span>
<span class="w">    </span><span class="c1">// COMPLUS_ENABLE_64BIT. When set, it makes system run suitable 32-bit MSIL images as native 64-bit processes (so</span>
<span class="w">    </span><span class="c1">// one can observe 32-bit PE images run as 64-bit processes). Registry value is normally 1, but this field initially</span>
<span class="w">    </span><span class="c1">// set to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a>, making engaged code use <a href="ntquerysysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQuerySystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtQuerySystemInformation</a>(SystemComPlusPackage) to query reg value and</span>
<span class="w">    </span><span class="c1">// update this field. NtSet(SystemComPlusPackage) updates registry and this field, but needs registry write access.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">ComPlusPackage</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 2E0 ◷👋♻ normally changes once at runtime; manually adjustable</span>

<span class="w">    </span><span class="c1">// Snapshot of GetTickCount() ms at the moment of the last user input, across all terminal sessions (including RDP).</span>
<span class="w">    </span><span class="c1">// Used for e.g. idle detection. Updated by win32kbase!CitpLastInputUpdate at most *once per second*.</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidlastsystemriteventtickcount" title="#define GlobalDataIdLastSystemRITEventTickCount 13 // KUSER_SHARED_DATA-&gt;LastSystemRITEventTickCount">GlobalDataIdLastSystemRITEventTickCount</a>[=13]).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">LastSystemRITEventTickCount</span><span class="p">;</span><span class="w">              </span><span class="c1">// 2E4 ❕👋 updates every second as long as some users provide input</span>

<span class="w">    </span><span class="c1">// OS-visible total RAM size, in pages, clamped to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a> (16 TB RAM). Since win11 24H2, extended 64-bit field is</span>
<span class="w">    </span><span class="c1">// also available: 🡓FullNumberOfPhysicalPages. Both fields can change if RAM is added or removed.</span>
<span class="w">    </span><span class="c1">// Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">NumberOfPhysicalPages</span><span class="p">;</span><span class="w">                    </span><span class="c1">// 2E8 ◷ fixed at boot, but might [rarely] change at runtime</span>

<span class="w">    </span><span class="c1">// True if booted in safe boot mode (&quot;SAFEBOOT:&quot; present in the OS load options).</span>
<span class="w">    </span><span class="n">BOOLEAN</span><span class="w"> </span><span class="n">SafeBootMode</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 2EC 𝍌</span>

<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Copy of nt!KiVirtFlags, made in KiInitializeKernel based on MSR_IA32_FEATURE_CONTROL and/or VM_CR MSR.</span>
<span class="w">        </span><span class="c1">// bit0: vmx/svm enableable, bit1: enableablement locked (MSR_IA32_FEATURE_CONTROL.lock is true). Bits are 0</span>
<span class="w">        </span><span class="c1">// when: Hyper-V is running (regardless of partition); or VMX is off (in bios, or VM VBS-compatibility off).</span>
<span class="w">        </span><span class="c1">// Bits form mask 3 or 1 when: Hyper-V is NOT running, and VMX is on (in bios, or VM VBS-compatibility ON).</span>
<span class="w">        </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">VirtualizationFlags</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 2ED 𝍌</span>
<span class="cp">#if defined(_M_ARM64)</span>
<span class="w">        </span><span class="c1">// Set during boot to exact copy of byte LoaderBlock.Extension.VirtualizationFlags.</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">ArchStartedInEl2</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">QcSlIsSupported</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="nl"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Zero. &quot;Available for reuse&quot;.</span>
<span class="w">    </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">Reserved12</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w">                            </span><span class="c1">// 2EE 𝍌♻</span>

<span class="w">    </span><span class="c1">// Various system state flags, SHARED_GLOBAL_FLAGS_*. System adjusts them using interlocked operations.</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(GlobalDataIdSharedDataFlags[=14]) in a special way:</span>
<span class="w">    </span><span class="c1">// bit *index* is bits [0..29] of the input dword; bit 30 to *set* the bit, and/or bit31 to *clear* the bit.</span>
<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">SharedDataFlags</span><span class="p">;</span><span class="w">                      </span><span class="c1">// 2F0 ◷👋 certain flags may change at runtime</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Process with SetTcb privilege can (re-)register one global alpc error port via SystemErrorPortInformation</span>
<span class="w">            </span><span class="c1">// system infoclass (-&gt; nt!DbgkRegisterErrorPort). When that happens, system sets this bit. When registrar</span>
<span class="w">            </span><span class="c1">// process exits, or if port somehow disconnects, system unregisters port and clears this bit. In practice,</span>
<span class="w">            </span><span class="c1">// this bit indicates whether WerSvc is currently running (it registers \WindowsErrorReportingServicePort).</span>
<span class="w">            </span><span class="c1">// Note processes in silo can register error port too, but it&#39;ll be silo-specific; this bit won&#39;t be set.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgErrorPortPresent</span><span class="w">       </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  0/0001 ◷👋</span>

<span class="w">            </span><span class="c1">// Following 3 flags, together with new 🡓DbgShadowAdminEnabled, form basis for <a href="rtl_elevation_flags" title="typedef union _RTL_ELEVATION_FLAGS&#10;{&#10;    ULONG Flags;&#10;    struct&#10;    {&#10;        ULONG ElevationEnabled : 1;&#10;        ULONG VirtualizationEnabled : 1;&#10;        ULONG InstallerDetectEnabled : 1;&#10;        ULONG AdminApprovalModeType : 2;&#10;        ULONG ReservedBits : 27;&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a> struct,</span>
<span class="w">            </span><span class="c1">// returned by <a href="rtlqueryelevationflags" title="NTSYSAPI&#10;NTSTATUS&#10;NTAPI&#10;RtlQueryElevationFlags(&#10;    _Out_ PRTL_ELEVATION_FLAGS Flags&#10;    );">RtlQueryElevationFlags</a> api (in both usermode and kernelmode). Fields set on boot from reg</span>
<span class="w">            </span><span class="c1">// data at HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System, they won&#39;t update until reboot</span>
<span class="w">            </span><span class="c1">// even if registry values change. Bad type or size of reg data, or a missing value, yields 1 (not 0).</span>
<span class="w">            </span><span class="c1">// However, if CCS\Control\LsaInformation₄UACInstalled is 0, all 4 flags will be set to 0.</span>
<span class="w">            </span><span class="c1">// </span>
<span class="w">            </span><span class="c1">// policy: &quot;UAC: Turn on Admin Approval Mode&quot;, aka &quot;UAC: Run all administrators in Admin Approval Mode&quot;.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgElevationEnabled</span><span class="w">       </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  1/0002 𝍌, reg value₄: &quot;EnableLUA&quot;</span>
<span class="w">            </span><span class="c1">// policy: &quot;UAC: Virtualize file and registry write failures to per-user locations&quot;.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgVirtEnabled</span><span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  2/0004 𝍌, reg value₄: &quot;EnableVirtualization&quot;</span>
<span class="w">            </span><span class="c1">// policy: &quot;UAC: Detect application installations and prompt for elevation&quot;.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgInstallerDetectEnabled</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  3/0008 𝍌, reg value₄: &quot;EnableInstallerDetection&quot;</span>

<span class="w">            </span><span class="c1">// Indicates if Last Known Good is enabled. This bit mirrors nt!CmpLKGEnabled, initialized at boot to</span>
<span class="w">            </span><span class="c1">// CCS\Control\Session Manager\Configuration Manager\LastKnownGood₄Enabled. Most often it&#39;s 0.</span>
<span class="w">            </span><span class="c1">// This bit is NOT directly related to &quot;DisableLKG&quot; reg value₄ set by <a href="ntdisablelastknowngood" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDisableLastKnownGood(&#10;    VOID&#10;    );">NtDisableLastKnownGood</a>.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgLkgEnabled</span><span class="w">             </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  4/0010 𝍌</span>

<span class="w">            </span><span class="c1">// Indicates if new processors can be added at runtime. This bit mirrors exported &quot;almost read-only&quot; value</span>
<span class="w">            </span><span class="c1">// nt!KeDynamicPartitioningSupported, initialized at boot; value depends on sku and licensing. Normally</span>
<span class="w">            </span><span class="c1">// it&#39;s 0 for client systems, and can be 1 for servers. However: it&#39;s always zero in Hyper-V root partition.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgDynProcessorEnabled</span><span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  5/0020 𝍌</span>

<span class="w">            </span><span class="c1">// Dynamic value, managed by ConDrv.sys (the console driver). When true, console attach/allocation routines</span>
<span class="w">            </span><span class="c1">// in usermode take different road. Normally value is 0. But if any process with SeTcb privilege asks for</span>
<span class="w">            </span><span class="c1">// brokerage via request to \Device\ConDrv\Broker, this bit becomes 1 (until all broker objects are gone).</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgConsoleBrokerEnabled</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  6/0040 👋</span>

<span class="w">            </span><span class="c1">// True when SecureBoot is enabled. Initialized during boot. Matches simultaneously set value in the</span>
<span class="w">            </span><span class="c1">// volatile &quot;State&quot; subkey: CCS\Control\SecureBoot\State₄UEFISecureBootEnabled.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgSecureBootEnabled</span><span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  7/0080 𝍌</span>

<span class="w">            </span><span class="c1">// Indicates that OS supports multiple sessions. For regular OS it&#39;s always 1, even for &quot;single-user sku&quot;.</span>
<span class="w">            </span><span class="c1">// It&#39;s 0 only for Hyper-V docker containers; even then, OS still uses separate session for user processes.</span>
<span class="w">            </span><span class="c1">// Cleared bit entails serious security lax across OS (user ⥵ admin) due to &quot;WIN://ISMULTISESSIONSKU&quot;</span>
<span class="w">            </span><span class="c1">// conditional ACEs (mainly for registry keys), and regular checks in both modes via <a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>.</span>
<span class="w">            </span><span class="c1">// Bit is zeroed only if: CCS\Control\Session Manager₄NumberOfInitialSessions &lt; 2 (default 2), AND</span>
<span class="w">            </span><span class="c1">// &quot;ext-ms-win-session-wtsapi32-l1-1-0&quot; apiset fails to resolve to proper dll.</span>
<span class="w">            </span><span class="c1">// Silo-aware: ntdll!<a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.IsMultiSessionSku.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgMultiSessionSku</span><span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  8/0100 𝍌</span>

<span class="w">            </span><span class="c1">// Probably indicates that multiple users can share a session (lightweight user separation?). Often gets</span>
<span class="w">            </span><span class="c1">// checked when 🡑DbgMultiSessionSku is 0. Set at boot to mirror nt!RtlpMultiUsersInSessionSupported,</span>
<span class="w">            </span><span class="c1">// from CCS\Control\Session Manager₄MultiUsersInSessionSupported. Default is 0.</span>
<span class="w">            </span><span class="c1">// Accessible via exported ntdll!<a href="rtlismultiusersinsessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiUsersInSessionSku(&#10;    VOID&#10;    );">RtlIsMultiUsersInSessionSku</a>.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgMultiUsersInSessionSku</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">//  9/0200 𝍌</span>

<span class="w">            </span><span class="c1">// Indicates if state separation is enabled. It&#39;s hard to enable it for a regular OS, so normally it&#39;s 0.</span>
<span class="w">            </span><span class="c1">// State separation is a facility to use different, configurable paths to some registry hives, some</span>
<span class="w">            </span><span class="c1">// registry keys, and some files. This bit set at boot time to mirror nt!CmStateSeparationEnabled, from</span>
<span class="w">            </span><span class="c1">// CCS\Control\StateSeparation\Policy₄Enabled.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgStateSeparationEnabled</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// 10/0400 𝍌</span>

<span class="w">            </span><span class="c1">// Relatively new flag, even though concept of split token itself is old.</span>
<span class="w">            </span><span class="c1">// Likely requires at least win11 25H2. Not set in win11 24H2 and before.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgSplitTokenEnabled</span><span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// 11/0800 𝍌</span>

<span class="w">            </span><span class="c1">// Part of <a href="rtl_elevation_flags" title="typedef union _RTL_ELEVATION_FLAGS&#10;{&#10;    ULONG Flags;&#10;    struct&#10;    {&#10;        ULONG ElevationEnabled : 1;&#10;        ULONG VirtualizationEnabled : 1;&#10;        ULONG InstallerDetectEnabled : 1;&#10;        ULONG AdminApprovalModeType : 2;&#10;        ULONG ReservedBits : 27;&#10;    };&#10;} RTL_ELEVATION_FLAGS, *PRTL_ELEVATION_FLAGS;">RTL_ELEVATION_FLAGS</a>.</span>
<span class="w">            </span><span class="c1">// Likely requires at least win11 25H2. Not set in win11 24H2 and before.</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DbgShadowAdminEnabled</span><span class="w">     </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// 12/1000 𝍌, reg value: &quot;TypeOfAdminApprovalMode&quot;</span>

<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">SpareBits</span><span class="w">                 </span><span class="o">:</span><span class="w"> </span><span class="mi">19</span><span class="p">;</span><span class="w">   </span><span class="c1">// 13/~1FFF 𝍌♻</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">DUMMYSTRUCTNAME2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">DUMMYUNIONNAME2</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Zero.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">DataFlagsPad</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">                          </span><span class="c1">// 2F4 𝍌♻</span>

<span class="w">    </span><span class="c1">// On x64 contains 0xC3 (&quot;ret&quot;), 0 on ARM64. 32-bit x86 code can jump here to check if DEP is enabled: this page is</span>
<span class="w">    </span><span class="c1">// not executable, but if DEP is effectively off, OS will remove its NX bit for the process on exec attempt, sparing</span>
<span class="w">    </span><span class="c1">// the app STATUS_ACCESS_VIOLATION. That won&#39;t affect 64-bit processes: they implicitly have DEP enabled, always.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">TestRetInstruction</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 2F8 𝍌♻</span>

<span class="w">    </span><span class="c1">// Frequency of the high-resolution counter, ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() and nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>().</span>
<span class="w">    </span><span class="c1">// Value from such counter is known simply as &quot;Qpc&quot;. 🡗QpcFrequency = (Qpc₁ - Qpc₀), where (t₁ - t₀) == 1 s.</span>
<span class="w">    </span><span class="c1">// </span>
<span class="w">    </span><span class="c1">// What counter is actually used determined by the _REGISTERED_TIMER struct pointed to by nt!HalpPerformanceCounter.</span>
<span class="w">    </span><span class="c1">// Timer type is normally TimerProcessor (rdtsc/TSC_DEADLINE_MSR) [or TimerHypervisor, or TimerGit, ⩯ rdtsc].</span>
<span class="w">    </span><span class="c1">// For TimerProcessor OS scales tsc values used for Qpc to 10 MHz == 10⁷ Hz == 0x989680 (since win10 1809).</span>
<span class="w">    </span><span class="c1">// For TimerHypervisor the frequency simply set to 10 MHz in the first place. Thus 0x989680 is what you&#39;d normally</span>
<span class="w">    </span><span class="c1">// see there. Duration of each Qpc tick in such case is, naturally, 10⁻⁷ seconds – exactly one centum (100 ns).</span>
<span class="w">    </span><span class="c1">// This field gets set once at boot time together with various other 🡓Qpc* fields, in nt!KiSetupTimeIncrement.</span>
<span class="w">    </span><span class="n"><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></span><span class="w"> </span><span class="n">QpcFrequency</span><span class="p">;</span><span class="w">                          </span><span class="c1">// 300 𝍌</span>

<span class="w">    </span><span class="c1">// Normally 0. Contains 1 if int2E is preferable to syscall (x64 only). Set to 1 when: nt!KiSystemCallSelector</span>
<span class="w">    </span><span class="c1">// AND  NtQuery(SystemIsolatedUserModeInformation).HvciEnabled  AND  cpuid(0x40000004).eax.UseIntForMbecSystemCalls.</span>
<span class="w">    </span><span class="c1">// Note int2E IDT entry is special: its DPL is 0 (disallowed for usermode) when nt!KiSystemCallSelector == 0. And</span>
<span class="w">    </span><span class="c1">// the latter mirrors the LoaderBlock.Extension.VsmConfigured bit (hypercall code page for VSM mapped by winload).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">SystemCall</span><span class="p">;</span><span class="w">                               </span><span class="c1">// 308 𝍌</span>

<span class="w">    </span><span class="c1">// Zero. &quot;Reserved field – do not use. Used to be UserCetAvailableEnvironments&quot;.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Reserved2</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 30C 𝍌♻</span>

<span class="w">    </span><span class="c1">// OS-visible total RAM size, in pages. For comparison, 🡑NumberOfPhysicalPages holds 32-bit value of such, clamped</span>
<span class="w">    </span><span class="c1">// to <a href="uint_max" title="#define UINT_MAX 0xffffffff">UINT_MAX</a> (16 TB RAM). Both values can change if RAM is added or removed; this larger field is updated first.</span>
<span class="w">    </span><span class="c1">// Be aware: often 1-24 MB less than the actual RAM (sum of smbios memory devices), likely due to uefi hiding some.</span>
<span class="w">    </span><span class="c1">// ⚠️ WARNING ⚠️: field available since win11 24H2. On previous systems this location contains 0.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">FullNumberOfPhysicalPages</span><span class="p">;</span><span class="w">            </span><span class="c1">// 310 ◷ fixed at boot, but might [rarely] change at runtime</span>

<span class="w">    </span><span class="c1">// Zero. &quot;Available for reuse&quot;.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">SystemCallPad</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">                     </span><span class="c1">// 318 𝍌♻</span>

<span class="w">    </span><span class="c1">// Number of osticks since boot, incremented with fixed-at-boot frequency. This value is NOT ms, it&#39;s &quot;osticks&quot;,</span>
<span class="w">    </span><span class="c1">// which can be translated into ms (most often single ostick is 15.625 ms); see 🡑TickCountMultiplier.</span>
<span class="w">    </span><span class="c1">// Value updated by the clock owner processor, together with 🡑InterruptTime (just usually not as often). And just</span>
<span class="w">    </span><span class="c1">// like 🡑InterruptTime, this value includes sleep/hibernation time and the like (i.e. it jumps forward on wakeup).</span>
<span class="w">    </span><span class="c1">// Coherence of this field with 🡑SystemTime, 🡑InterruptTime, and certain others ensured via 🡓TimeUpdateLock.</span>
<span class="w">    </span><span class="c1">// </span>
<span class="w">    </span><span class="c1">// ⚠️ To change initial value of this field, set CCS\Control\Session Manager\Executive₄TickcountRolloverDelay to</span>
<span class="w">    </span><span class="c1">// the NEGATIVE desired time, in ms. E.g. to start from ≈8 osticks, set reg data to -125 ms (0xFFFF&#39;FF83); that&#39;ll</span>
<span class="w">    </span><span class="c1">// also set 🡑InterruptTime and 🡓InterruptTimeBias initial values to 1250000. Adjustable range: up to 49.71 days.</span>
<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></span><span class="w"> </span><span class="n">TickCount</span><span class="p">;</span>
<span class="w">        </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></span><span class="w"> </span><span class="n">TickCountQuad</span><span class="p">;</span><span class="w">             </span><span class="c1">// 320 ❕ incremented by one every 15.625 ms (virtually all systems)</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">ReservedTickCountOverlay</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="w">            </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TickCountPad</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">                  </span><span class="c1">// 32C 𝍌♻</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">DUMMYSTRUCTNAME</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">DUMMYUNIONNAME3</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Cookie for encoding usermode pointers system-wide. Not related to the stack GS cookie, nor to the ProcessCookie</span>
<span class="w">    </span><span class="c1">// infoclass. Exported ntdll!<a href="rtlencodesystempointer" title="_Ret_maybenull_&#10;NTSYSAPI&#10;PVOID&#10;NTAPI&#10;RtlEncodeSystemPointer(&#10;    _In_opt_ PVOID Ptr&#10;    );">RtlEncodeSystemPointer</a> uses this field: encoded_ptr = rotr(orig_ptr ^ Cookie, Cookie).</span>
<span class="w">    </span><span class="c1">// Set once per boot to a good random value, on the first usermode thread creation, in nt!PspNotifyThreadCreation.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Cookie</span><span class="p">;</span><span class="w">                                   </span><span class="c1">// 330 𝍌</span>

<span class="w">    </span><span class="c1">// Zero. Could have been higher part of the cookie to encode more bits, but unfortunately this field is unused.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">CookiePad</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">                             </span><span class="c1">// 334 𝍌♻</span>

<span class="w">    </span><span class="c1">// Process ID (pid) of the process with focus in the current physical console. RDP sessions ignored. Edge cases when</span>
<span class="w">    </span><span class="c1">// value is zero: Windows Sandbox (as it&#39;s RDP), and Hyper-V docker containers (as they are gui-less, so no focus).</span>
<span class="w">    </span><span class="c1">// Hyper-V Manager *enhanced* sessions are RDP too, in such sessions you&#39;ll observe some &quot;leftover&quot; value, normally</span>
<span class="w">    </span><span class="c1">// the pid of the LogonUI.exe running in the &quot;physical&quot; *basic* session. Similar to 🡑ActiveConsoleId.</span>
<span class="w">    </span><span class="c1">// When the physical box (or its equivalent) is locked, focused app is normally LogonUI.exe; pid here reflects that.</span>
<span class="w">    </span><span class="c1">// ⚠️ Process death is not tracked – there might be brief periods when this field contains id of an already</span>
<span class="w">    </span><span class="c1">// terminated process, or even id of some new, unrelated process due to pid reuse (very brief and rare).</span>
<span class="w">    </span><span class="c1">// To set this field win32kfull.sys uses dedicated exported api: nt!RtlSetConsoleSessionForegroundProcessId.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a>, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.ConsoleSessionForegroundProcessId.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></span><span class="w"> </span><span class="n">ConsoleSessionForegroundProcessId</span><span class="p">;</span><span class="w">    </span><span class="c1">// 338 ❕👋 physical user controls it; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Sequence number/lock for time-related fields.</span>
<span class="w">    </span><span class="c1">// When value is odd, set of fields is being updated. See &quot;Cross-fields coherence via sequence numbers&quot; below for</span>
<span class="w">    </span><span class="c1">// details. List of protected fields, in currently utilized update order (not everything listed is always updated):</span>
<span class="w">    </span><span class="c1">// 🡑SystemTime, 🡑InterruptTime, 🡓BaselineSystemTimeQpc, 🡓BaselineInterruptTimeQpc , [🡑TickCountQuad].</span>
<span class="w">    </span><span class="c1">// And on the rare &quot;time-only&quot; codepath we have slightly different update order and 2 more fields:</span>
<span class="w">    </span><span class="c1">// 🡓BaselineSystemTimeQpc, 🡑SystemTime, 🡓QpcSystemTimeIncrement, 🡓QpcSystemTimeIncrementShift.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">TimeUpdateLock</span><span class="p">;</span><span class="w">              </span><span class="c1">// 340 ❕ changes twice each clock interrupt; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Value retrieved via nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>() right before the 🡑SystemTime field update, and used to</span>
<span class="w">    </span><span class="c1">// compute new value of 🡑SystemTime. Associated subfractional parts accumulator: nt!KiSystemTimeErrorAccumulator.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">BaselineSystemTimeQpc</span><span class="p">;</span><span class="w">       </span><span class="c1">// 348 ❕ updates together with 🡑SystemTime; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Value retrieved via nt!<a href="kequeryperformancecounter" title="NTHALAPI LARGE_INTEGER KeQueryPerformanceCounter(&#10;  [out, optional] PLARGE_INTEGER PerformanceFrequency&#10;);">KeQueryPerformanceCounter</a>() right before the 🡑InterruptTime field update, and used to</span>
<span class="w">    </span><span class="c1">// compute new value of 🡑InterruptTime. Since on the &quot;system tick&quot; codepath 🡑InterruptTime and 🡑SystemTime are</span>
<span class="w">    </span><span class="c1">// updated together, this field most often holds very same Qpc value as 🡑BaselineSystemTimeQpc.</span>
<span class="w">    </span><span class="c1">// Associated subfractional parts accumulator: nt!KiInterruptTimeErrorAccumulator.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">BaselineInterruptTimeQpc</span><span class="p">;</span><span class="w">    </span><span class="c1">// 350 ❕ updates together with 🡑InterruptTime; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Fractional part of the Multiplier for computing new 🡑SystemTime: SystemTime += QpcDelta × Multiplier.</span>
<span class="w">    </span><span class="c1">// This field might change at runtime to speedup/slowdown the clock; that avoids sudden time jumps during timesync.</span>
<span class="w">    </span><span class="c1">// Such clockrate change does NOT affect performance: rate of 🡑InterruptTime and osticks/GetTickCount is constant.</span>
<span class="w">    </span><span class="c1">// It&#39;s common to see value 0x8000&#39;0000&#39;0000&#39;0000 here; with fixed scaler of -0x40 that&#39;s effectively 0.5.</span>
<span class="w">    </span><span class="c1">// See &quot;Time updates via Qpc deltas and increments&quot; below for details on the System Time computation.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">QpcSystemTimeIncrement</span><span class="p">;</span><span class="w">               </span><span class="c1">// 358 ◷ might change at runtime for a bit (supposedly rare)</span>

<span class="w">    </span><span class="c1">// Fractional part of the Multiplier for computing new 🡑InterruptTime: InterruptTime += QpcDelta × Multiplier.</span>
<span class="w">    </span><span class="c1">// Set once during boot, in nt!KiSetupTimeIncrement. Remains constant afterwards.</span>
<span class="w">    </span><span class="c1">// It&#39;s common to see value 0x8000&#39;0000&#39;0000&#39;0000 here; with fixed scaler of -0x40 that&#39;s effectively 0.5.</span>
<span class="w">    </span><span class="c1">// See &quot;Time updates via Qpc deltas and increments&quot; below for details on the Interrupt Time computation.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">QpcInterruptTimeIncrement</span><span class="p">;</span><span class="w">            </span><span class="c1">// 360 𝍌</span>

<span class="w">    </span><span class="c1">// Extra scaling bits for computing new 🡑SystemTime; scaler = -0x40 + 🡗QpcSystemTimeIncrementShift.</span>
<span class="w">    </span><span class="c1">// Just like with 🡑QpcSystemTimeIncrement, this field *might change* at runtime to speedup or slowdown the clock.</span>
<span class="w">    </span><span class="c1">// It&#39;s common to see value 1 here; when const-scaled 🡑QpcSystemTimeIncrement is effectively 0.5, these two</span>
<span class="w">    </span><span class="c1">// fields basically cancel each other out. See &quot;Time updates via Qpc deltas and increments&quot; below for details.</span>
<span class="w">    </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">QpcSystemTimeIncrementShift</span><span class="p">;</span><span class="w">              </span><span class="c1">// 368 ◷ might change at runtime for a bit (supposedly rare)</span>

<span class="w">    </span><span class="c1">// Extra scaling bits for computing new 🡑InterruptTime; scaler = -0x40 + 🡗QpcInterruptTimeIncrementShift.</span>
<span class="w">    </span><span class="c1">// Just like with 🡑QpcInterruptTimeIncrement, this field *set once* during boot, in nt!KiSetupTimeIncrement.</span>
<span class="w">    </span><span class="c1">// It&#39;s common to see value 1 here; when const-scaled 🡑QpcInterruptTimeIncrement is effectively 0.5, these two</span>
<span class="w">    </span><span class="c1">// fields basically cancel each other out. See &quot;Time updates via Qpc deltas and increments&quot; below for details.</span>
<span class="w">    </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">QpcInterruptTimeIncrementShift</span><span class="p">;</span><span class="w">           </span><span class="c1">// 369 𝍌</span>

<span class="w">    </span><span class="c1">// Number of &quot;powered on&quot; [logical] processors. Each SMT core counts as a separate processor.</span>
<span class="w">    </span><span class="c1">// This value can swing a lot at runtime as OS parks CPUs to save power. Always ≤ 🡓ActiveProcessorCount.</span>
<span class="w">    </span><span class="c1">// Most often used to avoid spins in locks when there&#39;s only one running processor (by user and kernel mode alike).</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">UnparkedProcessorCount</span><span class="p">;</span><span class="w">         </span><span class="c1">// 36A ❕ may change a lot at runtime; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Bitmask of enclave features supported on this system. Used by ntdll!<a href="rtlisenclavefeaturepresent" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsEnclaveFeaturePresent(&#10;    _In_ ULONG FeatureMask&#10;    );">RtlIsEnclaveFeaturePresent</a>.</span>
<span class="w">    </span><span class="c1">// Out of the whole 128-bit value, only 3 bits seem to be currently defined.</span>
<span class="w">    </span><span class="c1">// bit1/bit2: SGX1/SGX2 leaf funcs enabled (and locked in that state).</span>
<span class="w">    </span><span class="c1">// bit8: 1 if LoaderBlock-&gt;Extension.IumEnabled (can be 1 in root and non-root partitions; 0 if Hyper-V is off).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">EnclaveFeatureMask</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w">                    </span><span class="c1">// 36C 𝍌♻</span>

<span class="w">    </span><span class="c1">// Current coverage round for telemetry based coverage (sequence number).</span>
<span class="w">    </span><span class="c1">// Set to 1 at boot in nt!EtwpInitializeCoverage – and most of the time stays like that. One way to increment this</span>
<span class="w">    </span><span class="c1">// value: end the coverage round via <a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a>(ProcessTelemetryCoverage, {.LastCoveredRound=-4});</span>
<span class="w">    </span><span class="c1">// however, that needs enabled Administrators group in client&#39;s token.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">TelemetryCoverageRound</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 37C 👋</span>

<span class="w">    </span><span class="c1">// Used for ETW UMGL (user-mode global logging). Indices are ETW_UMGL_INDEX_* constants (see nt!EtwpUmglProviders):</span>
<span class="w">    </span><span class="c1">// <a href="etw_umgl_index_heap" title="#define ETW_UMGL_INDEX_HEAP 0">ETW_UMGL_INDEX_HEAP</a> = 0 (nt!<a href="heapguid" title="DEFINE_GUID( /* 222962ab-6180-4b88-a825-346b75f2a24a */&#10;    HeapGuid,&#10;    0x222962ab,&#10;    0x6180,&#10;    0x4b88,&#10;    0xa8, 0x25, 0x34, 0x6b, 0x75, 0xf2, 0xa2, 0x4a&#10;    );">HeapGuid</a>), <a href="etw_umgl_index_critsec" title="#define ETW_UMGL_INDEX_CRITSEC 1">ETW_UMGL_INDEX_CRITSEC</a> = 1 (nt!<a href="critsecguid" title="DEFINE_GUID( /* 3AC66736-CC59-4cff-8115-8DF50E39816B */&#10;    CritSecGuid,&#10;    0x3ac66736,&#10;    0xcc59,&#10;    0x4cff,&#10;    0x81, 0x15, 0x8d, 0xf5, 0xe, 0x39, 0x81, 0x6b&#10;    );">CritSecGuid</a>), etc.</span>
<span class="w">    </span><span class="c1">// Each <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> is actually a 2-byte <a href="etw_umgl_key" title="typedef struct _ETW_UMGL_KEY&#10;{&#10;    UCHAR LoggerId;&#10;    UCHAR Flags;&#10;} ETW_UMGL_KEY, *PETW_UMGL_KEY;">ETW_UMGL_KEY</a> structure: byte0 is LoggerId, byte1 is &quot;MatchAnyKeyword&quot; Flags.</span>
<span class="w">    </span><span class="c1">// <a href="nttracecontrol" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtTraceControl(&#10;    _In_ ETWTRACECONTROLCODE FunctionCode,&#10;    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,&#10;    _In_ ULONG InputBufferLength,&#10;    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,&#10;    _In_ ULONG OutputBufferLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtTraceControl</a>(EtwSendDataBlock) -&gt; ... -&gt; nt!EtwpEnableDisableSpecialGuids() -&gt; nt!EtwpEnableDisableUMGL().</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.UserModeGlobalLogger. See ETW_UMGL_* macro and defines for more.</span>
<span class="w">    </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">UserModeGlobalLogger</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span><span class="w">              </span><span class="c1">// 380 👋 limited adjustability, specific conditions required</span>

<span class="w">    </span><span class="c1">// When bit0 is set, &quot;GlobalFlag&quot; bits <a href="flg_application_verifier" title="#define FLG_APPLICATION_VERIFIER 0x00000100 // u">FLG_APPLICATION_VERIFIER</a>|<a href="flg_heap_page_allocs" title="#define FLG_HEAP_PAGE_ALLOCS 0x02000000 // u">FLG_HEAP_PAGE_ALLOCS</a> (0x0200&#39;0100) will be read</span>
<span class="w">    </span><span class="c1">// from HKCU IFEO (as long as both flags🡕 absent in HKLM IFEO, and it&#39;s not a secure process). These two verifier</span>
<span class="w">    </span><span class="c1">// bits are read by ntdll during process init, saved in <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>.GlobalFlags.</span>
<span class="w">    </span><span class="c1">// This field does NOT affect other IFEO values or GlobalFlag bits; they&#39;re still read from HKLM and PE LoadConfig.</span>
<span class="w">    </span><span class="c1">// Bit0 initialized during boot in nt!VerifierInitSystem, from bit0 of nt!ViImageExecutionOptions (in turn, from</span>
<span class="w">    </span><span class="c1">// CCS\Control\Session Manager₄ImageExecutionOptions). This entire field can be adjusted at runtime by clients with</span>
<span class="w">    </span><span class="c1">// SeTcb privilege, via <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemImageFileExecutionOptionsInformation).</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">ImageFileExecutionOptions</span><span class="p">;</span><span class="w">                </span><span class="c1">// 3A0 👋♻ changeable at runtime (but normally static)</span>

<span class="w">    </span><span class="c1">// Sequence number of the nt!MUIRegistryInfo structure, which holds UI languages info. Starts at 0 during boot.</span>
<span class="w">    </span><span class="c1">// Only changes when usermode calls <a href="ntgetmuiregistryinfo" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtGetMUIRegistryInfo(&#10;    _In_ ULONG Flags,&#10;    _Inout_ PULONG DataSize,&#10;    _Out_ PVOID Data&#10;    );">NtGetMUIRegistryInfo</a>(Flags |= 8); that increments this field, and also assigns</span>
<span class="w">    </span><span class="c1">// updated value to nt!MUIRegistryInfo.Generation (when nt!MUIRegistryInfo exists). Normally the first and only</span>
<span class="w">    </span><span class="c1">// increment is done by the first Winlogon.exe. No rights nor privileges required to perform such increment.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">LangGenerationCount</span><span class="p">;</span><span class="w">                      </span><span class="c1">// 3A4 👋 changeable at runtime (but mostly static)</span>

<span class="w">    </span><span class="c1">// Zero. &quot;Available for reuse&quot;.</span>
<span class="w">    </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">Reserved4</span><span class="p">;</span><span class="w">                            </span><span class="c1">// 3A8 𝍌♻</span>

<span class="w">    </span><span class="c1">// Under certain conditions (e.g. after hibernation), OS makes 🡑InterruptTime to jump forward (OS &quot;biases&quot; it).</span>
<span class="w">    </span><span class="c1">// This field accumulates all such adjustments, enabling clients to get unadulterated Interrupt Time.</span>
<span class="w">    </span><span class="c1">// To get such unadulterated Unbiased Interrupt Time, take 🡑InterruptTime, and subtract 🡗InterruptTimeBias from it.</span>
<span class="w">    </span><span class="c1">// </span>
<span class="w">    </span><span class="c1">// ⚠️ Field is NOT protected via 🡑TimeUpdateLock. To ensure coherence between this field and 🡑InterruptTime,</span>
<span class="w">    </span><span class="c1">// read this value first, then 🡑InterruptTime, then this value again – and check it hasn&#39;t changed.</span>
<span class="w">    </span><span class="c1">// Note ntdll!<a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a> does a bit more: it wraps that sequence into a pair of reads of exported</span>
<span class="w">    </span><span class="c1">// ntdll!RtlpFreezeTimeBias [where OS accumulates Deep Freeze time for current process], and subtracts that too.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Updated on these paths:</span>
<span class="w">    </span><span class="c1">// 1) nt!KeAdjustInterruptTime. Mostly on exit from sleep/hibernate; also if &quot;TickcountRolloverDelay&quot; 🡑 used.</span>
<span class="w">    </span><span class="c1">// 2) nt!KiAdjustTimersAfterDripsExit. DRIPS is Deepest Runtime Idle Platform State. Tricky: only increments</span>
<span class="w">    </span><span class="c1">// if OS spent more than nt!KeTimerRebaseThresholdOnDripsExit consecutive seconds in the current DRIPS state.</span>
<span class="w">    </span><span class="c1">// That var is from CCS\Control\Power₄TimerRebaseThresholdOnDripsExit; by default it&#39;s 45 seconds.</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">InterruptTimeBias</span><span class="p">;</span><span class="w">           </span><span class="c1">// 3B0 ◷👋 rare updates on power events; &quot;manual&quot; via timed sleep</span>

<span class="w">    </span><span class="c1">// Somewhat similar to 🡑InterruptTimeBias. Accumulates bias for the Qpc value. But there&#39;s important difference:</span>
<span class="w">    </span><span class="c1">// 🡑InterruptTime already incorporates bias, so client-oriented api <a href="rtlqueryunbiasedinterrupttime" title="NTSYSAPI&#10;ULONGLONG&#10;NTAPI&#10;RtlQueryUnbiasedInterruptTime(&#10;    _Out_ PLARGE_INTEGER InterruptTime&#10;    );">RtlQueryUnbiasedInterruptTime</a> has to *subtract*</span>
<span class="w">    </span><span class="c1">// 🡑InterruptTimeBias; but raw Qpc value does NOT incorporate bias, so <a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a> has to *add*</span>
<span class="w">    </span><span class="c1">// 🡗QpcBias! Yes, it&#39;s almost like OS devs mixed up bias inclusion cases to do some extra math on hot codepaths.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Unit is 🡑QpcFrequency⁻¹ seconds. When nt!HalpPerformanceCounter type is Processor or Hypervisor,</span>
<span class="w">    </span><span class="c1">// frequency is 10 MHz; making the unit exactly one centum (100 ns), same as 🡑InterruptTimeBias.</span>
<span class="w">    </span><span class="c1">// Updated in nt!HalpTimerPropagateQpcBiasUpdate, on rare power-related events, like sleep/hibernation.</span>
<span class="w">    </span><span class="c1">// For TimerHypervisor and TimerGit, bias value comes directly from REGISTERED_TIMER.TimeBias. For TimerProcessor</span>
<span class="w">    </span><span class="c1">// that same TimeBias field is scaled to 10 MHz first.</span>
<span class="w">    </span><span class="c1">// Settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcbias" title="#define GlobalDataIdQpcBias 18 // KUSER_SHARED_DATA-&gt;QpcBias">GlobalDataIdQpcBias</a>[=18]).</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></span><span class="w"> </span><span class="n">QpcBias</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 3B8 ◷👋 rare updates on power events; &quot;manual&quot; via timed sleep</span>

<span class="w">    </span><span class="c1">// Number of [logical] processors in the system. Each SMT core counts as a separate processor. Field name is mildly</span>
<span class="w">    </span><span class="c1">// confusing (and digging deeper only makes it worse). Value mirrors unexported nt!KeNumberProcessors; don&#39;t mistake</span>
<span class="w">    </span><span class="c1">// it for the *exported* &quot;KeNumberProcessors&quot;, which is actually nt!KeNumberProcessorsGroup0 variable (¿⸮?).</span>
<span class="w">    </span><span class="c1">// Also don&#39;t mix it up with nt!KeMaximumProcessors🡖, nor with nt!KeActiveProcessors (set of <a href="kaffinity_ex" title="typedef struct _KAFFINITY_EX&#10;{&#10;    USHORT Count;&#10;    USHORT Size;&#10;    ULONG Reserved;&#10;    union&#10;    {&#10;        ULONG_PTR Bitmap[1];&#10;        ULONG_PTR StaticBitmap[32];&#10;    } DUMMYUNIONNAME;&#10;} KAFFINITY_EX, *PKAFFINITY_EX;">KAFFINITY_EX</a> masks).</span>
<span class="w">    </span><span class="c1">// ⮞ TLDR: just drop &quot;Active&quot; from the name. Use 🡑UnparkedProcessorCount for count of CPUs actually running atm.</span>
<span class="w">    </span><span class="c1">// Field set during boot. On some server SKUs you can add CPUs dynamically: on such systems this value may increase</span>
<span class="w">    </span><span class="c1">// at runtime. But it will never decrease, and will never exceed nt!KeMaximumProcessors during current boot session.</span>
<span class="w">    </span><span class="c1">// Absolute max # of processors: ws2022/win11: 0x800 (2048) [confirmed 24H2]; win10 22H2: 0x500 (1280).</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">ActiveProcessorCount</span><span class="p">;</span><span class="w">            </span><span class="c1">// 3C0 ◷ rare increments at runtime possible; 🐞 added &quot;volatile&quot;</span>

<span class="w">    </span><span class="c1">// Number of processor groups in the system. Mirrors nt!KiActiveGroups.</span>
<span class="w">    </span><span class="c1">// On some server SKUs you can add CPUs dynamically: on such systems this value may increase at runtime.</span>
<span class="w">    </span><span class="c1">// Note you can force-split CPUs into multiple groups on boot: &quot;bcdedit /set GroupSize 2&quot; to get N groups with 2</span>
<span class="w">    </span><span class="c1">// CPUs each. Absolute max # of CPU groups for any OS is 0x20 (32) [confirmed 24H2].</span>
<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">ActiveGroupCount</span><span class="p">;</span><span class="w">                </span><span class="c1">// 3C4 ◷ rare increments possible</span>

<span class="w">    </span><span class="c1">// Zero. &quot;Available for reuse&quot;.</span>
<span class="w">    </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">Reserved9</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 3C5 𝍌♻</span>

<span class="w">    </span><span class="c1">// Modern OS treats this union as bitmask/flags governing ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() behavior.</span>
<span class="w">    </span><span class="c1">// See SHARED_GLOBAL_FLAGS_QPC_BYPASS_* flags. Only 7 bits are in use, all overlaid with 🡗QpcBypassEnabled byte.</span>
<span class="w">    </span><span class="c1">//   0/0001: _ENABLED: usermode code can bypass <a href="ntqueryperformancecounter" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter,&#10;    _Out_opt_ PLARGE_INTEGER PerformanceFrequency&#10;    );">NtQueryPerformanceCounter</a> syscall, retrieve Qpc perfcounter by</span>
<span class="w">    </span><span class="c1">//     transforming rdtsc/rdtscp value or ARM64_CNTVCT_EL0 register. When this bit is 0, all others are zeroed too.</span>
<span class="w">    </span><span class="c1">//     On x86 you can force bit to 0 with &quot;bcdedit /set UsePlatformClock yes&quot; (don&#39;t mixup with &quot;UsePlatformTick&quot;).</span>
<span class="w">    </span><span class="c1">//   1/0002: _USE_HV_PAGE: use bias and multiplier from HV_REFERENCE_TSC_PAGE struct (aka &quot;huser&quot;, the page you get</span>
<span class="w">    </span><span class="c1">//     via SystemHypervisorSharedPageInformation infoclass). It&#39;s the most common case; hypervisor is NOT required.</span>
<span class="w">    </span><span class="c1">//   2/0004: _DISABLE_32BIT: 32-bit code (wow64) should not attempt to bypass the syscall.</span>
<span class="w">    </span><span class="c1">//   3/0008: – unused.</span>
<span class="w">    </span><span class="c1">//   4/0010: _USE_MFENCE: &quot;mfence&quot; instruction before rdtsc. For AMD CPUs where rdtscp can&#39;t be used.</span>
<span class="w">    </span><span class="c1">//           Kernel mode may use (KPRCB.CpuVendor == CPU_AMD) instead. But rdtscp (bit7 🡓) always outweighs it.</span>
<span class="w">    </span><span class="c1">//   5/0020: _USE_LFENCE: &quot;lfence&quot; instruction before rdtsc. For Intel CPUs where rdtscp can&#39;t be used.</span>
<span class="w">    </span><span class="c1">//           Kernel mode may use (KPRCB.CpuVendor == CPU_INTEL) instead. But rdtscp (bit7 🡓) always outweighs it.</span>
<span class="w">    </span><span class="c1">//   6/0040: _A73_ERRATA: read ARM64_CNTVCT_EL0 twice (barrier&#39;d); if bit32 changed, use the first reading.</span>
<span class="w">    </span><span class="c1">//   7/0080: _USE_RDTSCP: instead of rdtsc, use [partially serializing] &quot;rdtscp&quot;. For CPUs since Nehalem.</span>
<span class="w">    </span><span class="c1">//           Kernel mode may disregard it and use 🡑ProcessorFeatures[PF_RDTSCP_INSTRUCTION_AVAILABLE] instead.</span>
<span class="w">    </span><span class="c1">// </span>
<span class="w">    </span><span class="c1">// Severely simplified pseudocode for qpc retrieval in <a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a> (assuming syscall bypass enabled):</span>
<span class="w">    </span><span class="c1">//   tsc = rdtsc()   [or rdtscp(), or ReadStatusReg(ARM64_CNTVCT_EL0)]</span>
<span class="w">    </span><span class="c1">//   qpc = kuser.QpcBias + (kuser.QpcData &amp; _USE_HV_PAGE)? tsc × huser.TscScale × 2⁻⁶⁴ + huser.TscOffset: tsc</span>
<span class="w">    </span><span class="k">union</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Entire field settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(<a href="globaldataidqpcdata" title="#define GlobalDataIdQpcData 17 // KUSER_SHARED_DATA-&gt;QpcData">GlobalDataIdQpcData</a>[=17]).</span>
<span class="w">        </span><span class="n"><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></span><span class="w"> </span><span class="n">QpcData</span><span class="p">;</span><span class="w">                             </span><span class="c1">// 3C6 ◷</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Bitflags governing ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() behavior, described above.</span>
<span class="w">            </span><span class="c1">// On old OS [before win10 1709, RS3] it was a bool, that role is now taken by bit0.</span>
<span class="w">            </span><span class="c1">// This byte settable in kernel mode via <a href="rtlsetsystemglobaldata" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlSetSystemGlobalData(&#10;    _In_ RTL_SYSTEM_GLOBAL_DATA_ID DataId,&#10;    _In_ PVOID Buffer,&#10;    _In_ ULONG Size&#10;    );">RtlSetSystemGlobalData</a>(QpcBypassEnabled[=16]).</span>
<span class="w">            </span><span class="k">volatile</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">QpcBypassEnabled</span><span class="p">;</span><span class="w">        </span><span class="c1">// 3C6 ◷ won&#39;t really change, except possibly on OS live migration</span>

<span class="w">            </span><span class="c1">// Zero. Unused on modern OS. On old OS [before win10 1709, RS3] it was used as a bitshift value for the</span>
<span class="w">            </span><span class="c1">// raw perfcounter: ntdll!<a href="rtlqueryperformancecounter" title="NTSYSAPI&#10;LOGICAL&#10;NTAPI&#10;RtlQueryPerformanceCounter(&#10;    _Out_ PLARGE_INTEGER PerformanceCounter&#10;    );">RtlQueryPerformanceCounter</a>() =&gt; (rdtsc() + 🡑QpcBias) &gt;&gt; 🡗QpcShift [before 1709].</span>
<span class="w">            </span><span class="c1">// But that made Qpc rate very different across systems; nowadays OS uses much more precise scaling.</span>
<span class="w">            </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w"> </span><span class="n">QpcShift</span><span class="p">;</span><span class="w">                         </span><span class="c1">// 3C7 𝍌♻</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Pair (🡗TimeZoneBiasEffectiveStart, 🡗TimeZoneBiasEffectiveEnd) form a range for 🡑SystemTime when</span>
<span class="w">    </span><span class="c1">// 🡑TimeZoneBias is valid. That is, if 🡑SystemTime is in that range, LocalTime = (🡑SystemTime - 🡑TimeZoneBias).</span>
<span class="w">    </span><span class="c1">// That&#39;s true regardless of DST (it&#39;s already included in 🡑TimeZoneBias). If both range ends are 0, the range</span>
<span class="w">    </span><span class="c1">// spans *all* time. For time outside the range, local time has to be computed manually.</span>
<span class="w">    </span><span class="c1">// Fields can be updated at runtime (e.g. when range end is reached, or timezone changed).</span>
<span class="w">    </span><span class="c1">// Coherence in relation to 🡑TimeZoneBias during fields update ensured via 🡑TimeZoneBiasStamp.</span>
<span class="w">    </span><span class="c1">// Silo-aware: <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveStart, <a href="silo_user_shared_data" title="typedef struct _SILO_USER_SHARED_DATA&#10;{&#10;    ULONG ServiceSessionId;&#10;    ULONG ActiveConsoleId;&#10;    LONGLONG ConsoleSessionForegroundProcessId;&#10;    NT_PRODUCT_TYPE NtProductType;&#10;    ULONG SuiteMask;&#10;    ULONG SharedUserSessionId; // since RS2&#10;    BOOLEAN IsMultiSessionSku;&#10;    BOOLEAN IsStateSeparationEnabled;&#10;    WCHAR NtSystemRoot[260];&#10;    USHORT UserModeGlobalLogger[16];&#10;    ULONG TimeZoneId; // since 21H2&#10;    LONG TimeZoneBiasStamp;&#10;    KSYSTEM_TIME TimeZoneBias;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveStart;&#10;    LARGE_INTEGER TimeZoneBiasEffectiveEnd;&#10;} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;">SILO_USER_SHARED_DATA</a>.TimeZoneBiasEffectiveEnd.</span>
<span class="w">    </span><span class="c1">// </span>
<span class="w">    </span><span class="c1">// Normally, 🡗TimeZoneBiasEffectiveStart is equal to the snapshot of 🡑SystemTime at one of these moments:</span>
<span class="w">    </span><span class="c1">// a) system boot + 5..15 seconds; b) system date/time change; c) timezone change; d) crossing the DST line (i.e.</span>
<span class="w">    </span><span class="c1">// 🡑SystemTime reached 🡗TimeZoneBiasEffectiveEnd, so the new range has to be established).</span>
<span class="w">    </span><span class="c1">// 🡗TimeZoneBiasEffectiveEnd updated together with 🡗TimeZoneBiasEffectiveStart. It&#39;s set to either the next DST</span>
<span class="w">    </span><span class="c1">// line or to (end of year + 🡑TimeZoneBias), whichever is earlier.</span>
<span class="w">    </span><span class="c1">// Adjustable – within a certain amount – by clients with SeTimeZone privilege, together with 🡑TimeZoneBias.</span>
<span class="w">    </span><span class="n">LARGE_INTEGER</span><span class="w"> </span><span class="n">TimeZoneBiasEffectiveStart</span><span class="p">;</span><span class="w">       </span><span class="c1">// 3C8 ◷👋</span>
<span class="w">    </span><span class="n">LARGE_INTEGER</span><span class="w"> </span><span class="n">TimeZoneBiasEffectiveEnd</span><span class="p">;</span><span class="w">         </span><span class="c1">// 3D0 ◷👋</span>

<span class="w">    </span><span class="c1">// Extended processor state configuration.</span>
<span class="w">    </span><span class="c1">// Initialized once at boot in nt!KiInitializeXSaveConfiguration, based on features actually supported by cpu,</span>
<span class="w">    </span><span class="c1">// and features disabled via LoaderBlock (&quot;bcdedit /set xsaveDisable|xsavePolicy|xsaveRemoveFeature&quot;). Since</span>
<span class="w">    </span><span class="c1">// win11 24H2, ARM64 oskernel tries to ignore this field, uses its own 🡓XStateArm64 instead. But even though ARM64</span>
<span class="w">    </span><span class="c1">// doesn&#39;t init it, XState.EnabledFeatures still used sometimes (e.g. nt!PopHandleNextState) due to bugs/leftovers.</span>
<span class="w">    </span><span class="n">XSTATE_CONFIGURATION</span><span class="w"> </span><span class="n">XState</span><span class="p">;</span><span class="w">                    </span><span class="c1">// 3D8 𝍌♻ used now, but really should not be in kuser</span>

<span class="w">    </span><span class="c1">// Mirrors global value read via exported nt!<a href="rtlqueryfeatureconfigurationchangestamp" title="NTSYSAPI&#10;RTL_FEATURE_CHANGE_STAMP&#10;NTAPI&#10;RtlQueryFeatureConfigurationChangeStamp(&#10;    VOID&#10;    );">RtlQueryFeatureConfigurationChangeStamp</a> (part of nt!CmFcSystemManager).</span>
<span class="w">    </span><span class="c1">// Starts at 1 at boot, increments each time feature config changes. However, there is so called</span>
<span class="w">    </span><span class="c1">// &quot;SwapReferenceIndex&quot; (RtlGetSwapReferenceIndex), changing which might bring in parallel global value.</span>
<span class="w">    </span><span class="c1">// This field is what&#39;s referred to as <a href="rtl_feature_change_stamp" title="typedef ULONGLONG RTL_FEATURE_CHANGE_STAMP, *PRTL_FEATURE_CHANGE_STAMP;">RTL_FEATURE_CHANGE_STAMP</a>/ChangeStamp in structures for</span>
<span class="w">    </span><span class="c1">// <a href="ntsetsysteminformation" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetSystemInformation(&#10;    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,&#10;    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,&#10;    _In_ ULONG SystemInformationLength&#10;    );">NtSetSystemInformation</a>(SystemFeatureConfigurationInformation). Note these are NOT &quot;Optional Windows Features&quot;;</span>
<span class="w">    </span><span class="c1">// rather these are A/B features (and ongoing security fix &quot;features&quot;), adjustable via e.g. opensource ViveTool.</span>
<span class="w">    </span><span class="c1">// ⚠️ Size of 🡑XState increased by 0x10 in WS2022, changing this field offset from 0x710 to 0x720.</span>
<span class="w">    </span><span class="n"><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></span><span class="w"> </span><span class="n">FeatureConfigurationChangeStamp</span><span class="p">;</span><span class="w">   </span><span class="c1">// 720; offset is 0x710 on win10 22H2 and earlier OS</span>

<span class="w">    </span><span class="c1">// Zero.</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Spare</span><span class="p">;</span><span class="w">                                    </span><span class="c1">// 72C 𝍌♻</span>

<span class="w">    </span><span class="c1">// Mirrors nt!KePointerAuthMask. Only used for ARM64, zero on x64. Initialized once at boot.</span>
<span class="w">    </span><span class="c1">// Contains a mask to apply to a pointer value to extract authentication &quot;PAC&quot; bits together with a sign</span>
<span class="w">    </span><span class="c1">// bit (highest bit preceding the PAC). If PAC is not used, or PAC size is not exactly 8 bits, value is simply</span>
<span class="w">    </span><span class="c1">// zero (confirmed win11 24H2 and earlier). So the only values possible are 0 and 0xFF80&#39;0000&#39;0000&#39;0000 [2025-08].</span>
<span class="w">    </span><span class="n"><a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a></span><span class="w"> </span><span class="n">UserPointerAuthMask</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 730 𝍌 available since win11 22H2</span>

<span class="w">    </span><span class="c1">// Following fields are there since win11 24H2.</span>
<span class="cp">#ifdef _M_ARM64</span>
<span class="w">    </span><span class="c1">// Extended processor state configuration specifically for ARM64.</span>
<span class="w">    </span><span class="c1">// ARM64 OS kernels before win11 24H2 were less greedy and simply used 🡑XState.</span>
<span class="w">    </span><span class="n">XSTATE_CONFIGURATION</span><span class="w"> </span><span class="n">XStateArm64</span><span class="p">;</span><span class="w">               </span><span class="c1">// 738 𝍌♻ used now, but really should not be in kuser</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="c1">// &quot;The reserved space for other architectures is not available for reuse&quot;.</span>
<span class="w">    </span><span class="n"><a href="uint" title="typedef unsigned int UINT;">UINT</a></span><span class="w"> </span><span class="n">Reserved10</span><span class="p">[</span><span class="mh">0xD2</span><span class="p">];</span><span class="w">                          </span><span class="c1">// 738 𝍌♻</span>
<span class="cp">#endif</span>
<span class="p">};</span><span class="w">  </span><span class="c1">// struct _KUSER_SHARED_DATA, size: 0xA80</span>
</code></pre>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ntddk-kuser_shared_data)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>

<p>This topic describes the <strong>KUSER_SHARED_DATA</strong> structure.</p>

<h2>Members</h2>

<h3><code>TickCountLowDeprecated</code></h3>

<p>Current low 32-bit of tick count.</p>

<h3><code>TickCountMultiplier</code></h3>

<p>Tick count multiplier.</p>

<h3><code>InterruptTime</code></h3>

<p>Current 64-bit interrupt time in 100ns units.</p>

<h3><code>SystemTime</code></h3>

<p>Current 64-bit system time in 100ns units.</p>

<h3><code>TimeZoneBias</code></h3>

<p>Current 64-bit time zone bias.</p>

<h3><code>ImageNumberLow</code></h3>

<p>Low image magic number for the host system.</p>

<h3><code>ImageNumberHigh</code></h3>

<p>High image magic number for the host system.</p>

<h3><code>NtSystemRoot[260]</code></h3>

<p>Copy of system root in unicode. This field must be accessed via the <strong><a href="rtlgetntsystemroot" title="NTSYSAPI&#10;PWSTR&#10;NTAPI&#10;RtlGetNtSystemRoot(&#10;    VOID&#10;    );">RtlGetNtSystemRoot</a></strong> API for an accurate result.</p>

<h3><code>MaxStackTraceDepth</code></h3>

<p>Maximum stack trace depth if tracing enabled.</p>

<h3><code>CryptoExponent</code></h3>

<p>Crypto exponent value.</p>

<h3><code>TimeZoneId</code></h3>

<p>Time zone ID.</p>

<h3><code>LargePageMinimum</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>LargePageMinimum</strong>.</p>

<h3><code>AitSamplingValue</code></h3>

<p>This value controls the AIT sampling rate.</p>

<h3><code>AppCompatFlag</code></h3>

<p>This value controls switchback processing.</p>

<h3><code>RNGSeedVersion</code></h3>

<p>Current kernel root RNG state seed version.</p>

<h3><code>GlobalValidationRunlevel</code></h3>

<p>This value controls assertion failure handling.</p>

<h3><code>TimeZoneBiasStamp</code></h3>

<p>Defines the <strong><a href="long" title="typedef long LONG;">LONG</a></strong> member <strong>TimeZoneBiasStamp</strong>.</p>

<h3><code>NtBuildNumber</code></h3>

<p>The shared collective build number undecorated with C or F. <strong>GetVersionEx</strong> hides the real number.</p>

<h3><code>NtProductType</code></h3>

<p>Product type. This field must be accessed via the <strong><a href="rtlgetntproducttype" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlGetNtProductType(&#10;    _Out_ PNT_PRODUCT_TYPE NtProductType&#10;    );">RtlGetNtProductType</a></strong> API for an accurate result.</p>

<h3><code>ProductTypeIsValid</code></h3>

<p>Defines the <strong>BOOLEAN</strong> member <strong>ProductTypeIsValid</strong>.</p>

<h3><code>Reserved0[1]</code></h3>

<p>Reserved for future use.</p>

<h3><code>NativeProcessorArchitecture</code></h3>

<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member <strong>NativeProcessorArchitecture</strong>.</p>

<h3><code>NtMajorVersion</code></h3>

<p>The NT major version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>

<h3><code>NtMinorVersion</code></h3>

<p>The NT minor version. Each process sees a version from its <a href="peb" title="typedef struct _PEB&#10;{&#10;    //&#10;    // The process was cloned with an inherited address space.&#10;    //&#10;    BOOLEAN InheritedAddressSpace;&#10;&#10;    //&#10;    // The process has image file execution options (IFEO).&#10;    //&#10;    BOOLEAN ReadImageFileExecOptions;&#10;&#10;    //&#10;    // The process has a debugger attached.&#10;    //&#10;    BOOLEAN BeingDebugged;&#10;&#10;    union&#10;    {&#10;        BOOLEAN BitField;&#10;...">PEB</a>, but if the process is running with an altered view of the system version, this field is used to correctly identify the version.</p>

<h3><code>ProcessorFeatures[<a href="processor_feature_max" title="#define PROCESSOR_FEATURE_MAX 64">PROCESSOR_FEATURE_MAX</a>]</code></h3>

<p>Processor features.</p>

<h3><code>Reserved1</code></h3>

<p>Reserved for future use.</p>

<h3><code>Reserved3</code></h3>

<p>Reserved for future use.</p>

<h3><code>TimeSlip</code></h3>

<p>Time slippage while in debugger.</p>

<h3><code>AlternativeArchitecture</code></h3>

<p>Alternative system architecture. For example, NEC PC98xx on x86.</p>

<h3><code>BootId</code></h3>

<p>Boot sequence, incremented for each boot attempt by the OS loader.</p>

<h3><code>SystemExpirationDate</code></h3>

<p>If the system is an evaluation unit, the following field contains the date and time that the evaluation unit expires. A value of 0 indicates that there is no expiration. A non-zero value is the UTC absolute time that the system expires.</p>

<h3><code>SuiteMask</code></h3>

<p>Suite support. This field must be accessed via the <a href="rtlgetsuitemask" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetSuiteMask(&#10;    VOID&#10;    );">RtlGetSuiteMask</a> API for an accurate result.</p>

<h3><code>KdDebuggerEnabled</code></h3>

<p>TRUE if a kernel debugger is connected/enabled.</p>

<h3><code>MitigationPolicies</code></h3>

<p>Mitigation policies.</p>

<h3><code>NXSupportPolicy</code></h3>

<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>NXSupportPolicy</strong>.</p>

<h3><code>SEHValidationPolicy</code></h3>

<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>SEHValidationPolicy</strong>.</p>

<h3><code>CurDirDevicesSkippedForDlls</code></h3>

<p>Defines the <strong><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></strong> member <strong>CurDirDevicesSkippedForDlls</strong>.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for future use.</p>

<h3><code>CyclesPerYield</code></h3>

<p>Measured duration of a single processor yield, in cycles. This is used by lock packages to determine how many times to spin waiting for a state change before blocking.</p>

<h3><code>ActiveConsoleId</code></h3>

<p>Current console session Id. Always zero on non-TS systems. This field must be accessed via the <strong><a href="rtlgetactiveconsoleid" title="NTSYSAPI&#10;ULONG&#10;NTAPI&#10;RtlGetActiveConsoleId(&#10;    VOID&#10;    );">RtlGetActiveConsoleId</a></strong> API for an accurate result.</p>

<h3><code>DismountCount</code></h3>

<p>Force-dismounts cause handles to become invalid. Rather than always probe handles, a serial number of dismounts is maintained that clients can use to see if they need to probe handles.</p>

<h3><code>ComPlusPackage</code></h3>

<p>This field indicates the status of the 64-bit COM+ package on the system. It indicates whether the Intermediate Language (IL) COM+ images need to use the 64-bit COM+ runtime or the 32-bit COM+ runtime.</p>

<h3><code>LastSystemRITEventTickCount</code></h3>

<p>Time in tick count for system-wide last user input across all terminal sessions. For MP performance, it is not updated all the time (for example, once a minute per session). It is used for idle detection.</p>

<h3><code>NumberOfPhysicalPages</code></h3>

<p>Number of physical pages in the system. This can dynamically change as physical memory can be added or removed from a running system.</p>

<h3><code>SafeBootMode</code></h3>

<p>True if the system was booted in safe boot mode.</p>

<h3><code>VirtualizationFlags</code></h3>

<p>Virtualization flags.</p>

<h3><code>ArchStartedInEl2</code></h3>

<p>Keep this bitfield in sync with the one in arc.w.</p>

<h3><code>QcSlIsSupported</code></h3>

<p>Keep this bitfield in sync with the one in arc.w.</p>

<h3><code>Reserved12[2]</code></h3>

<p>Reserved for future use.</p>

<h3><code>DUMMYUNIONNAME2</code></h3>

<p>This is a packed bitfield that contains various flags concerning the system state. They must be manipulated using interlocked operations. <strong>DbgMultiSessionSku</strong> must be accessed via the <strong><a href="rtlismultisessionsku" title="NTSYSAPI&#10;BOOLEAN&#10;NTAPI&#10;RtlIsMultiSessionSku(&#10;    VOID&#10;    );">RtlIsMultiSessionSku</a></strong> API for an accurate result.</p>

<h3><code>DUMMYUNIONNAME2.SharedDataFlags</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>SharedDataFlags</strong>.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2</code></h3>

<p>Defines the <strong>DUMMYSTRUCTNAME2</strong> structure.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgErrorPortPresent</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgElevationEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgVirtEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgInstallerDetectEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgLkgEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgDynProcessorEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgConsoleBrokerEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgSecureBootEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiSessionSku</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgMultiUsersInSessionSku</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.DbgStateSeparationEnabled</code></h3>

<p>For debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DUMMYUNIONNAME2.DUMMYSTRUCTNAME2.SpareBits</code></h3>

<p>For the debugger only. Do not use. Use the bit definitions instead.</p>

<h3><code>DataFlagsPad[1]</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>DataFlagsPad</strong>.</p>

<h3><code>TestRetInstruction</code></h3>

<p>Depending on the processor, the code for fast system call will differ. This field is only used on 32-bit systems.</p>

<h3><code>QpcFrequency</code></h3>

<p>Defines the <strong><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></strong> member <strong>QpcFrequency</strong>.</p>

<h3><code>SystemCall</code></h3>

<p>On AMD64, this value is initialized to a nonzero value if the system operates with an altered view of the system service call mechanism.</p>

<h3><code>Reserved2</code></h3>

<p>Reserved for future use.</p>

<h3><code>FullNumberOfPhysicalPages</code></h3>

<p>Reserved for future use.</p>

<h3><code>SystemCallPad[1]</code></h3>

<p>Reserved for future use.</p>

<h3><code>DUMMYUNIONNAME3</code></h3>

<p>The 64-bit tick count.</p>

<h3><code>DUMMYUNIONNAME3.TickCount</code></h3>

<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>TickCount</strong>.</p>

<h3><code>DUMMYUNIONNAME3.TickCountQuad</code></h3>

<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>TickCountQuad</strong>.</p>

<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME</code></h3>

<p>Defines <strong>DUMMYSTRUCTNAME</strong>.</p>

<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.ReservedTickCountOverlay[3]</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>ReservedTickCountOverlay</strong>.</p>

<h3><code>DUMMYUNIONNAME3.DUMMYSTRUCTNAME.TickCountPad[1]</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>TickCountPad</strong>.</p>

<h3><code>Cookie</code></h3>

<p>Cookie for encoding pointers system wide.</p>

<h3><code>CookiePad[1]</code></h3>

<p>Reserved for future use.</p>

<h3><code>ConsoleSessionForegroundProcessId</code></h3>

<p>Client id of the process having the focus in the current active console session id. This field must be accessed via the <strong><a href="rtlgetconsolesessionforegroundprocessid" title="NTSYSAPI&#10;LONGLONG&#10;NTAPI&#10;RtlGetConsoleSessionForegroundProcessId(&#10;    VOID&#10;    );">RtlGetConsoleSessionForegroundProcessId</a></strong> API for an accurate result.</p>

<h3><code>TimeUpdateLock</code></h3>

<p>Placeholder for the (internal) time update lock. This data is used to implement the precise time services. It is aligned on a 64-byte cache-line boundary and arranged in the order of typical accesses.</p>

<h3><code>BaselineSystemTimeQpc</code></h3>

<p>The performance counter value used to establish the current system time.</p>

<h3><code>BaselineInterruptTimeQpc</code></h3>

<p>The performance counter value used to compute the last interrupt time.</p>

<h3><code>QpcSystemTimeIncrement</code></h3>

<p>The scaled number of system time seconds represented by a single performance count (this value may vary to achieve time synchronization).</p>

<h3><code>QpcInterruptTimeIncrement</code></h3>

<p>The scaled number of interrupt time seconds represented by a single performance count (this value is constant after the system is booted).</p>

<h3><code>QpcSystemTimeIncrementShift</code></h3>

<p>The scaling shift count applied to the performance counter system time increment.</p>

<h3><code>QpcInterruptTimeIncrementShift</code></h3>

<p>The scaling shift count applied to the performance counter interrupt time increment.</p>

<h3><code>UnparkedProcessorCount</code></h3>

<p>The count of unparked processors.</p>

<h3><code>EnclaveFeatureMask[4]</code></h3>

<p>A bitmask of enclave features supported on this system. This field must be accessed via the <strong>RtlIsEnclareFeaturePresent</strong> API for an accurate result.</p>

<h3><code>TelemetryCoverageRound</code></h3>

<p>Current coverage round for telemetry based coverage.</p>

<h3><code>UserModeGlobalLogger[16]</code></h3>

<p>The following field is used for ETW user mode global logging (UMGL).</p>

<h3><code>ImageFileExecutionOptions</code></h3>

<p>Settings that can enable the use of Image File Execution Options from HKCU in addition to the original HKLM.</p>

<h3><code>LangGenerationCount</code></h3>

<p>Generation of the kernel structure holding system language information.</p>

<h3><code>Reserved4</code></h3>

<p>Reserved for future use.</p>

<h3><code>InterruptTimeBias</code></h3>

<p>Current 64-bit interrupt time bias in 100ns units.</p>

<h3><code>QpcBias</code></h3>

<p>Current 64-bit performance counter bias, in performance counter units before the shift is applied.</p>

<h3><code>ActiveProcessorCount</code></h3>

<p>Number of active processors.</p>

<h3><code>ActiveGroupCount</code></h3>

<p>Number of active groups.</p>

<h3><code>Reserved9</code></h3>

<p>Reserved for future use.</p>

<h3><code>QpcData</code></h3>

<p>Defines the <strong><a href="ushort" title="typedef unsigned short USHORT;">USHORT</a></strong> member QpcData.</p>

<h3><code>QpcBypassEnabled</code></h3>

<p>A boolean indicating whether performance counter queries can read the counter directly (bypassing the system call).</p>

<h3><code>QpcReserved</code></h3>

<p>Reserved for future use.</p>

<h3><code>TimeZoneBiasEffectiveStart</code></h3>

<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveStart</strong>.</p>

<h3><code>TimeZoneBiasEffectiveEnd</code></h3>

<p>Defines the <strong>LARGE_INTEGER</strong> member <strong>TimeZoneBiasEffectiveEnd</strong>.</p>

<h3><code>XState</code></h3>

<p>Extended processor state configuration.</p>

<h3><code>FeatureConfigurationChangeStamp</code></h3>

<p>Defines the <strong><a href="ksystem_time" title="typedef struct _KSYSTEM_TIME&#10;{&#10;    ULONG LowPart;&#10;    LONG High1Time;&#10;    LONG High2Time;&#10;} KSYSTEM_TIME, *PKSYSTEM_TIME;">KSYSTEM_TIME</a></strong> member <strong>FeatureConfigurationChangeStamp</strong>.</p>

<h3><code>Spare</code></h3>

<p>Defines the <strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></strong> member <strong>Spare</strong>.</p>

<h3><code>UserPointerAuthMask</code></h3>

<p>Defines the <strong><a href="ulong64" title="typedef unsigned __int64 ULONG64;">ULONG64</a></strong> member <strong>UserPointerAuthMask</strong>.</p>

<h2>Remarks</h2>

<h2>See also</h2>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddk/ns-ntddk-kuser_shared_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
