<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="GET_IDLE_WAKE_INFO - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>GET_IDLE_WAKE_INFO - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            GET_IDLE_WAKE_INFO - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">GET_IDLE_WAKE_INFO GetIdleWakeInfo;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> GetIdleWakeInfo(
  [in, optional] PVOID Context,
  [in]           <a href="system_power_state" title="typedef enum _SYSTEM_POWER_STATE {&#10;  PowerSystemUnspecified,&#10;  PowerSystemWorking,&#10;  PowerSystemSleeping1,&#10;  PowerSystemSleeping2,&#10;  PowerSystemSleeping3,&#10;  PowerSystemHibernate,&#10;  PowerSystemShutdown,&#10;  PowerSystemMaximum&#10;} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;">SYSTEM_POWER_STATE</a> SystemPowerState,
  [out]          <a href="device_wake_depth" title="typedef enum _DEVICE_WAKE_DEPTH {&#10;  DeviceWakeDepthNotWakeable,&#10;  DeviceWakeDepthD0,&#10;  DeviceWakeDepthD1,&#10;  DeviceWakeDepthD2,&#10;  DeviceWakeDepthD3hot,&#10;  DeviceWakeDepthD3cold,&#10;  DeviceWakeDepthMaximum&#10;} DEVICE_WAKE_DEPTH, *PDEVICE_WAKE_DEPTH;">PDEVICE_WAKE_DEPTH</a> DeepestWakeableDstate
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-get_idle_wake_info">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/get_idle_wake_info.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wdm-get_idle_wake_info)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="get_idle_wake_info-callback-function">GET_IDLE_WAKE_INFO callback function</h1>

<h2 id="description">Description</h2>

<p>The <em>GetIdleWakeInfo</em> routine enables the driver for a device to discover the device power states from which the device can signal a wake event.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="context-in-optional"><code>Context</code> [in, optional]</h3>

<p>A pointer to interface-specific context information. The caller sets this parameter to the value of the <strong>Context</strong> member of the <a href="d3cold_support_interface" title="typedef struct _D3COLD_SUPPORT_INTERFACE {&#10;  USHORT                             Size;&#10;  USHORT                             Version;&#10;  PVOID                              Context;&#10;  PINTERFACE_REFERENCE               InterfaceReference;&#10;  PINTERFACE_DEREFERENCE             InterfaceDereference;&#10;  PSET_D3COLD_SUPPORT                SetD3ColdSupport;&#10;  PGET_IDLE_WAKE_INFO                GetIdleWakeInfo;&#10;  PGET_D3COLD_CAPABILITY             GetD3ColdCapability;&#10;  PGET_D3COLD_CAPABILITY             GetBusDriverD3ColdSupport;&#10;  PGET_D3COLD_LAST_TRANSITION_STATUS GetLastTransitionStatus;&#10;} D3COLD_SUPPORT_INTERFACE, *PD3COLD_SUPPORT_INTERFACE;">D3COLD_SUPPORT_INTERFACE</a> structure for the interface.</p>

<h3 id="systempowerstate-in"><code>SystemPowerState</code> [in]</h3>

<p>System power state. Set this parameter to one of the following <a href="system_power_state" title="typedef enum _SYSTEM_POWER_STATE {&#10;  PowerSystemUnspecified,&#10;  PowerSystemWorking,&#10;  PowerSystemSleeping1,&#10;  PowerSystemSleeping2,&#10;  PowerSystemSleeping3,&#10;  PowerSystemHibernate,&#10;  PowerSystemShutdown,&#10;  PowerSystemMaximum&#10;} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;">SYSTEM_POWER_STATE</a> enumeration values:</p>

<ul>
<li><strong>PowerSystemWorking</strong></li>
<li><strong>PowerSystemSleeping1</strong></li>
<li><strong>PowerSystemSleeping2</strong></li>
<li><strong>PowerSystemSleeping3</strong></li>
<li><strong>PowerSystemHibernate</strong></li>
</ul>

<p>These values represent system power states S0 (system working state) through S4. For the <em>SystemPowerState</em> value supplied by the caller, the routine determines the deepest device power state from which the device can issue a wake signal.</p>

<h3 id="deepestwakeabledstate-out"><code>DeepestWakeableDstate</code> [out]</h3>

<p>Deepest wakeable Dx state. This parameter is a pointer to a <a href="device_wake_depth" title="typedef enum _DEVICE_WAKE_DEPTH {&#10;  DeviceWakeDepthNotWakeable,&#10;  DeviceWakeDepthD0,&#10;  DeviceWakeDepthD1,&#10;  DeviceWakeDepthD2,&#10;  DeviceWakeDepthD3hot,&#10;  DeviceWakeDepthD3cold,&#10;  DeviceWakeDepthMaximum&#10;} DEVICE_WAKE_DEPTH, *PDEVICE_WAKE_DEPTH;">DEVICE_WAKE_DEPTH</a> variable. If the call is successful, the routine writes one of the following enumeration values to this variable:</p>

<ul>
<li><strong>DeviceWakeDepthNotWakeable</strong></li>
<li><strong>DeviceWakeDepthD0</strong></li>
<li><strong>DeviceWakeDepthD1</strong></li>
<li><strong>DeviceWakeDepthD2</strong></li>
<li><strong>DeviceWakeDepthD3hot</strong></li>
<li><strong>DeviceWakeDepthD3cold</strong></li>
</ul>

<p>A value in the range <strong>DeviceWakeDepthD0</strong> to <strong>DeviceWakeDepthD3cold</strong> indicates the lowest-powered Dx state from which the device can send a wake signal when the computer is in the system power state specified by the <em>SystemPowerState</em> parameter. <strong>DeviceWakeDepthNotWakeable</strong> indicates that there is no device power state from which the device can send a wake signal when the computer is in the system power state specified by <em>SystemPowerState</em>.</p>

<p>If the routine cannot determine the deepest wakeable device state (perhaps because the platform firmware does not contain this information), the call fails and the routine returns an error status code. If a <em>GetIdleWakeInfo</em> call fails for any <em>SystemPowerState</em> parameter value in the range <strong>PowerSystemWorking</strong> to <strong>PowerSystemHibernate</strong>, it will fail for all such values.</p>

<h2 id="return-value">Return value</h2>

<p>The <em>GetIdleWakeInfo</em> routine returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if it successfully retrieves the deepest wakeable device state. Otherwise, it returns an appropriate error status code.</p>

<h2 id="remarks">Remarks</h2>

<p>For the system power state specified by the caller, this routine tries to determine the lowest-powered device power state from which the device can signal a wake event to the processor. If successful, the routine writes the device power state to the location pointed to by the <em>DeepestWakeableDstate</em> parameter, and returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. Or, if the routine determines that the device cannot signal a wake event from any device power state, the routine writes the value <strong>DeviceWakeDepthNotWakeable</strong> to this location, and returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>.</p>

<p>The driver for a device uses the information supplied by the <em>GetIdleWakeInfo</em> routine to determine the conditions under which the device can signal a wake event. A device that needs to be able to signal certain wake events should not enter a device power state from which it cannot signal these events. For some types of devices, the wake signals that the device should send when the computer is in the S0 (working) system power state differ from those that the device should send when the computer appears to be off.</p>

<p>For example, when a card is inserted into a PCI Express card slot, and the PCI Express hot-plug controller device for the slot is in the D0 device power state, this device signals an interrupt to the processor. However, if the controller device is in a low-power Dx state when the card is inserted, the system power state of the computer might determine whether this device should signal a wake event to the processor. Ideally, the controller device should behave as follows:</p>

<ul>
<li>If the computer is in the S0 (working) system power state, the device should signal a wake event to the processor.</li>
<li>If the computer is sleeping (in a low-power Sx state), the device should not signal a wake event.</li>
</ul>

<p>Some older devices might not support this ideal behavior. If the PCI Express hot-plug controller device in this example can signal a wake event only when the computer is in the S3 state, the driver (which, in this case, is the inbox Pci.sys driver) for the controller should keep the controller in D0 when the computer is in S0 (and is not preparing to enter a sleeping state).</p>

<p>The driver in this example can call the <em>GetIdleWakeInfo</em> routine to determine whether the hot-plug controller device should leave the D0 state while the computer is in S0. For this call, the driver sets <em>SystemPowerState</em> = <strong>PowerSystemWorking</strong>. This device should not leave the D0 state (when the computer is in S0) in either of the following cases:</p>

<ul>
<li>The <em>GetIdleWakeInfo</em> call sets the output parameter to either <strong>DeviceWakeDepthNotWakeable</strong> or <strong>DeviceWakeDepthD0</strong> and returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>.</li>
<li>The <em>GetIdleWakeInfo</em> call fails and returns an error status code.</li>
</ul>

<p>The driver should interpret either of these results to mean that the device cannot signal a wake event when the computer is in S0. Based on this information, the driver should keep the device in D0 until the computer prepares to exit S0.</p>

<p>The drivers for most devices can treat an output value of <strong>DeviceWakeDepthD0</strong> the same as <strong>DeviceWakeDepthNotWakeable</strong>. Only a few drivers might have a reason to arm a wake signal when their devices are in D0. These are drivers for simple devices that monitor external events that trigger wake signals regardless of whether the devices are in D0 or low-power Dx states. An example of such a device is a power button or a sleep button on a computer.</p>

<p>The <em>GetIdleWakeInfo</em> routine queries the underlying bus driver and ACPI system firmware to determine the lowest device power state from which the device can signal a wake event. If the bus driver and firmware cannot supply this information, the routine fails and returns an error status code.</p>

<p>The <a href="device_capabilities" title="typedef struct _DEVICE_CAPABILITIES {&#10;  USHORT             Size;&#10;  USHORT             Version;&#10;  ULONG              DeviceD1 : 1;&#10;  ULONG              DeviceD2 : 1;&#10;  ULONG              LockSupported : 1;&#10;  ULONG              EjectSupported : 1;&#10;  ULONG              Removable : 1;&#10;  ULONG              DockDevice : 1;&#10;  ULONG              UniqueID : 1;&#10;  ULONG              SilentInstall : 1;&#10;  ULONG              RawDeviceOK : 1;&#10;  ULONG              SurpriseRemovalOK : 1;&#10;  ULONG              WakeFromD0 : 1;&#10;  ULONG              WakeFromD1 : 1;&#10;  ULONG              WakeFromD2 : 1;&#10;  ULONG              WakeFromD3 : 1;&#10;  ULONG              HardwareDisabled : 1;&#10;  ULONG              NonDynamic : 1;&#10;  ULONG              WarmEjectSupported : 1;&#10;...">DEVICE_CAPABILITIES</a> structure includes a <strong>DeviceWake</strong> member that provides information similar to that available from the <em>GetIdleWakeInfo</em> routine. However, the information in the <strong>DeviceWake</strong> member applies only to the system low-power states S1 to S4. For some devices, the information in the <strong>DeviceWake</strong> member might also apply to the S0 system power state, but drivers should not rely on such behavior. Only the <em>GetIdleWakeInfo</em> routine reliably reports the ability of a device to signal a wake event if the computer is in S0.</p>

<p>An inline helper function, <strong>MapWakeDepthToDstate</strong>, is provided to convert the <a href="device_wake_depth" title="typedef enum _DEVICE_WAKE_DEPTH {&#10;  DeviceWakeDepthNotWakeable,&#10;  DeviceWakeDepthD0,&#10;  DeviceWakeDepthD1,&#10;  DeviceWakeDepthD2,&#10;  DeviceWakeDepthD3hot,&#10;  DeviceWakeDepthD3cold,&#10;  DeviceWakeDepthMaximum&#10;} DEVICE_WAKE_DEPTH, *PDEVICE_WAKE_DEPTH;">DEVICE_WAKE_DEPTH</a> output value from the <em>GetIdleWakeInfo</em> routine to a <a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a> value that can be used as an input parameter by the <a href="porequestpowerirp" title="NTSTATUS PoRequestPowerIrp(&#10;  [in]           PDEVICE_OBJECT          DeviceObject,&#10;  [in]           UCHAR                   MinorFunction,&#10;  [in]           POWER_STATE             PowerState,&#10;  [in, optional] PREQUEST_POWER_COMPLETE CompletionFunction,&#10;  [in, optional] __drv_aliasesMem PVOID  Context,&#10;  [out]          PIRP                    *Irp&#10;);">PoRequestPowerIrp</a> routine.</p>

<h2 id="see-also">See also</h2>

<p><a href="d3cold_support_interface" title="typedef struct _D3COLD_SUPPORT_INTERFACE {&#10;  USHORT                             Size;&#10;  USHORT                             Version;&#10;  PVOID                              Context;&#10;  PINTERFACE_REFERENCE               InterfaceReference;&#10;  PINTERFACE_DEREFERENCE             InterfaceDereference;&#10;  PSET_D3COLD_SUPPORT                SetD3ColdSupport;&#10;  PGET_IDLE_WAKE_INFO                GetIdleWakeInfo;&#10;  PGET_D3COLD_CAPABILITY             GetD3ColdCapability;&#10;  PGET_D3COLD_CAPABILITY             GetBusDriverD3ColdSupport;&#10;  PGET_D3COLD_LAST_TRANSITION_STATUS GetLastTransitionStatus;&#10;} D3COLD_SUPPORT_INTERFACE, *PD3COLD_SUPPORT_INTERFACE;">D3COLD_SUPPORT_INTERFACE</a></p>

<p><a href="device_capabilities" title="typedef struct _DEVICE_CAPABILITIES {&#10;  USHORT             Size;&#10;  USHORT             Version;&#10;  ULONG              DeviceD1 : 1;&#10;  ULONG              DeviceD2 : 1;&#10;  ULONG              LockSupported : 1;&#10;  ULONG              EjectSupported : 1;&#10;  ULONG              Removable : 1;&#10;  ULONG              DockDevice : 1;&#10;  ULONG              UniqueID : 1;&#10;  ULONG              SilentInstall : 1;&#10;  ULONG              RawDeviceOK : 1;&#10;  ULONG              SurpriseRemovalOK : 1;&#10;  ULONG              WakeFromD0 : 1;&#10;  ULONG              WakeFromD1 : 1;&#10;  ULONG              WakeFromD2 : 1;&#10;  ULONG              WakeFromD3 : 1;&#10;  ULONG              HardwareDisabled : 1;&#10;  ULONG              NonDynamic : 1;&#10;  ULONG              WarmEjectSupported : 1;&#10;...">DEVICE_CAPABILITIES</a></p>

<p><a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a></p>

<p><a href="device_wake_depth" title="typedef enum _DEVICE_WAKE_DEPTH {&#10;  DeviceWakeDepthNotWakeable,&#10;  DeviceWakeDepthD0,&#10;  DeviceWakeDepthD1,&#10;  DeviceWakeDepthD2,&#10;  DeviceWakeDepthD3hot,&#10;  DeviceWakeDepthD3cold,&#10;  DeviceWakeDepthMaximum&#10;} DEVICE_WAKE_DEPTH, *PDEVICE_WAKE_DEPTH;">DEVICE_WAKE_DEPTH</a></p>

<p><a href="porequestpowerirp" title="NTSTATUS PoRequestPowerIrp(&#10;  [in]           PDEVICE_OBJECT          DeviceObject,&#10;  [in]           UCHAR                   MinorFunction,&#10;  [in]           POWER_STATE             PowerState,&#10;  [in, optional] PREQUEST_POWER_COMPLETE CompletionFunction,&#10;  [in, optional] __drv_aliasesMem PVOID  Context,&#10;  [out]          PIRP                    *Irp&#10;);">PoRequestPowerIrp</a></p>

<p><a href="system_power_state" title="typedef enum _SYSTEM_POWER_STATE {&#10;  PowerSystemUnspecified,&#10;  PowerSystemWorking,&#10;  PowerSystemSleeping1,&#10;  PowerSystemSleeping2,&#10;  PowerSystemSleeping3,&#10;  PowerSystemHibernate,&#10;  PowerSystemShutdown,&#10;  PowerSystemMaximum&#10;} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;">SYSTEM_POWER_STATE</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-get_idle_wake_info">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nc-wdm-get_idle_wake_info.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
