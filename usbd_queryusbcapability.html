<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="USBD_QueryUsbCapability - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>USBD_QueryUsbCapability - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            USBD_QueryUsbCapability - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// usbdlib.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> USBD_QueryUsbCapability(
  [in]            USBD_HANDLE USBDHandle,
  [in]            const GUID  *CapabilityType,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>       OutputBufferLength,
  [in, out]       PUCHAR      OutputBuffer,
  [out, optional] PULONG      ResultLength
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_queryusbcapability">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/usbd_queryusbcapability.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-usbdlib-usbd_queryusbcapability)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="usbd_queryusbcapability-function">USBD_QueryUsbCapability function</h1>

<h2 id="description">Description</h2>

<p>The <strong>USBD_QueryUsbCapability</strong> routine is called by a WDM client driver to determine whether the underlying USB driver stack and the host controller hardware support a specific capability. <strong>Note for Windows Driver Framework (WDF) Drivers:</strong> If your client driver is a WDF-based driver, then you must call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nf-wdfusb-wdfusbtargetdevicequeryusbcapability">WdfUsbTargetDeviceQueryUsbCapability</a> method instead of <strong>USBD_QueryUsbCapability</strong>.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="usbdhandle-in"><code>USBDHandle</code> [in]</h3>

<p>USBD handle that is retrieved by the client driver in a previous call to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_createhandle">USBD_CreateHandle</a> routine.</p>

<h3 id="capabilitytype-in"><code>CapabilityType</code> [in]</h3>

<p>Pointer to a GUID that represents the capability for which the client driver wants to retrieve information. The possible <em><a href="pguid" title="typedef GUID* PGUID;">PGUID</a></em> values are as follows:</p>

<ul>
<li>GUID_USB_CAPABILITY_CHAINED_MDLS</li>
<li>GUID_USB_CAPABILITY_STATIC_STREAMS</li>
<li>GUID_USB_CAPABILITY_SELECTIVE_SUSPEND</li>
<li>GUID_USB_CAPABILITY_FUNCTION_SUSPEND</li>
<li>GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE</li>
<li>GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE</li>
<li>GUID_USB_CAPABILITY_TIME_SYNC</li>
</ul>

<h3 id="outputbufferlength-in"><code>OutputBufferLength</code> [in]</h3>

<p>Length, in bytes, of the buffer pointed to by <em>OutputBuffer</em>.</p>

<h3 id="outputbuffer-in-out"><code>OutputBuffer</code> [in, out]</h3>

<p>Pointer to a caller-allocated buffer. Certain capability requests return additional information in an output buffer. For those requests, you must allocate the buffer and provide a pointer to the buffer in the <em>OutputBuffer</em> parameter. Currently, only the static-streams capability request requires an output buffer of the type <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>. The buffer is filled by <strong>USBD_QueryUsbCapability</strong> with the maximum number of streams supported per endpoint.</p>

<p>Other capability requests do not require an output buffer. For those requests, you must set <em>OutputBuffer</em> to NULL and <em>OutputBufferLength</em> to 0.</p>

<h3 id="resultlength-out-optional"><code>ResultLength</code> [out, optional]</h3>

<p>Pointer to a <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> variable that receives the actual number of bytes in the buffer pointed to by <em>OutputBuffer</em>. The caller can pass NULL in <em>ResultLength</em>. If <em>ResultLength</em> is not NULL, the received value is less than or equal to the <em>OutputBufferLength</em> value.</p>

<h2 id="return-value">Return value</h2>

<p>The <strong>USBD_QueryUsbCapability</strong> routine returns an NT status code.</p>

<p>Possible values include, but are not limited to, the status codes listed in the following table.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The request was successful and the specified capability is supported.</td>
</tr>
<tr>
  <td><strong>STATUS_INVALID_PARAMETER</strong></td>
  <td>The caller passed an invalid parameter value.<br><br>* <em>USBDHandle</em> or <em>CapabilityType</em> is NULL.<br>* <em>OutputBuffer</em> is NULL but <em>OutputBufferLength</em> indicates a nonzero value. Conversely, the caller provided an output buffer but the buffer length is 0.</td>
</tr>
<tr>
  <td><strong>STATUS_NOT_IMPLEMENTED</strong></td>
  <td>The specified capability is not supported by the underlying USB driver stack.</td>
</tr>
<tr>
  <td><strong>STATUS_NOT_SUPPORTED</strong></td>
  <td>The specified capability is not supported either by the host controller hardware or the USB driver stack.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>Windows 8 includes a new USB driver stack to support USB 3.0 devices. The new USB driver stack provides several new capabilities defined such as, stream support and chained MDLs that can be used by a client driver.</p>

<p>A client driver can determine the version of the underlying USB driver stack by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_isinterfaceversionsupported">IsInterfaceVersionSupported</a> routine.</p>

<p>The client driver can use the new capabilities <em>only if</em> the underlying USB driver stack <em>and</em> hardware support them. For example, in order to send I/O requests to a particular stream associated with a bulk endpoint, the underlying USB driver stack, the endpoint, and the host controller hardware must support the static streams capability. The client driver <em>must not</em> call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_isinterfaceversionsupported">IsInterfaceVersionSupported</a> and assume the capabilities of the driver stack. Instead, the client driver <em>must</em> always call <strong>USBD_QueryUsbCapability</strong> to determine whether the USB driver stack and hardware support a particular capability.</p>

<p>The following table describes the USB-specific capabilities that a client driver can query through a <strong>USBD_QueryUsbCapability</strong> call.</p>

<table>
<thead>
<tr>
  <th>Capability GUID</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>GUID_USB_CAPABILITY_CHAINED_MDLS</td>
  <td>If the USB driver stack supports chained MDLs, the client driver can provide the transfer data as a chain of MDLs that reference segmented buffers in physical memory. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl">MDL</a>. Chained MDLs preclude the need for allocating and copying memory to create virtually contiguous buffers and therefore make I/O transfers more efficient. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Send Chained MDLs</a>.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_STATIC_STREAMS</td>
  <td>If supported, the client driver can send I/O requests to streams in a bulk endpoint.<br><br>For the static streams query request, the client driver is required to provide an output buffer (<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>). After the call completes and if the static streams capability is supported, the output buffer receives the maximum number of supported streams by the host controller. <br><br>The output buffer value does not indicate the maximum number of streams supported by the bulk endpoint in the device. To determine that number, the client driver must inspect the endpoint companion descriptor.<br><br>The USB driver stack in Windows 8 supports up to 255 streams. <br><br>If static streams are supported, the client driver can send I/O requests to the first stream (also called the <em>default stream</em>) by using the pipe handle obtained through a select-configuration request. For other streams in the endpoint, the client driver must open those streams and obtain pipe handles for them in order to send I/O requests. For more information about opening streams, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Open and Close Static Streams in a USB Bulk Endpoint</a>.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_FUNCTION_SUSPEND</td>
  <td>This capability determines whether the underlying USB driver stack supports USB Function Suspend and Remote Wake-Up features. If supported, the driver stack can process a resume signal (for remote wake-up) from an individual function in a USB 3.0 composite device. Based on that signal, an individual function driver can exit the low-power state of its function.<br><br>The capability is intended to be used by a composite driver: the driver that is loaded as the function device object (FDO) in the device stack for the composite device. By default, the Microsoft-provided USB Generic Parent Driver (Usbccgp.sys) is loaded as the FDO. <br><br>If your driver replaces Usbccgp.sys, the driver must be able to request remote wake-up and propagate the resume signal from the USB driver stack. Before implementing that logic, the driver must determine the USB driver stack's support for the function suspend capability by calling <strong>USBD_QueryUsbCapability</strong>. Usbccgp.sys in Windows 8 implements function suspend.<br><br>For a code example and more information about function suspend, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Implement Function Suspend in a Composite Driver</a>.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_SELECTIVE_SUSPEND</td>
  <td>Determines whether the underlying USB driver stack supports selective suspend.<br><br>For information about selective suspend, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">USB Selective Suspend</a>.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE</td>
  <td>Determines whether the bus is operating at high-speed or higher.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE</td>
  <td>Determines whether the bus is operating at SuperSpeed or higher.</td>
</tr>
<tr>
  <td>GUID_USB_CAPABILITY_TIME_SYNC</td>
  <td>Determines whether the frame number and QPC association feature is supported on the controller.</td>
</tr>
</tbody>
</table>

<h4 id="examples">Examples</h4>

<p>The code snippet shows how to call <strong>USBD_QueryUsbCapability</strong> to determine the capabilities of the underlying USB driver stack.</p>

<div class="codehilite">
<pre><span></span><code><span class="cm">/*++</span>

<span class="cm">Routine Description:</span>
<span class="cm">This helper routine queries the underlying USB driver stack</span>
<span class="cm">for specific capabilities. This code snippet assumes that</span>
<span class="cm">USBD handle was retrieved by the client driver in a</span>
<span class="cm">previous call to the <a href="usbd_createhandle" title="NTSTATUS USBD_CreateHandle(&#10;  [in]  PDEVICE_OBJECT DeviceObject,&#10;  [in]  PDEVICE_OBJECT TargetDeviceObject,&#10;  [in]  ULONG          USBDClientContractVersion,&#10;  [in]  ULONG          PoolTag,&#10;  [out] USBD_HANDLE    *USBDHandle&#10;);">USBD_CreateHandle</a> routine.</span>

<span class="cm">Parameters:</span>

<span class="cm">fdo: Pointer to the device object that is the current top</span>
<span class="cm">of the stack as reported by <a href="ioattachdevicetodevicestack" title="PDEVICE_OBJECT IoAttachDeviceToDeviceStack(&#10;  [in] PDEVICE_OBJECT SourceDevice,&#10;  [in] PDEVICE_OBJECT TargetDevice&#10;);">IoAttachDeviceToDeviceStack</a>.</span>

<span class="cm">Return Value: VOID</span>
<span class="cm">--*/</span>

<span class="n">VOID</span><span class="w"> </span><span class="nf">QueryUsbDriverStackCaps</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a></span><span class="w"> </span><span class="n">fdo</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></span><span class="w"> </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">    </span><span class="n">PDEVICE_EXTENSION</span><span class="w"> </span><span class="n">deviceExtension</span><span class="p">;</span>

<span class="w">    </span><span class="n">deviceExtension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PDEVICE_EXTENSION</span><span class="p">)</span><span class="n">fdo</span><span class="o">-&gt;</span><span class="n">DeviceExtension</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Check if the underlying USB driver stack</span>
<span class="w">    </span><span class="c1">// supports USB 3.0 devices.</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="usbd_isinterfaceversionsupported" title="BOOLEAN USBD_IsInterfaceVersionSupported(&#10;  [in] USBD_HANDLE USBDHandle,&#10;  [in] ULONG       USBDInterfaceVersion&#10;);">USBD_IsInterfaceVersionSupported</a></span><span class="p">(</span>
<span class="w">        </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="n">USBD_INTERFACE_VERSION_602</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Old USB stack loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">        </span><span class="c1">// function suspend support.</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;New USB stack loaded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">            </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_FUNCTION_SUSPEND</span><span class="p">,</span>
<span class="w">            </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">FunctionSuspendSupported</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">            </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Function suspend supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">FunctionSuspendSupported</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="w">            </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">            </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Function suspend not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">    </span><span class="c1">// chained <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> support.</span>

<span class="w">    </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="p">(</span>
<span class="w">        </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_CHAINED_MDLS</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">ChainedMDLSupport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Chained MDLs supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">ChainedMDLSupport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Chained MDLs not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">    </span><span class="c1">// stream support.</span>

<span class="w">    </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="w"> </span><span class="p">(</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_STATIC_STREAMS</span><span class="p">,</span>
<span class="w">        </span><span class="k">sizeof</span><span class="p">(</span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="p">),</span>
<span class="w">        </span><span class="p">(</span><span class="n">PUCHAR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">MaxSupportedStreams</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">MaxSupportedStreams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Static streams not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">    </span><span class="c1">// selective suspend support.</span>

<span class="w">    </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="w"> </span><span class="p">(</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_SELECTIVE_SUSPEND</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Selective suspend not supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Selective suspend supported.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">    </span><span class="c1">// device speed.</span>
<span class="w">    </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="w"> </span><span class="p">(</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;The device is operating at full speed or lower.</span><span class="se">\n</span><span class="s"> The device can operate at high speed or higher.&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;The device is operating at high speed or higher.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Call USBD_QueryUsbCapability to determine</span>
<span class="w">    </span><span class="c1">// device speed.</span>
<span class="w">    </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USBD_QueryUsbCapability</span><span class="w"> </span><span class="p">(</span><span class="n">deviceExtension</span><span class="o">-&gt;</span><span class="n">UsbdHandle</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="n">GUID</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">        </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">ntStatus</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ntStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;The device is operating at high speed or lower.</span><span class="se">\n</span><span class="s"> The device can operate at Superspeed or higher.&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a></span><span class="p">((</span><span class="w"> </span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span><span class="w"> </span><span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;The device is operating at SuperSpeed or higher.</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="p">;</span>

<span class="p">}</span>
</code></pre>
</div>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_usbref/">USB device driver programming reference</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_queryusbcapability">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/usbdlib/nf-usbdlib-usbd_queryusbcapability.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
