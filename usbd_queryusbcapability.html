<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="USBD_QueryUsbCapability - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>USBD_QueryUsbCapability - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            USBD_QueryUsbCapability - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// usbdlib.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> USBD_QueryUsbCapability(
  [in]            USBD_HANDLE USBDHandle,
  [in]            const GUID  *CapabilityType,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>       OutputBufferLength,
  [in, out]       PUCHAR      OutputBuffer,
  [out, optional] PULONG      ResultLength
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_queryusbcapability">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/usbd_queryusbcapability.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-usbdlib-usbd_queryusbcapability)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>USBD_QueryUsbCapability function</h1>
<h2>Description</h2>
<p>The <strong>USBD_QueryUsbCapability</strong> routine is called by a WDM client driver to determine whether the underlying USB driver stack and the host controller hardware support a specific capability. <strong>Note for Windows Driver Framework (WDF) Drivers:</strong> If your client driver is a WDF-based driver, then you must call the <a href="wdfusbtargetdevicequeryusbcapability" title="NTSTATUS WdfUsbTargetDeviceQueryUsbCapability(&#10;  [in]            WDFUSBDEVICE UsbDevice,&#10;  [in]            const GUID   *CapabilityType,&#10;  [in]            ULONG        CapabilityBufferLength,&#10;  [out, optional] PVOID        CapabilityBuffer,&#10;  [out, optional] PULONG       ResultLength&#10;);">WdfUsbTargetDeviceQueryUsbCapability</a> method instead of <strong>USBD_QueryUsbCapability</strong>.</p>
<h2>Parameters</h2>
<h3><code>USBDHandle</code> [in]</h3>
<p>USBD handle that is retrieved by the client driver in a previous call to the <a href="usbd_createhandle" title="NTSTATUS USBD_CreateHandle(&#10;  [in]  PDEVICE_OBJECT DeviceObject,&#10;  [in]  PDEVICE_OBJECT TargetDeviceObject,&#10;  [in]  ULONG          USBDClientContractVersion,&#10;  [in]  ULONG          PoolTag,&#10;  [out] USBD_HANDLE    *USBDHandle&#10;);">USBD_CreateHandle</a> routine.</p>
<h3><code>CapabilityType</code> [in]</h3>
<p>Pointer to a GUID that represents the capability for which the client driver wants to retrieve information. The possible <em><a href="pguid" title="typedef GUID* PGUID;">PGUID</a></em> values are as follows:</p>
<ul>
<li>GUID_USB_CAPABILITY_CHAINED_MDLS</li>
<li>GUID_USB_CAPABILITY_STATIC_STREAMS</li>
<li>GUID_USB_CAPABILITY_SELECTIVE_SUSPEND</li>
<li>GUID_USB_CAPABILITY_FUNCTION_SUSPEND</li>
<li>GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE</li>
<li>GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE</li>
<li>GUID_USB_CAPABILITY_TIME_SYNC</li>
</ul>
<h3><code>OutputBufferLength</code> [in]</h3>
<p>Length, in bytes, of the buffer pointed to by <em>OutputBuffer</em>.</p>
<h3><code>OutputBuffer</code> [in, out]</h3>
<p>Pointer to a caller-allocated buffer. Certain capability requests return additional information in an output buffer. For those requests, you must allocate the buffer and provide a pointer to the buffer in the <em>OutputBuffer</em> parameter. Currently, only the static-streams capability request requires an output buffer of the type <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>. The buffer is filled by <strong>USBD_QueryUsbCapability</strong> with the maximum number of streams supported per endpoint.</p>
<p>Other capability requests do not require an output buffer. For those requests, you must set <em>OutputBuffer</em> to NULL and <em>OutputBufferLength</em> to 0.</p>
<h3><code>ResultLength</code> [out, optional]</h3>
<p>Pointer to a <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> variable that receives the actual number of bytes in the buffer pointed to by <em>OutputBuffer</em>. The caller can pass NULL in <em>ResultLength</em>. If <em>ResultLength</em> is not NULL, the received value is less than or equal to the <em>OutputBufferLength</em> value.</p>
<h2>Return value</h2>
<p>The <strong>USBD_QueryUsbCapability</strong> routine returns an NT status code.</p>
<p>Possible values include, but are not limited to, the status codes listed in the following table.</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
<td>The request was successful and the specified capability is supported.</td>
</tr>
<tr>
<td><strong>STATUS_INVALID_PARAMETER</strong></td>
<td>The caller passed an invalid parameter value.<br><br>* <em>USBDHandle</em> or <em>CapabilityType</em> is NULL.<br>* <em>OutputBuffer</em> is NULL but <em>OutputBufferLength</em> indicates a nonzero value. Conversely, the caller provided an output buffer but the buffer length is 0.</td>
</tr>
<tr>
<td><strong>STATUS_NOT_IMPLEMENTED</strong></td>
<td>The specified capability is not supported by the underlying USB driver stack.</td>
</tr>
<tr>
<td><strong>STATUS_NOT_SUPPORTED</strong></td>
<td>The specified capability is not supported either by the host controller hardware or the USB driver stack.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>Windows 8 includes a new USB driver stack to support USB 3.0 devices. The new USB driver stack provides several new capabilities defined such as, stream support and chained MDLs that can be used by a client driver.</p>
<p>A client driver can determine the version of the underlying USB driver stack by calling the <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_isinterfaceversionsupported">IsInterfaceVersionSupported</a> routine.</p>
<p>The client driver can use the new capabilities <em>only if</em> the underlying USB driver stack <em>and</em> hardware support them. For example, in order to send I/O requests to a particular stream associated with a bulk endpoint, the underlying USB driver stack, the endpoint, and the host controller hardware must support the static streams capability. The client driver <em>must not</em> call <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_isinterfaceversionsupported">IsInterfaceVersionSupported</a> and assume the capabilities of the driver stack. Instead, the client driver <em>must</em> always call <strong>USBD_QueryUsbCapability</strong> to determine whether the USB driver stack and hardware support a particular capability.</p>
<p>The following table describes the USB-specific capabilities that a client driver can query through a <strong>USBD_QueryUsbCapability</strong> call.</p>
<table>
<thead>
<tr>
<th>Capability GUID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>GUID_USB_CAPABILITY_CHAINED_MDLS</td>
<td>If the USB driver stack supports chained MDLs, the client driver can provide the transfer data as a chain of MDLs that reference segmented buffers in physical memory. For more information, see <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>. Chained MDLs preclude the need for allocating and copying memory to create virtually contiguous buffers and therefore make I/O transfers more efficient. For more information, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Send Chained MDLs</a>.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_STATIC_STREAMS</td>
<td>If supported, the client driver can send I/O requests to streams in a bulk endpoint.<br><br>For the static streams query request, the client driver is required to provide an output buffer (<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>). After the call completes and if the static streams capability is supported, the output buffer receives the maximum number of supported streams by the host controller. <br><br>The output buffer value does not indicate the maximum number of streams supported by the bulk endpoint in the device. To determine that number, the client driver must inspect the endpoint companion descriptor.<br><br>The USB driver stack in Windows 8 supports up to 255 streams. <br><br>If static streams are supported, the client driver can send I/O requests to the first stream (also called the <em>default stream</em>) by using the pipe handle obtained through a select-configuration request. For other streams in the endpoint, the client driver must open those streams and obtain pipe handles for them in order to send I/O requests. For more information about opening streams, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Open and Close Static Streams in a USB Bulk Endpoint</a>.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_FUNCTION_SUSPEND</td>
<td>This capability determines whether the underlying USB driver stack supports USB Function Suspend and Remote Wake-Up features. If supported, the driver stack can process a resume signal (for remote wake-up) from an individual function in a USB 3.0 composite device. Based on that signal, an individual function driver can exit the low-power state of its function.<br><br>The capability is intended to be used by a composite driver: the driver that is loaded as the function device object (FDO) in the device stack for the composite device. By default, the Microsoft-provided USB Generic Parent Driver (Usbccgp.sys) is loaded as the FDO. <br><br>If your driver replaces Usbccgp.sys, the driver must be able to request remote wake-up and propagate the resume signal from the USB driver stack. Before implementing that logic, the driver must determine the USB driver stack's support for the function suspend capability by calling <strong>USBD_QueryUsbCapability</strong>. Usbccgp.sys in Windows 8 implements function suspend.<br><br>For a code example and more information about function suspend, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Implement Function Suspend in a Composite Driver</a>.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_SELECTIVE_SUSPEND</td>
<td>Determines whether the underlying USB driver stack supports selective suspend.<br><br>For information about selective suspend, see <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">USB Selective Suspend</a>.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE</td>
<td>Determines whether the bus is operating at high-speed or higher.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE</td>
<td>Determines whether the bus is operating at SuperSpeed or higher.</td>
</tr>
<tr>
<td>GUID_USB_CAPABILITY_TIME_SYNC</td>
<td>Determines whether the frame number and QPC association feature is supported on the controller.</td>
</tr>
</tbody>
</table>
<h4>Examples</h4>
<p>The code snippet shows how to call <strong>USBD_QueryUsbCapability</strong> to determine the capabilities of the underlying USB driver stack.</p>
<pre><code>
/*++

Routine Description:
This helper routine queries the underlying USB driver stack
for specific capabilities. This code snippet assumes that
USBD handle was retrieved by the client driver in a
previous call to the <a href="usbd_createhandle" title="NTSTATUS USBD_CreateHandle(&#10;  [in]  PDEVICE_OBJECT DeviceObject,&#10;  [in]  PDEVICE_OBJECT TargetDeviceObject,&#10;  [in]  ULONG          USBDClientContractVersion,&#10;  [in]  ULONG          PoolTag,&#10;  [out] USBD_HANDLE    *USBDHandle&#10;);">USBD_CreateHandle</a> routine.

Parameters:

fdo: Pointer to the device object that is the current top
of the stack as reported by <a href="ioattachdevicetodevicestack" title="PDEVICE_OBJECT IoAttachDeviceToDeviceStack(&#10;  [in] PDEVICE_OBJECT SourceDevice,&#10;  [in] PDEVICE_OBJECT TargetDevice&#10;);">IoAttachDeviceToDeviceStack</a>.

Return Value: VOID
--*/

VOID QueryUsbDriverStackCaps (<a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a> fdo)
{
    <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION)fdo-&gt;DeviceExtension;

    if (!deviceExtension-&gt;UsbdHandle)
    {
        return;
    }

    // Check if the underlying USB driver stack
    // supports USB 3.0 devices.

    if (!<a href="usbd_isinterfaceversionsupported" title="BOOLEAN USBD_IsInterfaceVersionSupported(&#10;  [in] USBD_HANDLE USBDHandle,&#10;  [in] ULONG       USBDInterfaceVersion&#10;);">USBD_IsInterfaceVersionSupported</a>(
        deviceExtension-&gt;UsbdHandle,
        USBD_INTERFACE_VERSION_602))
    {
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Old USB stack loaded.\n&quot; ));
    }
    else
    {
        // Call USBD_QueryUsbCapability to determine
        // function suspend support.
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;New USB stack loaded.\n&quot; ));
        ntStatus = USBD_QueryUsbCapability ( deviceExtension-&gt;UsbdHandle,
            (GUID*)&amp;GUID_USB_CAPABILITY_FUNCTION_SUSPEND,
            0,
            NULL,
            NULL);

        if (<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
        {
            deviceExtension-&gt;FunctionSuspendSupported = TRUE;
            <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Function suspend supported.\n&quot; ));
        }
        else
        {
            deviceExtension-&gt;FunctionSuspendSupported  = FALSE;
            ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
            <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Function suspend not supported.\n&quot; ));
        }
    }

    // Call USBD_QueryUsbCapability to determine
    // chained <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> support.

    ntStatus = USBD_QueryUsbCapability(
        deviceExtension-&gt;UsbdHandle,
        (GUID*)&amp;GUID_USB_CAPABILITY_CHAINED_MDLS,
        0,
        NULL,
        NULL);

    if (<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
    {
        deviceExtension-&gt;ChainedMDLSupport = TRUE;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Chained MDLs supported.\n&quot; ));
    }
    else
    {
        deviceExtension-&gt;ChainedMDLSupport = FALSE;
        ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Chained MDLs not supported.\n&quot; ));
    }

    // Call USBD_QueryUsbCapability to determine
    // stream support.

    ntStatus = USBD_QueryUsbCapability (deviceExtension-&gt;UsbdHandle,
        (GUID*)&amp;GUID_USB_CAPABILITY_STATIC_STREAMS,
        sizeof(<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>),
        (PUCHAR) &amp;deviceExtension-&gt;MaxSupportedStreams,
        NULL);

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
    {
        deviceExtension-&gt;MaxSupportedStreams = 0;
        ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Static streams not supported.\n&quot; ));
    }

    // Call USBD_QueryUsbCapability to determine
    // selective suspend support.

    ntStatus = USBD_QueryUsbCapability (deviceExtension-&gt;UsbdHandle,
        (GUID*)&amp;GUID_USB_CAPABILITY_SELECTIVE_SUSPEND,
        0,
        NULL,
        NULL);

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
    {
        ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Selective suspend not supported.\n&quot; ));
    }
    else
    {
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;Selective suspend supported.\n&quot; ));
    }

    // Call USBD_QueryUsbCapability to determine
    // device speed.
    ntStatus = USBD_QueryUsbCapability (deviceExtension-&gt;UsbdHandle,
        (GUID*)&amp;GUID_USB_CAPABILITY_DEVICE_CONNECTION_HIGH_SPEED_COMPATIBLE,
        0,
        NULL,
        NULL);

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
    {
        ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;The device is operating at full speed or lower.\n The device can operate at high speed or higher.&quot; ));
    }
    else
    {
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;The device is operating at high speed or higher.\n&quot; ));
    }

    // Call USBD_QueryUsbCapability to determine
    // device speed.
    ntStatus = USBD_QueryUsbCapability (deviceExtension-&gt;UsbdHandle,
        (GUID*)&amp;GUID_USB_CAPABILITY_DEVICE_CONNECTION_SUPER_SPEED_COMPATIBLE,
        0,
        NULL,
        NULL);

    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
    {
        ntStatus = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;The device is operating at high speed or lower.\n The device can operate at Superspeed or higher.&quot; ));
    }
    else
    {
        <a href="kdprintex" title="void KdPrintEx(&#10;  _x_&#10;);">KdPrintEx</a>(( DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, &quot;The device is operating at SuperSpeed or higher.\n&quot; ));
    }

    return;

}

</code></pre>
<h2>See also</h2>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_usbref/">USB device driver programming reference</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usbdlib/nf-usbdlib-usbd_queryusbcapability">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/usbdlib/nf-usbdlib-usbd_queryusbcapability.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
