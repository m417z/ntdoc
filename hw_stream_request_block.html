<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="HW_STREAM_REQUEST_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>HW_STREAM_REQUEST_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            HW_STREAM_REQUEST_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// strmini.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _HW_STREAM_REQUEST_BLOCK {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           SizeOfThisPacket;
  <a href="srb_command" title="typedef enum _SRB_COMMAND {&#10;  SRB_READ_DATA,&#10;  SRB_WRITE_DATA,&#10;  SRB_GET_STREAM_STATE,&#10;  SRB_SET_STREAM_STATE,&#10;  SRB_SET_STREAM_PROPERTY,&#10;  SRB_GET_STREAM_PROPERTY,&#10;  SRB_OPEN_MASTER_CLOCK,&#10;  SRB_INDICATE_MASTER_CLOCK,&#10;  SRB_UNKNOWN_STREAM_COMMAND,&#10;  SRB_SET_STREAM_RATE,&#10;  SRB_PROPOSE_DATA_FORMAT,&#10;  SRB_CLOSE_MASTER_CLOCK,&#10;  SRB_PROPOSE_STREAM_RATE,&#10;  SRB_SET_DATA_FORMAT,&#10;  SRB_GET_DATA_FORMAT,&#10;  SRB_BEGIN_FLUSH,&#10;  SRB_END_FLUSH,&#10;  SRB_GET_STREAM_INFO,&#10;  SRB_OPEN_STREAM,&#10;...">SRB_COMMAND</a>                     Command;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>                        Status;
  <a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">PHW_STREAM_OBJECT</a>               StreamObject;
  PVOID                           HwDeviceExtension;
  PVOID                           SRBExtension;
  union {
    <a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">PKSSTREAM_HEADER</a>                       DataBufferArray;
    <a href="hw_stream_descriptor" title="typedef struct _HW_STREAM_DESCRIPTOR {&#10;  HW_STREAM_HEADER      StreamHeader;&#10;  HW_STREAM_INFORMATION StreamInfo;&#10;} HW_STREAM_DESCRIPTOR, *PHW_STREAM_DESCRIPTOR;">PHW_STREAM_DESCRIPTOR</a>                  StreamBuffer;
    <a href="ksstate" title="typedef enum {&#10;  KSSTATE_STOP,&#10;  KSSTATE_ACQUIRE,&#10;  KSSTATE_PAUSE,&#10;  KSSTATE_RUN&#10;} KSSTATE, *PKSSTATE;">KSSTATE</a>                                StreamState;
    <a href="stream_time_reference" title="typedef struct _STREAM_TIME_REFERENCE {&#10;  STREAM_TIMESTAMP CurrentOnboardClockValue;&#10;  LARGE_INTEGER    OnboardClockFrequency;&#10;  LARGE_INTEGER    CurrentSystemTime;&#10;  ULONG            Reserved[2];&#10;} STREAM_TIME_REFERENCE, *PSTREAM_TIME_REFERENCE;">PSTREAM_TIME_REFERENCE</a>                 TimeReference;
    <a href="stream_property_descriptor" title="typedef struct _STREAM_PROPERTY_DESCRIPTOR {&#10;  PKSPROPERTY Property;&#10;  ULONG       PropertySetID;&#10;  PVOID       PropertyInfo;&#10;  ULONG       PropertyInputSize;&#10;  ULONG       PropertyOutputSize;&#10;} STREAM_PROPERTY_DESCRIPTOR, *PSTREAM_PROPERTY_DESCRIPTOR;">PSTREAM_PROPERTY_DESCRIPTOR</a>            PropertyInfo;
    <a href="ksdataformat" title="typedef struct {&#10;  ULONG FormatSize;&#10;  ULONG Flags;&#10;  ULONG SampleSize;&#10;  ULONG Reserved;&#10;  GUID  MajorFormat;&#10;  GUID  SubFormat;&#10;  GUID  Specifier;&#10;} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;">PKSDATAFORMAT</a>                          OpenFormat;
    <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">struct _PORT_CONFIGURATION_INFORMATION</a> *ConfigInfo;
    HANDLE                                 MasterClockHandle;
    <a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a>                     DeviceState;
    <a href="stream_data_intersect_info" title="typedef struct _STREAM_DATA_INTERSECT_INFO {&#10;  ULONG        StreamNumber;&#10;  PKSDATARANGE DataRange;&#10;  PVOID        DataFormatBuffer;&#10;  ULONG        SizeOfDataFormatBuffer;&#10;} STREAM_DATA_INTERSECT_INFO, *PSTREAM_DATA_INTERSECT_INFO;">PSTREAM_DATA_INTERSECT_INFO</a>            IntersectInfo;
    PVOID                                  MethodInfo;
    <a href="long" title="typedef long LONG;">LONG</a>                                   FilterTypeIndex;
    BOOLEAN                                Idle;
  } CommandData;
  _CommandData                    _CommandData;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           NumberOfBuffers;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           TimeoutCounter;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           TimeoutOriginal;
  struct _HW_STREAM_REQUEST_BLOCK *NextSRB;
  PIRP                            Irp;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           Flags;
  PVOID                           HwInstanceExtension;
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> NumberOfBytesToTransfer;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ActualBytesTransferred;
  };
  <a href="ksscatter_gather" title="typedef struct {&#10;  PHYSICAL_ADDRESS PhysicalAddress;&#10;  ULONG            Length;&#10;} KSSCATTER_GATHER, *PKSSCATTER_GATHER;">PKSSCATTER_GATHER</a>               ScatterGatherBuffer;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           NumberOfPhysicalPages;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           NumberOfScatterGatherElements;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                           Reserved[1];
} HW_STREAM_REQUEST_BLOCK, *PHW_STREAM_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_hw_stream_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/hw_stream_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-strmini-_hw_stream_request_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The stream class driver uses the <strong>HW_STREAM_REQUEST_BLOCK</strong> structure to pass information to and from the minidriver, using minidriver provided callbacks.</p>

<h2 id="members">Members</h2>

<h3 id="sizeofthispacket"><code>SizeOfThisPacket</code></h3>

<p>Specifies the size, in bytes, of this structure.</p>

<h3 id="command"><code>Command</code></h3>

<p>Specifies the operation to be performed by the minidriver's callback. The class driver passes SRB_XXX command codes to minidriver callbacks.</p>

<h3 id="status"><code>Status</code></h3>

<p>When the minidriver completes a stream request, it fills this member with the status code of the request. See the documentation for the appropriate <strong>StrMini</strong><em>Xxx</em><strong>Request</strong> routine for the status codes minidrivers are expected to use.</p>

<h3 id="streamobject"><code>StreamObject</code></h3>

<p>For stream oriented requests, the class driver sets this to point to the <strong><a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">HW_STREAM_OBJECT</a></strong> structure that specifies the stream the class driver is making a request on.</p>

<h3 id="hwdeviceextension"><code>HwDeviceExtension</code></h3>

<p>Pointer to the minidriver's device extension. The minidriver may use this buffer to record private information. The minidriver sets the size of this buffer in the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure it passes when it registers itself via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nf-strmini-streamclassregisteradapter">StreamClassRegisterMinidriver</a>. The class driver also passes pointers to this buffer in the <strong>HwDeviceExtension</strong> member of the <strong><a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">HW_STREAM_OBJECT</a></strong>, <strong><a href="hw_time_context" title="typedef struct _HW_TIME_CONTEXT {&#10;  struct _HW_DEVICE_EXTENSION *HwDeviceExtension;&#10;  struct _HW_STREAM_OBJECT    *HwStreamObject;&#10;  TIME_FUNCTION               Function;&#10;  ULONGLONG                   Time;&#10;  ULONGLONG                   SystemTime;&#10;} HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;">HW_TIME_CONTEXT</a></strong>, and <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> structures it passes to the minidriver.</p>

<h3 id="srbextension"><code>SRBExtension</code></h3>

<p>Points to an uninitialized buffer the class driver allocates for the minidriver to use while processing this stream request block. This buffer is deallocated once the minidriver completes its handling of the block (see <a href="streamclassdevicenotification" title="VOID StreamClassDeviceNotification(&#10;  [in] STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,&#10;  [in] PVOID                                      HwDeviceExtension,&#10;       ...                                        &#10;);">StreamClassDeviceNotification</a> or <a href="streamclassstreamnotification" title="VOID StreamClassStreamNotification(&#10;  [in] STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,&#10;  [in] PHW_STREAM_OBJECT                          StreamObject,&#10;       ...                                        &#10;);">StreamClassStreamNotification</a> for details).</p>

<h3 id="commanddata"><code>CommandData</code></h3>

<p><strong>CommandData</strong> is a union of members provided for command-code-specific data.</p>

<h3 id="commanddatadatabufferarray"><code>CommandData.DataBufferArray</code></h3>

<p>Pointer to an array of <strong><a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">KSSTREAM_HEADER</a></strong> structures. The number of entries in this array is specified in <strong>NumberOfBuffers</strong>. Each <a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">KSSTREAM_HEADER</a> describes one block of data.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-read-data"><strong>SRB_READ_DATA</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-write-data"><strong>SRB_WRITE_DATA</strong></a>.</p>

<h3 id="commanddatastreambuffer"><code>CommandData.StreamBuffer</code></h3>

<p>Points to the <strong><a href="hw_stream_descriptor" title="typedef struct _HW_STREAM_DESCRIPTOR {&#10;  HW_STREAM_HEADER      StreamHeader;&#10;  HW_STREAM_INFORMATION StreamInfo;&#10;} HW_STREAM_DESCRIPTOR, *PHW_STREAM_DESCRIPTOR;">HW_STREAM_DESCRIPTOR</a></strong> structure the minidriver fills in with a description of the kernel streaming semantics it supports.</p>

<p>The minidriver specifies the size of this buffer in the <strong>StreamDescriptorSize</strong> member of its <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> structure.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-get-stream-info"><strong>SRB_GET_STREAM_INFO</strong></a>.</p>

<h3 id="commanddatastreamstate"><code>CommandData.StreamState</code></h3>

<p>The stream state. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/ksproperty-connection-state"><strong>KSPROPERTY_CONNECTION_STATE</strong></a> for details.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-get-stream-state"><strong>SRB_GET_STREAM_STATE</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-set-stream-state"><strong>SRB_SET_STREAM_STATE</strong></a>.</p>

<h3 id="commanddatatimereference"><code>CommandData.TimeReference</code></h3>

<p>A pointer to a <a href="stream_time_reference" title="typedef struct _STREAM_TIME_REFERENCE {&#10;  STREAM_TIMESTAMP CurrentOnboardClockValue;&#10;  LARGE_INTEGER    OnboardClockFrequency;&#10;  LARGE_INTEGER    CurrentSystemTime;&#10;  ULONG            Reserved[2];&#10;} STREAM_TIME_REFERENCE, *PSTREAM_TIME_REFERENCE;">STREAM_TIME_REFERENCE</a> structure.</p>

<h3 id="commanddatapropertyinfo"><code>CommandData.PropertyInfo</code></h3>

<p>Points to the <strong><a href="stream_property_descriptor" title="typedef struct _STREAM_PROPERTY_DESCRIPTOR {&#10;  PKSPROPERTY Property;&#10;  ULONG       PropertySetID;&#10;  PVOID       PropertyInfo;&#10;  ULONG       PropertyInputSize;&#10;  ULONG       PropertyOutputSize;&#10;} STREAM_PROPERTY_DESCRIPTOR, *PSTREAM_PROPERTY_DESCRIPTOR;">STREAM_PROPERTY_DESCRIPTOR</a></strong> structure that specifies the parameters for the property get or set operation.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-get-device-property"><strong>SRB_GET_DEVICE_PROPERTY</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-set-device-property"><strong>SRB_SET_DEVICE_PROPERTY</strong></a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-get-stream-property"><strong>SRB_GET_STREAM_PROPERTY</strong></a>, or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-set-stream-property"><strong>SRB_SET_STREAM_PROPERTY</strong></a>.</p>

<h3 id="commanddataopenformat"><code>CommandData.OpenFormat</code></h3>

<p>Pointer to the <strong><a href="ksdataformat" title="typedef struct {&#10;  ULONG FormatSize;&#10;  ULONG Flags;&#10;  ULONG SampleSize;&#10;  ULONG Reserved;&#10;  GUID  MajorFormat;&#10;  GUID  SubFormat;&#10;  GUID  Specifier;&#10;} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;">KSDATAFORMAT</a></strong> structure that specifies the format.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-open-stream"><strong>SRB_OPEN_STREAM</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-propose-data-format"><strong>SRB_PROPOSE_DATA_FORMAT</strong></a>.</p>

<h3 id="commanddataconfiginfo"><code>CommandData.ConfigInfo</code></h3>

<p>Pointer to the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> structure used to initialize the device</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-initialize-device"><strong>SRB_INITIALIZE_DEVICE</strong></a>.</p>

<h3 id="commanddatamasterclockhandle"><code>CommandData.MasterClockHandle</code></h3>

<p>Handle for the clock object that now serves as the master clock.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-open-master-clock"><strong>SRB_OPEN_MASTER_CLOCK</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-indicate-master-clock"><strong>SRB_INDICATE_MASTER_CLOCK</strong></a>.</p>

<h3 id="commanddatadevicestate"><code>CommandData.DeviceState</code></h3>

<p>Specifies the new power state.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-change-power-state"><strong>SRB_CHANGE_POWER_STATE</strong></a>.</p>

<h3 id="commanddataintersectinfo"><code>CommandData.IntersectInfo</code></h3>

<p>Pointer to a <strong><a href="stream_data_intersect_info" title="typedef struct _STREAM_DATA_INTERSECT_INFO {&#10;  ULONG        StreamNumber;&#10;  PKSDATARANGE DataRange;&#10;  PVOID        DataFormatBuffer;&#10;  ULONG        SizeOfDataFormatBuffer;&#10;} STREAM_DATA_INTERSECT_INFO, *PSTREAM_DATA_INTERSECT_INFO;">STREAM_DATA_INTERSECT_INFO</a></strong> structure that describes the parameters of this operation.</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-get-data-intersection"><strong>SRB_GET_DATA_INTERSECTION</strong></a>.</p>

<h3 id="commanddatamethodinfo"><code>CommandData.MethodInfo</code></h3>

<p>Pointer to a buffer that the method data will be read from or written to.</p>

<h3 id="commanddatafiltertypeindex"><code>CommandData.FilterTypeIndex</code></h3>

<p>Filter type index for SRB_OPEN_DEVICE_INSTANCE.</p>

<h3 id="commanddataidle"><code>CommandData.Idle</code></h3>

<p>This member is set to <strong>TRUE</strong> if no open handles to the device remain. This member is set to <strong>FALSE</strong> if the device is no longer idle (a handle to the device has been opened).</p>

<p>This member is used when the command code is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-notify-idle-state"><strong>SRB_NOTIFY_IDLE_STATE</strong></a>.</p>

<h3 id="_commanddata"><code>_CommandData</code></h3>

<p><strong>CommandData</strong> is a union of members provided for command-code-specific data.</p>

<h3 id="numberofbuffers"><code>NumberOfBuffers</code></h3>

<p>If Command is either <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-read-data"><strong>SRB_READ_DATA</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/srb-write-data"><strong>SRB_WRITE_DATA</strong></a>, then this specifies the number of entries in the array of <strong><a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">KSSTREAM_HEADER</a></strong> structures that begins at the address pointed to by <strong>CommandData.DataBufferArray</strong>. Otherwise this parameter is unused.</p>

<h3 id="timeoutcounter"><code>TimeoutCounter</code></h3>

<p>The number of seconds before this request times out. The class driver decrements this once per second. If the class driver decrements <strong>TimeoutCounter</strong> to zero before the minidriver completes this request, it will call the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_request_timeout_handler">StrMiniRequestTimeout</a> routine. If the minidriver sets this to zero, the request does not time out.</p>

<h3 id="timeoutoriginal"><code>TimeoutOriginal</code></h3>

<p>The class driver sets this to the original value of <strong>TimeoutCounter</strong> upon the creation of the SRB.</p>

<h3 id="nextsrb"><code>NextSRB</code></h3>

<p>Points to another stream request block. The minidriver can use this member to queue stream request blocks.</p>

<h3 id="irp"><code>Irp</code></h3>

<p>Pointer to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for the request. Most minidrivers do not need to use this member.</p>

<h3 id="flags"><code>Flags</code></h3>

<p>Specifies the type of request. The class driver and the minidriver can use this member to determine which callback the class driver passed this stream request block to.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Callback used</th>
</tr>
</thead>
<tbody>
<tr>
  <td>None</td>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveDevicePacket</a></td>
</tr>
<tr>
  <td>SRB_HW_FLAGS_STREAM_REQUEST</td>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff568467(v=vs.85)">StrMiniReceiveStreamControlPacket</a></td>
</tr>
<tr>
  <td>SRB_HW_FLAGS_DATA_TRANSFER</td>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveStreamDataPacket</a></td>
</tr>
<tr>
  <td>SRB_HW_FLAGS_STREAM_REQUEST</td>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveStreamDataPacket</a></td>
</tr>
</tbody>
</table>

<p>SRB_HW_FLAGS_STREAM_REQUEST bit is set for stream-specific requests (which are passed to the minidriver's <strong>StrMiniReceiveStream</strong><em>Xxx</em><strong>Packet</strong> routines). The SRB_HW_FLAGS_DATA_TRANSFER bit is set for data transfer requests (which are passed to the minidriver).</p>

<h3 id="hwinstanceextension"><code>HwInstanceExtension</code></h3>

<p>Pointer to the minidriver's instance extension. The minidriver may use this buffer to record private information global to this instance of the minidriver. The minidriver sets the size of this buffer in the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure it passes when it registers itself via <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nf-strmini-streamclassregisteradapter">StreamClassRegisterMinidriver</a>.</p>

<h3 id="numberofbytestotransfer"><code>NumberOfBytesToTransfer</code></h3>

<p>For a SRB_READ_DATA or SRB_WRITE_DATA request, the number of bytes to be transferred.</p>

<h3 id="actualbytestransferred"><code>ActualBytesTransferred</code></h3>

<p>For control requests, the number of bytes actually transferred.</p>

<h3 id="scattergatherbuffer"><code>ScatterGatherBuffer</code></h3>

<p>Points to an array of <a href="ksscatter_gather" title="typedef struct {&#10;  PHYSICAL_ADDRESS PhysicalAddress;&#10;  ULONG            Length;&#10;} KSSCATTER_GATHER, *PKSSCATTER_GATHER;">KSSCATTER_GATHER</a> structures, of the form:</p>

<div class="codehilite">
<pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n"><a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a></span><span class="w"> </span><span class="n">PhysicalAddress</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">Length</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n"><a href="ksscatter_gather" title="typedef struct {&#10;  PHYSICAL_ADDRESS PhysicalAddress;&#10;  ULONG            Length;&#10;} KSSCATTER_GATHER, *PKSSCATTER_GATHER;">KSSCATTER_GATHER</a></span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n"><a href="ksscatter_gather" title="typedef struct {&#10;  PHYSICAL_ADDRESS PhysicalAddress;&#10;  ULONG            Length;&#10;} KSSCATTER_GATHER, *PKSSCATTER_GATHER;">PKSSCATTER_GATHER</a></span><span class="p">;</span>
</code></pre>
</div>

<p>The array describes a scatter/gather list that can be used by the minidriver to do DMA. The memory does not need to be probed, locked, mapped, or flushed. The stream class driver performs these for the minidriver.</p>

<h3 id="numberofphysicalpages"><code>NumberOfPhysicalPages</code></h3>

<p>Specifies the size of the array passed in the <strong>ScatterGatherBuffer</strong> member.</p>

<h3 id="numberofscattergatherelements"><code>NumberOfScatterGatherElements</code></h3>

<p>Specifies the number of physical elements pointed to by <strong>ScatterGatherBuffer</strong>.</p>

<h3 id="reserved"><code>Reserved</code></h3>

<p>The Reserved[1] field is reserved for system use. Do not use.</p>

<h2 id="remarks">Remarks</h2>

<p>The stream class driver passes pointers to HW_STREAM_REQUEST_BLOCK structures to the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveStreamDataPacket</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff568467(v=vs.85)">StrMiniReceiveStreamControlPacket</a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveDevicePacket</a> routines.</p>

<p>The minidriver owns this stream request block until the request times out or it completes the request. The minidriver signals to the class driver that it has completed the request by calling <a href="streamclassdevicenotification" title="VOID StreamClassDeviceNotification(&#10;  [in] STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,&#10;  [in] PVOID                                      HwDeviceExtension,&#10;       ...                                        &#10;);">StreamClassDeviceNotification</a>(DeviceRequestComplete, pSrb->HwDeviceExtension, pSRB) for device-specific requests, or calling <a href="streamclassstreamnotification" title="VOID StreamClassStreamNotification(&#10;  [in] STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,&#10;  [in] PHW_STREAM_OBJECT                          StreamObject,&#10;       ...                                        &#10;);">StreamClassStreamNotification</a>(StreamRequestComplete, pSrb->StreamObject, pSrb) for stream-specific requests. (The minidriver can also complete a request by calling <a href="streamclasscompleterequestandmarkqueueready" title="VOID STREAMAPI StreamClassCompleteRequestAndMarkQueueReady(&#10;  [in] PHW_STREAM_REQUEST_BLOCK Srb&#10;);">StreamClassCompleteRequestAndMarkQueueReady</a>(pSrb). See that routine for details.)</p>

<p>If the class driver times out the request, it will call the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_request_timeout_handler">StrMiniRequestTimeout</a> routine, which has the responsibility of terminating processing of the request. If the minidriver queues a request for later processing, it should set the <strong>TimeoutCounter</strong> member to zero, which will prevent the class driver from timing out the request. Once the minidriver is ready to resume processing the request, it should reset the <strong>TimeoutCounter</strong> member to the value of <strong>TimeoutOriginal</strong>.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_hw_stream_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/strmini/ns-strmini-_hw_stream_request_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
