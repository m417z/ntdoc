<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="WdfUsbTargetDeviceFormatRequestForString - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>WdfUsbTargetDeviceFormatRequestForString - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            WdfUsbTargetDeviceFormatRequestForString - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdfusb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> WdfUsbTargetDeviceFormatRequestForString(
  [in]           WDFUSBDEVICE      UsbDevice,
  [in]           WDFREQUEST        Request,
  [in]           WDFMEMORY         Memory,
  [in, optional] <a href="wdfmemory_offset" title="typedef struct _WDFMEMORY_OFFSET {&#10;  size_t BufferOffset;&#10;  size_t BufferLength;&#10;} WDFMEMORY_OFFSET, *PWDFMEMORY_OFFSET;">PWDFMEMORY_OFFSET</a> Offset,
  [in]           <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>             StringIndex,
  [in, optional] <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>            LangID
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nf-wdfusb-wdfusbtargetdeviceformatrequestforstring">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/wdfusbtargetdeviceformatrequestforstring.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdfusb-wdfusbtargetdeviceformatrequestforstring)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>WdfUsbTargetDeviceFormatRequestForString function</h1>
<h2>Description</h2>
<p>[Applies to KMDF and UMDF]</p>
<p>The <strong>WdfUsbTargetDeviceFormatRequestForString</strong> method builds a request for the USB string descriptor that is associated with a USB device's string index value.</p>
<h2>Parameters</h2>
<h3><code>UsbDevice</code> [in]</h3>
<p>A handle to a USB device object that was obtained from a previous call to <a href="wdfusbtargetdevicecreatewithparameters" title="NTSTATUS WdfUsbTargetDeviceCreateWithParameters(&#10;  [in]           WDFDEVICE                     Device,&#10;  [in]           PWDF_USB_DEVICE_CREATE_CONFIG Config,&#10;  [in, optional] PWDF_OBJECT_ATTRIBUTES        Attributes,&#10;  [out]          WDFUSBDEVICE                  *UsbDevice&#10;);">WdfUsbTargetDeviceCreateWithParameters</a>.</p>
<h3><code>Request</code> [in]</h3>
<p>A handle to a framework request object.</p>
<h3><code>Memory</code> [in]</h3>
<p>A handle to a framework memory object.</p>
<h3><code>Offset</code> [in, optional]</h3>
<p>A pointer to a caller-allocated <a href="wdfmemory_offset" title="typedef struct _WDFMEMORY_OFFSET {&#10;  size_t BufferOffset;&#10;  size_t BufferLength;&#10;} WDFMEMORY_OFFSET, *PWDFMEMORY_OFFSET;">WDFMEMORY_OFFSET</a> structure that supplies optional byte offset and length values. The framework uses these values to determine the beginning address and length, within the output buffer, for storing the string descriptor. If this pointer is <strong>NULL</strong>, the descriptor is stored at the beginning of the output buffer, and the maximum string length is the buffer length.</p>
<h3><code>StringIndex</code> [in]</h3>
<p>An index value that identifies the string. This index value is obtained from a <a href="usb_device_descriptor" title="typedef struct _USB_DEVICE_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  USHORT bcdUSB;&#10;  UCHAR  bDeviceClass;&#10;  UCHAR  bDeviceSubClass;&#10;  UCHAR  bDeviceProtocol;&#10;  UCHAR  bMaxPacketSize0;&#10;  USHORT idVendor;&#10;  USHORT idProduct;&#10;  USHORT bcdDevice;&#10;  UCHAR  iManufacturer;&#10;  UCHAR  iProduct;&#10;  UCHAR  iSerialNumber;&#10;  UCHAR  bNumConfigurations;&#10;} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;">USB_DEVICE_DESCRIPTOR</a>, <a href="usb_configuration_descriptor" title="typedef struct _USB_CONFIGURATION_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  USHORT wTotalLength;&#10;  UCHAR  bNumInterfaces;&#10;  UCHAR  bConfigurationValue;&#10;  UCHAR  iConfiguration;&#10;  UCHAR  bmAttributes;&#10;  UCHAR  MaxPower;&#10;} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;">USB_CONFIGURATION_DESCRIPTOR</a>, or <a href="usb_interface_descriptor" title="typedef struct _USB_INTERFACE_DESCRIPTOR {&#10;  UCHAR bLength;&#10;  UCHAR bDescriptorType;&#10;  UCHAR bInterfaceNumber;&#10;  UCHAR bAlternateSetting;&#10;  UCHAR bNumEndpoints;&#10;  UCHAR bInterfaceClass;&#10;  UCHAR bInterfaceSubClass;&#10;  UCHAR bInterfaceProtocol;&#10;  UCHAR iInterface;&#10;} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;">USB_INTERFACE_DESCRIPTOR</a> structure.</p>
<h3><code>LangID</code> [in, optional]</h3>
<p>A language identifier. The string will be retrieved for the language that this identifier specifies. For information about obtaining a device's supported language identifiers, see the USB specification.</p>
<h2>Return value</h2>
<p><strong>WdfUsbTargetDeviceFormatRequestForString</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the operation succeeds. Otherwise, this method can return one of the following values:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>STATUS_INVALID_PARAMETER</strong></td>
<td>The buffer's byte count was not an even number.</td>
</tr>
<tr>
<td><strong>STATUS_INSUFFICIENT_RESOURCES</strong></td>
<td>There was insufficient memory.</td>
</tr>
<tr>
<td><strong>STATUS_INTEGER_OVERFLOW</strong></td>
<td>The offset that <em>Offset</em> specifies was invalid.</td>
</tr>
</tbody>
</table>
<p>This method also might return other <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/ntstatus-values">NTSTATUS values</a>.</p>
<p>A bug check occurs if the driver supplies an invalid object handle.</p>
<h2>Remarks</h2>
<p>After <strong>WdfUsbTargetDeviceFormatRequestForString</strong> returns, the driver must call <a href="wdfrequestsend" title="BOOLEAN WdfRequestSend(&#10;  [in] WDFREQUEST                Request,&#10;  [in] WDFIOTARGET               Target,&#10;       PWDF_REQUEST_SEND_OPTIONS Options&#10;);">WdfRequestSend</a> to send the request. After <strong><a href="wdfrequestsend" title="BOOLEAN WdfRequestSend(&#10;  [in] WDFREQUEST                Request,&#10;  [in] WDFIOTARGET               Target,&#10;       PWDF_REQUEST_SEND_OPTIONS Options&#10;);">WdfRequestSend</a></strong> returns, the driver can pass the <em>Memory</em> handle to <a href="wdfmemorygetbuffer" title="PVOID WdfMemoryGetBuffer(&#10;  [in]            WDFMEMORY Memory,&#10;  [out, optional] size_t    *BufferSize&#10;);">WdfMemoryGetBuffer</a> to obtain a pointer to the memory buffer. The buffer will contain a <a href="usb_string_descriptor" title="typedef struct _USB_STRING_DESCRIPTOR {&#10;  UCHAR bLength;&#10;  UCHAR bDescriptorType;&#10;  WCHAR bString[1];&#10;} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;">USB_STRING_DESCRIPTOR</a> structure that describes the string descriptor.</p>
<p>For more information about the <strong>WdfUsbTargetDeviceFormatRequestForString</strong> method and USB I/O targets, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/wdf/usb-i-o-targets">USB I/O Targets</a>.</p>
<h4>Examples</h4>
<p>The following code example creates a request object and a memory object, and it passes the object handles to <strong>WdfUsbTargetDeviceFormatRequestForString</strong>. Then, the example sets a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfrequest/nc-wdfrequest-evt_wdf_request_completion_routine">CompletionRoutine</a> callback function for the request and sends the request to an I/O target.</p>
<pre><code><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> status;
PDEVICE_CONTEXT deviceContext = GetDeviceContext(device);
WDFREQUEST request;
WDFMEMORY memHandle;
<a href="wdf_object_attributes" title="typedef struct _WDF_OBJECT_ATTRIBUTES {&#10;  ULONG                          Size;&#10;  PFN_WDF_OBJECT_CONTEXT_CLEANUP EvtCleanupCallback;&#10;  PFN_WDF_OBJECT_CONTEXT_DESTROY EvtDestroyCallback;&#10;  WDF_EXECUTION_LEVEL            ExecutionLevel;&#10;  WDF_SYNCHRONIZATION_SCOPE      SynchronizationScope;&#10;  WDFOBJECT                      ParentObject;&#10;  size_t                         ContextSizeOverride;&#10;  PCWDF_OBJECT_CONTEXT_TYPE_INFO ContextTypeInfo;&#10;} WDF_OBJECT_ATTRIBUTES, *PWDF_OBJECT_ATTRIBUTES;">WDF_OBJECT_ATTRIBUTES</a> attributes;

<a href="wdf_object_attributes_init" title="VOID WDF_OBJECT_ATTRIBUTES_INIT(&#10;  [out] PWDF_OBJECT_ATTRIBUTES Attributes&#10;);">WDF_OBJECT_ATTRIBUTES_INIT</a>(&amp;attributes);

status = <a href="wdfrequestcreate" title="NTSTATUS WdfRequestCreate(&#10;  [in, optional] PWDF_OBJECT_ATTRIBUTES RequestAttributes,&#10;  [in, optional] WDFIOTARGET            IoTarget,&#10;  [out]          WDFREQUEST             *Request&#10;);">WdfRequestCreate</a>(
    &amp;attributes,
    <a href="wdfusbtargetdevicegetiotarget" title="WDFIOTARGET WdfUsbTargetDeviceGetIoTarget(&#10;  [in] WDFUSBDEVICE UsbDevice&#10;);">WdfUsbTargetDeviceGetIoTarget</a>(deviceContext-&gt;UsbTargetDevice),
    &amp;request);

if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
    return status;
}

status = <a href="wdfmemorycreate" title="NTSTATUS WdfMemoryCreate(&#10;  [in, optional]  PWDF_OBJECT_ATTRIBUTES Attributes,&#10;  [in]            POOL_TYPE              PoolType,&#10;  [in, optional]  ULONG                  PoolTag,&#10;  [in]            size_t                 BufferSize,&#10;  [out]           WDFMEMORY              *Memory,&#10;  [out, optional] PVOID                  *Buffer&#10;);">WdfMemoryCreate</a>(
    WDF_NO_OBJECT_ATTRIBUTES,
    NonPagedPool,
    0,
    STR_DESC_STRING_SIZE,
    &amp;memHandle,
    NULL);
if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
    <a href="wdfobjectdelete" title="VOID WdfObjectDelete(&#10;  [in] WDFOBJECT Object&#10;);">WdfObjectDelete</a>(request);
    return status;
}

status = WdfUsbTargetDeviceFormatRequestForString(
    deviceContext-&gt;UsbTargetDevice,
    request,
    memHandle,
    NULL,
    deviceContext-&gt;UsbDeviceDescr.iManufacturer,
    0x0409);

if (<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
    <a href="wdfrequestsetcompletionroutine" title="VOID WdfRequestSetCompletionRoutine(&#10;  [in]           WDFREQUEST                         Request,&#10;  [in, optional] PFN_WDF_REQUEST_COMPLETION_ROUTINE CompletionRoutine,&#10;  [in, optional] __drv_aliasesMem WDFCONTEXT        CompletionContext&#10;);">WdfRequestSetCompletionRoutine</a>(
        request,
        MyCompletionRoutine,
        NULL);

    if (<a href="wdfrequestsend" title="BOOLEAN WdfRequestSend(&#10;  [in] WDFREQUEST                Request,&#10;  [in] WDFIOTARGET               Target,&#10;       PWDF_REQUEST_SEND_OPTIONS Options&#10;);">WdfRequestSend</a>(
            request,
            <a href="wdfusbtargetdevicegetiotarget" title="WDFIOTARGET WdfUsbTargetDeviceGetIoTarget(&#10;  [in] WDFUSBDEVICE UsbDevice&#10;);">WdfUsbTargetDeviceGetIoTarget</a>(deviceContext-&gt;UsbTargetDevice),
            NULL)) {
        status = STATUS_PENDING;
    }

}
else {
    <a href="wdfobjectdelete" title="VOID WdfObjectDelete(&#10;  [in] WDFOBJECT Object&#10;);">WdfObjectDelete</a>(memHandle);
    <a href="wdfobjectdelete" title="VOID WdfObjectDelete(&#10;  [in] WDFOBJECT Object&#10;);">WdfObjectDelete</a>(request);
    return status;
}
</code></pre>
<h2>See also</h2>
<p><a href="usb_configuration_descriptor" title="typedef struct _USB_CONFIGURATION_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  USHORT wTotalLength;&#10;  UCHAR  bNumInterfaces;&#10;  UCHAR  bConfigurationValue;&#10;  UCHAR  iConfiguration;&#10;  UCHAR  bmAttributes;&#10;  UCHAR  MaxPower;&#10;} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;">USB_CONFIGURATION_DESCRIPTOR</a></p>
<p><a href="usb_device_descriptor" title="typedef struct _USB_DEVICE_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  USHORT bcdUSB;&#10;  UCHAR  bDeviceClass;&#10;  UCHAR  bDeviceSubClass;&#10;  UCHAR  bDeviceProtocol;&#10;  UCHAR  bMaxPacketSize0;&#10;  USHORT idVendor;&#10;  USHORT idProduct;&#10;  USHORT bcdDevice;&#10;  UCHAR  iManufacturer;&#10;  UCHAR  iProduct;&#10;  UCHAR  iSerialNumber;&#10;  UCHAR  bNumConfigurations;&#10;} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;">USB_DEVICE_DESCRIPTOR</a></p>
<p><a href="usb_interface_descriptor" title="typedef struct _USB_INTERFACE_DESCRIPTOR {&#10;  UCHAR bLength;&#10;  UCHAR bDescriptorType;&#10;  UCHAR bInterfaceNumber;&#10;  UCHAR bAlternateSetting;&#10;  UCHAR bNumEndpoints;&#10;  UCHAR bInterfaceClass;&#10;  UCHAR bInterfaceSubClass;&#10;  UCHAR bInterfaceProtocol;&#10;  UCHAR iInterface;&#10;} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;">USB_INTERFACE_DESCRIPTOR</a></p>
<p><a href="usb_string_descriptor" title="typedef struct _USB_STRING_DESCRIPTOR {&#10;  UCHAR bLength;&#10;  UCHAR bDescriptorType;&#10;  WCHAR bString[1];&#10;} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;">USB_STRING_DESCRIPTOR</a></p>
<p><a href="wdfmemory_offset" title="typedef struct _WDFMEMORY_OFFSET {&#10;  size_t BufferOffset;&#10;  size_t BufferLength;&#10;} WDFMEMORY_OFFSET, *PWDFMEMORY_OFFSET;">WDFMEMORY_OFFSET</a></p>
<p><a href="wdfmemorygetbuffer" title="PVOID WdfMemoryGetBuffer(&#10;  [in]            WDFMEMORY Memory,&#10;  [out, optional] size_t    *BufferSize&#10;);">WdfMemoryGetBuffer</a></p>
<p><a href="wdfrequestsend" title="BOOLEAN WdfRequestSend(&#10;  [in] WDFREQUEST                Request,&#10;  [in] WDFIOTARGET               Target,&#10;       PWDF_REQUEST_SEND_OPTIONS Options&#10;);">WdfRequestSend</a></p>
<p><a href="wdfrequestsetcompletionroutine" title="VOID WdfRequestSetCompletionRoutine(&#10;  [in]           WDFREQUEST                         Request,&#10;  [in, optional] PFN_WDF_REQUEST_COMPLETION_ROUTINE CompletionRoutine,&#10;  [in, optional] __drv_aliasesMem WDFCONTEXT        CompletionContext&#10;);">WdfRequestSetCompletionRoutine</a></p>
<p><a href="wdfusbtargetdeviceallocandquerystring" title="NTSTATUS WdfUsbTargetDeviceAllocAndQueryString(&#10;  [in]            WDFUSBDEVICE           UsbDevice,&#10;  [in, optional]  PWDF_OBJECT_ATTRIBUTES StringMemoryAttributes,&#10;  [out]           WDFMEMORY              *StringMemory,&#10;  [out, optional] PUSHORT                NumCharacters,&#10;  [in]            UCHAR                  StringIndex,&#10;  [in, optional]  USHORT                 LangID&#10;);">WdfUsbTargetDeviceAllocAndQueryString</a></p>
<p><a href="wdfusbtargetdevicecreatewithparameters" title="NTSTATUS WdfUsbTargetDeviceCreateWithParameters(&#10;  [in]           WDFDEVICE                     Device,&#10;  [in]           PWDF_USB_DEVICE_CREATE_CONFIG Config,&#10;  [in, optional] PWDF_OBJECT_ATTRIBUTES        Attributes,&#10;  [out]          WDFUSBDEVICE                  *UsbDevice&#10;);">WdfUsbTargetDeviceCreateWithParameters</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdfusb/nf-wdfusb-wdfusbtargetdeviceformatrequestforstring">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdfusb/nf-wdfusb-wdfusbtargetdeviceformatrequestforstring.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
