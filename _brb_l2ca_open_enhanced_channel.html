<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="_BRB_L2CA_OPEN_ENHANCED_CHANNEL - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>_BRB_L2CA_OPEN_ENHANCED_CHANNEL - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            _BRB_L2CA_OPEN_ENHANCED_CHANNEL - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// bthddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">struct _BRB_L2CA_OPEN_ENHANCED_CHANNEL {
  <a href="brb_header" title="typedef struct _BRB_HEADER {&#10;  LIST_ENTRY ListEntry;&#10;  ULONG      Length;&#10;  USHORT     Version;&#10;  USHORT     Type;&#10;  ULONG      BthportFlags;&#10;  NTSTATUS   Status;&#10;  BTHSTATUS  BtStatus;&#10;  PVOID      Context[BTHPORT_CONTEXT_SIZE];&#10;  PVOID      ClientContext[BTHPORT_CONTEXT_SIZE];&#10;  ULONG      Reserved[BTHPORT_RESERVED_FIELD_SIZE];&#10;} BRB_HEADER;">BRB_HEADER</a>                              Hdr;
  L2CAP_CHANNEL_HANDLE                    ChannelHandle;
  union {
    struct {
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> Response;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ResponseStatus;
    };
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> Psm;
  };
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                   ChannelFlags;
  BTH_ADDR                                BtAddress;
  struct {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                    Flags;
    <a href="l2cap_config_value_range" title="typedef struct _L2CAP_CONFIG_VALUE_RANGE {&#10;  USHORT Min;&#10;  USHORT Preferred;&#10;  USHORT Max;&#10;} L2CAP_CONFIG_VALUE_RANGE, *PL2CAP_CONFIG_VALUE_RANGE;">L2CAP_CONFIG_VALUE_RANGE</a> Mtu;
    <a href="l2cap_config_value_range" title="typedef struct _L2CAP_CONFIG_VALUE_RANGE {&#10;  USHORT Min;&#10;  USHORT Preferred;&#10;  USHORT Max;&#10;} L2CAP_CONFIG_VALUE_RANGE, *PL2CAP_CONFIG_VALUE_RANGE;">L2CAP_CONFIG_VALUE_RANGE</a> FlushTO;
    <a href="l2cap_flowspec" title="typedef struct _L2CAP_FLOWSPEC {&#10;  UCHAR Flags;&#10;  UCHAR ServiceType;&#10;  ULONG TokenRate;&#10;  ULONG TokenBucketSize;&#10;  ULONG PeakBandwidth;&#10;  ULONG Latency;&#10;  ULONG DelayVariation;&#10;} L2CAP_FLOWSPEC, *PL2CAP_FLOWSPEC;">L2CAP_FLOWSPEC</a>           Flow;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                   LinkTO;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                    NumExtraOptions;
    <a href="l2cap_config_option" title="typedef struct _L2CAP_CONFIG_OPTION {&#10;  CO_HEADER Header;&#10;  VOID      *DynamicBuffer;&#10;  UCHAR     FixedBuffer[4];&#10;  USHORT    Flags;&#10;} L2CAP_CONFIG_OPTION, *PL2CAP_CONFIG_OPTION;">PL2CAP_CONFIG_OPTION</a>     ExtraOptions;
    struct {
      <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ServiceType;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Latency;
    } LocalQos;
    struct {
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                 Flags;
      <a href="l2cap_retransmission_and_flow_control" title="typedef struct _L2CAP_RETRANSMISSION_AND_FLOW_CONTROL {&#10;  UCHAR  Mode;&#10;  UCHAR  TxWindowSize;&#10;  UCHAR  MaxTransmit;&#10;  USHORT RetransmissionTO;&#10;  USHORT MonitorTO;&#10;  USHORT MaxPDUSize;&#10;} L2CAP_RETRANSMISSION_AND_FLOW_CONTROL, *PL2CAP_RETRANSMISSION_AND_FLOW_CONTROL;">L2CAP_RETRANSMISSION_AND_FLOW_CONTROL</a> RetransmissionAndFlow;
    } ModeConfig;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                   Fcs;
    <a href="l2cap_extended_flow_spec" title="typedef struct _L2CAP_EXTENDED_FLOW_SPEC {&#10;  UCHAR  Identifier;&#10;  UCHAR  ServiceType;&#10;  USHORT MaxSDUSize;&#10;  ULONG  SDUInterArrivalTime;&#10;  ULONG  AccessLatency;&#10;  ULONG  FlushTimeout;&#10;} L2CAP_EXTENDED_FLOW_SPEC, *PL2CAP_EXTENDED_FLOW_SPEC;">L2CAP_EXTENDED_FLOW_SPEC</a> ExtendedFlowSpec;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                   ExtendedWindowSize;
  } ConfigOut;
  struct {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                    Flags;
    <a href="l2cap_config_value_range" title="typedef struct _L2CAP_CONFIG_VALUE_RANGE {&#10;  USHORT Min;&#10;  USHORT Preferred;&#10;  USHORT Max;&#10;} L2CAP_CONFIG_VALUE_RANGE, *PL2CAP_CONFIG_VALUE_RANGE;">L2CAP_CONFIG_VALUE_RANGE</a> Mtu;
    <a href="l2cap_config_range" title="typedef struct _L2CAP_CONFIG_RANGE {&#10;  USHORT Min;&#10;  USHORT Max;&#10;} L2CAP_CONFIG_RANGE, *PL2CAP_CONFIG_RANGE;">L2CAP_CONFIG_RANGE</a>       FlushTO;
  } ConfigIn;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                   CallbackFlags;
  <a href="pfnbthport_indication_callback_enhanced" title="PFNBTHPORT_INDICATION_CALLBACK_ENHANCED PfnbthportIndicationCallbackEnhanced;&#10;&#10;void PfnbthportIndicationCallbackEnhanced(&#10;  [in] PVOID Context,&#10;  [in] INDICATION_CODE Indication,&#10;  [in] PINDICATION_PARAMETERS_ENHANCED Parameters&#10;)&#10;{...}">PFNBTHPORT_INDICATION_CALLBACK_ENHANCED</a> Callback;
  PVOID                                   CallbackContext;
  PVOID                                   ReferenceObject;
  <a href="channel_config_results_enhanced" title="typedef struct _CHANNEL_CONFIG_RESULTS_ENHANCED {&#10;  CHANNEL_CONFIG_PARAMETERS_ENHANCED Params;&#10;  ULONG                              ExtraOptionsBufferSize;&#10;} CHANNEL_CONFIG_RESULTS_ENHANCED, *PCHANNEL_CONFIG_RESULTS_ENHANCED;">CHANNEL_CONFIG_RESULTS_ENHANCED</a>         OutResults;
  <a href="channel_config_results_enhanced" title="typedef struct _CHANNEL_CONFIG_RESULTS_ENHANCED {&#10;  CHANNEL_CONFIG_PARAMETERS_ENHANCED Params;&#10;  ULONG                              ExtraOptionsBufferSize;&#10;} CHANNEL_CONFIG_RESULTS_ENHANCED, *PCHANNEL_CONFIG_RESULTS_ENHANCED;">CHANNEL_CONFIG_RESULTS_ENHANCED</a>         InResults;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                   IncomingQueueDepth;
  PVOID                                   Reserved;
};</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/bthddi/ns-bthddi-_brb_l2ca_open_enhanced_channel">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/_brb_l2ca_open_enhanced_channel.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-bthddi-_brb_l2ca_open_enhanced_channel)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>_BRB_L2CA_OPEN_ENHANCED_CHANNEL structure</h1>
<h2>Description</h2>
<p>The _BRB_L2CA_OPEN_ENHANCED_CHANNEL structure is used to open an enhanced L2CAP channel to a remote device, or send a response for accepting/rejecting an incoming enhanced L2CAP connection request that was initiated by a remote device.</p>
<h2>Members</h2>
<h3><code>Hdr</code></h3>
<p>A <a href="brb_header" title="typedef struct _BRB_HEADER {&#10;  LIST_ENTRY ListEntry;&#10;  ULONG      Length;&#10;  USHORT     Version;&#10;  USHORT     Type;&#10;  ULONG      BthportFlags;&#10;  NTSTATUS   Status;&#10;  BTHSTATUS  BtStatus;&#10;  PVOID      Context[BTHPORT_CONTEXT_SIZE];&#10;  PVOID      ClientContext[BTHPORT_CONTEXT_SIZE];&#10;  ULONG      Reserved[BTHPORT_RESERVED_FIELD_SIZE];&#10;} BRB_HEADER;">BRB_HEADER</a> structure that contains information about the current <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a>.</p>
<h3><code>ChannelHandle</code></h3>
<p>Handle used to identify the connection upon a successful connect. When sending a <strong>BRB_L2CA_OPEN_CHANNEL</strong>, this will be filled in when the <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a> completes. When sending a <strong>BRB_L2CA_OPEN_CHANNEL_RESPONSE</strong> request, this must be filled in by the server before sending down the <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a>. The value assigned should be <code><a href="indication_parameters" title="typedef struct _INDICATION_PARAMETERS {&#10;  L2CAP_CHANNEL_HANDLE ConnectionHandle;&#10;  IN BTH_ADDR          BtAddress;&#10;  union {&#10;    struct {&#10;      struct {&#10;        OUT USHORT PSM;&#10;      } Request;&#10;    } Connect;&#10;    struct {&#10;      CHANNEL_CONFIG_PARAMETERS CurrentParams;&#10;      CHANNEL_CONFIG_PARAMETERS RequestedParams;&#10;      CHANNEL_CONFIG_PARAMETERS ResponseParams;&#10;      USHORT                    Response;&#10;    } ConfigRequest;&#10;    struct {&#10;      CHANNEL_CONFIG_PARAMETERS CurrentParams;&#10;      CHANNEL_CONFIG_PARAMETERS RequestedParams;&#10;      CHANNEL_CONFIG_PARAMETERS RejectedParams;&#10;      PCO_TYPE                  UnknownTypes;&#10;...">INDICATION_PARAMETERS</a>::ConnectionHandle</code> which was passed in during the IndicationRemoteConnect.</p>
<h3><code>Response</code></h3>
<p>Used only with <strong>BRB_L2CA_OPEN_CHANNEL_RESPONSE</strong>. One of the CONNECT_RSP_RESULT_Xxx values is used.</p>
<p>If the <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a> returns with a status of STATUS_REQUEST_NOT_ACCEPTED, then <em>Response</em> will contain the negative response from the remote host.</p>
<h3><code>ResponseStatus</code></h3>
<p>If <em>Response</em> is equal to CONNECT_RSP_RESULT_PENDING, then this field is valid. One of the CONNECT_RSP_STATUS_XXX values is used.</p>
<h3><code>Psm</code></h3>
<p>The Protocol/Service Multiplexer (PSM) that the channel uses to connect to the remote device. When used with a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL</strong> request, this member is set as an input field. When used with a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE</strong> request, this member is used as an output field.</p>
<h3><code>ChannelFlags</code></h3>
<p>Flags that specify the requirements for the channel to be opened. Valid flag values are listed in the following table:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF_LINK_AUTHENTICATED</td>
<td>The link must be authenticated.</td>
</tr>
<tr>
<td>CF_LINK_ENCRYPTED</td>
<td>The link must be encrypted. Setting this flag also sets the CF_LINK_AUTHENTICATED flag.</td>
</tr>
<tr>
<td>CF_LINK_SUPPRESS_PIN</td>
<td>The profile driver indicates its preference that users not be prompted for a PIN.</td>
</tr>
</tbody>
</table>
<h3><code>BtAddress</code></h3>
<p>The Bluetooth address of the device for which the connection is intended.</p>
<h3><code>ConfigOut</code></h3>
<p>The substructure that contains parameter settings for a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL</strong> <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a> sent to a remote device.</p>
<h3><code>ConfigOut.Flags</code></h3>
<p>Flags that specify the requirements for the channel to be opened. Valid flag values are listed in the following table:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF_LINK_AUTHENTICATED</td>
<td>The link must be authenticated.</td>
</tr>
<tr>
<td>CF_LINK_ENCRYPTED</td>
<td>The link must be encrypted. Setting this flag also sets the CF_LINK_AUTHENTICATED flag.</td>
</tr>
<tr>
<td>CF_LINK_SUPPRESS_PIN</td>
<td>The profile driver indicates its preference that users not be prompted for a PIN.</td>
</tr>
<tr>
<td>CFG_ENHANCED</td>
<td>Specifies that the ModeConfig structure is valid.</td>
</tr>
<tr>
<td>CFG_FCS</td>
<td>Specifies that the Fcs value is valid.</td>
</tr>
</tbody>
</table>
<h3><code>ConfigOut.Mtu</code></h3>
<p>The range of message transfer units (MTUs) that is used to negotiate the size of the outbound half of channel.</p>
<h3><code>ConfigOut.FlushTO</code></h3>
<p>The range of possible values to be used for the flush timeout for the outbound half of the channel.</p>
<h3><code>ConfigOut.Flow</code></h3>
<p>Reserved for future use. Do not use.</p>
<h3><code>ConfigOut.LinkTO</code></h3>
<p>The Link Manager link timeout.</p>
<h3><code>ConfigOut.NumExtraOptions</code></h3>
<p>The number of array items that are contained in the <strong>ExtraOptions</strong> member. This value should be zero for most clients.</p>
<h3><code>ConfigOut.ExtraOptions</code></h3>
<p>Extra options. This value should be zero for most clients.</p>
<h3><code>ConfigOut.LocalQos</code></h3>
<p>Reserved for future use. Do not use.</p>
<h3><code>ConfigOut.LocalQos.ServiceType</code></h3>
<p>Reserved for future use. Do not use.</p>
<h3><code>ConfigOut.LocalQos.Latency</code></h3>
<p>Reserved for future use. Do not use.</p>
<h3><code>ConfigOut.ModeConfig</code></h3>
<p>Specifies the type of L2CAP channel being opened. This structure is valid only if CFG_ENHANCED flag is specified.</p>
<h3><code>ConfigOut.ModeConfig.Flags</code></h3>
<p>Specifies the type of L2CAP channel mode requested.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CM_BASIC</td>
<td>Open a basic mode channel.</td>
</tr>
<tr>
<td>CM_RETRANSMISSION_AND_FLOW</td>
<td>Open an enhanced retransmission mode channel.</td>
</tr>
<tr>
<td>CM_STREAMING</td>
<td>Open a streaming mode channel.</td>
</tr>
</tbody>
</table>
<h3><code>ConfigOut.ModeConfig.RetransmissionAndFlow</code></h3>
<p>Specifies the options for
CM_RETRANSMISSION_AND_FLOW and CM_STREAMING modes. This structure must be zero if only CM_BASIC is specified in the <strong>Flags</strong> member.</p>
<p>The <strong>Mode</strong> submember of <strong>RetransmissionAndFlow</strong> should be set to 0. Use the <strong>ModeConfig</strong> submember of <strong>RetransmissionAndFlow</strong> to specify the type of channel to open.</p>
<h3><code>ConfigOut.Fcs</code></h3>
<p>Specifies whether FCS should be used for the enhanced L2CAP channel. This value is valid only if CM_RETRANSMISSION_AND_FLOW or CM_STREAMING flag is specified in the <strong>Flags</strong> member.</p>
<h3><code>ConfigOut.ExtendedFlowSpec</code></h3>
<p>Not supported.</p>
<h3><code>ConfigOut.ExtendedWindowSize</code></h3>
<p>Not supported.</p>
<h3><code>ConfigIn</code></h3>
<p>The substructure that contains parameter settings to validate incoming <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE</strong> BRBs that are sent from a remote device.</p>
<h3><code>ConfigIn.Flags</code></h3>
<p>Flags that specify the requirements for the channel to be opened. Valid flag values are listed in the following table:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CF_LINK_AUTHENTICATED</td>
<td>The link must be authenticated.</td>
</tr>
<tr>
<td>CF_LINK_ENCRYPTED</td>
<td>The link must be encrypted. Setting this flag also sets the CF_LINK_AUTHENTICATED flag.</td>
</tr>
<tr>
<td>CF_LINK_SUPPRESS_PIN</td>
<td>The profile driver indicates its preference that users not be prompted for a PIN.</td>
</tr>
</tbody>
</table>
<h3><code>ConfigIn.Mtu</code></h3>
<p>The range of message transfer units (MTUs) that is used to negotiate the size of the inbound half of channel.</p>
<h3><code>ConfigIn.FlushTO</code></h3>
<p>The range of possible values to be used for the flush timeout for the inbound half of the channel.</p>
<h3><code>CallbackFlags</code></h3>
<p>A flag that specifies which events should generate a callback routine to notify the profile driver that the event has occurred. Valid flag values are contained in the following table.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CALLBACK_CONFIG_EXTRA_IN</td>
<td>If set, the callback routine will be called when the configuration request for the remote device contains extra options. If not set, the extra configuration options will be rejected as unknown options. This flag is used with <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE</strong> BRBs.</td>
</tr>
<tr>
<td>CALLBACK_CONFIG_EXTRA_OUT</td>
<td>If set, the callback routine will be called when the remote device rejects an extra configuration option from a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL</strong> request. If not set and the remote device rejects the configuration request due to an extra option, the connection will be closed.</td>
</tr>
<tr>
<td>CALLBACK_CONFIG_QOS</td>
<td>If set, the callback routine will be called when a remote device sends a configuration request that contains a QOS value. If this flag is not set and the remote device either sends QOS parameters in a configuration request or rejects the profile driver's requested QOS parameters, the connection is disconnected.</td>
</tr>
<tr>
<td>CALLBACK_DISCONNECT</td>
<td>If set, the callback routine will be called when a remote device disconnects from the enhanced L2CAP channel.</td>
</tr>
<tr>
<td>CALLBACK_RECV_PACKET</td>
<td>If set, the callback routine will be called when the profile driver receives an incoming enhanced L2CAP packet.</td>
</tr>
</tbody>
</table>
<h3><code>Callback</code></h3>
<p>The <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/bthddi/nc-bthddi-pfnbthport_indication_callback_enhanced">Enhanced L2CAP Callback Function</a> implemented by the profile driver, that the Bluetooth driver stack should call to notify the profile driver about any changes to the enhanced L2CAP connection.</p>
<h3><code>CallbackContext</code></h3>
<p>The context to pass to the callback function specified in the <strong>Callback</strong> member. The profile driver defines this value.</p>
<h3><code>ReferenceObject</code></h3>
<p>A pointer to an object to pass to <a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-obfreferenceobject">ObReferenceObject</a> and <a href="obdereferenceobject" title="void ObDereferenceObject(&#10;  [in] a&#10;);">ObDereferenceObject</a> for which to maintain a reference count.</p>
<h3><code>OutResults</code></h3>
<p>A <a href="channel_config_results_enhanced" title="typedef struct _CHANNEL_CONFIG_RESULTS_ENHANCED {&#10;  CHANNEL_CONFIG_PARAMETERS_ENHANCED Params;&#10;  ULONG                              ExtraOptionsBufferSize;&#10;} CHANNEL_CONFIG_RESULTS_ENHANCED, *PCHANNEL_CONFIG_RESULTS_ENHANCED;">CHANNEL_CONFIG_RESULTS_ENHANCED</a> structure that contains configuration parameters negotiated for the outbound request.</p>
<h3><code>InResults</code></h3>
<p>A <a href="channel_config_results_enhanced" title="typedef struct _CHANNEL_CONFIG_RESULTS_ENHANCED {&#10;  CHANNEL_CONFIG_PARAMETERS_ENHANCED Params;&#10;  ULONG                              ExtraOptionsBufferSize;&#10;} CHANNEL_CONFIG_RESULTS_ENHANCED, *PCHANNEL_CONFIG_RESULTS_ENHANCED;">CHANNEL_CONFIG_RESULTS_ENHANCED</a> structure that contains configuration parameters negotiated for the inbound request.</p>
<h3><code>IncomingQueueDepth</code></h3>
<p>Specifies the incoming queue length in message transfer units (MTUs).</p>
<h3><code>Reserved</code></h3>
<p>Reserved member. Do not use.</p>
<h4>Response</h4>
<p>This member is used as an input parameter for a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL</strong> request and an output parameter for the <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE</strong> request.</p>
<p>For a <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE</strong> request, this member holds a flag that indicates the profile driver's response to the remote device. Valid flag values are contained in the following table.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT_RSP_RESULT_NO_RESOURCES</td>
<td>The profile driver refused the connection due to a lack of resources.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_PENDING</td>
<td>The profile driver is currently busy and cannot accept the connection. Try again later.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_PSM_NEG</td>
<td>The profile driver refused the connection because the PSM is not supported.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_SECURITY_BLOCK</td>
<td>The profile driver refused the connection for security reasons.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_SUCCESS</td>
<td>The profile driver accepted the connection.</td>
</tr>
</tbody>
</table>
<p>For the <strong>BRB_L2CA_OPEN_ENHANCED_CHANNEL</strong> <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a>, this member contains the response from the remote device to which the profile driver attempted to connect. Valid flag values are contained in the following table.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECT_RSP_RESULT_NO_RESOURCES</td>
<td>The remote device refused the connection due to a lack of resources.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_PSM_NEG</td>
<td>The remote device refused the connection.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_SECURITY_BLOCK</td>
<td>The remote device refused the connection for security reasons.</td>
</tr>
<tr>
<td>CONNECT_RSP_RESULT_SUCCESS</td>
<td>The remote device accepted the connection.</td>
</tr>
</tbody>
</table>
<h4>ResponseStatus</h4>
<p>If during a call to the BRB_L2CA_OPEN_ENHANCED_CHANNEL_RESPONSE <a href="brb" title="typedef struct _BRB {&#10;  union {&#10;#if ...&#10;    _BRB_HEADER                             BrbHeader;&#10;#else&#10;    struct _BRB_HEADER                      BrbHeader;&#10;#endif&#10;#if ...&#10;    _BRB_GET_DEVICE_INTERFACE_STRING        BrbGetDeviceInterfaceString;&#10;#else&#10;    struct _BRB_GET_DEVICE_INTERFACE_STRING BrbGetDeviceInterfaceString;&#10;#endif&#10;#if ...&#10;    _BRB_GET_LOCAL_BD_ADDR                  BrbGetLocalBdAddress;&#10;#else&#10;    struct _BRB_GET_LOCAL_BD_ADDR           BrbGetLocalBdAddress;&#10;#endif&#10;#if ...&#10;    _BRB_ACL_GET_MODE                       BrbAclGetMode;&#10;#else&#10;...">BRB</a> the Response member is set to CONNECT_RSP_RESULT_PENDING, this member is valid and contains one of the following values:</p>
<ul>
<li>CONNECT_RSP_STATUS_AUTHENTICATION_PENDING</li>
<li>CONNECT_RSP_STATUS_AUTHORIZATION_PENDING</li>
<li>CONNECT_RSP_STATUS_NO_INFORMATION</li>
</ul>
<h2>Remarks</h2>
<p>Profile drivers can use <code>CM_BASIC | CM_RETRANSMISSION_AND_FLOW</code>, or <code>CM_BASIC | CM_STREAMING</code> modes for the <strong>Flags</strong> member. This indicates to open an enhanced retransmission mode, or streaming mode channel if possible, and if not fall back to basic mode channel.
A value of <code>CM_RETRANSMISSION_AND_FLOW | CM_STREAMING</code> is not supported.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/bthddi/ns-bthddi-_brb_l2ca_open_enhanced_channel">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/bthddi/ns-bthddi-_brb_l2ca_open_enhanced_channel.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
