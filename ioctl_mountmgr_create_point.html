<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IOCTL_MOUNTMGR_CREATE_POINT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IOCTL_MOUNTMGR_CREATE_POINT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IOCTL_MOUNTMGR_CREATE_POINT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTIOAPI_H

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">#define IOCTL_MOUNTMGR_CREATE_POINT                 <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(<a href="mountmgrcontroltype" title="#define MOUNTMGRCONTROLTYPE 0x0000006D // &#x27;m&#x27;">MOUNTMGRCONTROLTYPE</a>, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/3d935379c6ac1f147cc4e3b25bed778f0d140c69/phnt/include/ntioapi.h#L3236">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// mountmgr.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x006d, 0x000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CREATE_POINT 0x006DC000</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mountmgr/ni-mountmgr-ioctl_mountmgr_create_point">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<p>This IOCTL is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/mountmgr/ni-mountmgr-ioctl_mountmgr_create_point">documented in Windows Driver Kit</a>.</p>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ioctl_mountmgr_create_point.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ni-mountmgr-ioctl_mountmgr_create_point)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The mount manager clients can use this IOCTL to request that the mount manager create a persistent symbolic link name for the indicated volume.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="major-code">Major code</h3>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a></p>

<h3 id="input-buffer">Input buffer</h3>

<p>The mount point manager places a <strong><a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a></strong> structure at the beginning of the buffer at <strong>Irp->AssociatedIrp.SystemBuffer</strong>. The mount manager inserts the newly-assigned persistent symbolic link name at the address pointed to by the <strong>SymbolicLinkNameOffset</strong> member of this structure, and it inserts the nonpersistent device name at the address pointed to by the <strong>DeviceNameOffset</strong> member of this structure.</p>

<h3 id="input-buffer-length">Input buffer length</h3>

<p><strong>Parameters.DeviceIoControl.InputBufferLength</strong> in the I/O stack location of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> indicates the size, in bytes, of the input buffer, which must be greater than or equal to <code>sizeof(<a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a>)</code>.</p>

<h3 id="output-buffer">Output buffer</h3>

<p>None.</p>

<h3 id="output-buffer-length">Output buffer length</h3>

<p>None.</p>

<h3 id="inputoutput-buffer">Input/output buffer</h3>

<p>N/A</p>

<h3 id="inputoutput-buffer-length">Input/output buffer length</h3>

<p>N/A</p>

<h3 id="status-block">Status block</h3>

<p>If the operation is successful, the <strong>Status</strong> field is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>.</p>

<p>If <strong>InputBufferLength</strong> is less than <code>sizeof(<a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a>)</code>, the <strong>Status</strong> field is set to STATUS_INVALID_PARAMETER.</p>

<h2 id="remarks">Remarks</h2>

<p>The input to this request is the persistent symbolic link name to be created and a name that is already valid for purposes of identifying the volume. The name given for purposes of identifying the volume can be of any type: a unique volume name, a symbolic link name, or a nonpersistent device name. If the new persistent name is not already in use, the call will succeed and the mount manager database will be modified to reflect that the new persistent name belongs to the volume. If the mount manager database already contains the new persistent name but the volume that owns that name is not in the system, this call will overwrite ownership of the given persistent name.</p>

<p>The mount manager allows the creation of a new persistent symbolic link name even if it has not yet been notified of the given volume in the MOUNTDEV_MOUNTED_DEVICE_GUID device interface notification. In such a case, the mount manager simply creates the symbolic link and updates the mount manager database.</p>

<p>The mount manager enforces a policy of at most one persistent drive letter per volume. If an <strong>IOCTL_MOUNTMGR_CREATE_POINT</strong> request is sent with a drive letter, the request will fail if there is already a drive letter assigned to the volume, unless the mount manager has not yet been notified of the volume by means of the MOUNTDEV_MOUNTED_DEVICE_GUID device interface notification. In the latter case, the call succeeds and the mount manager purges the mount manager database of any other drive letters previously assigned to the volume.</p>

<p>If IOCTL_MOUNTMGR_CREATE_POINT specifies a drive letter, the drive letter must be upper case.</p>

<p>Note that a client can discover whether the mount manager has received the MOUNTDEV_MOUNTED_DEVICE_GUID device interface notification for its volume by querying the mount manager with <strong><a href="ioctl_mountmgr_query_points" title="#define IOCTL_MOUNTMGR_QUERY_POINTS CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)">IOCTL_MOUNTMGR_QUERY_POINTS</a></strong>.</p>

<p>In this pseudocode sample, a mount manager client uses IOCTL_MOUNTMGR_CREATE_POINT to send the mount manager a device object name and its corresponding symbolic link:</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="w">    </span><span class="c1">// The persistent symbolic link is a drive letter in</span>
<span class="w">    </span><span class="c1">// this case:</span>
<span class="w">    </span><span class="n">wsprintf</span><span class="p">(</span><span class="n">dosBuffer</span><span class="p">,</span><span class="w"> </span><span class="sa">L</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">DosDevices</span><span class="se">\\</span><span class="s">%C:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">DriveLetter</span><span class="p">);</span>
<span class="w">    </span><span class="n"><a href="rtlinitunicodestring" title="FORCEINLINE&#10;VOID&#10;NTAPI_INLINE&#10;RtlInitUnicodeString(&#10;    _Out_ PUNICODE_STRING DestinationString,&#10;    _In_opt_z_ PCWSTR SourceString&#10;    )&#10;{&#10;    if (SourceString)&#10;        DestinationString-&gt;MaximumLength = (DestinationString-&gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);&#10;    else&#10;        DestinationString-&gt;MaximumLength = DestinationString-&gt;Length = 0;&#10;&#10;    DestinationString-&gt;Buffer = (PWCH)SourceString;&#10;}">RtlInitUnicodeString</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">dosName</span><span class="p">,</span><span class="w"> </span><span class="n">dosBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// The nonpersistent volume (device) object name is</span>
<span class="w">    </span><span class="c1">// formed using the volume number as a suffix</span>
<span class="w">    </span><span class="n">wsprintf</span><span class="p">(</span><span class="n">ntBuffer</span><span class="p">,</span><span class="w"> </span><span class="sa">L</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">Device</span><span class="se">\\</span><span class="s">HarddiskVolume%D&quot;</span><span class="p">,</span>
<span class="w">                       </span><span class="n">Extension</span><span class="o">-&gt;</span><span class="n">VolumeNumber</span><span class="p">);</span>
<span class="w">    </span><span class="n"><a href="rtlinitunicodestring" title="FORCEINLINE&#10;VOID&#10;NTAPI_INLINE&#10;RtlInitUnicodeString(&#10;    _Out_ PUNICODE_STRING DestinationString,&#10;    _In_opt_z_ PCWSTR SourceString&#10;    )&#10;{&#10;    if (SourceString)&#10;        DestinationString-&gt;MaximumLength = (DestinationString-&gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);&#10;    else&#10;        DestinationString-&gt;MaximumLength = DestinationString-&gt;Length = 0;&#10;&#10;    DestinationString-&gt;Buffer = (PWCH)SourceString;&#10;}">RtlInitUnicodeString</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">ntName</span><span class="p">,</span><span class="w"> </span><span class="n">ntBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">createPointSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n"><a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a></span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">                      </span><span class="n">dosName</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ntName</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Allocate a header with length and offset information</span>
<span class="w">    </span><span class="n">createPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">PMOUNTMGR_CREATE_POINT_INPUT</a></span><span class="p">)</span>
<span class="w">                  </span><span class="n"><a href="exallocatepool" title="PVOID ExAllocatePool(&#10;  _In_ POOL_TYPE a,&#10;  _In_ SIZE_T b&#10;);">ExAllocatePool</a></span><span class="p">(</span><span class="n">PagedPool</span><span class="p">,</span>
<span class="w">                  </span><span class="n">createPointSize</span><span class="p">);</span>
<span class="w">    </span><span class="n">createPoint</span><span class="o">-&gt;</span><span class="n">SymbolicLinkNameOffset</span><span class="w"> </span><span class="o">=</span>
<span class="w">                  </span><span class="k">sizeof</span><span class="p">(</span><span class="n"><a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a></span><span class="p">);</span>
<span class="w">    </span><span class="n">createPoint</span><span class="o">-&gt;</span><span class="n">SymbolicLinkNameLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dosName</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="w">    </span><span class="n">createPoint</span><span class="o">-&gt;</span><span class="n">DeviceNameOffset</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">createPoint</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">SymbolicLinkNameOffset</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">createPoint</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">SymbolicLinkNameLength</span><span class="p">;</span>
<span class="w">    </span><span class="n">createPoint</span><span class="o">-&gt;</span><span class="n">DeviceNameLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ntName</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="rtlcopymemory" title="void RtlCopyMemory(&#10;  Destination,&#10;  Source,&#10;  Length&#10;);">RtlCopyMemory</a></span><span class="p">((</span><span class="n">PCHAR</span><span class="p">)</span><span class="w"> </span><span class="n">createPoint</span><span class="w"> </span><span class="o">+</span>
<span class="w">                  </span><span class="n">createPoint</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">SymbolicLinkNameOffset</span><span class="p">,</span>
<span class="w">                  </span><span class="n">dosName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span><span class="w"> </span><span class="n">dosName</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
<span class="w">    </span><span class="n"><a href="rtlcopymemory" title="void RtlCopyMemory(&#10;  Destination,&#10;  Source,&#10;  Length&#10;);">RtlCopyMemory</a></span><span class="p">((</span><span class="n">PCHAR</span><span class="p">)</span><span class="w"> </span><span class="n">createPoint</span><span class="w"> </span><span class="o">+</span>
<span class="w">                  </span><span class="n">createPoint</span><span class="o">-&gt;</span><span class="n">DeviceNameOffset</span><span class="p">,</span>
<span class="w">                  </span><span class="n">ntName</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span><span class="w"> </span><span class="n">ntName</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Use the name of the mount manager device object</span>
<span class="w">    </span><span class="c1">// defined in mountmgr.h (<a href="mountmgr_device_name" title="#define MOUNTMGR_DEVICE_NAME L&quot;\\Device\\MountPointManager&quot;">MOUNTMGR_DEVICE_NAME</a>) to</span>
<span class="w">    </span><span class="c1">// obtain a pointer to the mount manager.</span>
<span class="w">    </span><span class="n"><a href="rtlinitunicodestring" title="FORCEINLINE&#10;VOID&#10;NTAPI_INLINE&#10;RtlInitUnicodeString(&#10;    _Out_ PUNICODE_STRING DestinationString,&#10;    _In_opt_z_ PCWSTR SourceString&#10;    )&#10;{&#10;    if (SourceString)&#10;        DestinationString-&gt;MaximumLength = (DestinationString-&gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);&#10;    else&#10;        DestinationString-&gt;MaximumLength = DestinationString-&gt;Length = 0;&#10;&#10;    DestinationString-&gt;Buffer = (PWCH)SourceString;&#10;}">RtlInitUnicodeString</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="mountmgr_device_name" title="#define MOUNTMGR_DEVICE_NAME L&quot;\\Device\\MountPointManager&quot;">MOUNTMGR_DEVICE_NAME</a></span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="iogetdeviceobjectpointer" title="NTSTATUS IoGetDeviceObjectPointer(&#10;  [in]  PUNICODE_STRING ObjectName,&#10;  [in]  ACCESS_MASK     DesiredAccess,&#10;  [out] PFILE_OBJECT    *FileObject,&#10;  [out] PDEVICE_OBJECT  *DeviceObject&#10;);">IoGetDeviceObjectPointer</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span>
<span class="w">                              </span><span class="n">FILE_READ_ATTRIBUTES</span><span class="p">,</span>
<span class="w">                              </span><span class="o">&amp;</span><span class="n">fileObject</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">deviceObject</span><span class="p">);</span>
<span class="w">    </span><span class="n"><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="n">NotificationEvent</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">);</span>
<span class="w">    </span><span class="n">irp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="iobuilddeviceiocontrolrequest" title="__drv_aliasesMem PIRP IoBuildDeviceIoControlRequest(&#10;  [in]            ULONG            IoControlCode,&#10;  [in]            PDEVICE_OBJECT   DeviceObject,&#10;  [in, optional]  PVOID            InputBuffer,&#10;  [in]            ULONG            InputBufferLength,&#10;  [out, optional] PVOID            OutputBuffer,&#10;  [in]            ULONG            OutputBufferLength,&#10;  [in]            BOOLEAN          InternalDeviceIoControl,&#10;  [in, optional]  PKEVENT          Event,&#10;  [out]           PIO_STATUS_BLOCK IoStatusBlock&#10;);">IoBuildDeviceIoControlRequest</a></span><span class="p">(</span>
<span class="w">            </span><span class="n">IOCTL_MOUNTMGR_CREATE_POINT</span><span class="p">,</span>
<span class="w">            </span><span class="n">deviceObject</span><span class="p">,</span><span class="w"> </span><span class="n">createPoint</span><span class="p">,</span><span class="w"> </span><span class="n">createPointSize</span><span class="p">,</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">event</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ioStatus</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Send the irp to the mount manager requesting</span>
<span class="w">    </span><span class="c1">// that a new mount point (persistent symbolic link)</span>
<span class="w">    </span><span class="c1">// be created for the indicated volume.</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a></span><span class="p">(</span><span class="n">deviceObject</span><span class="p">,</span><span class="w"> </span><span class="n">irp</span><span class="p">);</span>
</code></pre>
</div>

<p>For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/supporting-mount-manager-requests-in-a-storage-class-driver">Supporting Mount Manager Requests in a Storage Class Driver</a>.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="mountmgr_create_point_input" title="typedef struct _MOUNTMGR_CREATE_POINT_INPUT&#10;{&#10;    USHORT SymbolicLinkNameOffset;&#10;    USHORT SymbolicLinkNameLength;&#10;    USHORT DeviceNameOffset;&#10;    USHORT DeviceNameLength;&#10;} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;">MOUNTMGR_CREATE_POINT_INPUT</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mountmgr/ni-mountmgr-ioctl_mountmgr_create_point">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/mountmgr/ni-mountmgr-ioctl_mountmgr_create_point.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
