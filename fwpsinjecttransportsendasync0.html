<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FwpsInjectTransportSendAsync0 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FwpsInjectTransportSendAsync0 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FwpsInjectTransportSendAsync0 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fwpsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FwpsInjectTransportSendAsync0(
  [in]           HANDLE                      injectionHandle,
  [in, optional] HANDLE                      injectionContext,
  [in]           <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a>                      endpointHandle,
  [in]           <a href="uint32" title="typedef unsigned int UINT32;">UINT32</a>                      flags,
  [in, optional] <a href="fwps_transport_send_params0_" title="typedef struct FWPS_TRANSPORT_SEND_PARAMS0_ {&#10;  UCHAR      *remoteAddress;&#10;  SCOPE_ID   remoteScopeId;&#10;  WSACMSGHDR *controlData;&#10;  ULONG      controlDataLength;&#10;} FWPS_TRANSPORT_SEND_PARAMS0;">FWPS_TRANSPORT_SEND_PARAMS0</a> *sendArgs,
  [in]           <a href="address_family" title="typedef USHORT ADDRESS_FAMILY;">ADDRESS_FAMILY</a>              addressFamily,
  [in]           COMPARTMENT_ID              compartmentId,
  [in, out]      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a>             *netBufferList,
  [in]           <a href="fwps_inject_complete0" title="FWPS_INJECT_COMPLETE0 FwpsInjectComplete0;&#10;&#10;void FwpsInjectComplete0(&#10;  [in]      void *context,&#10;  [in, out] NET_BUFFER_LIST *netBufferList,&#10;  [in]      BOOLEAN dispatchLevel&#10;)&#10;{...}">FWPS_INJECT_COMPLETE0</a>       completionFn,
  [in, optional] HANDLE                      completionContext
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjecttransportsendasync0">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fwpsinjecttransportsendasync0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fwpsk-fwpsinjecttransportsendasync0)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FwpsInjectTransportSendAsync0 function</h1>
<h2>Description</h2>
<p>The
<strong>FwpsInjectTransportSendAsync0</strong> function injects packet data from the transport, datagram data, or ICMP
error layers into the send data path.</p>
<p><strong>Note</strong> <strong>FwpsInjectTransportSendAsync0</strong> is the specific version of <strong>FwpsInjectTransportSendAsync</strong> used in Windows Vista and later. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FWP/wfp-version-independent-names-and-targeting-specific-versions-of-windows">WFP Version-Independent Names and Targeting Specific Versions of Windows</a> for more information. For Windows 7, <a href="fwpsinjecttransportsendasync1" title="NTSTATUS FwpsInjectTransportSendAsync1(&#10;  [in]           HANDLE                      injectionHandle,&#10;  [in, optional] HANDLE                      injectionContext,&#10;  [in]           UINT64                      endpointHandle,&#10;  [in]           UINT32                      flags,&#10;  [in, optional] FWPS_TRANSPORT_SEND_PARAMS1 *sendArgs,&#10;  [in]           ADDRESS_FAMILY              addressFamily,&#10;  [in]           COMPARTMENT_ID              compartmentId,&#10;  [in, out]      NET_BUFFER_LIST             *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0       completionFn,&#10;  [in, optional] HANDLE                      completionContext&#10;);">FwpsInjectTransportSendAsync1</a> is available.</p>
<h2>Parameters</h2>
<h3><code>injectionHandle</code> [in]</h3>
<p>An injection handle that was previously created by a call to the
<a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a> function.</p>
<h3><code>injectionContext</code> [in, optional]</h3>
<p>An optional handle to the injection context. If specified, it can be obtained by calling the
<a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a> function when the packet injection state
<a href="fwps_packet_injection_state_" title="typedef enum FWPS_PACKET_INJECTION_STATE_ {&#10;  FWPS_PACKET_NOT_INJECTED,&#10;  FWPS_PACKET_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTED_BY_OTHER,&#10;  FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTION_STATE_MAX&#10;} FWPS_PACKET_INJECTION_STATE;">FWPS_PACKET_INJECTION_STATE</a> is
<strong>FWPS_PACKET_INJECTED_BY_SELF</strong> or <strong>FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF</strong>.</p>
<h3><code>endpointHandle</code> [in]</h3>
<p>A handle that indicates the stack transport endpoint in the send data path into which the packet
is to be injected. This endpoint handle is provided to a callout through the
<strong>transportEndpointHandle</strong> member of the
<a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function. Callout
drivers should use the provided handle to inject cloned packets back into the data path as soon as
possible, before the socket associated with the stack endpoint is closed and the handle becomes no
longer valid.</p>
<h3><code>flags</code> [in]</h3>
<p>Reserved. Callout drivers must set this parameter to zero.</p>
<h3><code>sendArgs</code> [in, optional]</h3>
<p>A pointer to a
<a href="fwps_transport_send_params0_" title="typedef struct FWPS_TRANSPORT_SEND_PARAMS0_ {&#10;  UCHAR      *remoteAddress;&#10;  SCOPE_ID   remoteScopeId;&#10;  WSACMSGHDR *controlData;&#10;  ULONG      controlDataLength;&#10;} FWPS_TRANSPORT_SEND_PARAMS0;">FWPS_TRANSPORT_SEND_PARAMS0</a> structure that specifies the properties of the current outbound
packet. Can be <strong>NULL</strong> only if the net buffer list to be injected contains an IP header (for example, if
the packet is sent via a raw socket).</p>
<h3><code>addressFamily</code> [in]</h3>
<p>One of the following address families:</p>
<h4>AF_INET</h4>
<p>The IPv4 address family.</p>
<h4>AF_INET6</h4>
<p>The IPv6 address family.</p>
<h3><code>compartmentId</code> [in]</h3>
<p>The identifier of the routing compartment into which the packet data is injected, specified as a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ne-winnt-compartment_id">COMPARTMENT_ID</a> type. This identifier is provided
to a callout through the
<strong>compartmentId</strong> member of the
<a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function. If the
<strong>compartmentId</strong> member is available to callouts, FWPS_METADATA_FIELD_COMPARTMENT_ID will be set in
the
<strong>currentMetadataValues</strong> member. Otherwise, set this parameter to UNSPECIFIED_COMPARTMENT_ID.</p>
<h3><code>netBufferList</code> [in, out]</h3>
<p>A pointer to a
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure that describes
the packet data that is being injected. A callout driver allocates a <strong><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></strong> structure to use to
inject packet data by calling either the
<a href="fwpsallocateclonenetbufferlist0" title="NTSTATUS FwpsAllocateCloneNetBufferList0(&#10;  [in, out]      NET_BUFFER_LIST *originalNetBufferList,&#10;  [in, optional] NDIS_HANDLE     netBufferListPoolHandle,&#10;  [in, optional] NDIS_HANDLE     netBufferPoolHandle,&#10;  [in]           ULONG           allocateCloneFlags,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateCloneNetBufferList0</a> function or the
<a href="fwpsallocatenetbufferandnetbufferlist0" title="NTSTATUS FwpsAllocateNetBufferAndNetBufferList0(&#10;  [in]           NDIS_HANDLE     poolHandle,&#10;  [in]           USHORT          contextSize,&#10;  [in]           USHORT          contextBackFill,&#10;  [in, optional] MDL             *mdlChain,&#10;  [in]           ULONG           dataOffset,&#10;  [in]           SIZE_T          dataLength,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateNetBufferAndNetBufferList0</a> function.</p>
<h3><code>completionFn</code> [in]</h3>
<p>A pointer to a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a> callout function provided by
the callout driver. The filter engine calls this function after the packet data, described by the
<em>netBufferList</em> parameter, has been injected into the network stack.</p>
<h3><code>completionContext</code> [in, optional]</h3>
<p>A pointer to a callout driver-provided context that is passed to the callout function pointed to
by the
<em>completionFn</em> parameter. This parameter is optional and can be <strong>NULL</strong>.</p>
<h2>Return value</h2>
<p>The
<a href="fwpsinjectnetworksendasync0" title="NTSTATUS FwpsInjectNetworkSendAsync0(&#10;  [in]           HANDLE                injectionHandle,&#10;  [in, optional] HANDLE                injectionContext,&#10;  [in]           UINT32                flags,&#10;  [in]           COMPARTMENT_ID        compartmentId,&#10;  [in, out]      NET_BUFFER_LIST       *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0 completionFn,&#10;  [in, optional] HANDLE                completionContext&#10;);">FwpsInjectNetworkSendAsync0</a> function returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes.</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
<td>The packet data injection was initiated successfully. The filter engine will call the completion function after the filter engine has completed injecting the packet data into the network stack, or when an error occurred subsequently. In case of an error, the <strong>Status</strong> member of the completed <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure will indicate the reason for failure.</td>
</tr>
<tr>
<td><strong>STATUS_FWP_TCPIP_NOT_READY</strong></td>
<td>The TCP/IP network stack is not ready to accept injection of packet data.</td>
</tr>
<tr>
<td><strong>STATUS_FWP_INJECT_HANDLE_CLOSING</strong></td>
<td>The injection handle is being closed.</td>
</tr>
<tr>
<td><strong>Other status codes</strong></td>
<td>An error occurred.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>A callout driver calls the
<a href="fwpsinjectnetworksendasync0" title="NTSTATUS FwpsInjectNetworkSendAsync0(&#10;  [in]           HANDLE                injectionHandle,&#10;  [in, optional] HANDLE                injectionContext,&#10;  [in]           UINT32                flags,&#10;  [in]           COMPARTMENT_ID        compartmentId,&#10;  [in, out]      NET_BUFFER_LIST       *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0 completionFn,&#10;  [in, optional] HANDLE                completionContext&#10;);">FwpsInjectNetworkSendAsync0</a> function to inject packet data from the transport, datagram data, or
ICMP error layers into the send data path. At these layers, the IP header might not yet be formed, and
when IPsec policy is active, the packet data is not encrypted or signed. Therefore, this function is
ideal to use for packet inspection in an IPsec-enabled environment.</p>
<p>This function can execute asynchronously.</p>
<p>If the return value is not <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>, the completion function will not be called. In this case,
the net buffer list pointed to by
<em>netBufferList</em> needs to be freed by a call to
<a href="fwpsfreenetbufferlist0" title="void FwpsFreeNetBufferList0(&#10;  [in, out] NET_BUFFER_LIST *netBufferList&#10;);">FwpsFreeNetBufferList0</a> or
<a href="fwpsfreeclonenetbufferlist0" title="void FwpsFreeCloneNetBufferList0(&#10;  [in, out] NET_BUFFER_LIST *netBufferList,&#10;  [in]      ULONG           freeCloneFlags&#10;);">FwpsFreeCloneNetBufferList0</a>.</p>
<p>Callout drivers normally inject data into the network stack when they modify packet data. For more
information about how a callout driver can modify packet data, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/callout-driver-operations">Callout Driver Operations</a>.</p>
<p>Due to the TCP protocol locking semantics, TCP can only be injected Out of Band at any transport layer or equivalent layer, so <a href="fwpsinjecttransportreceiveasync0" title="NTSTATUS FwpsInjectTransportReceiveAsync0(&#10;  [in]           HANDLE                injectionHandle,&#10;  [in, optional] HANDLE                injectionContext,&#10;                 PVOID                 reserved,&#10;  [in]           UINT32                flags,&#10;  [in]           ADDRESS_FAMILY        addressFamily,&#10;  [in]           COMPARTMENT_ID        compartmentId,&#10;  [in]           IF_INDEX              interfaceIndex,&#10;  [in]           IF_INDEX              subInterfaceIndex,&#10;  [in, out]      NET_BUFFER_LIST       *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0 completionFn,&#10;  [in, optional] HANDLE                completionContext&#10;);">FwpsInjectTransportReceiveAsync0</a> and FwpsInjectTransportSendAsync0 must be queued and run by a DPC.</p>
<p>The injected packet can be indicated to the callout driver again. To prevent infinite looping, the
driver should first call the
<a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a> function before calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function, and permit
packets that have the injection state
<a href="fwps_packet_injection_state_" title="typedef enum FWPS_PACKET_INJECTION_STATE_ {&#10;  FWPS_PACKET_NOT_INJECTED,&#10;  FWPS_PACKET_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTED_BY_OTHER,&#10;  FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTION_STATE_MAX&#10;} FWPS_PACKET_INJECTION_STATE;">FWPS_PACKET_INJECTION_STATE</a> set to
<strong>FWPS_PACKET_INJECTED_BY_SELF</strong> or <strong>FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF</strong>.</p>
<p>The
<em>endpointHandle</em> parameter, as well as members declared in the
<a href="fwps_transport_send_params0_" title="typedef struct FWPS_TRANSPORT_SEND_PARAMS0_ {&#10;  UCHAR      *remoteAddress;&#10;  SCOPE_ID   remoteScopeId;&#10;  WSACMSGHDR *controlData;&#10;  ULONG      controlDataLength;&#10;} FWPS_TRANSPORT_SEND_PARAMS0;">FWPS_TRANSPORT_SEND_PARAMS0</a> structure pointed to by the
<em>sendArgs</em> parameter, are provided to callouts from the following network layers:</p>
<p>FWPS_LAYER_OUTBOUND_TRANSPORT_V4</p>
<p>FWPS_LAYER_OUTBOUND_TRANSPORT_V6</p>
<p>FWPS_LAYER_DATAGRAM_DATA_V4 (when outbound direction is specified with FWP_DIRECTION_OUTBOUND)</p>
<p>FWPS_LAYER_DATAGRAM_DATA_V6 (when outbound direction is specified with FWP_DIRECTION_OUTBOUND)</p>
<p>FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4</p>
<p>FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6</p>
<p>The datagram belongs to a raw socket if both of the following are true:</p>
<ul>
<li>
The <strong>currentMetadataValues</strong> member of the <a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure has the <strong>FWPS_METADATA_FIELD_IP_HEADER_SIZE</strong> flag set.
</li>
<li>
The <strong>ipHeaderSize</strong> member of the <a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure is greater than zero.
</li>
</ul>
<p>At the following network layers, if the datagram belongs to a raw socket, the net buffer list pointed to by <em>netBufferList</em> must be adjusted to start at the IP header (which must be prepended to the net buffer list):</p>
<ul>
<li>
FWPS_LAYER_DATAGRAM_DATA_V4 (when outbound direction is specified with FWP_DIRECTION_OUTBOUND)
</li>
<li>
FWPS_LAYER_DATAGRAM_DATA_V6 (when outbound direction is specified with FWP_DIRECTION_OUTBOUND)
</li>
</ul>
<h2>See also</h2>
<p><a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a></p>
<p><a href="fwps_packet_injection_state_" title="typedef enum FWPS_PACKET_INJECTION_STATE_ {&#10;  FWPS_PACKET_NOT_INJECTED,&#10;  FWPS_PACKET_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTED_BY_OTHER,&#10;  FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTION_STATE_MAX&#10;} FWPS_PACKET_INJECTION_STATE;">FWPS_PACKET_INJECTION_STATE</a></p>
<p><a href="fwps_transport_send_params0_" title="typedef struct FWPS_TRANSPORT_SEND_PARAMS0_ {&#10;  UCHAR      *remoteAddress;&#10;  SCOPE_ID   remoteScopeId;&#10;  WSACMSGHDR *controlData;&#10;  ULONG      controlDataLength;&#10;} FWPS_TRANSPORT_SEND_PARAMS0;">FWPS_TRANSPORT_SEND_PARAMS0</a></p>
<p><a href="fwpsallocateclonenetbufferlist0" title="NTSTATUS FwpsAllocateCloneNetBufferList0(&#10;  [in, out]      NET_BUFFER_LIST *originalNetBufferList,&#10;  [in, optional] NDIS_HANDLE     netBufferListPoolHandle,&#10;  [in, optional] NDIS_HANDLE     netBufferPoolHandle,&#10;  [in]           ULONG           allocateCloneFlags,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateCloneNetBufferList0</a></p>
<p><a href="fwpsallocatenetbufferandnetbufferlist0" title="NTSTATUS FwpsAllocateNetBufferAndNetBufferList0(&#10;  [in]           NDIS_HANDLE     poolHandle,&#10;  [in]           USHORT          contextSize,&#10;  [in]           USHORT          contextBackFill,&#10;  [in, optional] MDL             *mdlChain,&#10;  [in]           ULONG           dataOffset,&#10;  [in]           SIZE_T          dataLength,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateNetBufferAndNetBufferList0</a></p>
<p><a href="fwpsfreeclonenetbufferlist0" title="void FwpsFreeCloneNetBufferList0(&#10;  [in, out] NET_BUFFER_LIST *netBufferList,&#10;  [in]      ULONG           freeCloneFlags&#10;);">FwpsFreeCloneNetBufferList0</a></p>
<p><a href="fwpsfreenetbufferlist0" title="void FwpsFreeNetBufferList0(&#10;  [in, out] NET_BUFFER_LIST *netBufferList&#10;);">FwpsFreeNetBufferList0</a></p>
<p><a href="fwpsinjecttransportsendasync1" title="NTSTATUS FwpsInjectTransportSendAsync1(&#10;  [in]           HANDLE                      injectionHandle,&#10;  [in, optional] HANDLE                      injectionContext,&#10;  [in]           UINT64                      endpointHandle,&#10;  [in]           UINT32                      flags,&#10;  [in, optional] FWPS_TRANSPORT_SEND_PARAMS1 *sendArgs,&#10;  [in]           ADDRESS_FAMILY              addressFamily,&#10;  [in]           COMPARTMENT_ID              compartmentId,&#10;  [in, out]      NET_BUFFER_LIST             *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0       completionFn,&#10;  [in, optional] HANDLE                      completionContext&#10;);">FwpsInjectTransportSendAsync1</a></p>
<p><a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a></p>
<p><a href="fwpsinjectionhandledestroy0" title="NTSTATUS FwpsInjectionHandleDestroy0(&#10;  [in] HANDLE injectionHandle&#10;);">FwpsInjectionHandleDestroy0</a></p>
<p><a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a></p>
<p><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjecttransportsendasync0">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fwpsk/nf-fwpsk-fwpsinjecttransportsendasync0.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
