<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltGetTunneledName - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltGetTunneledName - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltGetTunneledName - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltGetTunneledName(
  [in]  <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a>         CallbackData,
  [in]  <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">PFLT_FILE_NAME_INFORMATION</a> FileNameInformation,
  [out] <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">PFLT_FILE_NAME_INFORMATION</a> *RetTunneledFileNameInformation
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltgettunneledname">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltgettunneledname.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltgettunneledname)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fltgettunneledname-function">FltGetTunneledName function</h1>

<h2 id="description">Description</h2>

<p>The <strong>FltGetTunneledName</strong> routine retrieves the tunneled name for a file, given the normalized name returned for the file by a previous call to <strong><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></strong>, <strong><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></strong>, or <strong><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></strong>.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="callbackdata-in"><code>CallbackData</code> [in]</h3>

<p>Pointer to the callback data structure for the I/O operation (<a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a>). This parameter is required and cannot be <strong>NULL</strong>.</p>

<h3 id="filenameinformation-in"><code>FileNameInformation</code> [in]</h3>

<p>Pointer to an <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a> structure containing normalized name information returned by a previous call to <strong><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></strong>, <strong><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></strong>, or <strong><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></strong> for the file.</p>

<h3 id="rettunneledfilenameinformation-out"><code>RetTunneledFileNameInformation</code> [out]</h3>

<p>Pointer to a caller-allocated variable that receives the address of a newly allocated structure containing the tunneled file name. If no tunneled name is found, this variable receives <strong>NULL</strong>. This parameter is required and cannot be <strong>NULL</strong> on input.</p>

<h2 id="return-value">Return value</h2>

<p><strong>FltGetTunneledName</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the tunneled name is found or if there is no tunneled name for the file. Otherwise, it returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value, such as the following:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>STATUS_INSUFFICIENT_RESOURCES</strong></td>
  <td><strong>FltGetTunneledName</strong> encountered a pool allocation failure. This is an error code.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>File systems, such as NTFS and FAT, use a per-volume tunnel cache to briefly preserve file names and other metadata for files that are being renamed, linked to, or deleted. File name tunneling can cause the final component in normalized file name information returned by a preoperation call to <strong><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></strong>, <strong><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></strong>, or <strong><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></strong> to be invalidated.</p>

<p>If a minifilter driver retrieves normalized file name information in the preoperation callback routine (<a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a>) for a create (<a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a>), hard-link (<a href="irp_mj_set_information" title="#define IRP_MJ_SET_INFORMATION 0x06">IRP_MJ_SET_INFORMATION</a> with <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> set to <em>FileLinkInformation</em>), or rename operation (<a href="irp_mj_set_information" title="#define IRP_MJ_SET_INFORMATION 0x06">IRP_MJ_SET_INFORMATION</a> with <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> set to <em>FileRenameInformation</em>), it must call <strong>FltGetTunneledName</strong> from its postoperation callback routine (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>) to retrieve the correct file name information for the file.</p>

<p>Only normalized file name information is affected by tunneling. The Filter Manager cannot ensure that the final component is normalized until after the create, hard-link, or rename operation has actually occurred, because tunneling can cause a short name to be changed to a long name. Thus a minifilter driver must call <strong>FltGetTunneledName</strong> from its postoperation callback routine to determine whether the normalized file name information retrieved in the preoperation callback routine is valid.</p>

<p>For more information about normalized file name information, see <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a>.</p>

<p>Minifilter drivers that only retrieve short or opened file name information should not call <strong>FltGetTunneledName</strong>.</p>

<p>After calling <strong><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></strong>, <strong><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></strong>, or <strong><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></strong> in the preoperation callback routine, the minifilter driver must store the returned <em>FileNameInformation</em> pointer in the preoperation callback routine's <em>CompletionContext</em> structure so that the postoperation callback can pass this pointer in the <em>FileNameInformation</em> parameter to <strong>FltGetTunneledName</strong>.</p>

<blockquote>
  <p>[!NOTE]
  File name tunneling affects only create, hard-link, and rename operations in this way. It does not affect other I/O operations, such as read and write.</p>
</blockquote>

<p>The following paired operations can cause the file name <em>name</em> to be tunneled:</p>

<ul>
<li>delete(<em>name</em>)/create(<em>name</em>)</li>
<li>delete(<em>name</em>)/rename(<em>source</em>, <em>name</em>)</li>
<li>rename(<em>name</em>, <em>newname</em>)/create(<em>name</em>)</li>
<li>rename(<em>name</em>, <em>newname</em>)/rename(<em>source</em>, <em>name</em>)</li>
</ul>

<p>If no tunneled name is found for the file, the <em>RetTunneledFileNameInformation</em> parameter receives <strong>NULL</strong>.</p>

<p>After a successful call to <strong>FltGetTunneledName</strong>, the caller is responsible for releasing the <em>RetTunneledFileNameInformation</em> and <em>FileNameInformation</em> pointers when they are no longer needed by calling <strong><a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a></strong>.</p>

<p><strong>FltGetTunneledName</strong> should only be called from a minifilter driver's postoperation callback routine for <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> or <a href="irp_mj_set_information" title="#define IRP_MJ_SET_INFORMATION 0x06">IRP_MJ_SET_INFORMATION</a>. Calling <strong>FltGetTunneledName</strong> from a postoperation callback routine for any other type of I/O operation, or calling it from a preoperation callback routine, is a programming error.</p>

<p>The caller must not modify the contents of the structure returned in the <em>RetTunneledFileNameInformation</em> parameter, because this structure is cached by the Filter Manager so that all minifilter drivers can use it.</p>

<p>File tunneling enables compatibility with programs that rely on file systems to preserve file meta-information for a short period of time; for example, for the safe save process. Tunneling preserves the association between a file's long and short (8.3) name. When a file name is removed from a directory (rename or delete), its short and long name pair and creation time are saved in a tunnel cache, keyed by the name that was removed. When a name is added to a directory (rename or create), the cache is searched to determine if there is information to restore. The cache is effective per instance of a directory. If a directory is deleted, its cache is removed.</p>

<h2 id="see-also">See also</h2>

<p><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></p>

<p><a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a></p>

<p><strong><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></strong></p>

<p><strong><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></strong></p>

<p><strong><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></strong></p>

<p><strong><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></strong></p>

<p><strong><a href="fltreferencefilenameinformation" title="VOID FLTAPI FltReferenceFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReferenceFileNameInformation</a></strong></p>

<p><strong><a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a></strong></p>

<p><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></p>

<p><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltgettunneledname">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltgettunneledname.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
