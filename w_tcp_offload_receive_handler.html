<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="W_TCP_OFFLOAD_RECEIVE_HANDLER - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>W_TCP_OFFLOAD_RECEIVE_HANDLER - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            W_TCP_OFFLOAD_RECEIVE_HANDLER - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ndischimney.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">W_TCP_OFFLOAD_RECEIVE_HANDLER WTcpOffloadReceiveHandler;

NDIS_STATUS WTcpOffloadReceiveHandler(
  [in] IN NDIS_HANDLE MiniportAdapterContext,
  [in] IN PVOID MiniportOffloadContext,
  [in] IN <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">PNET_BUFFER_LIST</a> NetBufferList
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_tcp_offload_receive_handler">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/w_tcp_offload_receive_handler.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-ndischimney-w_tcp_offload_receive_handler)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>W_TCP_OFFLOAD_RECEIVE_HANDLER callback function</h1>
<h2>Description</h2>
<p>[The TCP chimney offload feature is deprecated and should not be used.]</p>
<p>NDIS calls the
<em>MiniportTcpOffloadReceive</em> function to post receive requests (receive buffers) on an offloaded TCP
connection.</p>
<h2>Parameters</h2>
<h3><code>MiniportAdapterContext</code> [in]</h3>
<p>The handle to an offload-target allocated context area in which the offload target maintains state
information about this instance of the adapter. The miniport driver provided this handle to NDIS when it
called
<a href="ndismsetminiportattributes" title="NDIS_STATUS NdisMSetMiniportAttributes(&#10;       NDIS_HANDLE                       NdisMiniportHandle,&#10;  [in] PNDIS_MINIPORT_ADAPTER_ATTRIBUTES MiniportAttributes&#10;);">NdisMSetMiniportAttributes</a> from its
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndis/nc-ndis-miniport_initialize">MiniportInitializeEx</a> function.</p>
<h3><code>MiniportOffloadContext</code> [in]</h3>
<p>A pointer to a memory location that contains a PVOID value. This PVOID value references the
miniport offload context that contains the state object for the TCP connection on which the receive
requests are being posted. The offload target supplied this PVOID value when it offloaded the TCP
connection state object.</p>
<h3><code>NetBufferList</code> [in]</h3>
<p>A pointer to a
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure. This structure
can be a stand-alone structure or the first structure in a linked list of <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structures.
Each <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure in the list describes one
<a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a> structure. The <a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a> structure
maps to a chain of memory descriptor lists (MDLs). The <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> and associated structures are
locked so that they remain resident in physical memory. However, they are not mapped into system
memory.</p>
<h2>Return value</h2>
<p>NDIS_STATUS_PENDING is the only return value that is allowed. An offload target always completes
(returns) posted receive requests asynchronously by calling
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-ndis_tcp_offload_receive_complete">NdisTcpOffloadReceiveComplete</a>.</p>
<h2>Remarks</h2>
<p>A client application can post receive requests on an offloaded TCP connection. The offload target uses
these requests to transfer data received on the connection to the client application. If receive requests
are posted on a connection, the offload target should always use them to transfer data that is received
on the connection. For more information, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/delivery-algorithm">Delivery Algorithm</a>.</p>
<p>The offload target queues the posted <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structures in first in, first out (FIFO) order.
The offload target uses the
<strong>MiniportReserved</strong> member of each <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure to queue the structure.</p>
<p>Each <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure passed to the
<em>MiniportTcpOffloadReceive</em> function has only one <a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a> structure associated with it.</p>
<p>The offload target should place receive data into the posted receive requests in FIFO order. That is,
data that was received first should be placed into the first posted receive request, and so on.</p>
<p>The host stack serializes calls to the
<em>MiniportTcpOffloadReceive</em> function on a per-connection basis. The host stack will not call the
<em>MiniportTcpOffloadReceive</em> function on a connection while a call to the
<em>MiniportTcpOffloadReceive</em> function on that connection is in progress. This ensures that receive
requests are always posted in the correct order to an offload target's
<em>MiniportTcpOffloadReceive</em> function.</p>
<p>Note, however, that the host stack can call the
<em>MiniportTcpOffloadReceive</em> function on a connection before the offload target has completed one or
more previous calls to the
<em>MiniportTcpOffloadReceive</em> function on that same connection. Note also that the host stack can call
an offload target's
<em>MiniportTcpOffloadReceive</em> function on one connection while one or more calls to the
<em>MiniportTcpOffloadReceive</em> function are in progress on another connection.</p>
<p>A posted receive request can optionally be in either of two modes:</p>
<ul>
<li>Push mode</li>
<li>Nonpush mode</li>
</ul>
<p>Note that an offload target must support both push mode and nonpush mode. .</p>
<p>To determine which mode a buffer is in, an offload target calls the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/net-buffer-list-info">NET_BUFFER_LIST_INFO</a> macro to get the
value of
<strong>TcpReceiveNoPush</strong>. If the value is <strong>TRUE</strong>, the receive request is in nonpush mode.</p>
<p>If the receive request is in push mode, the offload target retrieves the value of
<strong>TcpReceiveBytesTransferred</strong> by calling the <a href="net_buffer_list_info" title="void NET_BUFFER_LIST_INFO(&#10;  _NBL,&#10;  _Id&#10;);">NET_BUFFER_LIST_INFO</a> macro. If this value is non-zero,
the offload target immediately starts the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/push-timer">push timer</a> for the connection. If this value is
zero, the offload target starts the push timer for the connection as soon as the offload target places
the first byte of receive data into the receive request. The offload target always completes filled
receive requests immediately. The offload target completes a partially filled receive request that is in
push mode if either of the following occurs:</p>
<ul>
<li>The push timer expires.</li>
<li>The offload target receives a TCP segment on the connection that has the PSH bit set.</li>
</ul>
<p>If the receive request is in nonpush mode, the offload target does not start a push timer. The offload
target completes the receive request only when the receive request is filled. The offload target ignores
the PSH bit in TCP segments that it receives on the connection.</p>
<p>If data is received on an offloaded connection while the push timer is running, the offload target
must restart the push timer for that connection.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndis/nc-ndis-miniport_initialize">MiniportInitializeEx</a></p>
<p><a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a></p>
<p><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></p>
<p><a href="ndismsetminiportattributes" title="NDIS_STATUS NdisMSetMiniportAttributes(&#10;       NDIS_HANDLE                       NdisMiniportHandle,&#10;  [in] PNDIS_MINIPORT_ADAPTER_ATTRIBUTES MiniportAttributes&#10;);">NdisMSetMiniportAttributes</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-ndis_tcp_offload_receive_complete">NdisTcpOffloadReceiveComplete</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_tcp_offload_receive_handler">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ndischimney/nc-ndischimney-w_tcp_offload_receive_handler.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
