<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtCopyFileChunk - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtCopyFileChunk - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtCopyFileChunk - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTIOAPI_H
#if (PHNT_VERSION &gt;= PHNT_WINDOWS_11)

</span><span class="ntdoc-code-intro language-cpp">/**
 * The NtCopyFileChunk routine copies a contiguous range of bytes (a chunk)
 * from a source file to a destination file. The operation may be performed
 * synchronously or asynchronously depending on the file handles and flags.
 *
 * \param[in] SourceHandle Handle to the source file. The handle must be opened
 *            with access that allows reading the specified range.
 * \param[in] DestinationHandle Handle to the destination file. The handle must
 *            be opened with access that allows writing to the specified range.
 * \param[in] EventHandle Optional handle to an event object. If provided,
 *            the event is set when the operation completes. May be NULL.
 * \param[out] IoStatusBlock Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that
 *            receives the final completion status and information about the operation.
 * \param[in] Length The number of bytes to copy.
 * \param[in] SourceOffset Pointer to a LARGE_INTEGER specifying the byte
 *            offset in the source file at which copying begins.
 * \param[in] DestOffset Pointer to a LARGE_INTEGER specifying the byte
 *            offset in the destination file at which copying begins.
 * \param[in] SourceKey Optional pointer to a source file key. May be NULL.
 * \param[in] DestKey Optional pointer to a destination file key. May be NULL.
 * \param[in] Flags Additional flags controlling copy semantics.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \remarks The exact meaning and required privileges for `Flags` and keys may
 *          depend on the Windows version and file system. Consumers should
 *          verify handle access rights and the platform&#x27;s support for this call.
 */
</span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtCopyFileChunk(
    _In_ HANDLE SourceHandle,
    _In_ HANDLE DestinationHandle,
    _In_opt_ HANDLE EventHandle,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_ PLARGE_INTEGER SourceOffset,
    _In_ PLARGE_INTEGER DestOffset,
    _In_opt_ PULONG SourceKey,
    _In_opt_ PULONG DestKey,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/cc4793e6bec630c14918c05cea0cf33d71b274e3/phnt/include/ntioapi.h#L2926">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwCopyFileChunk(
    _In_ HANDLE SourceHandle,
    _In_ HANDLE DestinationHandle,
    _In_opt_ HANDLE EventHandle,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_ PLARGE_INTEGER SourceOffset,
    _In_ PLARGE_INTEGER DestOffset,
    _In_opt_ PULONG SourceKey,
    _In_opt_ PULONG DestKey,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/cc4793e6bec630c14918c05cea0cf33d71b274e3/phnt/include/ntzwapi.h#L890">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntifs.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtCopyFileChunk(
  [in]           HANDLE           SourceHandle,
  [in]           HANDLE           DestHandle,
  [in, optional] HANDLE           Event,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in]           PLARGE_INTEGER   SourceOffset,
  [in]           PLARGE_INTEGER   DestOffset,
  [in, optional] PULONG           SourceKey,
  [in, optional] PULONG           DestKey,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Flags
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcopyfilechunk">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<p>This function is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ifs/nf-ntifs-ntcopyfilechunk">documented in Windows Driver Kit</a>.</p>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntcopyfilechunk.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntcopyfilechunk)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p>The <strong>NtCopyFileChunk</strong> routine copies data from the source file into the destination file.</p>
<h2>Parameters</h2>
<h3><code>SourceHandle</code> [in]</h3>
<p>The HANDLE of the source file to be read.</p>
<h3><code>DestHandle</code> [in]</h3>
<p>The HANDLE of the destination file. The data from <strong>SourceHandle</strong>'s file is copied into <strong>DestHandle</strong>'s file. Completion ports can be used on this handle.</p>
<h3><code>Event</code> [in, optional]</h3>
<p>An optional event to be signaled when the copy operation is complete.</p>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>A pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that receives the final completion status and other information about the copy operation.</p>
<h3><code>Length</code> [in]</h3>
<p>The length of the data to copy, in bytes.</p>
<h3><code>SourceOffset</code> [in]</h3>
<p>The starting byte offset within the source file to begin the read operation.</p>
<h3><code>DestOffset</code> [in]</h3>
<p>The starting byte offset within the destination file to begin the write operation.</p>
<h3><code>SourceKey</code> [in, optional]</h3>
<p>An optional key to be used if there are oplocks associated with the source file.</p>
<h3><code>DestKey</code> [in, optional]</h3>
<p>An optional key to be used if there are oplocks associated with the destination file.</p>
<h3><code>Flags</code> [in]</h3>
<p>Optional flags. Currently there are no valid flag values.</p>
<h2>Return value</h2>
<p><strong>NtCopyFileChunk</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the copy is successfully completed, or an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code such as one of the following:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_PENDING</td>
<td>The copy is in progress. Callers must wait on the event or file object to get the final status.</td>
</tr>
<tr>
<td>STATUS_[<em>ERROR</em>]</td>
<td>Various errors can occur similar to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> and <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong>.</td>
</tr>
</tbody>
</table>
<p>Once the write completes the status of the operation can be determined by examining the <strong>Status</strong> field of <strong>IoStatusBlock</strong>.</p>
<p>See <strong>Remarks</strong> for details regarding the handling of synchronous/asynchronous I/O.</p>
<h2>Remarks</h2>
<p><strong>NtCopyFileChunk</strong> copies data from a source file into a destination file using the provided file offsets for the requested length. If the length surpasses the end of file (EOF) on the source file, then <strong>NtCopyFileChunk</strong> will only read and copy the data to the destination up to the source’s EOF. Callers can get the actual number of bytes written from the <strong>IoStatusBlock</strong>.</p>
<p><strong>NtCopyFileChunk</strong> includes two I/O operations: a read of the source file and a write to the destination file. While each I/O internally has its own completion, the caller’s event (or destination file handle if no event is provided) will be signaled when the copy operation is complete.</p>
<p>The source and destination files can be opened asynchronously or synchronously. While it is recommended that callers are consistent between the two handles, it is not required. Depending on the handles provided, <strong>NtCopyFileChunk</strong> will return at different points in the copy operation as specified in the following table.</p>
<table>
<thead>
<tr>
<th>Source Handle</th>
<th>Destination Handle</th>
<th>Return Conditions</th>
</tr>
</thead>
<tbody>
<tr>
<td>Asynchronous</td>
<td>Asynchronous</td>
<td>Once the read has been successfully queued OR if there are errors prior to queuing the read.</td>
</tr>
<tr>
<td>Asynchronous</td>
<td>Synchronous</td>
<td>Once the write has finished OR if there are errors prior to write completion.</td>
</tr>
<tr>
<td>Synchronous</td>
<td>Synchronous</td>
<td>Once the write has finished OR if there are errors prior to write completion.</td>
</tr>
<tr>
<td>Synchronous</td>
<td>Asynchronous</td>
<td>Once the write has been successfully queued OR if there are errors prior to queueing the write.</td>
</tr>
</tbody>
</table>
<p>If STATUS_PENDING is returned, the called must wait for the operation to complete before looking at the I/O status block for the final status. If <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> is returned or the I/O status block indicates success, the caller should look at the <strong>IoStatusBlock</strong> to determine how many bytes were copied.</p>
<p>If either file is opened for non-cached I/O, the caller must ensure that the requested length is sector-aligned with whichever file is opened as non-cached. If both, the length should be aligned with the larger sector size of the two.</p>
<p>All read and write operations from <strong>NtCopyFileChunk</strong> will have:</p>
<ul>
<li>The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>'s requestor mode set to <strong>KernelMode</strong></li>
<li>An <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> extension of type <strong>IopCopyInformationType</strong>.</li>
</ul>
<p>Filters do not have access to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> extensions directly but can check the presence of this extension and get copy information from the callback data by calling <strong><a href="fltgetcopyinformationfromcallbackdata" title="NTSTATUS FLTAPI FltGetCopyInformationFromCallbackData(&#10;  [in]  PFLT_CALLBACK_DATA Data,&#10;  [out] PCOPY_INFORMATION  CopyInformation&#10;);">FltGetCopyInformationFromCallbackData</a></strong>.</p>
<p>Fast IO is not available in this copy because the copy information is present in the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> extension (and Fast IO doesn't create IRPs).</p>
<p><strong>NtCopyFileChunk</strong> is used internally by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfile"><strong>CopyFile</strong></a> for most forms of copy. Current exceptions include cloud copies, SMB offload and ODX.</p>
<p>The following example shows how to use <strong>NtCopyFileChunk</strong>.</p>
<pre><code class="language-C">
// Input parameters to NtCopyFileChunk. Opening
// the file handles is done using <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a>
// and creating the event is done with CreateEvent.
// This is not shown in this code sample.

HANDLE sourceHandle;
HANDLE destHandle;
HANDLE event;
<a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> ioStatusBlock;
<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> length;
LARGE_INTEGER sourceOffset;
LARGE_INTEGER destOffset;

// Copy the data

status = NtCopyFileChunk( sourceHandle,
                          destHandle,
                          event,
                          &amp;ioStatusBlock,
                          length,
                          &amp;sourceOffset,
                          &amp;destOffset,
                          NULL,
                          NULL,
                          0 );

// Wait for the copy to complete

if (status == STATUS_PENDING) {
    status = <a href="ntwaitforsingleobject" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWaitForSingleObject(&#10;    _In_ HANDLE Handle,&#10;    _In_ BOOLEAN Alertable,&#10;    _In_opt_ PLARGE_INTEGER Timeout&#10;    );">NtWaitForSingleObject</a>( event, FALSE, NULL );

    if (<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
        status = ioStatusBlock.Status;
    }
}

</code></pre>
<p>See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/km-file-copy">Kernel-mode file copy and detecting copy file scenarios</a> for more information.</p>
<h2>See also</h2>
<p><strong><a href="fltgetcopyinformationfromcallbackdata" title="NTSTATUS FLTAPI FltGetCopyInformationFromCallbackData(&#10;  [in]  PFLT_CALLBACK_DATA Data,&#10;  [out] PCOPY_INFORMATION  CopyInformation&#10;);">FltGetCopyInformationFromCallbackData</a></strong></p>
<p><strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong></p>
<p><strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcopyfilechunk">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntcopyfilechunk.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
