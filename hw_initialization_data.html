<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="HW_INITIALIZATION_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>HW_INITIALIZATION_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            HW_INITIALIZATION_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _HW_INITIALIZATION_DATA {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               HwInitializationDataSize;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>      AdapterInterfaceType;
  <a href="phw_initialize" title="PHW_INITIALIZE PhwInitialize;&#10;&#10;BOOLEAN PhwInitialize(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INITIALIZE</a>      HwInitialize;
  <a href="phw_startio" title="PHW_STARTIO PhwStartio;&#10;&#10;BOOLEAN PhwStartio(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PSCSI_REQUEST_BLOCK Srb&#10;)&#10;{...}">PHW_STARTIO</a>         HwStartIo;
  <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>       HwInterrupt;
  <a href="phw_find_adapter" title="PHW_FIND_ADAPTER PhwFindAdapter;&#10;&#10;ULONG PhwFindAdapter(&#10;  [in]      PVOID DeviceExtension,&#10;  [in]      PVOID HwContext,&#10;  [in]      PVOID BusInformation,&#10;  [in]      PCHAR ArgumentString,&#10;  [in, out] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [out]     PBOOLEAN Again&#10;)&#10;{...}">PHW_FIND_ADAPTER</a>    HwFindAdapter;
  <a href="phw_reset_bus" title="PHW_RESET_BUS PhwResetBus;&#10;&#10;BOOLEAN PhwResetBus(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG PathId&#10;)&#10;{...}">PHW_RESET_BUS</a>       HwResetBus;
  <a href="phw_dma_started" title="PHW_DMA_STARTED PhwDmaStarted;&#10;&#10;VOID PhwDmaStarted(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_DMA_STARTED</a>     HwDmaStarted;
  <a href="phw_adapter_state" title="PHW_ADAPTER_STATE PhwAdapterState;&#10;&#10;BOOLEAN PhwAdapterState(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PVOID Context,&#10;  [in] BOOLEAN SaveState&#10;)&#10;{...}">PHW_ADAPTER_STATE</a>   HwAdapterState;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               DeviceExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               SpecificLuExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               SrbExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               NumberOfAccessRanges;
  PVOID               Reserved;
  BOOLEAN             MapBuffers;
  BOOLEAN             NeedPhysicalAddresses;
  BOOLEAN             TaggedQueuing;
  BOOLEAN             AutoRequestSense;
  BOOLEAN             MultipleRequestPerLu;
  BOOLEAN             ReceiveEvent;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>              VendorIdLength;
  PVOID               VendorId;
  union {
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ReservedUshort;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> PortVersionFlags;
  };
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>              DeviceIdLength;
  PVOID               DeviceId;
  <a href="phw_adapter_control" title="PHW_ADAPTER_CONTROL PhwAdapterControl;&#10;&#10;SCSI_ADAPTER_CONTROL_STATUS PhwAdapterControl(&#10;  [in] PVOID DeviceExtension,&#10;  [in] SCSI_ADAPTER_CONTROL_TYPE ControlType,&#10;  [in] PVOID Parameters&#10;)&#10;{...}">PHW_ADAPTER_CONTROL</a> HwAdapterControl;
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _HW_INITIALIZATION_DATA {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       HwInitializationDataSize;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>              AdapterInterfaceType;
  <a href="phw_initialize" title="PHW_INITIALIZE PhwInitialize;&#10;&#10;BOOLEAN PhwInitialize(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INITIALIZE</a>              HwInitialize;
  <a href="phw_startio" title="PHW_STARTIO PhwStartio;&#10;&#10;BOOLEAN PhwStartio(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PSCSI_REQUEST_BLOCK Srb&#10;)&#10;{...}">PHW_STARTIO</a>                 HwStartIo;
  <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>               HwInterrupt;
  PVOID                       HwFindAdapter;
  <a href="phw_reset_bus" title="PHW_RESET_BUS PhwResetBus;&#10;&#10;BOOLEAN PhwResetBus(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG PathId&#10;)&#10;{...}">PHW_RESET_BUS</a>               HwResetBus;
  <a href="phw_dma_started" title="PHW_DMA_STARTED PhwDmaStarted;&#10;&#10;VOID PhwDmaStarted(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_DMA_STARTED</a>             HwDmaStarted;
  <a href="phw_adapter_state" title="PHW_ADAPTER_STATE PhwAdapterState;&#10;&#10;BOOLEAN PhwAdapterState(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PVOID Context,&#10;  [in] BOOLEAN SaveState&#10;)&#10;{...}">PHW_ADAPTER_STATE</a>           HwAdapterState;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       DeviceExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       SpecificLuExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       SrbExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       NumberOfAccessRanges;
  PVOID                       Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                       MapBuffers;
  BOOLEAN                     NeedPhysicalAddresses;
  BOOLEAN                     TaggedQueuing;
  BOOLEAN                     AutoRequestSense;
  BOOLEAN                     MultipleRequestPerLu;
  BOOLEAN                     ReceiveEvent;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                      VendorIdLength;
  PVOID                       VendorId;
  union {
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> ReservedUshort;
    <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> PortVersionFlags;
  };
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                      DeviceIdLength;
  PVOID                       DeviceId;
  <a href="phw_adapter_control" title="PHW_ADAPTER_CONTROL PhwAdapterControl;&#10;&#10;SCSI_ADAPTER_CONTROL_STATUS PhwAdapterControl(&#10;  [in] PVOID DeviceExtension,&#10;  [in] SCSI_ADAPTER_CONTROL_TYPE ControlType,&#10;  [in] PVOID Parameters&#10;)&#10;{...}">PHW_ADAPTER_CONTROL</a>         HwAdapterControl;
  PHW_BUILDIO                 HwBuildIo;
  PHW_FREE_ADAPTER_RESOURCES  HwFreeAdapterResources;
  PHW_PROCESS_SERVICE_REQUEST HwProcessServiceRequest;
  PHW_COMPLETE_SERVICE_IRP    HwCompleteServiceIrp;
  PHW_INITIALIZE_TRACING      HwInitializeTracing;
  PHW_CLEANUP_TRACING         HwCleanupTracing;
  PHW_TRACING_ENABLED         HwTracingEnabled;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       FeatureSupport;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       SrbTypeFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       AddressTypeFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       Reserved1;
  union {
    PHW_UNIT_CONTROL      HwUnitControl;
    PHW_NAMESPACE_CONTROL HwNamespaceControl;
  };
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_hw_initialization_data-r1">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// strmini.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _HW_INITIALIZATION_DATA {
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> HwInitializationDataSize;
    struct {
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> SizeOfThisPacket;
      <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> StreamClassVersion;
    };
  };
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       HwInitializationDataSize;
  <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>               HwInterrupt;
  <a href="phw_receive_device_srb" title="PHW_RECEIVE_DEVICE_SRB PhwReceiveDeviceSrb;&#10;&#10;VOID PhwReceiveDeviceSrb(&#10;  [in] IN PHW_STREAM_REQUEST_BLOCK SRB&#10;)&#10;{...}">PHW_RECEIVE_DEVICE_SRB</a>      HwReceivePacket;
  <a href="phw_cancel_srb" title="PHW_CANCEL_SRB PhwCancelSrb;&#10;&#10;VOID PhwCancelSrb(&#10;  [in] IN PHW_STREAM_REQUEST_BLOCK SRB&#10;)&#10;{...}">PHW_CANCEL_SRB</a>              HwCancelPacket;
  <a href="phw_request_timeout_handler" title="PHW_REQUEST_TIMEOUT_HANDLER PhwRequestTimeoutHandler;&#10;&#10;VOID PhwRequestTimeoutHandler(&#10;  [in] IN PHW_STREAM_REQUEST_BLOCK SRB&#10;)&#10;{...}">PHW_REQUEST_TIMEOUT_HANDLER</a> HwRequestTimeoutHandler;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       DeviceExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       PerRequestExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       PerStreamExtensionSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       FilterInstanceExtensionSize;
  BOOLEAN                     BusMasterDMA;
  BOOLEAN                     Dma24BitAddresses;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       BufferAlignment;
  BOOLEAN                     TurnOffSynchronization;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       DmaBufferSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       NumNameExtensions;
  PWCHAR                      *NameExtensionArray;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                       Reserved[2];
} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_hw_initialization_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/hw_initialization_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_hw_initialization_data)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_hw_initialization_data-structure-srbh">_HW_INITIALIZATION_DATA structure (srb.h)</h1>

<h2 id="description">Description</h2>

<p>Each SCSI miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/driverentry-of-ide-controller-minidriver">DriverEntry</a> routine must initialize with zeros and, then, fill in the relevant HW_INITIALIZATION_DATA (SCSI) information for the OS-specific port driver.</p>

<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>

<h2 id="members">Members</h2>

<h3 id="hwinitializationdatasize"><code>HwInitializationDataSize</code></h3>

<p>Specifies the size of this structure in bytes, as returned by <strong>sizeof</strong>(). In effect, this member indicates the version of this structure being used by the miniport driver. A miniport driver's <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine should set this member's value for the port driver.</p>

<h3 id="adapterinterfacetype"><code>AdapterInterfaceType</code></h3>

<p>Specifies the type of I/O bus to which the HBA is connected, which can be one of the following: <strong>Internal</strong>, <strong>Isa</strong>, <strong>Eisa</strong>, <strong>MicroChannel</strong>, <strong>TurboChannel</strong>, or <strong>PCIBus</strong>. However, additional types of buses will be supported in future. The upper bound on the types of buses supported is always <strong>MaximumInterfaceType</strong>.</p>

<p>If this is set to <strong>PCIBus</strong>, the miniport driver must supply values for the <strong>VendorIdLength</strong>, <strong>VendorId</strong>, <strong>DeviceIdLength</strong>, and <strong>DeviceId</strong> members, described later.</p>

<h3 id="hwinitialize"><code>HwInitialize</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557302(v=vs.85)">HwScsiInitialize</a> routine, which is a required entry point for all miniport drivers. The prototype for this routine is <a href="phw_initialize" title="PHW_INITIALIZE PhwInitialize;&#10;&#10;BOOLEAN PhwInitialize(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INITIALIZE</a>.</p>

<h3 id="hwstartio"><code>HwStartIo</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557323(v=vs.85)">HwScsiStartIo</a> routine, which is a required entry point for all miniport drivers. The prototype for this routine is <a href="phw_startio" title="PHW_STARTIO PhwStartio;&#10;&#10;BOOLEAN PhwStartio(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PSCSI_REQUEST_BLOCK Srb&#10;)&#10;{...}">PHW_STARTIO</a>.</p>

<h3 id="hwinterrupt"><code>HwInterrupt</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557312(v=vs.85)">HwScsiInterrupt</a> routine, which is a required entry point for any miniport driver of an HBA that generates interrupts. Set this to <strong>NULL</strong> if the miniport driver needs no ISR. The prototype for this routine is <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>.</p>

<h3 id="hwfindadapter"><code>HwFindAdapter</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)">HwScsiFindAdapter</a> routine, which is a required entry point for all miniport drivers. The prototype for this routine is <a href="phw_find_adapter" title="PHW_FIND_ADAPTER PhwFindAdapter;&#10;&#10;ULONG PhwFindAdapter(&#10;  [in]      PVOID DeviceExtension,&#10;  [in]      PVOID HwContext,&#10;  [in]      PVOID BusInformation,&#10;  [in]      PCHAR ArgumentString,&#10;  [in, out] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [out]     PBOOLEAN Again&#10;)&#10;{...}">PHW_FIND_ADAPTER</a>.</p>

<h3 id="hwresetbus"><code>HwResetBus</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557318(v=vs.85)">HwScsiResetBus</a> routine, which is a required entry point for all miniport drivers. The prototype for this routine is <a href="phw_reset_bus" title="PHW_RESET_BUS PhwResetBus;&#10;&#10;BOOLEAN PhwResetBus(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG PathId&#10;)&#10;{...}">PHW_RESET_BUS</a>.</p>

<h3 id="hwdmastarted"><code>HwDmaStarted</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557291(v=vs.85)">HwScsiDmaStarted</a> routine if its HBA uses system DMA, that is, a system DMA controller. Set this to <strong>NULL</strong> if the HBA is a bus master or uses PIO. The prototype for this routine is <a href="phw_dma_started" title="PHW_DMA_STARTED PhwDmaStarted;&#10;&#10;VOID PhwDmaStarted(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_DMA_STARTED</a>.</p>

<h3 id="hwadapterstate"><code>HwAdapterState</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557278(v=vs.85)">HwScsiAdapterState</a> routine, which is a required entry point for miniport drivers of HBAs with BIOSs that are linked with an operating system-dependent, x86-platform-only port driver that must switch between x86 protected and real processor modes. If the miniport driver needs no <em>HwScsiAdapterState</em> routine, set this member to <strong>NULL</strong>. A miniport driver for an HBA that has a BIOS must have a HwScsiAdapterState routine in order to be compatible with the x86-only port driver and portable to an x86-only operating system environment. The prototype for this routine is <a href="phw_adapter_state" title="PHW_ADAPTER_STATE PhwAdapterState;&#10;&#10;BOOLEAN PhwAdapterState(&#10;  [in] PVOID DeviceExtension,&#10;  [in] PVOID Context,&#10;  [in] BOOLEAN SaveState&#10;)&#10;{...}">PHW_ADAPTER_STATE</a>.</p>

<h3 id="deviceextensionsize"><code>DeviceExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-HBA device extension. A miniport driver uses its device extension as storage for driver-determined HBA information. The OS-specific port driver initializes each device extension it allocates with zeros, and passes a pointer to the HBA-specific device extension in every call to a miniport driver except to its <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine. The given size does not include any miniport driver-requested per-logical-unit storage, described next.</p>

<h3 id="specificluextensionsize"><code>SpecificLuExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-logical-unit storage, if any. A miniport driver can use its LU extensions as storage for driver-determined logical-unit information about SCSI peripherals on the bus. The OS-specific port driver initializes each LU extension it allocates with zeros. Leave this member set to zero if the miniport driver does not maintain per-LU information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a>.</p>

<h3 id="srbextensionsize"><code>SrbExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-request storage, if any. A miniport driver can use SRB extensions as storage for driver-determined, request-specific information, such as data necessary to process a particular request. The OS-specific port driver does not initialize SRB extensions, but sets a pointer to this storage in each SRB it sends to the miniport driver. An SRB extension can be safely accessed by the HBA hardware. Leave this member set to zero if the miniport driver does not maintain per-SRB information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <a href="scsiportgetuncachedextension" title="SCSIPORT_API PVOID ScsiPortGetUncachedExtension(&#10;  [in] PVOID                           HwDeviceExtension,&#10;  [in] PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  [in] ULONG                           NumberOfBytes&#10;);">ScsiPortGetUncachedExtension</a>.</p>

<h3 id="numberofaccessranges"><code>NumberOfAccessRanges</code></h3>

<p>Specifies how many access ranges the adapter uses. Each is a range either of memory addresses or I/O port addresses. A typical HBA uses two ranges, one for its I/O ports and another for its device memory range.</p>

<h3 id="reserved"><code>Reserved</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3 id="mapbuffers"><code>MapBuffers</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that all data buffer addresses must be mapped to virtual addresses for access by the miniport driver. When <strong>FALSE</strong>, data buffer addresses do not have to be mapped to virtual addresses.</p>

<h3 id="needphysicaladdresses"><code>NeedPhysicalAddresses</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that the miniport driver needs to translate its device, any per-LU, and any per-SRB extension addresses, as well as SRB buffer addresses, to physical addresses, as required by the HBA. When <strong>FALSE</strong>, none of these addresses have to be translated to physical addresses.</p>

<h3 id="taggedqueuing"><code>TaggedQueuing</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that miniport driver can support SCSI tagged queuing. When <strong>FALSE</strong>, the miniport driver cannot support SCSI-tagged queuing.</p>

<h3 id="autorequestsense"><code>AutoRequestSense</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that the HBA can perform a request-sense operation without requiring an explicit request to do so. When <strong>FALSE</strong>, the HBA requires an explicit request before it can perform a request-sense operation. Only miniport drivers driving HBAs with built-in firmware to perform request-sense operations should set this member to <strong>TRUE</strong>.</p>

<h3 id="multiplerequestperlu"><code>MultipleRequestPerLu</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that the miniport driver can queue multiple requests per logical unit, in particular, within the HBA. When <strong>FALSE</strong>, the miniport driver cannot queue multiple requests per logical unit. Note that an HBA must support auto request sense for its miniport driver to enable this functionality. If a miniport driver sets this member to <strong>TRUE</strong>, it must use each SRB <strong>QueueTag<em>* member for requests of this type, but the SRB_FLAGS_QUEUE_ACTION_ENABLE is not set in the *</em>SrbFlags</strong> member of the <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> structure.</p>

<h3 id="receiveevent"><code>ReceiveEvent</code></h3>

<p>Indicates, when <strong>TRUE</strong>, that the miniport driver drives an HBA that can support the receive-event SRB for SCSI asynchronous events. When <strong>FALSE</strong>, the HBA cannot support the receive-event SRB for SCSI asynchronous events.</p>

<h3 id="vendoridlength"><code>VendorIdLength</code></h3>

<p>Specifies the size in bytes of the <strong>VendorId</strong> string, described next.</p>

<h3 id="vendorid"><code>VendorId</code></h3>

<p>Pointer to an ASCII byte string identifying the manufacturer of the HBA. This member is irrelevant for Plug and Play drivers.</p>

<p>If the given <strong>AdapterInterfaceType</strong> is <strong>PCIBus</strong>, the vendor ID is a <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> value allocated by the PCI SIG, which must be converted into a byte string by the miniport driver. For example, if the assigned PCI vendor ID value is 1001, the miniport driver-supplied <strong>VendorId</strong> string would be ('1', '0', '0', '1').</p>

<h3 id="reservedushort"><code>ReservedUshort</code></h3>

<p>Reserved for system use and is not available for use by miniport drivers.</p>

<h3 id="portversionflags"><code>PortVersionFlags</code></h3>

<h3 id="deviceidlength"><code>DeviceIdLength</code></h3>

<p>Specifies the size in bytes of the <strong>DeviceId</strong> string, described next.</p>

<h3 id="deviceid"><code>DeviceId</code></h3>

<p>Pointer to an ASCII byte string identifying the HBA model(s) supported by the miniport driver. This member is irrelevant for Plug and Play drivers.</p>

<p>If the given <strong>AdapterInterfaceType</strong> is <strong>PCIBus</strong>, a device ID is a <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> value assigned by the manufacturer of the HBA. The miniport driver must convert any PCI device ID value(s) for the HBA(s) it can support into <strong>DeviceId</strong> byte string(s), as for the <strong>VendorId</strong> member. For example, if a miniport driver can support HBAs with the PCI device IDs 8040 and 8050, it might set <strong>DeviceId</strong> with a pointer to the byte string ('8', '0').</p>

<h3 id="hwadaptercontrol"><code>HwAdapterControl</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557274(v=vs.85)">HwScsiAdapterControl</a> routine, which is a required entry point for all PnP miniport drivers. Set this to <strong>NULL</strong> if the miniport driver does not support Plug and Play.</p>

<h2 id="remarks">Remarks</h2>

<p>Each miniport driver must initialize the HW_INITIALIZATION_DATA structure with zeros before it sets the values of relevant members in this structure and calls <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>.</p>

<p>The <strong>Dma64BitAddresses</strong> member of HW_INITIALIZATION_DATA has been eliminated in Windows 2000 (See the discussion under PORT_CONFIGURATION_DATA for further details).</p>

<p>Both HW_INITIALIZATION_DATA and <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> have a pair of members called <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> whose values are handled differently than they were prior to Windows 2000. The miniport driver must calculate the initial values of <strong>SpecificLuExtensionSize</strong> and <strong>SrbExtensionSize</strong> in HW_INITIALIZATION_DATA based on the assumption that the HBA is capable of handling 32-bit addresses, regardless of what the controller can actually support. (See the discussion under PORT_CONFIGURATION_DATA for further details.)</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">DriverEntry of SCSI Miniport Driver</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557302(v=vs.85)">HwScsiInitialize</a></p>

<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>

<p><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_hw_initialization_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_hw_initialization_data~r1)</h1>
</div>
<div class="ntdoc-description">
<h1>HW_INITIALIZATION_DATA structure</h1>

<h2>Description</h2>

<p>The <strong>HW_INITIALIZATION_DATA (Storport)</strong> structure contains information particular to each miniport driver and the hardware that the miniport driver manages.</p>

<h2>Members</h2>

<h3><code>HwInitializationDataSize</code></h3>

<p>Specifies the size of this structure in bytes, as returned by <strong>sizeof</strong>(HW_INITIALIZATION_DATA). In effect, this member indicates the version of this structure being used by the miniport driver. A miniport driver's <a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a> routine should set this member's value for the port driver.</p>

<h3><code>AdapterInterfaceType</code></h3>

<p>The Storport driver does not support legacy buses. Therefore, most of the adapter interface types used with the SCSI Port driver are invalid for Storport. In particular, <strong>Isa</strong>, <strong>Eisa</strong>, <strong>MicroChannel</strong>, and <strong>TurboChannel</strong> are not supported. Furthermore, unlike the SCSI Port case, a miniport driver that works with the Storport driver is not required to supply values for the <strong>VendorIdLength</strong>, <strong>VendorId</strong>, <strong>DeviceIdLength</strong>, and <strong>DeviceId</strong> members.</p>

<h3><code>HwInitialize</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_initialize"><strong>HwStorInitialize</strong></a> routine, which is a required entry point for all miniport drivers.</p>

<h3><code>HwStartIo</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_startio"><strong>HwStorStartIo</strong></a> routine, which is a required entry point for all miniport drivers.</p>

<h3><code>HwInterrupt</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_interrupt"><strong>HwStorInterrupt</strong></a> routine, which is a required entry point for all miniport drivers.</p>

<h3><code>HwFindAdapter</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwStorFindAdapter</strong></a> routine, which is a required entry point for all miniport drivers.</p>

<h3><code>HwResetBus</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_reset_bus"><strong>HwStorResetBus</strong></a> routine, which is a required entry point for all miniport drivers.</p>

<h3><code>HwDmaStarted</code></h3>

<p>The Storport driver does not support subordinate-mode DMA. Therefore, this member must be <strong>NULL</strong>.</p>

<h3><code>HwAdapterState</code></h3>

<p>The Storport driver does not support legacy drivers. Therefore, this member must be <strong>NULL</strong>.</p>

<h3><code>DeviceExtensionSize</code></h3>

<p>Specifies the size, in bytes, required by the miniport driver for its per-adapter device extension. A miniport driver uses its device extension as storage for driver-determined host bus adapter (HBA) information. The operating system-specific port driver initializes each device extension one time, when it first allocates the extension and fills it with zeros. It passes a pointer to the HBA-specific device extension in every call to a miniport driver. The given size does not include any miniport driver-requested per-logical-unit storage. The size of per-logical-unit storage is specified via the <strong>SpecificLuExtensionSize</strong> field, described later in this topic.</p>

<p>Although SCSIPort re-initializes the device extension whenever the adapter is stopped and thus subsequent calls to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)"><strong>HwScsiFindAdapter</strong></a> receive a zeroed-out device extension, Storport does not follow that model. Rather, Storport resets the device extension to zero only when it is first allocated, so only the first call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwStorFindAdapter</strong></a> for a given adapter receives a zeroed-out device extension. Subsequent calls to <strong>HwStorFindAdapter</strong> and other miniport functions receive the device extension as last modified by the miniport. This allows the miniport driver to maintain knowledge about the state of the adapter between Plug and Play (PnP) stops and restarts, possibly enabling the miniport driver to optimize its initialization procedure.</p>

<h3><code>SpecificLuExtensionSize</code></h3>

<p>Specifies the size in bytes required by the miniport driver for its per-logical-unit storage, if any. A miniport driver can use its LU extensions as storage for driver-determined logical-unit information about peripherals on the bus. The Storport driver initializes each LU extension it allocates with zeros. Leave this member set to zero if the miniport driver does not maintain per-LU information for which it requires storage. This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="storportgetuncachedextension" title="STORPORT_API PVOID StorPortGetUncachedExtension(&#10;  PVOID                           HwDeviceExtension,&#10;  PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  ULONG                           NumberOfBytes&#10;);">StorPortGetUncachedExtension</a></strong>.</p>

<h3><code>SrbExtensionSize</code></h3>

<p>Specifies the size, in bytes, required by the miniport driver for its per-request storage, if any. A miniport driver can use SRB extensions as storage for driver-determined, request-specific information, such as data necessary to process a particular request. The Storport driver does not initialize SRB extensions, but sets a pointer to this storage in each SRB it sends to the miniport driver. An SRB extension can be safely accessed by the HBA hardware. Because miniport drivers that work with the Storport driver must support scatter/gather lists, and the per-SRB scatter/gather lists are usually allocated in the SRB extension, this member is rarely zero. Leave this member set to zero if the miniport driver does not maintain per-SRB information for which it requires storage.</p>

<p>This value is based on the assumption that the HBA is able to receive 32-bit addresses, regardless of what the controller can actually support. If additional space is needed in the LUN or SRB extensions to handle 64-bit addresses, then appropriate adjustments must be made to this value before using it with routines such as <strong><a href="storportgetuncachedextension" title="STORPORT_API PVOID StorPortGetUncachedExtension(&#10;  PVOID                           HwDeviceExtension,&#10;  PPORT_CONFIGURATION_INFORMATION ConfigInfo,&#10;  ULONG                           NumberOfBytes&#10;);">StorPortGetUncachedExtension</a></strong>.</p>

<h3><code>NumberOfAccessRanges</code></h3>

<p>Specifies how many access ranges the adapter uses. Each is a range either of memory addresses or I/O port addresses.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for system use and not available for use by miniport drivers.</p>

<h3><code>MapBuffers</code></h3>

<p>Indicates whether the Storport driver maps SRB data buffer addresses to system virtual addresses. The <strong>MapBuffers</strong> member can have one of the following values.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>STOR_MAP_NO_BUFFERS</strong> (0)</td>
  <td>Do not map for any SRB except SRB_FUNCTION_IO_CONTROL and SRB_FUNCTION_WMI.</td>
</tr>
<tr>
  <td><strong>STOR_MAP_ALL_BUFFERS</strong> (1)</td>
  <td>Obsolete. This value has the same effect as STOR_MAP_NON_READ_WRITE_BUFFERS.</td>
</tr>
<tr>
  <td><strong>STOR_MAP_NON_READ_WRITE_BUFFERS</strong> (2)</td>
  <td>Map the buffer for all I/O except for read or write requests.</td>
</tr>
<tr>
  <td><strong>STOR_MAP_ALL_BUFFERS_INCLUDING_READ_WRITE</strong> (3)</td>
  <td>Map the buffer for all I/O including read and write requests. This value is valid starting with Windows 8.</td>
</tr>
</tbody>
</table>

<h3><code>NeedPhysicalAddresses</code></h3>

<p>Must be set to <strong>TRUE</strong>. A value of <strong>TRUE</strong> indicates that the miniport driver must translate certain types of addresses to physical addresses. Miniport drivers that work with the Storport driver must support bus-master DMA, so they will always be required to do address translation.</p>

<h3><code>TaggedQueuing</code></h3>

<p>Must be set to <strong>TRUE</strong>. A value of <strong>TRUE</strong> indicates that the miniport driver supports SCSI tagged queuing. All miniport drivers that work with the Storport driver must support tagged queuing.</p>

<h3><code>AutoRequestSense</code></h3>

<p>Must be <strong>TRUE</strong>. A value of <strong>TRUE</strong> indicates that the HBA can perform a request-sense operation without requiring an explicit request to do so. All miniport drivers that work with the Storport driver must support SCSI Auto-Request Sense.</p>

<h3><code>MultipleRequestPerLu</code></h3>

<p>Must be set to <strong>TRUE</strong>. A value of <strong>TRUE</strong> indicates that the miniport driver can queue multiple requests per logical unit. Miniport drivers that work with the Storport driver must support multiple requests per logical unit.</p>

<h3><code>ReceiveEvent</code></h3>

<p>The Storport driver ignores this member.</p>

<h3><code>VendorIdLength</code></h3>

<p>The Storport driver ignores this member, because miniport drivers that work with the Storport driver must support PnP.</p>

<h3><code>VendorId</code></h3>

<p>The Storport driver ignores this member, because miniport drivers that work with the Storport driver must support PnP.</p>

<h3><code>ReservedUshort</code></h3>

<h3><code>PortVersionFlags</code></h3>

<p>Flags to indicate supported features.</p>

<h3><code>DeviceIdLength</code></h3>

<p>The Storport driver ignores this member, because miniport drivers that work with the Storport driver must support PnP.</p>

<h3><code>DeviceId</code></h3>

<p>The Storport driver ignores this member, because miniport drivers that work with the Storport driver must support PnP.</p>

<h3><code>HwAdapterControl</code></h3>

<p>Pointer to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control"><strong>HwStorAdapterControl</strong></a> routine. This is a required routine because miniport drivers that work with the Storport driver require PnP support.</p>

<h3><code>HwBuildIo</code></h3>

<p>Pointer to an optional <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio"><strong>HwStorBuildIo</strong></a> routine that the port driver calls to do unsynchronized processing prior to calling the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_startio"><strong>HwStorStartIo</strong></a> routine. This callback is specific to physical miniports and should be set to NULL by virtual miniports.</p>

<h3><code>HwFreeAdapterResources</code></h3>

<p>A pointer to the virtual miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_free_adapter_resources"><strong>HwStorFreeAdapterResources</strong></a> routine, which is a required entry point for all virtual miniport drivers. This callback is specific to virtual miniports and is set to <strong>NULL</strong> for physical miniports.</p>

<p>This callback is added in Windows 8. Virtual miniports for previous versions of Windows should use <strong><a href="virtual_hw_initialization_data" title="typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {&#10;  ULONG                       HwInitializationDataSize;&#10;  INTERFACE_TYPE              AdapterInterfaceType;&#10;  PHW_INITIALIZE              HwInitialize;&#10;  PHW_STARTIO                 HwStartIo;&#10;  PHW_INTERRUPT               HwInterrupt;&#10;  PVIRTUAL_HW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS               HwResetBus;&#10;  PHW_DMA_STARTED             HwDmaStarted;&#10;  PHW_ADAPTER_STATE           HwAdapterState;&#10;  ULONG                       DeviceExtensionSize;&#10;  ULONG                       SpecificLuExtensionSize;&#10;  ULONG                       SrbExtensionSize;&#10;  ULONG                       NumberOfAccessRanges;&#10;  PVOID                       Reserved;&#10;  UCHAR                       MapBuffers;&#10;  BOOLEAN                     NeedPhysicalAddresses;&#10;  BOOLEAN                     TaggedQueuing;&#10;  BOOLEAN                     AutoRequestSense;&#10;  BOOLEAN                     MultipleRequestPerLu;&#10;...">VIRTUAL_HW_INITIALIZATION_DATA</a></strong> instead of this structure.</p>

<h3><code>HwProcessServiceRequest</code></h3>

<p>A pointer to the virtual miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_process_service_request"><strong>HwStorProcessServiceRequest</strong></a> routine. This callback is specific to virtual miniports and is set to <strong>NULL</strong> for physical miniports.</p>

<p>This callback is added in Windows 8. Virtual miniports for previous versions of Windows should use <strong><a href="virtual_hw_initialization_data" title="typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {&#10;  ULONG                       HwInitializationDataSize;&#10;  INTERFACE_TYPE              AdapterInterfaceType;&#10;  PHW_INITIALIZE              HwInitialize;&#10;  PHW_STARTIO                 HwStartIo;&#10;  PHW_INTERRUPT               HwInterrupt;&#10;  PVIRTUAL_HW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS               HwResetBus;&#10;  PHW_DMA_STARTED             HwDmaStarted;&#10;  PHW_ADAPTER_STATE           HwAdapterState;&#10;  ULONG                       DeviceExtensionSize;&#10;  ULONG                       SpecificLuExtensionSize;&#10;  ULONG                       SrbExtensionSize;&#10;  ULONG                       NumberOfAccessRanges;&#10;  PVOID                       Reserved;&#10;  UCHAR                       MapBuffers;&#10;  BOOLEAN                     NeedPhysicalAddresses;&#10;  BOOLEAN                     TaggedQueuing;&#10;  BOOLEAN                     AutoRequestSense;&#10;  BOOLEAN                     MultipleRequestPerLu;&#10;...">VIRTUAL_HW_INITIALIZATION_DATA</a></strong> instead of this structure.</p>

<h3><code>HwCompleteServiceIrp</code></h3>

<p>A pointer to the virtual miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_complete_service_irp"><strong>HwStorCompleteServiceIrp</strong></a> routine. This callback is specific to virtual miniports and is set to <strong>NULL</strong> for physical miniports.</p>

<p>This callback is added in Windows 8. Virtual miniports for previous versions of Windows should use <strong><a href="virtual_hw_initialization_data" title="typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {&#10;  ULONG                       HwInitializationDataSize;&#10;  INTERFACE_TYPE              AdapterInterfaceType;&#10;  PHW_INITIALIZE              HwInitialize;&#10;  PHW_STARTIO                 HwStartIo;&#10;  PHW_INTERRUPT               HwInterrupt;&#10;  PVIRTUAL_HW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS               HwResetBus;&#10;  PHW_DMA_STARTED             HwDmaStarted;&#10;  PHW_ADAPTER_STATE           HwAdapterState;&#10;  ULONG                       DeviceExtensionSize;&#10;  ULONG                       SpecificLuExtensionSize;&#10;  ULONG                       SrbExtensionSize;&#10;  ULONG                       NumberOfAccessRanges;&#10;  PVOID                       Reserved;&#10;  UCHAR                       MapBuffers;&#10;  BOOLEAN                     NeedPhysicalAddresses;&#10;  BOOLEAN                     TaggedQueuing;&#10;  BOOLEAN                     AutoRequestSense;&#10;  BOOLEAN                     MultipleRequestPerLu;&#10;...">VIRTUAL_HW_INITIALIZATION_DATA</a></strong> instead of this structure.</p>

<h3><code>HwInitializeTracing</code></h3>

<p>A pointer to the virtual miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_initialize_tracing"><strong>HwStorInitializeTracing</strong></a> routine. This callback is specific to virtual miniports and is set to <strong>NULL</strong> for physical miniports.</p>

<p>This callback is added in Windows 8. Virtual miniports for previous versions of Windows should use <strong><a href="virtual_hw_initialization_data" title="typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {&#10;  ULONG                       HwInitializationDataSize;&#10;  INTERFACE_TYPE              AdapterInterfaceType;&#10;  PHW_INITIALIZE              HwInitialize;&#10;  PHW_STARTIO                 HwStartIo;&#10;  PHW_INTERRUPT               HwInterrupt;&#10;  PVIRTUAL_HW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS               HwResetBus;&#10;  PHW_DMA_STARTED             HwDmaStarted;&#10;  PHW_ADAPTER_STATE           HwAdapterState;&#10;  ULONG                       DeviceExtensionSize;&#10;  ULONG                       SpecificLuExtensionSize;&#10;  ULONG                       SrbExtensionSize;&#10;  ULONG                       NumberOfAccessRanges;&#10;  PVOID                       Reserved;&#10;  UCHAR                       MapBuffers;&#10;  BOOLEAN                     NeedPhysicalAddresses;&#10;  BOOLEAN                     TaggedQueuing;&#10;  BOOLEAN                     AutoRequestSense;&#10;  BOOLEAN                     MultipleRequestPerLu;&#10;...">VIRTUAL_HW_INITIALIZATION_DATA</a></strong> instead of this structure.</p>

<h3><code>HwCleanupTracing</code></h3>

<p>A pointer to the virtual miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_cleanup_tracing"><strong>HwStorCleanupTracing</strong></a> routine. This callback is specific to virtual miniports and is set to <strong>NULL</strong> for physical miniports.</p>

<p>This callback is added in Windows 8. Virtual miniports for previous versions of Windows should use <strong><a href="virtual_hw_initialization_data" title="typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {&#10;  ULONG                       HwInitializationDataSize;&#10;  INTERFACE_TYPE              AdapterInterfaceType;&#10;  PHW_INITIALIZE              HwInitialize;&#10;  PHW_STARTIO                 HwStartIo;&#10;  PHW_INTERRUPT               HwInterrupt;&#10;  PVIRTUAL_HW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS               HwResetBus;&#10;  PHW_DMA_STARTED             HwDmaStarted;&#10;  PHW_ADAPTER_STATE           HwAdapterState;&#10;  ULONG                       DeviceExtensionSize;&#10;  ULONG                       SpecificLuExtensionSize;&#10;  ULONG                       SrbExtensionSize;&#10;  ULONG                       NumberOfAccessRanges;&#10;  PVOID                       Reserved;&#10;  UCHAR                       MapBuffers;&#10;  BOOLEAN                     NeedPhysicalAddresses;&#10;  BOOLEAN                     TaggedQueuing;&#10;  BOOLEAN                     AutoRequestSense;&#10;  BOOLEAN                     MultipleRequestPerLu;&#10;...">VIRTUAL_HW_INITIALIZATION_DATA</a></strong> instead of this structure.</p>

<h3><code>HwTracingEnabled</code></h3>

<p>A pointer to an optional <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_tracing_enabled"><strong>HwStorTracingEnabled</strong></a> routine that the port driver calls to notify the miniport of whether tracing is enabled or not.</p>

<h3><code>FeatureSupport</code></h3>

<p>Flags indicating features that are supported by the miniport. <strong>FeatureSupport</strong> is set to a combination of these values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>STOR_FEATURE_VIRTUAL_MINIPORT</strong> (0x00000001)</td>
  <td>This is a virtual miniport driver.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_ATA_PASS_THROUGH</strong> (0x00000002)</td>
  <td>The miniport supports ATA pass through.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_FULL_PNP_DEVICE_CAPABILITIES</strong> (0x00000004)</td>
  <td>The miniport provides complete settings in its <strong><a href="stor_device_capabilities_ex" title="typedef struct _STOR_DEVICE_CAPABILITIES_EX {&#10;  USHORT Version;&#10;  USHORT Size;&#10;  ULONG  DeviceD1 : 1;&#10;  ULONG  DeviceD2 : 1;&#10;  ULONG  LockSupported : 1;&#10;  ULONG  EjectSupported : 1;&#10;  ULONG  Removable : 1;&#10;  ULONG  DockDevice : 1;&#10;  ULONG  UniqueID : 1;&#10;  ULONG  SilentInstall : 1;&#10;  ULONG  RawDeviceOK : 1;&#10;  ULONG  SurpriseRemovalOK : 1;&#10;  ULONG  NoDisplayInUI : 1;&#10;  ULONG  DefaultWriteCacheEnabled : 1;&#10;  ULONG  Reserved0 : 20;&#10;  ULONG  Address;&#10;  ULONG  UINumber;&#10;  ULONG  Reserved1[2];&#10;} STOR_DEVICE_CAPABILITIES_EX, *PSTOR_DEVICE_CAPABILITIES_EX;">STOR_DEVICE_CAPABILITIES_EX</a></strong> structure.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DUMP_POINTERS</strong> (0x00000008)</td>
  <td>The miniport supports the dump pointer SRBs.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DEVICE_NAME_NO_SUFFIX</strong> (0x00000010)</td>
  <td>The miniport driver does not want the suffix "SCSI <em>type</em> Device" as part of the device friendly name.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DUMP_RESUME_CAPABLE</strong> (0x00000020)</td>
  <td>The miniport's dump capability is functional for resume from hibernation.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DEVICE_DESCRIPTOR_FROM_ATA_INFO_VPD</strong> (0x00000040)</td>
  <td>The Storport driver initializes the <strong><a href="storage_device_descriptor" title="typedef struct _STORAGE_DEVICE_DESCRIPTOR {&#10;  ULONG            Version;&#10;  ULONG            Size;&#10;  UCHAR            DeviceType;&#10;  UCHAR            DeviceTypeModifier;&#10;  BOOLEAN          RemovableMedia;&#10;  BOOLEAN          CommandQueueing;&#10;  ULONG            VendorIdOffset;&#10;  ULONG            ProductIdOffset;&#10;  ULONG            ProductRevisionOffset;&#10;  ULONG            SerialNumberOffset;&#10;  STORAGE_BUS_TYPE BusType;&#10;  ULONG            RawPropertiesLength;&#10;  UCHAR            RawDeviceProperties[1];&#10;} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;">STORAGE_DEVICE_DESCRIPTOR</a></strong> from the ATA Information VPD page instead of from INQUIRY data.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_EXTRA_IO_INFORMATION</strong> (0x00000080)</td>
  <td>The miniport driver wants <a href="srbex_data_io_info" title="typedef struct _SRBEX_DATA_IO_INFO {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  ULONG         Flags;&#10;  ULONG         Key;&#10;  ULONG         RWLength;&#10;  BOOLEAN       IsWriteRequest;&#10;  UCHAR         CachePriority;&#10;  UCHAR         Reserved[2];&#10;  ULONG         Reserved1[2];&#10;} SRBEX_DATA_IO_INFO, *PSRBEX_DATA_IO_INFO;">SRBEX_DATA_IO_INFO</a> in a SRBEX if available.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_ADAPTER_CONTROL_PRE_FINDADAPTER</strong> (0x00000100)</td>
  <td>The miniport driver can safely process AdapterControl call from Storport before receiving HwFindAdapter.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_ADAPTER_NOT_REQUIRE_IO_PORT</strong> (0x00000200)</td>
  <td>The miniport driver doesn't require IO Port resource for its adapter.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DUMP_16_BYTE_ALIGNMENT</strong> (0x00000400)</td>
  <td>The miniport driver wants its HwDeviceExtension to be 16 byte aligned in dump mode.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_SET_ADAPTER_INTERFACE_TYPE</strong> (0x00000800)</td>
  <td>The miniport wants Storport to set the adapter interface type.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DUMP_INFO</strong> (0x00001000)</td>
  <td>The miniport driver supports the dump info SRBs.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_DMA_ALLOCATION_NO_BOUNDARY</strong> (0x00002000)</td>
  <td>The miniport driver supports to allocate DMA to physical memory without boundaries.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_SUPPORTS_NVME_ADAPTER</strong> (0x00004000)</td>
  <td>The miniport driver supports NVMe based Storage Adapters.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_REPORT_INTERNAL_DATA</strong> (0x00008000)</td>
  <td>The miniport driver supports reporting internal data.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_EARLY_DUMP</strong> (0x00010000)</td>
  <td>The miniport driver supports early crash dump generation.</td>
</tr>
<tr>
  <td><strong>STOR_FEATURE_NVME_ICE</strong> (0x00020000)</td>
  <td>The miniport driver supports NVMe ICE.</td>
</tr>
</tbody>
</table>

<h3><code>SrbTypeFlags</code></h3>

<p>Flags indicating the SRB types supported by the miniport. <strong>SrbTypeFlags</strong> is set to 0 or a combination of the following values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>SRB_TYPE_FLAG_SCSI_REQUEST_BLOCK</strong> (0x1)</td>
  <td>The miniport uses standard SRBs.</td>
</tr>
<tr>
  <td><strong>SRB_TYPE_FLAG_STORAGE_REQUEST_BLOCK</strong> (0x2)</td>
  <td>The miniport supports extended SRBs.</td>
</tr>
</tbody>
</table>

<h3><code>AddressTypeFlags</code></h3>

<p>The address schemes supported by the miniport. Currently, the only one address scheme is supported and the miniport must set this member to ADDRESS_TYPE_FLAG_BTL8.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>ADDRESS_TYPE_FLAG_BTL8</strong> (0x1)</td>
  <td>Bus, Target, and LUN (BTL) 8-bit addressing.</td>
</tr>
</tbody>
</table>

<h3><code>Reserved1</code></h3>

<p>Reserved, set to 0.</p>

<h3><code>HwUnitControl</code></h3>

<p>A pointer the miniport driver's <strong>HwStorUnitControl</strong> routine. The port driver calls this routine with a control request for a storage unit device.</p>

<h2>Remarks</h2>

<p>Every Storport miniport driver's <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine must call <strong><a href="storportinitialize" title="STORPORT_API ULONG StorPortInitialize(&#10;  [in]           PVOID                   Argument1,&#10;  [in]           PVOID                   Argument2,&#10;  [in]           _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in, optional] PVOID                   HwContext&#10;);">StorPortInitialize</a></strong> after the miniport driver has first zeroed and then set the members of <strong>HW_INITIALIZATION_DATA</strong>.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_hw_initialization_data-r1">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_hw_initialization_data~r1.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-strmini-_hw_initialization_data)</h1>
</div>
<div class="ntdoc-description">
<h1>_HW_INITIALIZATION_DATA structure (strmini.h)</h1>

<h2>Description</h2>

<p>The HW_INITIALIZATION_DATA structure specifies the basic information the class driver needs to begin initializing the minidriver. The minidriver passes an HW_INITIALIZATION_DATA structure to the class driver when it registers itself by calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nf-strmini-streamclassregisteradapter">StreamClassRegisterMinidriver</a>.</p>

<h2>Members</h2>

<h3><code>SizeOfThisPacket</code></h3>

<h3><code>StreamClassVersion</code></h3>

<h3><code>HwInitializationDataSize</code></h3>

<p>Specifies the size of this data structure, in bytes.</p>

<h3><code>HwInterrupt</code></h3>

<p>Points to the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_interrupt">StrMiniInterrupt</a> routine.</p>

<h3><code>HwReceivePacket</code></h3>

<p>Points to the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_receive_device_srb">StrMiniReceiveDevicePacket</a> routine.</p>

<h3><code>HwCancelPacket</code></h3>

<p>Points to the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_cancel_srb">StrMiniCancelPacket</a> routine.</p>

<h3><code>HwRequestTimeoutHandler</code></h3>

<p>Points to the minidriver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/nc-strmini-phw_request_timeout_handler">StrMiniRequestTimeout</a> routine.</p>

<h3><code>DeviceExtensionSize</code></h3>

<p>Specifies the size in bytes of the buffer the class driver should allocate for the minidriver's device extension. The minidriver may use this buffer to record private information. The class driver passes pointers to this buffer in the <strong>HwDeviceExtension</strong> member of <a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">HW_STREAM_OBJECT</a>, <a href="hw_stream_request_block" title="typedef struct _HW_STREAM_REQUEST_BLOCK {&#10;  ULONG                           SizeOfThisPacket;&#10;  SRB_COMMAND                     Command;&#10;  NTSTATUS                        Status;&#10;  PHW_STREAM_OBJECT               StreamObject;&#10;  PVOID                           HwDeviceExtension;&#10;  PVOID                           SRBExtension;&#10;  union {&#10;    PKSSTREAM_HEADER                       DataBufferArray;&#10;    PHW_STREAM_DESCRIPTOR                  StreamBuffer;&#10;    KSSTATE                                StreamState;&#10;    PSTREAM_TIME_REFERENCE                 TimeReference;&#10;    PSTREAM_PROPERTY_DESCRIPTOR            PropertyInfo;&#10;    PKSDATAFORMAT                          OpenFormat;&#10;    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;&#10;    HANDLE                                 MasterClockHandle;&#10;    DEVICE_POWER_STATE                     DeviceState;&#10;    PSTREAM_DATA_INTERSECT_INFO            IntersectInfo;&#10;    PVOID                                  MethodInfo;&#10;    LONG                                   FilterTypeIndex;&#10;...">HW_STREAM_REQUEST_BLOCK</a>, <a href="hw_time_context" title="typedef struct _HW_TIME_CONTEXT {&#10;  struct _HW_DEVICE_EXTENSION *HwDeviceExtension;&#10;  struct _HW_STREAM_OBJECT    *HwStreamObject;&#10;  TIME_FUNCTION               Function;&#10;  ULONGLONG                   Time;&#10;  ULONGLONG                   SystemTime;&#10;} HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;">HW_TIME_CONTEXT</a>, and <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structures it passes to the minidriver.</p>

<h3><code>PerRequestExtensionSize</code></h3>

<p>Specifies the size in bytes of the buffer the class driver should allocate for the buffer pointed to by <strong>SRBExtension</strong> member of <a href="hw_stream_request_block" title="typedef struct _HW_STREAM_REQUEST_BLOCK {&#10;  ULONG                           SizeOfThisPacket;&#10;  SRB_COMMAND                     Command;&#10;  NTSTATUS                        Status;&#10;  PHW_STREAM_OBJECT               StreamObject;&#10;  PVOID                           HwDeviceExtension;&#10;  PVOID                           SRBExtension;&#10;  union {&#10;    PKSSTREAM_HEADER                       DataBufferArray;&#10;    PHW_STREAM_DESCRIPTOR                  StreamBuffer;&#10;    KSSTATE                                StreamState;&#10;    PSTREAM_TIME_REFERENCE                 TimeReference;&#10;    PSTREAM_PROPERTY_DESCRIPTOR            PropertyInfo;&#10;    PKSDATAFORMAT                          OpenFormat;&#10;    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;&#10;    HANDLE                                 MasterClockHandle;&#10;    DEVICE_POWER_STATE                     DeviceState;&#10;    PSTREAM_DATA_INTERSECT_INFO            IntersectInfo;&#10;    PVOID                                  MethodInfo;&#10;    LONG                                   FilterTypeIndex;&#10;...">HW_STREAM_REQUEST_BLOCK</a> structures it passes to the minidriver. The class driver will allocate one buffer for each <a href="hw_stream_request_block" title="typedef struct _HW_STREAM_REQUEST_BLOCK {&#10;  ULONG                           SizeOfThisPacket;&#10;  SRB_COMMAND                     Command;&#10;  NTSTATUS                        Status;&#10;  PHW_STREAM_OBJECT               StreamObject;&#10;  PVOID                           HwDeviceExtension;&#10;  PVOID                           SRBExtension;&#10;  union {&#10;    PKSSTREAM_HEADER                       DataBufferArray;&#10;    PHW_STREAM_DESCRIPTOR                  StreamBuffer;&#10;    KSSTATE                                StreamState;&#10;    PSTREAM_TIME_REFERENCE                 TimeReference;&#10;    PSTREAM_PROPERTY_DESCRIPTOR            PropertyInfo;&#10;    PKSDATAFORMAT                          OpenFormat;&#10;    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;&#10;    HANDLE                                 MasterClockHandle;&#10;    DEVICE_POWER_STATE                     DeviceState;&#10;    PSTREAM_DATA_INTERSECT_INFO            IntersectInfo;&#10;    PVOID                                  MethodInfo;&#10;    LONG                                   FilterTypeIndex;&#10;...">HW_STREAM_REQUEST_BLOCK</a>.</p>

<h3><code>PerStreamExtensionSize</code></h3>

<p>Specifies the size in bytes of the buffer the class driver should allocate for the buffer pointed to by the <strong>HwStreamExtension</strong> member of a stream's <a href="hw_stream_object" title="typedef struct _HW_STREAM_OBJECT {&#10;  ULONG                          SizeOfThisPacket;&#10;  ULONG                          StreamNumber;&#10;  PVOID                          HwStreamExtension;&#10;  PHW_RECEIVE_STREAM_DATA_SRB    ReceiveDataPacket;&#10;  PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;&#10;  HW_CLOCK_OBJECT                HwClockObject;&#10;  BOOLEAN                        Dma;&#10;  BOOLEAN                        Pio;&#10;  PVOID                          HwDeviceExtension;&#10;  ULONG                          StreamHeaderMediaSpecific;&#10;  ULONG                          StreamHeaderWorkspace;&#10;  BOOLEAN                        Allocator;&#10;  PHW_EVENT_ROUTINE              HwEventRoutine;&#10;  ULONG                          Reserved[2];&#10;} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;">HW_STREAM_OBJECT</a>. The class driver will allocate one buffer for each stream.</p>

<h3><code>FilterInstanceExtensionSize</code></h3>

<p>Specifies the size in bytes of the buffer the class extension should allocate for the buffer pointed to by the <strong>HwInstanceExtension</strong> member of <a href="hw_stream_request_block" title="typedef struct _HW_STREAM_REQUEST_BLOCK {&#10;  ULONG                           SizeOfThisPacket;&#10;  SRB_COMMAND                     Command;&#10;  NTSTATUS                        Status;&#10;  PHW_STREAM_OBJECT               StreamObject;&#10;  PVOID                           HwDeviceExtension;&#10;  PVOID                           SRBExtension;&#10;  union {&#10;    PKSSTREAM_HEADER                       DataBufferArray;&#10;    PHW_STREAM_DESCRIPTOR                  StreamBuffer;&#10;    KSSTATE                                StreamState;&#10;    PSTREAM_TIME_REFERENCE                 TimeReference;&#10;    PSTREAM_PROPERTY_DESCRIPTOR            PropertyInfo;&#10;    PKSDATAFORMAT                          OpenFormat;&#10;    struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;&#10;    HANDLE                                 MasterClockHandle;&#10;    DEVICE_POWER_STATE                     DeviceState;&#10;    PSTREAM_DATA_INTERSECT_INFO            IntersectInfo;&#10;    PVOID                                  MethodInfo;&#10;    LONG                                   FilterTypeIndex;&#10;...">HW_STREAM_REQUEST_BLOCK</a> structures it passes to the minidriver. The class driver allocates one buffer for each instance of the minidriver.</p>

<h3><code>BusMasterDMA</code></h3>

<p>If <strong>TRUE</strong>, the device can perform direct bus-master DMA to the minidriver's DMA buffer.</p>

<h3><code>Dma24BitAddresses</code></h3>

<p>Minidrivers should set this to <strong>TRUE</strong> if the DMA hardware the devices uses can access only the lower 24 bits of the address space.</p>

<h3><code>BufferAlignment</code></h3>

<p>Specifies the alignment requirement, in bytes, for DMA buffers. For example, a value of 4 indicates the DMA buffers should be aligned on 4-byte boundaries.</p>

<h3><code>TurnOffSynchronization</code></h3>

<p>If <strong>TRUE</strong>, the minidriver will handle its own synchronization; otherwise the class driver handles synchronization. Most minidrivers should set this value to <strong>FALSE</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/minidriver-synchronization">Minidriver Synchronization</a> in the <em>Streaming Minidriver Design Guide</em> for more information.</p>

<h3><code>DmaBufferSize</code></h3>

<p>Specifies the size in bytes of the DMA buffer the class driver should allocate for the minidriver. The minidriver gets a pointer to this buffer by calling <a href="streamclassgetdmabuffer" title="PVOID STREAMAPI StreamClassGetDmaBuffer(&#10;  [in] PVOID HwDeviceExtension&#10;);">StreamClassGetDmaBuffer</a>. The class driver allocates contiguous nonpageable memory that will not be available to the operating system, or to other drivers, so this value should be as small as possible.</p>

<h3><code>NumNameExtensions</code></h3>

<h3><code>NameExtensionArray</code></h3>

<h3><code>Reserved</code></h3>

<p>Reserved for system use. Minidrivers should ignore this member.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_hw_initialization_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/strmini/ns-strmini-_hw_initialization_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
