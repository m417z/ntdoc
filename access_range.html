<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="ACCESS_RANGE - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>ACCESS_RANGE - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            ACCESS_RANGE - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _ACCESS_RANGE {
  SCSI_PHYSICAL_ADDRESS RangeStart;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                 RangeLength;
  BOOLEAN               RangeInMemory;
} ACCESS_RANGE, *PACCESS_RANGE;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_access_range">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _ACCESS_RANGE {
  STOR_PHYSICAL_ADDRESS RangeStart;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                 RangeLength;
  BOOLEAN               RangeInMemory;
} ACCESS_RANGE, *PACCESS_RANGE;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_access_range">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// strmini.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _ACCESS_RANGE {
  SCSI_PHYSICAL_ADDRESS RangeStart;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                 RangeLength;
  BOOLEAN               RangeInMemory;
} ACCESS_RANGE, *PACCESS_RANGE;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_access_range">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/access_range.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_access_range)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_access_range-structure-srbh">_ACCESS_RANGE structure (srb.h)</h1>

<h2 id="description">Description</h2>

<p>An ACCESS_RANGE describes a memory or I/O port range used by an HBA.</p>

<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>

<h2 id="members">Members</h2>

<h3 id="rangestart"><code>RangeStart</code></h3>

<p>Contains an address of type <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff565350(v=vs.85)">SCSI_PHYSICAL_ADDRESS</a> that specifies the bus-relative base address of the range. This is an address that can be passed into <a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a>.</p>

<h3 id="rangelength"><code>RangeLength</code></h3>

<p>Specifies the size, in bytes, or number of ports in the range. A miniport driver must ensure that this value matches the range actually decoded by the adapter. For example, if the HBA uses seven registers but responds to eight, this member should be set to 8.</p>

<h3 id="rangeinmemory"><code>RangeInMemory</code></h3>

<p>Indicates the range is in memory when <strong>TRUE</strong>, rather than in I/O space. When <strong>FALSE</strong>, the range is in I/O space.</p>

<h2 id="remarks">Remarks</h2>

<p>Each ACCESS_RANGE is an <strong>AccessRanges</strong> array element within the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structure that is passed to a miniport driver's HwScsiFindAdapter routine.</p>

<p>If possible, the OS-specific port driver sets up each access range element with a bus-relative HBA range for the miniport driver before calling the miniport driver's HwScsiFindAdapter routine. Otherwise, the port driver zeros range elements for which it cannot supply configuration information.</p>

<p>If the port driver does supply a range, the miniport driver's HwScsiFindAdapter routine should use only the supplied addresses and should <em>never</em> attempt to find other HBAs on the same bus using addresses of its own devising. Attempting to access other bus-relative port or memory ranges when the port driver has supplied range information, particularly in x86-only systems in which some devices are initialized in x86 real mode, can cause other devices on the bus to fail initialization or even cause the system to fail the boot process.</p>

<p>Each miniport driver should have a set of bus-relative default ranges to try if the OS-specific port driver cannot supply the information. A miniport driver must call <strong><a href="scsiportvalidaterange" title="SCSIPORT_API BOOLEAN ScsiPortValidateRange(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortValidateRange</a></strong> to check the safety of any miniport driver-supplied access range <em>before</em> it attempts to map such a range with <strong><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></strong> and use the returned logical addresses to access an adapter, particularly if one of its HBAs has a BIOS.</p>

<p>Any access range that a miniport driver fills in for the OS-specific port driver in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> must have the <strong>RangeStart</strong> member set to a bus-relative address, such as a value returned by <strong><a href="scsiportgetbusdata" title="SCSIPORT_API ULONG ScsiPortGetBusData(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG BusDataType,&#10;  [in] ULONG SystemIoBusNumber,&#10;  [in] ULONG SlotNumber,&#10;  [in] PVOID Buffer,&#10;  [in] ULONG Length&#10;);">ScsiPortGetBusData</a></strong>.</p>

<p>The corresponding base logical address returned by <strong><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></strong> should be stored, usually in the miniport driver's device extension, as the <strong>RangeStart</strong> address for a mapped range of I/O ports or memory addresses used to call the <strong>ScsiPortRead</strong><em>Xxx</em> and <strong>ScsiPortWrite</strong><em>Xxx</em> routines.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)">HwScsiFindAdapter</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">PORT_CONFIGURATION_INFORMATION (SCSI)</a></p>

<p><a href="scsiportconvertulongtophysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortConvertUlongToPhysicalAddress(&#10;  [in] ULONG_PTR UlongAddress&#10;);">ScsiPortConvertUlongToPhysicalAddress</a></p>

<p><a href="scsiportgetbusdata" title="SCSIPORT_API ULONG ScsiPortGetBusData(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG BusDataType,&#10;  [in] ULONG SystemIoBusNumber,&#10;  [in] ULONG SlotNumber,&#10;  [in] PVOID Buffer,&#10;  [in] ULONG Length&#10;);">ScsiPortGetBusData</a></p>

<p><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></p>

<p><a href="scsiportvalidaterange" title="SCSIPORT_API BOOLEAN ScsiPortValidateRange(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortValidateRange</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_access_range">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_access_range.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_access_range)</h1>
</div>
<div class="ntdoc-description">
<h1>_ACCESS_RANGE structure (storport.h)</h1>

<h2>Description</h2>

<p>An ACCESS_RANGE describes a memory or I/O port range used by an HBA.</p>

<h2>Members</h2>

<h3><code>RangeStart</code></h3>

<p>Contains a physical address that specifies the bus-relative base address of a range used by the HBA. The value of this member can be obtained from one of the <strong>AccessRanges</strong> elements in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> structure. This is an address that can be passed into <strong><a href="storportgetdevicebase" title="STORPORT_API PVOID StorPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] STOR_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">StorPortGetDeviceBase</a></strong>.</p>

<h3><code>RangeLength</code></h3>

<p>Specifies the size, in bytes, or number of ports in the range. A miniport driver must ensure that this value matches the range actually decoded by the adapter. For example, if the HBA uses seven registers but responds to eight, this member should be set to 8.</p>

<h3><code>RangeInMemory</code></h3>

<p>Indicates the range is in memory when <strong>TRUE</strong>, rather than in I/O space. When <strong>FALSE</strong>, the range is in I/O space.</p>

<h2>Remarks</h2>

<p>Each ACCESS_RANGE is an <strong>AccessRanges</strong> array element within the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> structure that is passed to a miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwStorFindAdapter</strong></a> routine.</p>

<p>Storport allocates memory for the access ranges and initializes the <strong>AccessRanges</strong> member. The miniport driver's <strong>HwStorFindAdapter</strong> routine should use only the supplied addresses and should <em>never</em> attempt to find other HBAs on the same bus using addresses of its own devising. Attempting to access other bus-relative port or memory ranges when the port driver has supplied range information, particularly in x86-only systems in which some devices are initialized in x86 real mode, can cause other devices on the bus to fail initialization or even cause the system to fail the boot process.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_find_adapter"><strong>HwStorFindAdapter</strong></a></p>

<p><strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong></p>

<p><strong><a href="storportgetdevicebase" title="STORPORT_API PVOID StorPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] STOR_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">StorPortGetDeviceBase</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_access_range">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_access_range.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-strmini-_access_range)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>

<p>An ACCESS_RANGE describes a memory or I/O port range used by an HBA.</p>

<p>The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver-overview">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>

<h2>Members</h2>

<h3><code>RangeStart</code></h3>

<p>Contains an address of type <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff565350(v=vs.85)">SCSI_PHYSICAL_ADDRESS</a> that specifies the bus-relative base address of the range. This is an address that can be passed into <a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a>.</p>

<h3><code>RangeLength</code></h3>

<p>Specifies the size, in bytes, or number of ports in the range. A miniport driver must ensure that this value matches the range actually decoded by the adapter. For example, if the HBA uses seven registers but responds to eight, this member should be set to 8.</p>

<h3><code>RangeInMemory</code></h3>

<p>Indicates the range is in memory when <strong>TRUE</strong>, rather than in I/O space. When <strong>FALSE</strong>, the range is in I/O space.</p>

<h3><code>Reserved</code></h3>

<h2>Syntax</h2>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_ACCESS_RANGE</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SCSI_PHYSICAL_ADDRESS</span><span class="w"> </span><span class="n">RangeStart</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w">                 </span><span class="n">RangeLength</span><span class="p">;</span>
<span class="w">  </span><span class="n">BOOLEAN</span><span class="w">               </span><span class="n">RangeInMemory</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">ACCESS_RANGE</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">PACCESS_RANGE</span><span class="p">;</span>
</code></pre>
</div>

<h2>Remarks</h2>

<p>Each ACCESS_RANGE is an <strong>AccessRanges</strong> array element within the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structure that is passed to a miniport driver's HwScsiFindAdapter routine.</p>

<p>If possible, the OS-specific port driver sets up each access range element with a bus-relative HBA range for the miniport driver before calling the miniport driver's HwScsiFindAdapter routine. Otherwise, the port driver zeros range elements for which it cannot supply configuration information.</p>

<p>If the port driver does supply a range, the miniport driver's HwScsiFindAdapter routine should use only the supplied addresses and should <em>never</em> attempt to find other HBAs on the same bus using addresses of its own devising. Attempting to access other bus-relative port or memory ranges when the port driver has supplied range information, particularly in x86-only systems in which some devices are initialized in x86 real mode, can cause other devices on the bus to fail initialization or even cause the system to fail the boot process.</p>

<p>Each miniport driver should have a set of bus-relative default ranges to try if the OS-specific port driver cannot supply the information. A miniport driver must call <strong><a href="scsiportvalidaterange" title="SCSIPORT_API BOOLEAN ScsiPortValidateRange(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortValidateRange</a></strong> to check the safety of any miniport driver-supplied access range <em>before</em> it attempts to map such a range with <strong><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></strong> and use the returned logical addresses to access an adapter, particularly if one of its HBAs has a BIOS.</p>

<p>Any access range that a miniport driver fills in for the OS-specific port driver in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> must have the <strong>RangeStart</strong> member set to a bus-relative address, such as a value returned by <strong><a href="scsiportgetbusdata" title="SCSIPORT_API ULONG ScsiPortGetBusData(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG BusDataType,&#10;  [in] ULONG SystemIoBusNumber,&#10;  [in] ULONG SlotNumber,&#10;  [in] PVOID Buffer,&#10;  [in] ULONG Length&#10;);">ScsiPortGetBusData</a></strong>.</p>

<p>The corresponding base logical address returned by <strong><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></strong> should be stored, usually in the miniport driver's device extension, as the <strong>RangeStart</strong> address for a mapped range of I/O ports or memory addresses used to call the <strong>ScsiPortRead</strong><em>Xxx</em> and <strong>ScsiPortWrite</strong><em>Xxx</em> routines.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_port_configuration_information">PORT_CONFIGURATION_INFORMATION (SCSI)</a></p>

<p><a href="scsiportgetbusdata" title="SCSIPORT_API ULONG ScsiPortGetBusData(&#10;  [in] PVOID DeviceExtension,&#10;  [in] ULONG BusDataType,&#10;  [in] ULONG SystemIoBusNumber,&#10;  [in] ULONG SlotNumber,&#10;  [in] PVOID Buffer,&#10;  [in] ULONG Length&#10;);">ScsiPortGetBusData</a></p>

<p><a href="scsiportgetdevicebase" title="SCSIPORT_API PVOID ScsiPortGetDeviceBase(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortGetDeviceBase</a></p>

<p><a href="scsiportvalidaterange" title="SCSIPORT_API BOOLEAN ScsiPortValidateRange(&#10;  [in] PVOID                 HwDeviceExtension,&#10;  [in] INTERFACE_TYPE        BusType,&#10;  [in] ULONG                 SystemIoBusNumber,&#10;  [in] SCSI_PHYSICAL_ADDRESS IoAddress,&#10;  [in] ULONG                 NumberOfBytes,&#10;  [in] BOOLEAN               InIoSpace&#10;);">ScsiPortValidateRange</a></p>

<p><a href="scsiportconvertulongtophysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortConvertUlongToPhysicalAddress(&#10;  [in] ULONG_PTR UlongAddress&#10;);">ScsiPortConvertUlongToPhysicalAddress</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557300(v=vs.85)">HwScsiFindAdapter</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/strmini/ns-strmini-_access_range">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/strmini/ns-strmini-_access_range.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
