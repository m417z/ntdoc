<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="RxStartMinirdr - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>RxStartMinirdr - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            RxStartMinirdr - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// mrx.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> RxStartMinirdr(
  [in]  IN <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">PRX_CONTEXT</a> RxContext,
  [out] OUT PBOOLEAN   PostToFsp
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nf-mrx-rxstartminirdr">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/rxstartminirdr.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-mrx-rxstartminirdr)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="rxstartminirdr-function">RxStartMinirdr function</h1>

<h2 id="description">Description</h2>

<p><strong>RxStartMinirdr</strong> is called to start up a network mini-redirector that has previously called to register with RDBSS. As part of <strong>RxStartMinirdr</strong>, RDBSS will also register the network mini-redirector driver as a universal naming convention (UNC) provider with the Multiple UNC Provider (MUP) if the driver indicates support for UNC names.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="rxcontext-in"><code>RxContext</code> [in]</h3>

<p>A pointer to the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to use to get the device object and determine if this is a file system process.</p>

<h3 id="posttofsp-out"><code>PostToFsp</code> [out]</h3>

<p>A pointer to a logical value set to TRUE on return if the request must be posted for later processing by the file system process.</p>

<h2 id="return-value">Return value</h2>

<p><strong>RxStartMinirdr</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the startup sequence was successful or one of the following error values:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STATUS_ACCESS_DENIED</td>
  <td>The request to register as a UNC provider failed because access was denied.</td>
</tr>
<tr>
  <td>STATUS_ACCESS_VIOLATION</td>
  <td>The request to register as a UNC provider failed with an access violation.</td>
</tr>
<tr>
  <td>STATUS_INSUFFICIENT_RESOURCES</td>
  <td>There were insufficient resources to complete this routine.</td>
</tr>
<tr>
  <td>STATUS_PENDING</td>
  <td>The startup sequence for RDBSS and network mini-redirectors must be completed in the context of system process, not a user-mode application process. If the call to <strong>RxStartMinirdr</strong> comes from a user-mode process (a user-mode service request, for example), then the request is posted for later processing within RDBSS and STATUS_PENDING will be returned. This error can also be returned if certain internal RDBSS locks cannot be acquired without waiting. The call will be completed later from a system thread.</td>
</tr>
<tr>
  <td>STATUS_REDIRECTOR_STARTED</td>
  <td>The network mini-redirector was already started.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>A network mini-redirector registers with RDBSS whenever the driver is loaded by the kernel and then unregisters with RDBSS when the driver is unloaded. A network mini-redirector informs RDBSS that it has been loaded by calling <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong>, the registration routine exported from RDBSS. As part of this registration process, the network mini-redirector passes a parameter to <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong> that is a pointer to a large structure, MINIRDR_DISPATCH, which contains configuration information for the network mini-redirector and a table of pointers to callback routines implemented by the network mini-redirector driver. RDBSS uses the callback routines passed in this structure to communicate with the network mini-redirector.</p>

<p>The network mini-redirector does not actually start operation until it receives a call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_calldown_ctx">MRxStart</a> routine, one of the callback routines passed in the MINIRDR_DISPATCH structure. The <strong>MrxStart</strong> callback routine must be implemented by the network mini-redirector driver if it wishes to receive callback routines for operations unless the network mini-redirector preserves its own driver dispatch entry points. Otherwise, RDBSS will only allow the following I/O request packets through to the driver until <strong>MrxStart</strong> returns successfully:</p>

<ul>
<li><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> requests for device create operations and device operations where the <strong>FileObject->FileName.Length</strong> parameter on the IRPSP is zero and the <strong>FileObject->RelatedFileObject</strong> parameter is NULL.</li>
</ul>

<p>For any other <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> request, the RDBSS dispatch routine <a rel="noopener" target="_blank" href="rxfsddispatch">RxFsdDispatch</a> will return a status of STATUS_REDIRECTOR_NOT_STARTED.</p>

<p>The RDBSS dispatch routine will also fail any requests for the following I/O request packets:</p>

<ul>
<li><a href="irp_mj_create_mailslot" title="#define IRP_MJ_CREATE_MAILSLOT 0x13">IRP_MJ_CREATE_MAILSLOT</a></li>
<li><a href="irp_mj_create_named_pipe" title="#define IRP_MJ_CREATE_NAMED_PIPE 0x01">IRP_MJ_CREATE_NAMED_PIPE</a></li>
</ul>

<p>The network mini-redirector <strong>MrxStart</strong> routine is called by RDBSS when the <strong>RxStartMinirdr</strong> routine is called. The RDBSS <strong>RxStartMinirdr</strong> routine is usually called as a result of an FSCTL or IOCTL request from a user-mode application or service to start the network mini-redirector. The call to <strong>RxStartMinirdr</strong> cannot be made from the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/driverentry-of-ide-controller-minidriver">DriverEntry</a> routine of the network mini-redirector after a successful call to <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong> since some of the start processing requires that the driver initialization be completed.</p>

<p>When RDBSS receives an FSCTL or IOCTL request sent to network mini-redirector driver from user mode, RDBSS creates an <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure and passes this call to the network mini-redirector's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-">MRxLowIOSubmit[LOWIO_OP_FSCTL]</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-">MRxLowIOSubmit[LOWIO_OP_IOCTL]</a> call back routine defined in the MINIRDR_DISPATCH structure. The network mini-redirector's implementation of this call back routine would recognize the request to start and call <strong>RxStartMinirdr</strong>. This normal process of events is listed below in more detail:</p>

<ol>
<li><p>A user-mode application issues a private FSCTL or IOCTL request to start the network mini-redirector.</p></li>
<li><p>The RDBSS kernel driver receives the FSCTL or IOCTL request on behalf of the network mini-redirector since RDBSS has replaced the driver dispatch entry points of the mini-redirector driver to point to RDBSS internal routines. Note that this assumes that the network mini-redirector did not set the RX_REGISTERMINI_FLAG_DONT_INIT_DRIVER_DISPATCH in the <strong>Controls</strong> parameter when calling <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong>. This option passed to <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong> would be unusual and indicates that the network mini-redirector does not want RDBSS to replace its driver dispatch entry points.</p></li>
<li><p>RDBSS receives the FSCTL or IOCTL request internally on behalf of the network redirector. The RDBSS dispatcher allocates and initializes an <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure. RDBSS then calls the network mini-redirector **MRxLowIOSubmit[LOW_OP_FSCTL]** or **MRxLowIOSubmit[LOW_OP_IOCTL]** routine defined in the MINIRDR_DISPATCH structure for this network mini-redirector, passing in the initialized <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure as a parameter.</p></li>
<li><p>The network mini-redirector implementation of this call back routine would recognize the private FSCTL or IOCTL request to start and call <strong>RxStartMinirdr</strong>, passing in a pointer the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure it received from RDBSS as the *<em>RxContext</em>* parameter and the address of the <strong>PostToFSP</strong> member of <strong>RxContext</strong> as the <strong>PostToFsp</strong> parameter.</p></li>
<li><p>Since this call was initiated from user mode, <strong>RxStartMinirdr</strong> would return STATUS_PENDING and set <strong>PostToFsp</strong> to TRUE.</p></li>
<li><p>The network mini-redirector <strong>MRxLowIOSubmit[LOW_OP_FSCTL]</strong> or <strong>MRxLowIOSubmit[LOW_OP_IOCTL]</strong> routine would receive this return value and pass it back to the RDBSS dispatcher.</p></li>
<li><p>The RDBSS dispatcher would receive the STATUS_PENDING return value and would set <strong>PostToFsp</strong> to TRUE and would then post a request to a worker thread to re-execute the call to the network mini-redirector.</p></li>
</ol>

<p>After this point, there are two possible outcomes based on whether the FSCTL or IOCTL was requested as an asynchronous or a synchronous operation.</p>

<p>If this were an asynchronous request, the following would occur:</p>

<ul>
<li>The user-mode caller would receive the STATUS_PENDING response from the call. The posted worker thread would eventually call <strong>RxStartMinirdr</strong> from a file system thread and the call would be processed. The <strong>RxStartMinirdr</strong> routine will try to register the network mini-redirector as a UNC provider, if requested. On versions of Windows prior to Windows Vista, RDBSS will then try to register the network mini-redirector as a file system with the I/O manager. If these calls are successful, then <strong>RxStartMinirdr</strong> calls the <strong>MrxStart</strong> callback routine implemented by the network mini-redirector. The return value from <strong>MrxStart</strong> would eventually be returned to the user-mode application that initiated the calling sequence process as an asynchronous operation.</li>
</ul>

<p>If this were a synchronous request, the following would occur:</p>

<ul>
<li>The user-mode caller would not receive the STATUS_PENDING response but would be forced to wait until the call returned from the posted worker thread. The posted worker thread would eventually call <strong>RxStartMinirdr</strong> from a file system thread and the call would be processed. The <strong>RxStartMinirdr</strong> routine will try to register the network mini-redirector as a UNC provider, if requested. On versions of Windows prior to Windows Vista, RDBSS will then try to register the network mini-redirector as a file system with the I/O manager. If these calls are successful, then <strong>RxStartMinirdr</strong> calls the <strong>MrxStart</strong> callback routine implemented by the network mini-redirector. The return value from <strong>MrxStart</strong> would be returned to the user mode application that initiated the calling sequence process.</li>
</ul>

<p>If a network mini-redirector indicates support for UNC when registering with RDBSS (the <strong>Controls</strong> parameter to <strong><a href="rxregisterminirdr" title="NTSTATUS RxRegisterMinirdr(&#10;  [out]     OUT PRDBSS_DEVICE_OBJECT *DeviceObject,&#10;  [in, out] IN OUT PDRIVER_OBJECT    DriverObject,&#10;  [in]      IN PMINIRDR_DISPATCH     MrdrDispatch,&#10;  [in]      IN ULONG                 Controls,&#10;  [in]      IN PUNICODE_STRING       DeviceName,&#10;  [in]      IN ULONG                 DeviceExtensionSize,&#10;  [in]      IN DEVICE_TYPE           DeviceType,&#10;  [in]      IN ULONG                 DeviceCharacteristics&#10;);">RxRegisterMinirdr</a></strong>), then <strong>RxStartMinirdr</strong> will try to register the <strong>DeviceName</strong> parameter of the network mini-redirector as a UNC provider with MUP (RDBSS calls <a rel="noopener" target="_blank" href="fsrtlregisteruncprovider">FsRtlRegisterUncProvider</a> on behalf of the network mini-redirector).</p>

<p>On versions of Windows prior to Windows Vista, <strong>RxStartMinirdr</strong> registers the file system with the I/O manager (RDBSS calls <a rel="noopener" target="_blank" href="ioregisterfilesystem">IoRegisterFileSystem</a> on behalf of the network mini-redirector).</p>

<p>If the calls are successful, then <strong>RxStartMinirdr</strong> calls the network mini-redirector <strong>MrxStart</strong> routine. If <strong>MrxStart</strong> returns success, the internal state of the mini-redirector in RDBSS is set to RDBSS_STARTED. The <strong>StartStopContext.Version</strong> member of the mini-redirector device object will also be incremented.</p>

<p>The startup sequence for RDBSS and the network mini-redirector must be completed in the context of the system process if asynchronous operation is requested. If the call to <strong>RxStartMinirdr</strong> comes from a user-mode process (a user mode service request, for example), then the request will be internally posted by RDBSS to a work queue for later processing and STATUS_PENDING will be returned and the **PostToFsp** parameter will be set to TRUE. In addition, If certain internal RDBSS locks cannot be obtained without waiting, STATUS_PENDING is returned and <strong>PostToFsp</strong> is set to TRUE. When STATUS_PENDING is returned, **RxStartMinirdr** will be called again from within a system process. If the FSCTL or IOCTL request that initiated the call to **RxStartMinirdr** was set for asynchronous operation, then RDBSS would return STATUS_PENDING back up the call chain to the original FSCTL or IOCTL request from user mode. In contrast, if the FSCTL or IOCTL request was for synchronous operation, then the call would also be posted to a work thread for later execution, but the FSCTL or IOCTL call would not return to user mode until <strong>RxStartMinirdr</strong> had been executed in the context of the file system process. In this case, the caller of the FSCTL or IOCTL would never see the STATUS_PENDING error return. The more typical behavior is to initiate a synchronous request for these start/stop operations to simplify the user-mode application code.</p>

<p>On an abnormal termination or other failure, <strong>RxStartMinirdr</strong> will try to undo these operations, including de-registering the UNC provider with MUP, unregistering the file system, freeing memory allocated for storing the domain name to be used by mailslot broadcasts, and updating internal RDBSS tables.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="rxpunregisterminirdr">, RxpUnregisterMinirdr</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/driverentry-of-ide-controller-minidriver">DriverEntry</a></p>

<p><a rel="noopener" target="_blank" href="fsrtlregisteruncprovider">FsRtlRegisterUncProvider</a></p>

<p><a rel="noopener" target="_blank" href="ioregisterfilesystem">IoRegisterFileSystem</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-">MRxLowIOSubmit[LOWIO_OP_FSCTL]</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-">MRxLowIOSubmit[LOWIO_OP_IOCTL]</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_calldown_ctx">MRxStart</a></p>

<p><a rel="noopener" target="_blank" href="rxfsddispatch">RxFsdDispatch</a></p>

<p><a rel="noopener" target="_blank" href="rxregisterminirdr">RxRegisterMinirdr</a></p>

<p><a rel="noopener" target="_blank" href="rxsetdomainformailslotbroadcast">RxSetDomainForMailslotBroadcast</a></p>

<p><a rel="noopener" target="_blank" href="rxstopminirdr">RxStopMinirdr</a></p>

<p><a rel="noopener" target="_blank" href="rxunregisterminirdr">RxUnregisterMinirdr</a></p>

<p><a rel="noopener" target="_blank" href="__rxfillandinstallfastiodispatch">__RxFillAndInstallFastIoDispatch</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nf-mrx-rxstartminirdr">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/mrx/nf-mrx-rxstartminirdr.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
