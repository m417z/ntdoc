<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_RECEIVE_FROM - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_RECEIVE_FROM - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_RECEIVE_FROM - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wsk.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">PFN_WSK_RECEIVE_FROM PfnWskReceiveFrom;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskReceiveFrom(
  [in]            <a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">PWSK_SOCKET</a> Socket,
  [in]            <a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">PWSK_BUF</a> Buffer,
                  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags,
  [out, optional] PSOCKADDR RemoteAddress,
  [in, out]       PULONG ControlLength,
  [out, optional] PCMSGHDR ControlInfo,
  [out, optional] PULONG ControlFlags,
  [in, out]       PIRP Irp
)
{...}</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_from">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_receive_from.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_receive_from)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>PFN_WSK_RECEIVE_FROM callback function</h1>
<h2>Description</h2>
<p>The
<strong>WskReceiveFrom</strong> function receives a datagram and any associated control information from a remote
transport address.</p>
<h2>Parameters</h2>
<h3><code>Socket</code> [in]</h3>
<p>A pointer to a
<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a> structure that specifies the socket
object for the datagram socket from which to receive the datagram.</p>
<h3><code>Buffer</code> [in]</h3>
<p>A pointer to an initialized
<a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">WSK_BUF</a> structure that describes the data buffer
that receives the datagram from the socket.</p>
<h3><code>Flags</code></h3>
<p>This parameter is reserved for system use. A WSK application must set this parameter to
zero.</p>
<h3><code>RemoteAddress</code> [out, optional]</h3>
<p>A pointer to a caller-allocated buffer that receives the remote transport address from which the
received datagram originated. The buffer must be located in non-paged memory. The buffer must also be
large enough to contain the specific SOCKADDR structure type that corresponds to the address family that
the WSK application specified when it created the datagram socket. This pointer is optional and can be
<strong>NULL</strong>.</p>
<h3><code>ControlLength</code> [in, out]</h3>
<p>A pointer to a <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> that specifies the size of the buffer that is pointed to by the <strong>ControlInfo</strong> parameter. When the receive operation is complete, the variable receives the size of the control information that is associated with the received datagram. If the value that is returned is zero, there is no control information present for the datagram. This pointer is optional and can be <strong>NULL</strong>. If this parameter is <strong>NULL</strong>, the <strong>ControlInfo</strong> parameter is ignored.</p>
<h3><code>ControlInfo</code> [out, optional]</h3>
<p>A pointer to a caller-allocated buffer that receives the control information that is associated
with the received datagram. The control information data that is associated with a datagram is made up
of one or more control data objects, each of which begins with a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-wsacmsghdr">CMSGHDR</a> structure. If there is no control
information present for the received datagram, the contents of the buffer are undefined. This pointer is
optional and can be <strong>NULL</strong>. If the
<strong>ControlInfoLength</strong> parameter is <strong>NULL</strong>, the
<strong>ControlInfo</strong> parameter should be <strong>NULL</strong>.</p>
<h3><code>ControlFlags</code> [out, optional]</h3>
<p>A pointer to a <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>-typed variable that receives the bitwise OR of a combination of the following
flags:</p>
<h4>MSG_BCAST</h4>
<p>The datagram was received as a link-layer broadcast or with a destination transport address that
is a broadcast address.</p>
<h4>MSG_MCAST</h4>
<p>The datagram was received with a destination transport address that is a multicast
address.</p>
<h4>MSG_TRUNC</h4>
<p>The datagram was truncated because the size of the datagram was larger than the size of the
buffer that is specified by the
<strong>Buffer</strong> parameter.</p>
<h4>MSG_CTRUNC</h4>
<p>The control information data was truncated because the number of bytes of control information
was greater than the size of the buffer that is specified by the
<strong>ControlInfo</strong> parameter.</p>
<p>This parameter is optional and can be <strong>NULL</strong>.</p>
<h3><code>Irp</code> [in, out]</h3>
<p>A pointer to a caller-allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that the WSK subsystem uses to complete the receive operation
asynchronously. For more information about using IRPs with WSK functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions">Using IRPs with Winsock
Kernel Functions</a>.</p>
<h2>Return value</h2>
<p><strong>WskReceiveFrom</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
<td>Data was successfully received from the socket. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with success status. The <strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> contains the number of bytes that were received.</td>
</tr>
<tr>
<td><strong>STATUS_PENDING</strong></td>
<td>The WSK subsystem could not receive the datagram from the socket immediately. The WSK subsystem will complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> after it has received the datagram from the socket. The status of the receive operation will be returned in the <strong>IoStatus.Status</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. If the operation succeeds, the <strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will contain the number of bytes that were received.</td>
</tr>
<tr>
<td><strong>STATUS_FILE_FORCED_CLOSED</strong></td>
<td>The socket is no longer functional. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status. The WSK application must call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a> function to close the socket as soon as possible.</td>
</tr>
<tr>
<td><strong>Other status codes</strong></td>
<td>An error occurred. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>If the WSK application has set a fixed remote transport address for the datagram socket, datagrams
that are received from any other remote transport address will be discarded by the WSK subsystem. For
more information about setting the remote transport address for a datagram socket, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-set-remote-address">SIO_WSK_SET_REMOTE_ADDRESS</a>.</p>
<p>If a WSK application's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_from_event">WskReceiveFromEvent</a> event callback
function is enabled on a datagram socket and the application also has a pending call to the
<strong>WskReceiveFrom</strong> function on the same datagram socket, then, when datagrams arrive, the pending call
to the
<strong>WskReceiveFrom</strong> function will take precedence over the
<strong>WskReceiveFromEvent</strong> event callback function. The WSK subsystem calls the application's
<strong>WskReceiveFromEvent</strong> event callback function only if there are no IRPs queued from pending calls to
the
<strong>WskReceiveFrom</strong> function. However, a WSK application should not assume that the WSK subsystem will
not call the application's
<strong>WskReceiveFromEvent</strong> event callback function for a datagram socket that has a pending call to the
<strong>WskReceiveFrom</strong> function. Race conditions exist where the WSK subsystem could still call the WSK
application's
<strong>WskReceiveFromEvent</strong> event callback function for the socket. The only way for a WSK application to
ensure that the WSK subsystem will not call the application's
<strong>WskReceiveFromEvent</strong> event callback function on a datagram socket is to disable the application's
<strong>WskReceiveFromEvent</strong> event callback function on the socket.</p>
<p>If the
<strong>WskReceiveFrom</strong> function returns STATUS_PENDING, the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> chain that is described in the
<a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">WSK_BUF</a> structure that is pointed to by the
<strong>Buffer</strong> parameter must remain locked in memory until the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed. In addition, the variable
that is pointed to by the
<strong>ControlInfoLength</strong> parameter, the buffer that is pointed to by the
<strong>ControlInfo</strong> parameter, and the variable that is pointed to by the
<strong>ControlFlags</strong> parameter must also remain valid until the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed. If the WSK application
allocated these buffers or variables with one of the
<strong>ExAllocate__Xxx__</strong> functions, it cannot free the memory with the corresponding
<strong>ExFree__Xxx__</strong> function until after the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed. If the WSK application allocated these buffers or
variables on the stack, it cannot return from the function that calls the
<strong>WskReceiveFrom</strong> function until after the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-wsacmsghdr">CMSGHDR</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/sio-wsk-set-remote-address">SIO_WSK_SET_REMOTE_ADDRESS</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-sockaddr">SOCKADDR</a></p>
<p><a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">WSK_BUF</a></p>
<p><a href="wsk_provider_datagram_dispatch" title="typedef struct _WSK_PROVIDER_DATAGRAM_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH              Basic;&#10;  PFN_WSK_BIND                             WskBind;&#10;  PFN_WSK_SEND_TO                          WskSendTo;&#10;  PFN_WSK_RECEIVE_FROM                     WskReceiveFrom;&#10;  PFN_WSK_RELEASE_DATAGRAM_INDICATION_LIST WskRelease;&#10;  PFN_WSK_GET_LOCAL_ADDRESS                WskGetLocalAddress;&#10;  PFN_WSK_SEND_MESSAGES                    WskSendMessages;&#10;} WSK_PROVIDER_DATAGRAM_DISPATCH, *PWSK_PROVIDER_DATAGRAM_DISPATCH;">WSK_PROVIDER_DATAGRAM_DISPATCH</a></p>
<p><a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_socket">WskControlSocket</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_from_event">WskReceiveFromEvent</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_send_to">WskSendTo</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_from">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_receive_from.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
