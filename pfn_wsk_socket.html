<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_SOCKET - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_SOCKET - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_SOCKET - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFN_WSK_SOCKET PfnWskSocket;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskSocket(
  [in]           PWSK_CLIENT Client,
  [in]           <a href="address_family" title="typedef USHORT ADDRESS_FAMILY;">ADDRESS_FAMILY</a> AddressFamily,
  [in]           <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> SocketType,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Protocol,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags,
  [in, optional] PVOID SocketContext,
  [in, optional] const VOID *Dispatch,
  [in, optional] PEPROCESS OwningProcess,
  [in, optional] PETHREAD OwningThread,
  [in, optional] PSECURITY_DESCRIPTOR SecurityDescriptor,
  [in, out]      PIRP Irp
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_socket.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_socket)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfn_wsk_socket-callback-function">PFN_WSK_SOCKET callback function</h1>

<h2 id="description">Description</h2>

<p>The
<strong>WskSocket</strong> function creates a new socket and returns a pointer to the associated socket object.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="client-in"><code>Client</code> [in]</h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-client">WSK_CLIENT</a> structure that was returned through
the
<em>WskProviderNpi</em> parameter of the
<a href="wskcaptureprovidernpi" title="NTSTATUS WskCaptureProviderNPI(&#10;  [in]  PWSK_REGISTRATION WskRegistration,&#10;  [in]  ULONG             WaitTimeout,&#10;  [out] PWSK_PROVIDER_NPI WskProviderNpi&#10;);">WskCaptureProviderNPI</a> function.</p>

<h3 id="addressfamily-in"><code>AddressFamily</code> [in]</h3>

<p>The address family for the socket that is being created. For more information about supported
address families, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/ws2def-h">WSK Address Families</a>.</p>

<h3 id="sockettype-in"><code>SocketType</code> [in]</h3>

<p>The type of socket that is being created. The following socket types are supported:</p>

<h4 id="sock_stream">SOCK_STREAM</h4>

<p>Supports reliable connection-oriented byte stream communication.</p>

<h4 id="sock_dgram">SOCK_DGRAM</h4>

<p>Supports unreliable connectionless datagram communication.</p>

<h4 id="sock_raw">SOCK_RAW</h4>

<p>Supports raw access to the transport protocol.</p>

<p>For more information about the socket types that are supported for each supported address family, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/ws2def-h">WSK Address Families</a>.</p>

<h3 id="protocol-in"><code>Protocol</code> [in]</h3>

<p>The transport protocol for the socket that is being created. For more information about the
protocols that are supported for each supported address family, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/ws2def-h">WSK Address Families</a>.</p>

<h3 id="flags-in"><code>Flags</code> [in]</h3>

<p>A flag that specifies the WSK
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/winsock-kernel-socket-categories">socket category</a> for the
socket that is being created. This parameter can be one of the following flags:</p>

<h4 id="wsk_flag_basic_socket">WSK_FLAG_BASIC_SOCKET</h4>

<p>A basic socket will be created that can be used only to get and set transport stack socket
options or to perform socket I/O control operations.</p>

<h4 id="wsk_flag_listen_socket">WSK_FLAG_LISTEN_SOCKET</h4>

<p>A listening socket will be created that can be used to listen for incoming connections from
remote transport addresses.</p>

<h4 id="wsk_flag_datagram_socket">WSK_FLAG_DATAGRAM_SOCKET</h4>

<p>A datagram socket will be created that can be used to send and receive datagrams.</p>

<h4 id="wsk_flag_connection_socket">WSK_FLAG_CONNECTION_SOCKET</h4>

<p>A connection-oriented socket will be created that can be used to send and receive network data
over a connection.</p>

<h4 id="wsk_flag_stream_socket">WSK_FLAG_STREAM_SOCKET</h4>

<p>A stream socket will be created that can either be used to listen for incoming connections from remote transport addresses, or send and receive network data over a connection.</p>

<p>If a WSK application does not specify any of the preceding flags,
<strong>WskSocket</strong> creates a basic socket.</p>

<h3 id="socketcontext-in-optional"><code>SocketContext</code> [in, optional]</h3>

<p>A pointer to a caller-supplied context for the socket that is being created. The WSK subsystem
passes this pointer to the socket's event callback functions. The context information is opaque to the
WSK subsystem and must be stored in non-paged memory. If the WSK application will not be enabling any
event callback functions on the new socket, it should set this pointer to <strong>NULL</strong>. For a basic socket, this
pointer should always be <strong>NULL</strong>.</p>

<h3 id="dispatch-in-optional"><code>Dispatch</code> [in, optional]</h3>

<p>A pointer to a constant client dispatch structure. This structure is a dispatch table that
contains pointers to the event callback functions for the new socket. Depending on the WSK
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/winsock-kernel-socket-categories">socket category</a> of the socket
(as specified by the
<em>Flags</em> parameter), this parameter is a pointer to one of the following structures.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Dispatch table structure</th>
</tr>
</thead>
<tbody>
<tr>
  <td>WSK_FLAG_LISTEN_SOCKET</td>
  <td><a href="wsk_client_listen_dispatch" title="typedef struct _WSK_CLIENT_LISTEN_DISPATCH {&#10;  PFN_WSK_ACCEPT_EVENT  WskAcceptEvent;&#10;  PFN_WSK_INSPECT_EVENT WskInspectEvent;&#10;  PFN_WSK_ABORT_EVENT   WskAbortEvent;&#10;} WSK_CLIENT_LISTEN_DISPATCH, *PWSK_CLIENT_LISTEN_DISPATCH;">WSK_CLIENT_LISTEN_DISPATCH</a></td>
</tr>
<tr>
  <td>WSK_FLAG_DATAGRAM_SOCKET</td>
  <td><a href="wsk_client_datagram_dispatch" title="typedef struct _WSK_CLIENT_DATAGRAM_DISPATCH {&#10;  PFN_WSK_RECEIVE_FROM_EVENT WskReceiveFromEvent;&#10;} WSK_CLIENT_DATAGRAM_DISPATCH, *PWSK_CLIENT_DATAGRAM_DISPATCH;">WSK_CLIENT_DATAGRAM_DISPATCH</a></td>
</tr>
<tr>
  <td>WSK_FLAG_CONNECTION_SOCKET</td>
  <td><a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a></td>
</tr>
<tr>
  <td>WSK_FLAG_STREAM_SOCKET</td>
  <td><a href="wsk_client_stream_dispatch" title="typedef struct _WSK_CLIENT_STREAM_DISPATCH {&#10;  const WSK_CLIENT_LISTEN_DISPATCH     *Listen;&#10;  const WSK_CLIENT_CONNECTION_DISPATCH *Connect;&#10;} WSK_CLIENT_STREAM_DISPATCH, *PWSK_CLIENT_STREAM_DISPATCH;">WSK_CLIENT_STREAM_DISPATCH</a></td>
</tr>
</tbody>
</table>

<p>If the WSK application will not be enabling all of the event callback functions for the new socket,
it should set the pointers in the dispatch table to <strong>NULL</strong> for those event callback functions that it does
not enable. If the WSK application will not be enabling any event callback functions on the new socket,
it should set the
<em>Dispatch</em> pointer to <strong>NULL</strong>. For a basic socket, this pointer should always be <strong>NULL</strong>.</p>

<h3 id="owningprocess-in-optional"><code>OwningProcess</code> [in, optional]</h3>

<p>A pointer to the process from which the WSK subsystem will retrieve the security context to use
when it binds the socket. The WSK subsystem uses the security context to determine whether the local
transport address can be shared if that address is already in use. To specify the current process, a WSK
application sets this pointer to <strong>NULL</strong>.</p>

<h3 id="owningthread-in-optional"><code>OwningThread</code> [in, optional]</h3>

<p>A pointer to a specific thread from which the WSK subsystem will retrieve the security context to
use when it binds the socket. The WSK subsystem uses the security context to determine whether the local
transport address can be shared if that address is already in use. If a WSK application does not need to
specify a specific thread, it sets this pointer to <strong>NULL</strong>.</p>

<h3 id="securitydescriptor-in-optional"><code>SecurityDescriptor</code> [in, optional]</h3>

<p>A pointer to a <a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> structure that specifies the security descriptor to apply to
the socket that is being created. The security descriptor controls the sharing of the local transport
address to which the socket is bound. If a WSK application specifies a non-**NULL** pointer, it must specify
a pointer to a cached copy of a security descriptor that was obtained by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a> function with the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-cache-sd">WSK_CACHE_SD</a> control code. To specify a
default security descriptor that does not allow sharing of the local transport address, a WSK
application sets
<em>SecurityDescriptor</em> to <strong>NULL</strong>.</p>

<p>For more information about the <a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> structure, see the reference page for
<a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> in the Microsoft Windows SDK documentation.</p>

<h3 id="irp-in-out"><code>Irp</code> [in, out]</h3>

<p>A pointer to a caller-allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that the WSK subsystem uses to complete the creation of the
new socket asynchronously. For more information about using IRPs with WSK functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions">Using IRPs with Winsock
Kernel Functions</a>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>WskSocket</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The new socket was successfully created. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with success status.</td>
</tr>
<tr>
  <td><strong>STATUS_PENDING</strong></td>
  <td>The WSK subsystem could not create the socket immediately. The WSK subsystem will complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> after it has created the new socket. The status of the socket creation will be returned in the <strong>IoStatus.Status</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><strong>Other status codes</strong></td>
  <td>An error occurred. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>If the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed with success status, the
<strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> contains a pointer to a socket object structure (
<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a>) for the new socket.</p>

<p>A WSK application can obtain a list of available transport protocols by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a> function with the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-transport-list-query">WSK_TRANSPORT_LIST_QUERY</a> control
code.
**WskControlClient** returns a list of
<a href="wsk_transport" title="typedef struct _WSK_TRANSPORT {&#10;  USHORT         Version;&#10;  USHORT         SocketType;&#10;  ULONG          Protocol;&#10;  ADDRESS_FAMILY AddressFamily;&#10;  GUID           ProviderId;&#10;} WSK_TRANSPORT, *PWSK_TRANSPORT;">WSK_TRANSPORT</a> structures that contains all of
the valid combinations of the
<em>AddressFamily</em>,
<em>SocketType</em>, and
<em>Protocol</em> parameters.</p>

<p>When a WSK application successfully creates a new socket, all of the event callback functions on the
new socket are disabled by default. For more information about enabling any of the new socket's event
callback functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/evntprov/nc-evntprov-penablecallback">Enabling and
Disabling Event Callback Functions</a>.</p>

<p>If a WSK application specifies a non-<strong>NULL</strong> pointer for the
<em>SecurityDescriptor</em> parameter, it must not release the cached security descriptor until after the
<a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed.</p>

<p>The WSK subsystem allocates the memory for the socket object structure (<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a>) for the new socket
on behalf of the WSK application. The WSK subsystem deallocates this memory when the socket is
closed.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-client">WSK_CLIENT</a></p>

<p><a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a></p>

<p><a href="wsk_client_datagram_dispatch" title="typedef struct _WSK_CLIENT_DATAGRAM_DISPATCH {&#10;  PFN_WSK_RECEIVE_FROM_EVENT WskReceiveFromEvent;&#10;} WSK_CLIENT_DATAGRAM_DISPATCH, *PWSK_CLIENT_DATAGRAM_DISPATCH;">WSK_CLIENT_DATAGRAM_DISPATCH</a></p>

<p><a href="wsk_client_listen_dispatch" title="typedef struct _WSK_CLIENT_LISTEN_DISPATCH {&#10;  PFN_WSK_ACCEPT_EVENT  WskAcceptEvent;&#10;  PFN_WSK_INSPECT_EVENT WskInspectEvent;&#10;  PFN_WSK_ABORT_EVENT   WskAbortEvent;&#10;} WSK_CLIENT_LISTEN_DISPATCH, *PWSK_CLIENT_LISTEN_DISPATCH;">WSK_CLIENT_LISTEN_DISPATCH</a></p>

<p><a href="wsk_client_stream_dispatch" title="typedef struct _WSK_CLIENT_STREAM_DISPATCH {&#10;  const WSK_CLIENT_LISTEN_DISPATCH     *Listen;&#10;  const WSK_CLIENT_CONNECTION_DISPATCH *Connect;&#10;} WSK_CLIENT_STREAM_DISPATCH, *PWSK_CLIENT_STREAM_DISPATCH;">WSK_CLIENT_STREAM_DISPATCH</a></p>

<p><a href="wsk_provider_dispatch" title="typedef struct _WSK_PROVIDER_DISPATCH {&#10;  USHORT                    Version;&#10;  USHORT                    Reserved;&#10;  PFN_WSK_SOCKET            WskSocket;&#10;  PFN_WSK_SOCKET_CONNECT    WskSocketConnect;&#10;  PFN_WSK_CONTROL_CLIENT    WskControlClient;&#10;  PFN_WSK_GET_ADDRESS_INFO  WskGetAddressInfo;&#10;  PFN_WSK_FREE_ADDRESS_INFO WskFreeAddressInfo;&#10;  PFN_WSK_GET_NAME_INFO     WskGetNameInfo;&#10;} WSK_PROVIDER_DISPATCH, *PWSK_PROVIDER_DISPATCH;">WSK_PROVIDER_DISPATCH</a></p>

<p><a href="wsk_provider_npi" title="typedef struct _WSK_PROVIDER_NPI {&#10;  PWSK_CLIENT                 Client;&#10;  const WSK_PROVIDER_DISPATCH *Dispatch;&#10;} WSK_PROVIDER_NPI, *PWSK_PROVIDER_NPI;">WSK_PROVIDER_NPI</a></p>

<p><a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a></p>

<p><a href="wskcaptureprovidernpi" title="NTSTATUS WskCaptureProviderNPI(&#10;  [in]  PWSK_REGISTRATION WskRegistration,&#10;  [in]  ULONG             WaitTimeout,&#10;  [out] PWSK_PROVIDER_NPI WskProviderNpi&#10;);">WskCaptureProviderNPI</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">WskSocketConnect</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_socket.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
