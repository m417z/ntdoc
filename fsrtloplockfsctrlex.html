<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FsRtlOplockFsctrlEx - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FsRtlOplockFsctrlEx - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FsRtlOplockFsctrlEx - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FsRtlOplockFsctrlEx(
  [in] POPLOCK Oplock,
  [in] PIRP    Irp,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>   OpenCount,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>   Flags
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtloplockfsctrlex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fsrtloplockfsctrlex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-_fsrtl_advanced_fcb_header-fsrtloplockfsctrlex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FsRtlOplockFsctrlEx function</h1>
<h2>Description</h2>
<p>The <strong>FsRtlOplockFsctrlEx</strong> routine performs various opportunistic lock (oplock) operations on behalf of a file system or filter driver.</p>
<h2>Parameters</h2>
<h3><code>Oplock</code> [in]</h3>
<p>Opaque oplock pointer for the file. This pointer must have been initialized by a previous call to <strong><a href="fsrtlinitializeoplock" title="VOID FsRtlInitializeOplock(&#10;  [in, out] POPLOCK Oplock&#10;);">FsRtlInitializeOplock</a></strong>.</p>
<h3><code>Irp</code> [in]</h3>
<p>Pointer to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for the I/O operation. This parameter is required and cannot be <strong>NULL</strong>.</p>
<h3><code>OpenCount</code> [in]</h3>
<p>Number of user handles for the file, if an exclusive oplock is being requested. Setting a nonzero value for a level 2, R, or RH oplock request indicates that there are byte-range locks on the file. For information about oplock types, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-overview">Oplock Overview</a>.</p>
<h3><code>Flags</code> [in]</h3>
<p>A bitmask for the associated oplock operations. A file system or filter driver sets bits to specify the behavior of <strong>FsRtlOplockFsctrlEx</strong>. This parameter has the following options:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPLOCK_FSCTRL_FLAG_ALL_KEYS_MATCH (0x00000001)</td>
<td>The file system verified that all oplock keys on any currently open handles match. By specifying this flag, you allow the oplock package to grant an oplock of level RW or RWH when more than one open handle to the file exists. For more information about oplock types, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-overview">Oplock Overview</a>.</td>
</tr>
</tbody>
</table>
<h2>Return value</h2>
<p><strong>FsRtlOplockFsctrlEx</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> values:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></td>
<td>For an <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request, <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> indicates that the requested filter oplock was granted. For a FSCTL operation, the meaning of <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> depends on the FSCTL code. For more information, see the reference pages for the FSCTL codes listed in the following Remarks section.</td>
</tr>
<tr>
<td>STATUS_CANCELLED</td>
<td>The I/O operation was canceled. STATUS_CANCELLED is an error code.</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>The FSCTL code for the I/O operation was not one of the valid values listed in the following Remarks section. STATUS_INVALID_PARAMETER is an error code.</td>
</tr>
<tr>
<td>STATUS_OPLOCK_NOT_GRANTED</td>
<td>The oplock could not be granted. STATUS_OPLOCK_NOT_GRANTED is an error code.</td>
</tr>
<tr>
<td>STATUS_PENDING</td>
<td>Used only for FSCTL operations. The meaning of STATUS_PENDING depends on the FSCTL code. For more information, see the reference pages for the FSCTL codes listed in the following Remarks section. STATUS_PENDING is a success code.</td>
</tr>
<tr>
<td>STATUS_CANNOT_BREAK_OPLOCK</td>
<td>A new oplock could not be granted. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is an <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request and <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> was specified in the create options parameter for the operation. STATUS_CANNOT_BREAK_OPLOCK is a success code.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>File systems and legacy filter drivers call <strong>FsRtlOplockFsctrlEx</strong> to perform various oplock operations for a create or file system control I/O operation. Minifilters should call <strong><a href="fltoplockfsctrlex" title="FLT_PREOP_CALLBACK_STATUS FLTAPI FltOplockFsctrlEx(&#10;  [in] POPLOCK            Oplock,&#10;  [in] PFLT_CALLBACK_DATA CallbackData,&#10;  [in] ULONG              OpenCount,&#10;  [in] ULONG              Flags&#10;);">FltOplockFsctrlEx</a></strong> instead of <strong>FsRtlOplockFsctrlEx</strong>.</p>
<p>The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> pointed to by the <em>Irp</em> parameter must be a valid <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control">IRP_MJ_FILE_SYSTEM_CONTROL</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create">IRP_MJ_CREATE</a> operation.</p>
<p>If the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control">IRP_MJ_FILE_SYSTEM_CONTROL</a> request, <strong>FsRtlOplockFsctrlEx</strong> can be used with one of the following FSCTL codes, which is set in <em>IrpSp-&gt;Parameters.FileSystemControl.FsControlCode</em>:</p>
<ul>
<li>
<a href="fsctl_opbatch_ack_close_pending" title="// CTL_CODE(0x0009, 0x004, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPBATCH_ACK_CLOSE_PENDING 0x00090010">FSCTL_OPBATCH_ACK_CLOSE_PENDING</a>
</li>
<li>
<a href="fsctl_oplock_break_ack_no_2" title="// CTL_CODE(0x0009, 0x014, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_ACK_NO_2 0x00090050">FSCTL_OPLOCK_BREAK_ACK_NO_2</a>
</li>
<li>
<a href="fsctl_oplock_break_acknowledge" title="// CTL_CODE(0x0009, 0x003, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE 0x0009000C">FSCTL_OPLOCK_BREAK_ACKNOWLEDGE</a>
</li>
<li>
<a href="fsctl_oplock_break_notify" title="// CTL_CODE(0x0009, 0x005, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_NOTIFY 0x00090014">FSCTL_OPLOCK_BREAK_NOTIFY</a>
</li>
<li>
<a href="fsctl_request_batch_oplock" title="// CTL_CODE(0x0009, 0x002, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_BATCH_OPLOCK 0x00090008">FSCTL_REQUEST_BATCH_OPLOCK</a>
</li>
<li>
<a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a>
</li>
<li>
<a href="fsctl_request_oplock_level_1" title="// CTL_CODE(0x0009, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_1 0x00090000">FSCTL_REQUEST_OPLOCK_LEVEL_1</a>
</li>
<li>
<a href="fsctl_request_oplock_level_2" title="// CTL_CODE(0x0009, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_2 0x00090004">FSCTL_REQUEST_OPLOCK_LEVEL_2</a>
</li>
<li>
<a href="fsctl_request_oplock" title="// CTL_CODE(0x0009, 0x090, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK 0x00090240">FSCTL_REQUEST_OPLOCK</a>
</li>
</ul>
<p>For more information about these FSCTLs and about opportunistic locks in general, see the Microsoft Windows SDK documentation.</p>
<p>If the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is an <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request, <strong>FsRtlOplockFsctrlEx</strong> can be used to request a pending filter oplock if all of the following conditions are true:</p>
<ul>
<li>
The value of the <em>OpenCount</em> parameter must be 1.
</li>
<li>
The value of the <em>DesiredAccess</em> parameter for the <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request must be FILE_READ_ATTRIBUTES.
</li>
<li>
The value of the <em>ShareAccess</em> parameter for the <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request must be <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>.
</li>
</ul>
<p>If the request for a pending filter oplock is granted, <strong>FsRtlOplockFsctrlEx</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. For more information about create parameters, see the reference entry for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create">IRP_MJ_CREATE</a>.</p>
<p>Filters and file systems that call this function must synchronize calls into the system-supplied oplock package. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-synchronization">Oplock synchronization</a> for more information.</p>
<h2>See also</h2>
<p><a href="fsctl_opbatch_ack_close_pending" title="// CTL_CODE(0x0009, 0x004, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPBATCH_ACK_CLOSE_PENDING 0x00090010">FSCTL_OPBATCH_ACK_CLOSE_PENDING</a></p>
<p><a href="fsctl_oplock_break_acknowledge" title="// CTL_CODE(0x0009, 0x003, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE 0x0009000C">FSCTL_OPLOCK_BREAK_ACKNOWLEDGE</a></p>
<p><a href="fsctl_oplock_break_ack_no_2" title="// CTL_CODE(0x0009, 0x014, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_ACK_NO_2 0x00090050">FSCTL_OPLOCK_BREAK_ACK_NO_2</a></p>
<p><a href="fsctl_oplock_break_notify" title="// CTL_CODE(0x0009, 0x005, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_OPLOCK_BREAK_NOTIFY 0x00090014">FSCTL_OPLOCK_BREAK_NOTIFY</a></p>
<p><a href="fsctl_request_batch_oplock" title="// CTL_CODE(0x0009, 0x002, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_BATCH_OPLOCK 0x00090008">FSCTL_REQUEST_BATCH_OPLOCK</a></p>
<p><a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a></p>
<p><a href="fsctl_request_oplock" title="// CTL_CODE(0x0009, 0x090, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK 0x00090240">FSCTL_REQUEST_OPLOCK</a></p>
<p><a href="fsctl_request_oplock_level_1" title="// CTL_CODE(0x0009, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_1 0x00090000">FSCTL_REQUEST_OPLOCK_LEVEL_1</a></p>
<p><a href="fsctl_request_oplock_level_2" title="// CTL_CODE(0x0009, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_2 0x00090004">FSCTL_REQUEST_OPLOCK_LEVEL_2</a></p>
<p><strong><a href="fltoplockfsctrl" title="FLT_PREOP_CALLBACK_STATUS FLTAPI FltOplockFsctrl(&#10;  [in] POPLOCK            Oplock,&#10;  [in] PFLT_CALLBACK_DATA CallbackData,&#10;  [in] ULONG              OpenCount&#10;);">FltOplockFsctrl</a></strong></p>
<p><strong><a href="fsrtlinitializeoplock" title="VOID FsRtlInitializeOplock(&#10;  [in, out] POPLOCK Oplock&#10;);">FsRtlInitializeOplock</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create">IRP_MJ_CREATE</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control">IRP_MJ_FILE_SYSTEM_CONTROL</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtloplockfsctrlex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtloplockfsctrlex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
