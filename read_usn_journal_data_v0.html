<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="READ_USN_JOURNAL_DATA_V0 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>READ_USN_JOURNAL_DATA_V0 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            READ_USN_JOURNAL_DATA_V0 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct {
  USN       StartUsn;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     ReasonMask;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     ReturnOnlyOnClose;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> Timeout;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> BytesToWaitFor;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a> UsnJournalID;
} READ_USN_JOURNAL_DATA_V0, *PREAD_USN_JOURNAL_DATA_V0;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ns-ntifs-read_usn_journal_data_v0">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winioctl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct {
  USN       StartUsn;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>     ReasonMask;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>     ReturnOnlyOnClose;
  <a href="dwordlong" title="typedef unsigned __int64 DWORDLONG;">DWORDLONG</a> Timeout;
  <a href="dwordlong" title="typedef unsigned __int64 DWORDLONG;">DWORDLONG</a> BytesToWaitFor;
  <a href="dwordlong" title="typedef unsigned __int64 DWORDLONG;">DWORDLONG</a> UsnJournalID;
} READ_USN_JOURNAL_DATA_V0, *PREAD_USN_JOURNAL_DATA_V0;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ns-winioctl-read_usn_journal_data_v0">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/read_usn_journal_data_v0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ntifs-read_usn_journal_data_v0)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>READ_USN_JOURNAL_DATA_V0</strong> structure contains information defining a set of update sequence number (USN) change journal records to return to the calling process. It is used by the <strong><a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a></strong> and <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> control codes. Prior to Windows 8 and Windows Server 2012 this structure was named <strong>READ_USN_JOURNAL_DATA</strong>. Windows Server 2012 introduced <strong><a href="read_usn_journal_data_v1" title="typedef struct {&#10;  USN       StartUsn;&#10;  ULONG     ReasonMask;&#10;  ULONG     ReturnOnlyOnClose;&#10;  ULONGLONG Timeout;&#10;  ULONGLONG BytesToWaitFor;&#10;  ULONGLONG UsnJournalID;&#10;  USHORT    MinMajorVersion;&#10;  USHORT    MaxMajorVersion;&#10;} READ_USN_JOURNAL_DATA_V1, *PREAD_USN_JOURNAL_DATA_V1;">READ_USN_JOURNAL_DATA_V1</a></strong> to support 128-bit file identifiers used by ReFS.</p>

<h2 id="members">Members</h2>

<h3 id="startusn"><code>StartUsn</code></h3>

<p>The USN at which to begin reading the change journal.</p>

<p>To start the read operation at the first record in the journal, set the <strong>StartUsn</strong> member to zero. Because a USN is contained in every journal record, the output buffer tells at which record the read operation actually started.</p>

<p>To start the read operation at a specific record, set <strong>StartUsn</strong> to that record USN.</p>

<p>If a nonzero USN is specified that is less than the first USN in the change journal, then an error occurs and the ERROR_JOURNAL_ENTRY_DELETED error code is returned. This code may indicate a case in which the specified USN is valid at one time but has since been deleted.</p>

<p>For more information on navigating the change journal buffer returned in <strong>READ_USN_JOURNAL_DATA_V0</strong>, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/walking-a-buffer-of-change-journal-records">Walking a Buffer of Change Journal Records</a>.</p>

<h3 id="reasonmask"><code>ReasonMask</code></h3>

<p>A mask of flags, each flag noting a change for which the file or directory has a record in the change journal. To be returned in a <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation, a change journal record must have at least one of these flags set.</p>

<p>The list of valid flags is as follows. Unused bits are reserved.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>USN_REASON_BASIC_INFO_CHANGE (0x00008000)</td>
  <td>A user has either changed one or more file or directory attributes (such as the read-only, hidden, system, archive, or sparse attribute), or one or more time stamps.</td>
</tr>
<tr>
  <td>USN_REASON_CLOSE (0x80000000)</td>
  <td>The file or directory is closed.</td>
</tr>
<tr>
  <td>USN_REASON_COMPRESSION_CHANGE (0x00020000)</td>
  <td>The compression state of the file or directory is changed from or to compressed.</td>
</tr>
<tr>
  <td>USN_REASON_DATA_EXTEND (0x00000002)</td>
  <td>The file or directory is added to.</td>
</tr>
<tr>
  <td>USN_REASON_DATA_OVERWRITE (0x00000001)</td>
  <td>Data in the file or directory is overwritten.</td>
</tr>
<tr>
  <td>USN_REASON_DATA_TRUNCATION (0x00000004)</td>
  <td>The file or directory is truncated.</td>
</tr>
<tr>
  <td>USN_REASON_EA_CHANGE (0x00000400)</td>
  <td>The user makes a change to the file or directory extended attributes. These NTFS file system attributes are not accessible to Windows-based applications.</td>
</tr>
<tr>
  <td>USN_REASON_ENCRYPTION_CHANGE (0x00040000)</td>
  <td>The file or directory is encrypted or decrypted.</td>
</tr>
<tr>
  <td>USN_REASON_FILE_CREATE (0x00000100)</td>
  <td>The file or directory is created for the first time.</td>
</tr>
<tr>
  <td>USN_REASON_FILE_DELETE (0x00000200)</td>
  <td>The file or directory is deleted.</td>
</tr>
<tr>
  <td>USN_REASON_HARD_LINK_CHANGE (0x00010000)</td>
  <td>An NTFS file system hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX hard link, is one of several directory entries that see the same file or directory.</td>
</tr>
<tr>
  <td>USN_REASON_INDEXABLE_CHANGE (0x00004000)</td>
  <td>A user changed the FILE_ATTRIBUTE_NOT_CONTENT_INDEXED attribute. That is, the user changed the file or directory from one that can be content indexed to one that cannot, or vice versa. (Content indexing permits rapid searching of data by building a database of selected content.)</td>
</tr>
<tr>
  <td>USN_REASON_NAMED_DATA_EXTEND (0x00000020)</td>
  <td>One or more named data streams for the file were added to.</td>
</tr>
<tr>
  <td>USN_REASON_NAMED_DATA_OVERWRITE (0x00000010)</td>
  <td>Data in one or more named data streams for the file is overwritten.</td>
</tr>
<tr>
  <td>USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)</td>
  <td>One or more named data streams for the file is truncated.</td>
</tr>
<tr>
  <td>USN_REASON_OBJECT_ID_CHANGE (0x00080000)</td>
  <td>The object identifier of the file or directory is changed.</td>
</tr>
<tr>
  <td>USN_REASON_RENAME_NEW_NAME (0x00002000)</td>
  <td>The file or directory is renamed, and the file name in the <a href="usn_record_v2" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  ULONGLONG     FileReferenceNumber;&#10;  ULONGLONG     ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V2, *PUSN_RECORD_V2;">USN_RECORD_V2</a> or <a href="usn_record_v3" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  FILE_ID_128   FileReferenceNumber;&#10;  FILE_ID_128   ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V3, *PUSN_RECORD_V3;">USN_RECORD_V3</a> structure holding this journal record is the new name.</td>
</tr>
<tr>
  <td>USN_REASON_RENAME_OLD_NAME (0x00001000)</td>
  <td>The file or directory is renamed, and the file name in the <a href="usn_record_v2" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  ULONGLONG     FileReferenceNumber;&#10;  ULONGLONG     ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V2, *PUSN_RECORD_V2;">USN_RECORD_V2</a> or <a href="usn_record_v3" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  FILE_ID_128   FileReferenceNumber;&#10;  FILE_ID_128   ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V3, *PUSN_RECORD_V3;">USN_RECORD_V3</a> structure holding this journal record is the previous name.</td>
</tr>
<tr>
  <td>USN_REASON_REPARSE_POINT_CHANGE (0x00100000)</td>
  <td>The reparse point contained in the file or directory is changed, or a reparse point is added to or deleted from the file or directory.</td>
</tr>
<tr>
  <td>USN_REASON_SECURITY_CHANGE (0x00000800)</td>
  <td>A change is made in the access permissions to the file or directory.</td>
</tr>
<tr>
  <td>USN_REASON_STREAM_CHANGE (0x00200000)</td>
  <td>A named stream is added to or removed from the file or directory, or a named stream is renamed.</td>
</tr>
</tbody>
</table>

<h3 id="returnonlyonclose"><code>ReturnOnlyOnClose</code></h3>

<p>A value that specifies when to return change journal records.</p>

<p>To receive notification when the final handle for the changed file or directory is closed, rather than at the time a change occurs, set <strong>ReturnOnlyOnClose</strong> to any nonzero value and specify the USN_REASON_CLOSE flag in the <strong>ReasonMask</strong> member.</p>

<p>All changes indicated by <strong>ReasonMask</strong> flags eventually generate a call to the change journal software when the file is closed. If your call is waiting for the file to be closed, that call in turn will allow your call to return. In the event that a file or directory is not closed prior to a volume failure, operating system failure, or shutdown, a cleanup call to the change journal software occurs the next time the volume is mounted. The call occurs even if there is an intervening system restart.</p>

<p>To receive notification the first time each change is logged, as well as at cleanup, set <strong>ReturnOnlyOnClose</strong> to zero.</p>

<p>Whether <strong>ReturnOnlyOnClose</strong> is zero or nonzero, the records generated at cleanup log within the change journal all reasons for USN changes that occurred to the file or directory. Each time a final close operation occurs for an item, a USN close record is written to the change journal, and the ReasonMask flags for the item are all reset.</p>

<p>For a file or directory for which no user data exists (for example, a mounted folder), the final close operation occurs when the CloseHandle function is called on the last user handle to the item.</p>

<h3 id="timeout"><code>Timeout</code></h3>

<p>The time-out value, in seconds, used with the <strong>BytesToWaitFor</strong> member to tell the operating system what to do if the <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation requests more data than exists in the change journal.</p>

<p>If <strong>Timeout</strong> is zero and <strong>BytesToWaitFor</strong> is nonzero, and the <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation call reaches the end of the change journal without finding data to return, <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> waits until <strong>BytesToWaitFor</strong> bytes of unfiltered data have been added to the change journal and then retrieves the specified records.</p>

<p>If <strong>Timeout</strong> is nonzero and <strong>BytesToWaitFor</strong> is nonzero, and the <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation call reaches the end of the change journal without finding data to return, <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> waits <strong>Timeout</strong> seconds and then attempts to return the specified records. After <strong>Timeout</strong> seconds, <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> retrieves any records available within the specified range.</p>

<p>In either case, after the time-out period any new data appended to the change journal is processed. If there are still no records to return from the specified set, the time-out period is repeated. In this mode, <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> remains outstanding until at least one record is returned or I/O is canceled.</p>

<p>If <strong>BytesToWaitFor</strong> is zero, then <strong>Timeout</strong> is ignored. <strong>Timeout</strong> is also ignored for asynchronously opened handles.</p>

<h3 id="bytestowaitfor"><code>BytesToWaitFor</code></h3>

<p>The number of bytes of unfiltered data added to the change journal. Use this value with <strong>Timeout</strong> to tell the operating system what to do if the <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation requests more data than exists in the change journal.</p>

<p>If <strong>BytesToWaitFor</strong> is zero, then <strong>Timeout</strong> is ignored. In this case, the <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation always returns successfully when the end of the change journal file is encountered. It also retrieves the USN that should be used for the next <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation. When the returned next USN is the same as the StartUsn supplied, there are no records available. The calling process should not use <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> again immediately.</p>

<p>Because the amount of data returned cannot be predicted when <strong>BytesToWaitFor</strong> is zero, you run a risk of overflowing the output buffer. To reduce this risk, specify a nonzero <strong>BytesToWaitFor</strong> value in repeated <strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operations until all records in the change journal are exhausted. Then specify zero to await new records.</p>

<h3 id="usnjournalid"><code>UsnJournalID</code></h3>

<p>The identifier for the instance of the journal that is current for the volume.</p>

<p>The NTFS file system can miss putting events in the change journal if the change journal is stopped and restarted or deleted and re-created. If either of these events occurs, the NTFS file system gives the journal a new identifier. If the journal identifier does not agree with the current journal identifier, the call fails and returns an appropriate error code. To retrieve the new journal identifier, call with the <strong><a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a></strong> operation.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a></strong></p>

<p><strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ns-ntifs-read_usn_journal_data_v0">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/ns-ntifs-read_usn_journal_data_v0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (ns-winioctl-read_usn_journal_data_v0)</h1>
</div>
<div class="ntdoc-description">
<h1>READ_USN_JOURNAL_DATA_V0 structure</h1>

<h2>Description</h2>

<p>Contains information defining a set of update sequence number (USN) change journal records to return
to the calling process. It is used by the
<a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a> and
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> control codes. Prior to
Windows 8 and Windows Server 2012 this structure was named
<strong>READ_USN_JOURNAL_DATA</strong>. Use that name to compile
with older SDKs and compilers. Windows Server 2012 introduced
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/desktop/legacy/hh802706(v=vs.85)">READ_USN_JOURNAL_DATA_V1</a> to support 128-bit file
identifiers used by ReFS.</p>

<h2>Members</h2>

<h3><code>StartUsn</code></h3>

<p>The USN at which to begin reading the change journal.</p>

<p>To start the read operation at the first record in the journal, set the <strong>StartUsn</strong>
member to zero. Because a USN is contained in every journal record, the output buffer tells at which record the
read operation actually started.</p>

<p>To start the read operation at a specific record, set <strong>StartUsn</strong> to that record
USN.</p>

<p>If a nonzero USN is specified that is less than the first USN in the change journal, then an error occurs and
the <strong>ERROR_JOURNAL_ENTRY_DELETED</strong> error code is returned. This code may indicate a case
in which the specified USN is valid at one time but has since been deleted.</p>

<p>For more information on navigating the change journal buffer returned in
<strong>READ_USN_JOURNAL_DATA_V0</strong>, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/walking-a-buffer-of-change-journal-records">Walking a Buffer of Change Journal Records</a>.</p>

<h3><code>ReasonMask</code></h3>

<p>A mask of flags, each flag noting a change for which the file or directory has a record in the change
journal. To be returned in a
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation, a
change journal record must have at least one of these flags set.</p>

<p>The list of valid flags is as follows. Unused bits are reserved.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>USN_REASON_BASIC_INFO_CHANGE</strong><br><br>0x00008000</td>
  <td>A user has either changed one or more file or directory attributes (such as the read-only, hidden, system, archive, or sparse attribute), or one or more time stamps.</td>
</tr>
<tr>
  <td><strong>USN_REASON_CLOSE</strong><br><br>0x80000000</td>
  <td>The file or directory is closed.</td>
</tr>
<tr>
  <td><strong>USN_REASON_COMPRESSION_CHANGE</strong><br><br>0x00020000</td>
  <td>The compression state of the file or directory is changed from or to compressed.</td>
</tr>
<tr>
  <td><strong>USN_REASON_DATA_EXTEND</strong><br><br>0x00000002</td>
  <td>The file or directory is added to.</td>
</tr>
<tr>
  <td><strong>USN_REASON_DATA_OVERWRITE</strong><br><br>0x00000001</td>
  <td>Data in the file or directory is overwritten.</td>
</tr>
<tr>
  <td><strong>USN_REASON_DATA_TRUNCATION</strong><br><br>0x00000004</td>
  <td>The file or directory is truncated.</td>
</tr>
<tr>
  <td><strong>USN_REASON_EA_CHANGE</strong><br><br>0x00000400</td>
  <td>The user makes a change to the file or directory extended attributes. These NTFS file system attributes are not accessible to Windows-based applications.</td>
</tr>
<tr>
  <td><strong>USN_REASON_ENCRYPTION_CHANGE</strong><br><br>0x00040000</td>
  <td>The file or directory is encrypted or decrypted.</td>
</tr>
<tr>
  <td><strong>USN_REASON_FILE_CREATE</strong><br><br>0x00000100</td>
  <td>The file or directory is created for the first time.</td>
</tr>
<tr>
  <td><strong>USN_REASON_FILE_DELETE</strong><br><br>0x00000200</td>
  <td>The file or directory is deleted.</td>
</tr>
<tr>
  <td><strong>USN_REASON_HARD_LINK_CHANGE</strong><br><br>0x00010000</td>
  <td>An NTFS file system hard link is added to or removed from the file or directory. An NTFS file system hard link, similar to a POSIX hard link, is one of several directory entries that see the same file or directory.</td>
</tr>
<tr>
  <td><strong>USN_REASON_INDEXABLE_CHANGE</strong><br><br>0x00004000</td>
  <td>A user changed the <strong>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</strong> attribute. That is, the user changed the file or directory from one that can be content indexed to one that cannot, or vice versa. (Content indexing permits rapid searching of data by building a database of selected content.)</td>
</tr>
<tr>
  <td><strong>USN_REASON_NAMED_DATA_EXTEND</strong><br><br>0x00000020</td>
  <td>One or more named data streams for the file were added to.</td>
</tr>
<tr>
  <td><strong>USN_REASON_NAMED_DATA_OVERWRITE</strong><br><br>0x00000010</td>
  <td>Data in one or more named data streams for the file is overwritten.</td>
</tr>
<tr>
  <td><strong>USN_REASON_NAMED_DATA_TRUNCATION</strong><br><br>0x00000040</td>
  <td>One or more named data streams for the file is truncated.</td>
</tr>
<tr>
  <td><strong>USN_REASON_OBJECT_ID_CHANGE</strong><br><br>0x00080000</td>
  <td>The object identifier of the file or directory is changed.</td>
</tr>
<tr>
  <td><strong>USN_REASON_RENAME_NEW_NAME</strong><br><br>0x00002000</td>
  <td>The file or directory is renamed, and the file name in the <a href="usn_record_v2" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  ULONGLONG     FileReferenceNumber;&#10;  ULONGLONG     ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V2, *PUSN_RECORD_V2;">USN_RECORD_V2</a> or <a href="usn_record_v3" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  FILE_ID_128   FileReferenceNumber;&#10;  FILE_ID_128   ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V3, *PUSN_RECORD_V3;">USN_RECORD_V3</a> structure holding this journal record is the new name.</td>
</tr>
<tr>
  <td><strong>USN_REASON_RENAME_OLD_NAME</strong><br><br>0x00001000</td>
  <td>The file or directory is renamed, and the file name in the <a href="usn_record_v2" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  ULONGLONG     FileReferenceNumber;&#10;  ULONGLONG     ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V2, *PUSN_RECORD_V2;">USN_RECORD_V2</a> or <a href="usn_record_v3" title="typedef struct {&#10;  ULONG         RecordLength;&#10;  USHORT        MajorVersion;&#10;  USHORT        MinorVersion;&#10;  FILE_ID_128   FileReferenceNumber;&#10;  FILE_ID_128   ParentFileReferenceNumber;&#10;  USN           Usn;&#10;  LARGE_INTEGER TimeStamp;&#10;  ULONG         Reason;&#10;  ULONG         SourceInfo;&#10;  ULONG         SecurityId;&#10;  ULONG         FileAttributes;&#10;  USHORT        FileNameLength;&#10;  USHORT        FileNameOffset;&#10;  WCHAR         FileName[1];&#10;} USN_RECORD_V3, *PUSN_RECORD_V3;">USN_RECORD_V3</a> structure holding this journal record is the previous name.</td>
</tr>
<tr>
  <td><strong>USN_REASON_REPARSE_POINT_CHANGE</strong><br><br>0x00100000</td>
  <td>The reparse point contained in the file or directory is changed, or a reparse point is added to or deleted from the file or directory.</td>
</tr>
<tr>
  <td><strong>USN_REASON_SECURITY_CHANGE</strong><br><br>0x00000800</td>
  <td>A change is made in the access permissions to the file or directory.</td>
</tr>
<tr>
  <td><strong>USN_REASON_STREAM_CHANGE</strong><br><br>0x00200000</td>
  <td>A named stream is added to or removed from the file or directory, or a named stream is renamed.</td>
</tr>
</tbody>
</table>

<h3><code>ReturnOnlyOnClose</code></h3>

<p>A value that specifies when to return change journal records.</p>

<p>To receive notification when the final handle for the changed file or directory is closed, rather than at the
time a change occurs, set <strong>ReturnOnlyOnClose</strong> to any nonzero value and specify the
<strong>USN_REASON_CLOSE</strong> flag in the <strong>ReasonMask</strong> member.</p>

<p>All changes indicated by <strong>ReasonMask</strong> flags eventually generate a call to the change
journal software when the file is closed. If your
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> call is waiting for the file to be
closed, that call in turn will allow your
<strong>DeviceIoControl</strong> call to return. In the event that a
file or directory is not closed prior to a volume failure, operating system failure, or shutdown, a cleanup
call to the change journal software occurs the next time the volume is mounted. The call occurs even if there
is an intervening system restart.</p>

<p>To receive notification the first time each change is logged, as well as at cleanup, set
<strong>ReturnOnlyOnClose</strong> to zero.</p>

<p>Whether <strong>ReturnOnlyOnClose</strong> is zero or nonzero, the records generated at cleanup log
within the change journal all reasons for USN changes that occurred to the file or directory. Each time a final
close operation occurs for an item, a USN close record is written to the change journal, and the
<strong>ReasonMask</strong> flags for the item are all reset.</p>

<p>For a file or directory for which no user data exists (for example, a mounted folder), the final close
operation occurs when the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function is
called on the last user handle to the item.</p>

<h3><code>Timeout</code></h3>

<p>The time-out value, in seconds, used with the <strong>BytesToWaitFor</strong> member to tell the
operating system what to do if the
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation
requests more data than exists in the change journal.</p>

<p>If <strong>Timeout</strong> is zero and <strong>BytesToWaitFor</strong> is nonzero, and
the <a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation call reaches
the end of the change journal without finding data to return,
<strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> waits until
<strong>BytesToWaitFor</strong> bytes of unfiltered data have been added to the change journal and
then retrieves the specified records.</p>

<p>If <strong>Timeout</strong> is nonzero and <strong>BytesToWaitFor</strong> is nonzero,
and the <a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation call
reaches the end of the change journal without finding data to return,
<strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> waits
<strong>Timeout</strong> seconds and then attempts to return the specified records. After
<strong>Timeout</strong> seconds,
<strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> retrieves any records
available within the specified range.</p>

<p>In either case, after the time-out period any new data appended to the change journal is processed. If there
are still no records to return from the specified set, the time-out period is repeated. In this mode,
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> remains outstanding until
at least one record is returned or I/O is canceled.</p>

<p>If <strong>BytesToWaitFor</strong> is zero, then <strong>Timeout</strong> is ignored.
<strong>Timeout</strong> is also ignored for asynchronously opened handles.</p>

<h3><code>BytesToWaitFor</code></h3>

<p>The number of bytes of unfiltered data added to the change journal. Use this value with
<strong>Timeout</strong> to tell the operating system what to do if the
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation requests more
data than exists in the change journal.</p>

<p>If <strong>BytesToWaitFor</strong> is zero, then <strong>Timeout</strong> is ignored. In
this case, the <a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation
always returns successfully when the end of the change journal file is encountered. It also retrieves the USN
that should be used for the next
<strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> operation. When the
returned next USN is the same as the <strong>StartUsn</strong> supplied, there are no records
available. The calling process should not use
<strong><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></strong> again immediately.</p>

<p>Because the amount of data returned cannot be predicted when <strong>BytesToWaitFor</strong> is
zero, you run a risk of overflowing the output buffer. To reduce this risk, specify a nonzero
<strong>BytesToWaitFor</strong> value in repeated
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operations until all
records in the change journal are exhausted. Then specify zero to await new records.</p>

<p>Alternatively, use the <em>lpBytesReturned</em> parameter of
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> in the
<a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a> operation call to
determine the amount of data available, reallocate the output buffer (with room to spare for new records), and
call <strong>DeviceIoControl</strong> again.</p>

<h3><code>UsnJournalID</code></h3>

<p>The identifier for the instance of the journal that is current for the volume.</p>

<p>The NTFS file system can miss putting events in the change journal if the change journal is stopped and
restarted or deleted and re-created. If either of these events occurs, the NTFS file system gives the journal a
new identifier. If the journal identifier does not agree with the current journal identifier, the call to
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> fails and returns an appropriate
error code. To retrieve the new journal identifier, call
<strong>DeviceIoControl</strong> with the
<a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a>
operation.</p>

<h2>See also</h2>

<p><a href="fsctl_query_usn_journal" title="// CTL_CODE(0x0009, 0x03d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_QUERY_USN_JOURNAL 0x000900F4">FSCTL_QUERY_USN_JOURNAL</a></p>

<p><a href="fsctl_read_usn_journal" title="// CTL_CODE(0x0009, 0x02e, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define FSCTL_READ_USN_JOURNAL 0x000900BB">FSCTL_READ_USN_JOURNAL</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/winioctl/ns-winioctl-usn_record_v2">USN_RECORD</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ns-winioctl-read_usn_journal_data_v0">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winioctl/ns-winioctl-read_usn_journal_data_v0.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
