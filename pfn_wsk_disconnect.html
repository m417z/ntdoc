<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_DISCONNECT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_DISCONNECT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_DISCONNECT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFN_WSK_DISCONNECT PfnWskDisconnect;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskDisconnect(
  [in]           <a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">PWSK_SOCKET</a> Socket,
  [in, optional] <a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">PWSK_BUF</a> Buffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags,
  [in, out]      PIRP Irp
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_disconnect">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_disconnect.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_disconnect)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfn_wsk_disconnect-callback-function">PFN_WSK_DISCONNECT callback function</h1>

<h2 id="description">Description</h2>

<p>The
<strong>WskDisconnect</strong> function disconnects a connection-oriented or stream socket from a remote transport
address.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="socket-in"><code>Socket</code> [in]</h3>

<p>A pointer to a
<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a> structure that specifies the socket
object for the socket that is being disconnected.</p>

<h3 id="buffer-in-optional"><code>Buffer</code> [in, optional]</h3>

<p>A pointer to a
<a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">WSK_BUF</a> structure. This structure describes a data
buffer that contains data to be transmitted by the WSK subsystem to the remote transport address before
the socket is disconnected. If there is no such data to be transmitted, the WSK application sets this
pointer to **NULL**. If WSK_FLAG_ABORTIVE is specified in the
<em>Flags</em> parameter, the
<em>Buffer</em> parameter must be <strong>NULL</strong>.</p>

<h3 id="flags-in"><code>Flags</code> [in]</h3>

<p>A <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> value that contains the following flag, or zero:</p>

<h4 id="wsk_flag_abortive">WSK_FLAG_ABORTIVE</h4>

<p>Directs the WSK subsystem to perform an abortive disconnect of the socket. If a WSK application
does not specify this flag, the WSK subsystem will perform a graceful disconnect of the socket.</p>

<h3 id="irp-in-out"><code>Irp</code> [in, out]</h3>

<p>A pointer to a caller-allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that the WSK subsystem uses to complete the disconnect
operation asynchronously. For more information about using IRPs with WSK functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions">Using IRPs with Winsock
Kernel Functions</a>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>WskDisconnect</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The socket was successfully disconnected from the remote transport address. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with success status.</td>
</tr>
<tr>
  <td><strong>STATUS_PENDING</strong></td>
  <td>The WSK subsystem could not disconnect the socket immediately. The WSK subsystem will complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> after it has disconnected the socket from the remote transport address. The status of the disconnect operation will be returned in the <strong>IoStatus.Status</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
  <td><strong>STATUS_FILE_FORCED_CLOSED</strong></td>
  <td>The socket is no longer functional. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status. The WSK application must call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a> function to close the socket as soon as possible.</td>
</tr>
<tr>
  <td><strong>Other status codes</strong></td>
  <td>An error occurred. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>A WSK application can call the
<strong>WskDisconnect</strong> function only on a connection-oriented or stream socket that it previously connected to a
remote transport address or on a socket that it accepted on a listening socket.</p>

<p><strong>WskDisconnect</strong> causes the WSK subsystem to notify the remote transport address, through whatever
means is appropriate for the underlying transport, that the connection is being disconnected. If the
<em>Buffer</em> parameter is non-<strong>NULL</strong>, the WSK subsystem transmits the data in the buffer to the remote
transport address before disconnecting the socket.</p>

<p>If a graceful disconnect is performed, the WSK subsystem waits until all outstanding transmit data has
been sent before disconnecting the socket. After the socket has been disconnected, the WSK application
cannot send any additional data to the remote transport address. However, the WSK application can still
receive additional data from the remote transport address until the remote application disconnects its
end of the socket.</p>

<p>Note that not all transports support half-open connections. If a transport does not support half-open
connections, the WSK application will not receive any additional data from the remote transport address
after a graceful disconnect has been performed.</p>

<p>With a graceful disconnect, the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed only when the disconnect operation is fully completed
by the transport protocol. For some transport protocols, the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> might not complete if there is a problem
transmitting data to the remote transport address. In this situation, the WSK application can recover by
either calling the
<strong>WskDisconnect</strong> function again and specifying the WSK_FLAG_ABORTIVE flag or by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a> function. In either
situation, the WSK subsystem will abortively disconnect the socket and force completion of the pending
<a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<p>If an abortive disconnect is performed, the WSK subsystem cancels all in-progress and pending transmit
operations and does not wait to disconnect the socket. After an abortive disconnect, the WSK application
cannot send any additional data to the remote transport address or receive any additional data from the
remote transport address.</p>

<p>A WSK application can completely close the connection by calling the
<strong>WskCloseSocket</strong> function.</p>

<h2 id="see-also">See also</h2>

<p><a href="wsk_buf" title="typedef struct _WSK_BUF {&#10;  PMDL   Mdl;&#10;  ULONG  Offset;&#10;  SIZE_T Length;&#10;} WSK_BUF, *PWSK_BUF;">WSK_BUF</a></p>

<p><a href="wsk_provider_connection_dispatch" title="typedef struct _WSK_PROVIDER_CONNECTION_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH          Basic;&#10;  PFN_WSK_BIND                         WskBind;&#10;  PFN_WSK_CONNECT                      WskConnect;&#10;  PFN_WSK_GET_LOCAL_ADDRESS            WskGetLocalAddress;&#10;  PFN_WSK_GET_REMOTE_ADDRESS           WskGetRemoteAddress;&#10;  PFN_WSK_SEND                         WskSend;&#10;  PFN_WSK_RECEIVE                      WskReceive;&#10;  PFN_WSK_DISCONNECT                   WskDisconnect;&#10;  PFN_WSK_RELEASE_DATA_INDICATION_LIST WskRelease;&#10;  PFN_WSK_CONNECT_EX                   WskConnectEx;&#10;  PFN_WSK_SEND_EX                      WskSendEx;&#10;  PFN_WSK_RECEIVE_EX                   WskReceiveEx;&#10;} WSK_PROVIDER_CONNECTION_DISPATCH, *PWSK_PROVIDER_CONNECTION_DISPATCH;">WSK_PROVIDER_CONNECTION_DISPATCH</a></p>

<p><a href="wsk_provider_stream_dispatch" title="typedef struct _WSK_PROVIDER_STREAM_DISPATCH {&#10;  WSK_PROVIDER_BASIC_DISPATCH          Basic;&#10;  PFN_WSK_BIND                         WskBind;&#10;  PFN_WSK_ACCEPT                       WskAccept;&#10;  PFN_WSK_CONNECT                      WskConnect;&#10;  PFN_WSK_LISTEN                       WskListen;&#10;  PFN_WSK_SEND                         WskSend;&#10;  PFN_WSK_RECEIVE                      WskReceive;&#10;  PFN_WSK_DISCONNECT                   WskDisconnect;&#10;  PFN_WSK_RELEASE_DATA_INDICATION_LIST WskRelease;&#10;  PFN_WSK_GET_LOCAL_ADDRESS            WskGetLocalAddress;&#10;  PFN_WSK_GET_REMOTE_ADDRESS           WskGetRemoteAddress;&#10;  PFN_WSK_CONNECT_EX                   WskConnectEx;&#10;  PFN_WSK_SEND_EX                      WskSendEx;&#10;  PFN_WSK_RECEIVE_EX                   WskReceiveEx;&#10;} WSK_PROVIDER_STREAM_DISPATCH, *PWSK_PROVIDER_STREAM_DISPATCH;">WSK_PROVIDER_STREAM_DISPATCH</a></p>

<p><a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_connect">WskConnect</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_disconnect_event">WskDisconnectEvent</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">WskSocketConnect</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_disconnect">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_disconnect.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
