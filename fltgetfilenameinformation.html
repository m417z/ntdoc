<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltGetFileNameInformation - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltGetFileNameInformation - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltGetFileNameInformation - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltGetFileNameInformation(
  [in]  <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a>         CallbackData,
  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,
  [out] <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">PFLT_FILE_NAME_INFORMATION</a> *FileNameInformation
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltgetfilenameinformation">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltgetfilenameinformation.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltgetfilenameinformation)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fltgetfilenameinformation-function">FltGetFileNameInformation function</h1>

<h2 id="description">Description</h2>

<p>The <strong>FltGetFileNameInformation</strong> routine returns name information for a file or directory.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="callbackdata-in"><code>CallbackData</code> [in]</h3>

<p>Pointer to a <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a> structure, which is the callback data structure for the I/O operation. This parameter is required and cannot be <strong>NULL</strong>.</p>

<h3 id="nameoptions-in"><code>NameOptions</code> [in]</h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-file-name-options"><strong>FLT_FILE_NAME_OPTIONS</strong></a> value containing flags that specify the format of the name information to be returned, as well as the query method that the Filter Manager is to use. The caller must include a name format flag and a query method flag. Additional flags can be used by name provider minifilter drivers to specify name query options. This parameter is required and cannot be <strong>NULL</strong>.</p>

<p>The following are the file name format flag values. Only one of the following flags can be specified. For an explanation of these formats, see <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a>.</p>

<table>
<thead>
<tr>
  <th>Name Format Flag Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLT_FILE_NAME_NORMALIZED</td>
  <td>The <em>FileNameInformation</em> parameter receives the address of a structure containing the normalized name for the file.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_OPENED</td>
  <td>The <em>FileNameInformation</em> parameter receives the address of a structure containing the name that was used when the file was opened.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_SHORT</td>
  <td>The <em>FileNameInformation</em> parameter receives the address of a structure containing the short (8.3) name for the file. The short name consists of up to 8 characters, followed immediately by a period and up to 3 more characters. The short name for a file does not include the volume name, directory path, or stream name. Not valid in the pre-create path.</td>
</tr>
</tbody>
</table>

<p>Following are the file name query method flag values. Only one of the following flags can be specified.</p>

<table>
<thead>
<tr>
  <th>Query Method Flag Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLT_FILE_NAME_QUERY_DEFAULT</td>
  <td>If it is not currently safe to query the file system for the file name, <strong>FltGetFileNameInformation</strong> does nothing. Otherwise, <strong>FltGetFileNameInformation</strong> queries the Filter Manager's name cache for the file name information. If the name is not found in the cache, <strong>FltGetFileNameInformation</strong> queries the file system and caches the result.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_QUERY_CACHE_ONLY</td>
  <td><strong>FltGetFileNameInformation</strong> queries the Filter Manager's name cache for the file name information. <strong>FltGetFileNameInformation</strong> does not query the file system.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY</td>
  <td><strong>FltGetFileNameInformation</strong> queries the file system for the file name information. <strong>FltGetFileNameInformation</strong> does not query the Filter Manager's name cache, and does not cache the result of the file system query.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP</td>
  <td><strong>FltGetFileNameInformation</strong> queries the Filter Manager's name cache for the file name information. If the name is not found in the cache, and it is currently safe to do so, <strong>FltGetFileNameInformation</strong> queries the file system for the file name information and caches the result.</td>
</tr>
</tbody>
</table>

<p>Name provider minifilters use the following flags to specify the properties of file name operations.</p>

<table>
<thead>
<tr>
  <th>Name Provider Flag Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLT_FILE_NAME_REQUEST_FROM_CURRENT_PROVIDER</td>
  <td>A name provider minifilter can use this flag to specify that a name query request should be redirected to itself (the name provider minifilter) rather than being satisfied by the name providers lower in the stack.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_DO_NOT_CACHE</td>
  <td>This flag denotes that the name retrieved from this query should not be cached. Name provider minifilters use this flag as they perform intermediate queries to generate a name.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_ALLOW_QUERY_ON_REPARSE</td>
  <td>A name provider minifilter can use this flag to specify that it is safe to query the name in the post-create path even if STATUS_REPARSE was returned. It is the caller's responsibility to ensure that the <strong>FileObject->FileName</strong> field was not changed. Do not use this flag with mount points or symbolic link reparse points.</td>
</tr>
</tbody>
</table>

<h3 id="filenameinformation-out"><code>FileNameInformation</code> [out]</h3>

<p>Pointer to a caller-allocated variable that receives the address of a system-allocated <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a> structure containing the file name information. <strong>FltGetFileNameInformation</strong> allocates this structure from paged pool. This parameter is required and cannot be <strong>NULL</strong>.</p>

<h2 id="return-value">Return value</h2>

<p>If the name information is successfully returned, <strong>FltGetFileNameInformation</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. Otherwise, it returns an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value such as one of the following:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>STATUS_FLT_INVALID_NAME_REQUEST</strong></td>
  <td><strong>FltGetFileNameInformation</strong> cannot get file name information in any of the following circumstances if the query cannot be satisfied from Filter Manager’s name cache:&lt;br&gt;&lt;br&gt;* In the paging I/O path.&lt;br&gt;&lt;br&gt;* When the <strong>TopLevelIrp</strong> field of the current thread is not <strong>NULL</strong>, because the resulting file system recursion could cause deadlocks or stack overflows. (For more information about this issue, see <a href="iogettoplevelirp" title="PIRP IoGetTopLevelIrp();">IoGetTopLevelIrp</a>.)&lt;br&gt;&lt;br&gt;* After an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-cleanup">IRP_MJ_CLEANUP</a> operation is completed; that is, in the post-clean up, pre-close, or post-close path (the target file object has the <a href="fo_cleanup_complete" title="#define FO_CLEANUP_COMPLETE 0x00004000">FO_CLEANUP_COMPLETE</a> flag set).&lt;br&gt;&lt;br&gt;* In a preoperation (<a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a>) or postoperation (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>) callback routine for any of the following operations:   + <a href="irp_mj_acquire_for_cc_flush" title="#define IRP_MJ_ACQUIRE_FOR_CC_FLUSH ((UCHAR)-5)">IRP_MJ_ACQUIRE_FOR_CC_FLUSH</a>   + <a href="irp_mj_acquire_for_mod_write" title="#define IRP_MJ_ACQUIRE_FOR_MOD_WRITE ((UCHAR)-3)">IRP_MJ_ACQUIRE_FOR_MOD_WRITE</a>+ <a href="irp_mj_release_for_cc_flush" title="#define IRP_MJ_RELEASE_FOR_CC_FLUSH ((UCHAR)-6)">IRP_MJ_RELEASE_FOR_CC_FLUSH</a>     + <a href="irp_mj_release_for_mod_write" title="#define IRP_MJ_RELEASE_FOR_MOD_WRITE ((UCHAR)-4)">IRP_MJ_RELEASE_FOR_MOD_WRITE</a>     + <a href="irp_mj_release_for_section_synchronization" title="#define IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION ((UCHAR)-2)">IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION</a>&lt;br&gt;&lt;br&gt;* In a postoperation callback routine for <a href="irp_mj_acquire_for_section_synchronization" title="#define IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION ((UCHAR)-1)">IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION</a>.&lt;br&gt;&lt;br&gt;* When all APCs are disabled; that is, when <a href="keareallapcsdisabled" title="BOOLEAN KeAreAllApcsDisabled();">KeAreAllApcsDisabled</a> returns TRUE.&lt;br&gt;&lt;br&gt;<strong>FltGetFileNameInformation</strong> cannot get the short name of a file in the pre-create path.&lt;br&gt;&lt;br&gt;STATUS_FLT_INVALID_NAME_REQUEST is an error code.</td>
</tr>
<tr>
  <td><strong>STATUS_INSUFFICIENT_RESOURCES</strong></td>
  <td><strong>FltGetFileNameInformation</strong> encountered a pool allocation failure. This is an error code.</td>
</tr>
<tr>
  <td><strong>STATUS_INVALID_PARAMETER</strong></td>
  <td>Returned when an invalid parameter is passed, such as one of the following:&lt;br&gt;&lt;br&gt;* The <strong>FileNameInformation</strong> parameter cannot be <strong>NULL</strong>.&lt;br&gt;* The <em>CallbackData</em> parameter cannot be <strong>NULL</strong>.&lt;br&gt;&lt;br&gt;STATUS_INVALID_PARAMETER is an error code.</td>
</tr>
<tr>
  <td><strong>STATUS_FLT_NAME_CACHE_MISS</strong></td>
  <td>The file name information is not found in the name cache and <em>NameOptions</em> includes FLT_FILE_NAME_QUERY_CACHE_ONLY.&lt;br&gt;&lt;br&gt;-or-&lt;br&gt;&lt;br&gt;The file name information is not found in the name cache when <em>NameOptions</em> includes FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP and the file name information cannot be queried from the file system.&lt;br&gt;&lt;br&gt;An additional call to <strong>FltGetFileNameInformation</strong> with FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY set in <em>NameOptions</em> may return the file name information.</td>
</tr>
<tr>
  <td><strong>STATUS_NOT_SAME_DEVICE</strong></td>
  <td>The file being queried during pre-create is on a different volume than its parent directory. This error is returned for normalized name queries, where the file was a junction or symlink that resolved to a different volume.</td>
</tr>
<tr>
  <td><strong>STATUS_ACCESS_DENIED</strong></td>
  <td>If the user opened the file by file ID but does not have traverse privileges for the entire path, <strong>FltGetFileNameInformation</strong> fails with this return value.&lt;br&gt;&lt;br&gt;STATUS_ACCESS_DENIED is an error code.&lt;br&gt;&lt;br&gt;-or-&lt;br&gt;&lt;br&gt;The file is a system file with all access denied.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p><strong>FltGetFileNameInformation</strong> returns the requested name information for the file or directory that is the target of the operation described by <em>CallbackData</em>, in the specified format. The file or directory does not need to be opened yet by the file system.</p>

<p>For a pre-create operation, if the <strong>CallbackData->Iopb->OperationFlags</strong> member contains the <a href="sl_open_target_directory" title="#define SL_OPEN_TARGET_DIRECTORY 0x04">SL_OPEN_TARGET_DIRECTORY</a> bitwise flag, <strong>FltGetFileNameInformation</strong> returns the name of the containing (parent) directory for the given file. This name is the actual path that the create operation opens.</p>

<p>To parse the contents of the <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a> structure returned by <strong>FltGetFileNameInformation</strong>, call <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a>. (For more information about file name formats, see <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a>.)</p>

<p>After a successful call to <strong>FltGetFileNameInformation</strong>, the caller is responsible for releasing the pointer returned in the <em>FileNameInformation</em> parameter when the pointer is no longer needed. The caller does this by calling <a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a>.</p>

<p>The caller must not modify the contents of the structure returned in the <em>FileNameInformation</em> parameter because this structure is cached by the Filter Manager so that all minifilter drivers can use it.</p>

<p>If <strong>FltGetFileNameInformation</strong> is called in the preoperation callback routine for a create operation to retrieve the opened name, <strong>FltGetFileNameInformation</strong> succeeds even if the path to the file being opened does not exist on the volume.</p>

<p>If <strong>FltGetFileNameInformation</strong> is called in the preoperation callback routine for a create operation to retrieve the normalized name, <strong>FltGetFileNameInformation</strong> succeeds even if the final component of the path to the file being opened does not exist on the volume.</p>

<blockquote>
  <p>[!NOTE]</p>
  
  <p>Server Message Block (SMB) support for querying normalized file names on a remote volume varies on different Windows 10 versions. See the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/openspecs/windows_protocols/ms-smb2/5606ad47-5ee0-437a-817e-70c366052962">MS-SMB2 Protocol</a> for details.</p>
</blockquote>

<p>In create, hard-link, and rename operations, file name tunneling can cause the final component in normalized file name information that a minifilter driver retrieves in a preoperation callback routine to be invalidated. If a minifilter driver retrieves normalized file name information in a preoperation callback (<a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a>) routine by calling a routine such as <strong>FltGetFileNameInformation</strong>, it must call <a href="fltgettunneledname" title="NTSTATUS FLTAPI FltGetTunneledName(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  PFLT_FILE_NAME_INFORMATION FileNameInformation,&#10;  [out] PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation&#10;);">FltGetTunneledName</a> from its postoperation callback (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>) routine to retrieve the correct file name information for the file.</p>

<p>For Windows 8.1 and earlier, <strong>FltGetFileNameInformation</strong> can include a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/file-streams">stream type</a> <em>only</em> when called from a filter’s pre-create callback. To distinguish between a file’s default stream and metadata streams, this call should be made in the pre-create operation. The resulting stream type will remain valid across the lifetime of the file.</p>

<p>Prior to Windows 8, Filter Manager obtained the normalized name for a file or directory by collecting the name information for each component of the file path. This required multiple queries to the file system to compile the complete path. Starting with Windows 8, local file systems support the <strong>FileNormalizedNameInformation</strong> file information class and only a single query is necessary to obtain the normalized name. Remote file systems may not support the <strong>FileNormalizedNameInformation</strong> file information class. When this is the case, a query for each component of the file path is still required to assemble the normalized name. Under certain network conditions, a full name query can require a significant amount of time to complete.</p>

<p>For more information about normalized file name information, see <a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a>.</p>

<blockquote>
  <p>[!NOTE]</p>
  
  <p>File name tunneling affects only create, hard-link, and rename operations in this way. It does not affect other I/O operations, such as read and write.</p>
</blockquote>

<p>The following paired operations can cause the file name <em>name</em> to be tunneled:</p>

<ul>
<li>delete (<em>name</em>)/create(<em>name</em>)</li>
<li>delete (<em>name</em>)/rename(<em>source, name</em>)</li>
<li>rename (<em>name, newname</em>)/create(<em>name</em>)</li>
<li>rename (<em>name, newname</em>)/rename(<em>source,name</em>)</li>
</ul>

<h2 id="see-also">See also</h2>

<p><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></p>

<p><a href="flt_file_name_information" title="typedef struct _FLT_FILE_NAME_INFORMATION {&#10;  USHORT                     Size;&#10;  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;&#10;  FLT_FILE_NAME_OPTIONS      Format;&#10;  UNICODE_STRING             Name;&#10;  UNICODE_STRING             Volume;&#10;  UNICODE_STRING             Share;&#10;  UNICODE_STRING             Extension;&#10;  UNICODE_STRING             Stream;&#10;  UNICODE_STRING             FinalComponent;&#10;  UNICODE_STRING             ParentDir;&#10;} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;">FLT_FILE_NAME_INFORMATION</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-file-name-options">FLT_FILE_NAME_OPTIONS</a></p>

<p><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></p>

<p><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></p>

<p><a href="fltgettunneledname" title="NTSTATUS FLTAPI FltGetTunneledName(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  PFLT_FILE_NAME_INFORMATION FileNameInformation,&#10;  [out] PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation&#10;);">FltGetTunneledName</a></p>

<p><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></p>

<p><a href="fltreferencefilenameinformation" title="VOID FLTAPI FltReferenceFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReferenceFileNameInformation</a></p>

<p><a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a></p>

<p><a href="iogettoplevelirp" title="PIRP IoGetTopLevelIrp();">IoGetTopLevelIrp</a></p>

<p><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></p>

<p><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltgetfilenameinformation">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltgetfilenameinformation.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
