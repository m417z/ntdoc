<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_RECEIVE_EVENT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_RECEIVE_EVENT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_RECEIVE_EVENT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFN_WSK_RECEIVE_EVENT PfnWskReceiveEvent;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskReceiveEvent(
  [in, optional] PVOID SocketContext,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags,
  [in, optional] <a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">PWSK_DATA_INDICATION</a> DataIndication,
  [in]           <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> BytesIndicated,
  [in, out]      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> *BytesAccepted
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_event">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_receive_event.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_receive_event)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfn_wsk_receive_event-callback-function">PFN_WSK_RECEIVE_EVENT callback function</h1>

<h2 id="description">Description</h2>

<p>The
<em>WskReceiveEvent</em> event callback function notifies a WSK application that data has been received on a
connection-oriented socket.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="socketcontext-in-optional"><code>SocketContext</code> [in, optional]</h3>

<p>A pointer to the socket context for the connection-oriented socket that has received the data. The
WSK application provided this pointer to the WSK subsystem in one of the following ways:</p>

<ul>
<li>It called the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">WskSocket</a> function to create the socket.</li>
<li>It called the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">WskSocketConnect</a> function to create
the socket.</li>
<li>It called the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_accept">WskAccept</a> function to accept the socket as an
incoming connection.</li>
<li>Its
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_accept_event">WskAcceptEvent</a> event callback function
was called to accept the socket as an incoming connection.</li>
</ul>

<h3 id="flags-in"><code>Flags</code> [in]</h3>

<p>A <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> value that contains a bitwise OR of a combination of the following flags:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>WSK_FLAG_RELEASE_ASAP</strong></td>
  <td>The data buffers that contain the received data should not be retained by the WSK application if at all possible. If the WSK application retains the buffers, it should release them as soon as possible by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff571144(v=vs.85)">WskRelease</a> function.</td>
</tr>
<tr>
  <td><strong>WSK_FLAG_ENTIRE_MESSAGE</strong></td>
  <td>The data buffers contain either an entire message or the final portion of a message. The interpretation of what constitutes an entire message is transport protocol-specific. For TCP, this flag indicates that the push bit was set for one or more of the TCP segments that constitute the data in the data buffers.</td>
</tr>
<tr>
  <td><strong>WSK_FLAG_AT_DISPATCH_LEVEL</strong></td>
  <td>The WSK subsystem called the <em>WskReceiveEvent</em> event callback function at IRQL = DISPATCH_LEVEL. If this flag is not set, the WSK subsystem might have called the <em>WskReceiveEvent</em> event callback function at any IRQL &lt;= DISPATCH_LEVEL.</td>
</tr>
</tbody>
</table>

<h3 id="dataindication-in-optional"><code>DataIndication</code> [in, optional]</h3>

<p>A pointer to a linked list of
<a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a> structures that
describe the received data. If this parameter is <strong>NULL</strong>, the socket is no longer functional and the WSK
application must call the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a> function to close the
socket as soon as possible.</p>

<h3 id="bytesindicated-in"><code>BytesIndicated</code> [in]</h3>

<p>The number of bytes of received data described by the linked list of
<a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a> structures.</p>

<h3 id="bytesaccepted-in-out"><code>BytesAccepted</code> [in, out]</h3>

<p>A pointer to a <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>-typed variable which receives the number of bytes of received data that is
accepted by the WSK application. This variable needs to be set only if the WSK application accepts a
portion of the total number of bytes of received data. If the WSK application accepts all of the
received data, it does not have to set this variable. If the
<em>WskReceiveEvent</em> event callback function returns a status other than <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>, the WSK
subsystem ignores the value of this variable.</p>

<h2 id="return-value">Return value</h2>

<p>A WSK application's
<em>WskReceiveEvent</em> event callback function can return one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The WSK application accepted at least some of the received data. If the WSK application accepted all of the received data, the WSK subsystem can call the <em>WskReceiveEvent</em> event callback function again when new data is received on the socket. However, if the WSK application accepted only a portion of the received data, the WSK subsystem will not call the <em>WskReceiveEvent</em> event callback function again until after the WSK application calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive">WskReceive</a> function. After the WSK application calls the <strong>WskReceive</strong> function, the WSK subsystem will resume calling the <em>WskReceiveEvent</em> event callback function with any remaining buffered data and when new data is received on the socket. A WSK application can call the <strong>WskReceive</strong> function with a zero-length buffer, which will cause the WSK subsystem to resume calling the <em>WskReceiveEvent</em> event callback function without calling <strong>WskReceive</strong> to receive any data from the socket.</td>
</tr>
<tr>
  <td><strong>STATUS_PENDING</strong></td>
  <td>The WSK application accepted the data but did not retrieve all of the data contained in the linked list of <a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a> structures. The WSK application retains the linked list of <a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a> structures until all of the data has been retrieved. After the WSK application has retrieved all of the data it calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff571144(v=vs.85)">WskRelease</a> function to release the linked list of <a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a> structures back to the WSK subsystem. The WSK subsystem can call the <em>WskReceiveEvent</em> event callback function again when new data is received on the socket.</td>
</tr>
<tr>
  <td><strong>STATUS_DATA_NOT_ACCEPTED</strong></td>
  <td>The WSK application did not accept the data. In this situation, the WSK subsystem will have the underlying transport buffer the data if possible or if otherwise required by the protocol. The WSK subsystem will not call the <em>WskReceiveEvent</em> event callback function again until after the WSK application calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive">WskReceive</a> function. After the WSK application calls the <strong>WskReceive</strong> function, the WSK subsystem will resume calling the <em>WskReceiveEvent</em> event callback function with any remaining buffered data and when new data is received on the socket. A WSK application can call the <strong>WskReceive</strong> function with a zero-length buffer, which will cause the WSK subsystem to resume calling the <em>WskReceiveEvent</em> event callback function without calling <strong>WskReceive</strong> to receive any data from the socket.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>The WSK subsystem calls a WSK application's
<em>WskReceiveEvent</em> event callback function when new data is received on a connection-oriented socket
only if the event callback function was previously enabled with the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/so-wsk-event-callback">SO_WSK_EVENT_CALLBACK</a> socket option.
For more information about enabling a socket's event callback functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/evntprov/nc-evntprov-penablecallback">Enabling and
Disabling Event Callback Functions</a>.</p>

<p>If a WSK application's
<em>WskReceiveEvent</em> event callback function is enabled on a connection-oriented socket and the
application also has a pending call to the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive">WskReceive</a> function on the same
connection-oriented socket, then, when data arrives, the pending call to the
<strong>WskReceive</strong> function will take precedence over the
<em>WskReceiveEvent</em> event callback function. The WSK subsystem calls the application's
<em>WskReceiveEvent</em> event callback function only if there are no IRPs queued from pending calls to the
<strong>WskReceive</strong> function. However, a WSK application should not assume that the WSK subsystem will not
call the application's
<em>WskReceiveEvent</em> event callback function for a connection-oriented socket that has a pending call to
the
<strong>WskReceive</strong> function. Race conditions exist where the WSK subsystem could still call the WSK
application's
<em>WskReceiveEvent</em> event callback function for the socket. The only way for a WSK application to
ensure that the WSK subsystem will not call the application's
<em>WskReceiveEvent</em> event callback function for a connection-oriented socket is to disable the
application's
<em>WskReceiveEvent</em> event callback function on the socket.</p>

<blockquote>
  <p>[!NOTE]
  Winsock Kernel (WSK) calls this callback serially, so it is not always invoked as soon as data is received.</p>
</blockquote>

<p>The WSK subsystem calls a WSK application's
<em>WskReceiveEvent</em> event callback function at IRQL &lt;= DISPATCH_LEVEL.</p>

<p>A WSK application's <em>WskReceiveEvent</em> event callback function must not wait for completion of other WSK requests in the context of WSK completion or event callback functions. The callback can initiate other WSK requests (assuming that it doesn't spend too much time at DISPATCH_LEVEL), but it must not wait for their completion even when the callback is called at IRQL = PASSIVE_LEVEL.</p>

<h2 id="see-also">See also</h2>

<p><a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a></p>

<p><a href="wsk_data_indication" title="typedef struct _WSK_DATA_INDICATION {&#10;  struct _WSK_DATA_INDICATION *Next;&#10;  WSK_BUF                     Buffer;&#10;} WSK_DATA_INDICATION, *PWSK_DATA_INDICATION;">WSK_DATA_INDICATION</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_accept">WskAccept</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_accept_event">WskAcceptEvent</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive">WskReceive</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff571144(v=vs.85)">WskRelease</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_send">WskSend</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">WskSocket</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">WskSocketConnect</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_receive_event">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_receive_event.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
