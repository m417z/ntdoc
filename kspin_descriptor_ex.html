<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="KSPIN_DESCRIPTOR_EX - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>KSPIN_DESCRIPTOR_EX - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            KSPIN_DESCRIPTOR_EX - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ks.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _KSPIN_DESCRIPTOR_EX {
  const <a href="kspin_dispatch" title="typedef struct _KSPIN_DISPATCH {&#10;  PFNKSPINIRP                Create;&#10;  PFNKSPINIRP                Close;&#10;  PFNKSPIN                   Process;&#10;  PFNKSPINVOID               Reset;&#10;  PFNKSPINSETDATAFORMAT      SetDataFormat;&#10;  PFNKSPINSETDEVICESTATE     SetDeviceState;&#10;  PFNKSPIN                   Connect;&#10;  PFNKSPINVOID               Disconnect;&#10;  const KSCLOCK_DISPATCH     *Clock;&#10;  const KSALLOCATOR_DISPATCH *Allocator;&#10;} KSPIN_DISPATCH, *PKSPIN_DISPATCH;">KSPIN_DISPATCH</a>         *Dispatch;
  const <a href="ksautomation_table_" title="typedef struct KSAUTOMATION_TABLE_ {&#10;  ULONG                PropertySetsCount;&#10;  ULONG                PropertyItemSize;&#10;  const KSPROPERTY_SET *PropertySets;&#10;  ULONG                MethodSetsCount;&#10;  ULONG                MethodItemSize;&#10;  const KSMETHOD_SET   *MethodSets;&#10;  ULONG                EventSetsCount;&#10;  ULONG                EventItemSize;&#10;  const KSEVENT_SET    *EventSets;&#10;  PVOID                Alignment;&#10;} KSAUTOMATION_TABLE, *PKSAUTOMATION_TABLE;">KSAUTOMATION_TABLE</a>     *AutomationTable;
  <a href="kspin_descriptor" title="typedef struct {&#10;  ULONG                 InterfacesCount;&#10;  const KSPIN_INTERFACE *Interfaces;&#10;  ULONG                 MediumsCount;&#10;  const KSPIN_MEDIUM    *Mediums;&#10;  ULONG                 DataRangesCount;&#10;  const PKSDATARANGE    *DataRanges;&#10;  KSPIN_DATAFLOW        DataFlow;&#10;  KSPIN_COMMUNICATION   Communication;&#10;  const GUID            *Category;&#10;  const GUID            *Name;&#10;  union {&#10;    LONGLONG Reserved;&#10;    struct {&#10;      ULONG        ConstrainedDataRangesCount;&#10;      PKSDATARANGE *ConstrainedDataRanges;&#10;    };&#10;  };&#10;} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;">KSPIN_DESCRIPTOR</a>             PinDescriptor;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        Flags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        InstancesPossible;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        InstancesNecessary;
  const <a href="ksallocator_framing_ex" title="typedef struct {&#10;  ULONG           CountItems;&#10;  ULONG           PinFlags;&#10;  KS_COMPRESSION  OutputCompression;&#10;  ULONG           PinWeight;&#10;  KS_FRAMING_ITEM FramingItem[1];&#10;} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;">KSALLOCATOR_FRAMING_EX</a> *AllocatorFraming;
  <a href="pfnksintersecthandlerex" title="PFNKSINTERSECTHANDLEREX Pfnksintersecthandlerex;&#10;&#10;NTSTATUS Pfnksintersecthandlerex(&#10;  [in]  PVOID Context,&#10;  [in]  PIRP Irp,&#10;  [in]  PKSP_PIN Pin,&#10;  [in]  PKSDATARANGE DataRange,&#10;  [in]  PKSDATARANGE MatchingDataRange,&#10;  [in]  ULONG DataBufferSize,&#10;  [out] PVOID Data,&#10;  [out] PULONG DataSize&#10;)&#10;{...}">PFNKSINTERSECTHANDLEREX</a>      IntersectHandler;
} KSPIN_DESCRIPTOR_EX, *PKSPIN_DESCRIPTOR_EX;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ks/ns-ks-_kspin_descriptor_ex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/kspin_descriptor_ex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ks-_kspin_descriptor_ex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p>The <strong>KSPIN_DESCRIPTOR_EX</strong> structure describes the characteristics of a pin type on a given filter type.</p>
<h2>Members</h2>
<h3><code>Dispatch</code></h3>
<p>A pointer to the <strong><a href="kspin_dispatch" title="typedef struct _KSPIN_DISPATCH {&#10;  PFNKSPINIRP                Create;&#10;  PFNKSPINIRP                Close;&#10;  PFNKSPIN                   Process;&#10;  PFNKSPINVOID               Reset;&#10;  PFNKSPINSETDATAFORMAT      SetDataFormat;&#10;  PFNKSPINSETDEVICESTATE     SetDeviceState;&#10;  PFNKSPIN                   Connect;&#10;  PFNKSPINVOID               Disconnect;&#10;  const KSCLOCK_DISPATCH     *Clock;&#10;  const KSALLOCATOR_DISPATCH *Allocator;&#10;} KSPIN_DISPATCH, *PKSPIN_DISPATCH;">KSPIN_DISPATCH</a></strong> structure for this pin. This pointer is optional and should only be provided by clients that wish to receive notifications. Clients that need to perform pin-centric processing (filters concerned with the routing of data, in other words hardware drivers) must provide this dispatch table and a process dispatch. See <strong><a href="kspin_dispatch" title="typedef struct _KSPIN_DISPATCH {&#10;  PFNKSPINIRP                Create;&#10;  PFNKSPINIRP                Close;&#10;  PFNKSPIN                   Process;&#10;  PFNKSPINVOID               Reset;&#10;  PFNKSPINSETDATAFORMAT      SetDataFormat;&#10;  PFNKSPINSETDEVICESTATE     SetDeviceState;&#10;  PFNKSPIN                   Connect;&#10;  PFNKSPINVOID               Disconnect;&#10;  const KSCLOCK_DISPATCH     *Clock;&#10;  const KSALLOCATOR_DISPATCH *Allocator;&#10;} KSPIN_DISPATCH, *PKSPIN_DISPATCH;">KSPIN_DISPATCH</a></strong> for more information.</p>
<h3><code>AutomationTable</code></h3>
<p>A pointer to the <a href="ksautomation_table_" title="typedef struct KSAUTOMATION_TABLE_ {&#10;  ULONG                PropertySetsCount;&#10;  ULONG                PropertyItemSize;&#10;  const KSPROPERTY_SET *PropertySets;&#10;  ULONG                MethodSetsCount;&#10;  ULONG                MethodItemSize;&#10;  const KSMETHOD_SET   *MethodSets;&#10;  ULONG                EventSetsCount;&#10;  ULONG                EventItemSize;&#10;  const KSEVENT_SET    *EventSets;&#10;  PVOID                Alignment;&#10;} KSAUTOMATION_TABLE, *PKSAUTOMATION_TABLE;">KSAUTOMATION_TABLE</a> structure for this pin. The automation table contains the properties, methods, and events supported by the pin. This automation table is merged with the automation table provided by AVStream for all pins. If the client supplies any property, event, or method handlers that are already provided by AVStream, the client's implementation supersedes that of AVStream.</p>
<h3><code>PinDescriptor</code></h3>
<p>This member specifies a structure of type <strong><a href="kspin_descriptor" title="typedef struct {&#10;  ULONG                 InterfacesCount;&#10;  const KSPIN_INTERFACE *Interfaces;&#10;  ULONG                 MediumsCount;&#10;  const KSPIN_MEDIUM    *Mediums;&#10;  ULONG                 DataRangesCount;&#10;  const PKSDATARANGE    *DataRanges;&#10;  KSPIN_DATAFLOW        DataFlow;&#10;  KSPIN_COMMUNICATION   Communication;&#10;  const GUID            *Category;&#10;  const GUID            *Name;&#10;  union {&#10;    LONGLONG Reserved;&#10;    struct {&#10;      ULONG        ConstrainedDataRangesCount;&#10;      PKSDATARANGE *ConstrainedDataRanges;&#10;    };&#10;  };&#10;} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;">KSPIN_DESCRIPTOR</a></strong>.</p>
<h3><code>Flags</code></h3>
<p>Specifies a value of type <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>. This can be any combination of the flags listed in the following list. Specify flags using a bitwise OR, with the following exceptions: KSPIN_FLAG_CRITICAL_PROCESSING and KSPIN_FLAG_HYPERCRITICAL_PROCESSING are mutually exclusive. KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING and KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL are mutually exclusive. KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING and KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING are mutually exclusive. KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY and KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE are mutually exclusive.</p>
<h4>KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING</h4>
<p>Indicates that the minidriver requests that the process dispatch to happen at IRQL DISPATCH_LEVEL instead of PASSIVE_LEVEL.</p>
<h4>KSPIN_FLAG_CRITICAL_PROCESSING</h4>
<p>If asynchronous processing has been specified or if the system is running at PASSIVE_LEVEL and a process call comes in at DISPATCH_LEVEL, processing is done in a queued work item. This flag indicates that the work item should be placed on the critical work queue as opposed to the delayed work queue.</p>
<h4>KSPIN_FLAG_HYPERCRITICAL_PROCESSING</h4>
<p>If asynchronous processing has been specified or if the system is running at PASSIVE_LEVEL and a process call comes in at DISPATCH_LEVEL, processing is done in a queued work item. This flag indicates that the work item should be placed on the hypercritical work queue as opposed to the delayed work queue or critical work queue.</p>
<h4>KSPIN_FLAG_ASYNCHRONOUS_PROCESSING</h4>
<p>Indicates that the pin should process data asynchronously. If this flag is set, AVStream does not wait for one process dispatch to be called before proceeding with additional frames.</p>
<h4>KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING</h4>
<p>AVStream calls the processing dispatch only when the minidriver explicitly calls <strong>Ks</strong><em>Xxx</em><strong>AttemptProcessing</strong>. Useful for clients that intend to directly poll the queue at, for example, DPC time to transport data to hardware.</p>
<h4>KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL</h4>
<p>Indicates that processing should occur every time a data frame arrives into the queue. If this flag is not specified, the process dispatch is only called when data arrives into a previously empty queue.</p>
<h4>KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING</h4>
<p>Indicates that frames are not required on this pin for processing to commence. Even if no frames exist in the queue, a state change will now suffice to cause AVStream to call the processing dispatch. This flag is useful only for filter-centric filters. Pins that do not specify this flag delay processing on the filter if they do not have available frames. Pins that do specify this flag do not delay processing in this manner. If a pin specifies this flag, it becomes the responsibility of the process dispatch to check for available frames.</p>
<h4>KSPIN_FLAG_ENFORCE_FIFO</h4>
<p>Specifying this flag causes the queue to force IRPs to be handled in a first-in-first-out manner. If one <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed by the minidriver prior to an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that was sent earlier, the later <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is not completed by AVStream until the earlier <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> has been completed by the minidriver.</p>
<h4>KSPIN_FLAG_GENERATE_MAPPINGS</h4>
<p>Specifying this flag causes AVStream to automatically generate scatter/gather mappings for a queued frame when the minidriver locks a stream pointer referencing that frame. Clients that intend to use this feature need to register their DMA adapter object with AVStream via the <a href="ksdeviceregisteradapterobject" title="void KsDeviceRegisterAdapterObject(&#10;  [in] PKSDEVICE       Device,&#10;  [in] PADAPTER_OBJECT AdapterObject,&#10;  [in] ULONG           MaxMappingsByteCount,&#10;  [in] ULONG           MappingTableStride&#10;);">KsDeviceRegisterAdapterObject</a> function. See the <strong>DataUsed</strong> member of <strong><a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">KSSTREAM_HEADER</a></strong> for the effect of this flag on the <a href="ksstream_header" title="typedef struct {&#10;  ULONG    Size;&#10;  ULONG    TypeSpecificFlags;&#10;  KSTIME   PresentationTime;&#10;  LONGLONG Duration;&#10;  ULONG    FrameExtent;&#10;  ULONG    DataUsed;&#10;  PVOID    Data;&#10;  ULONG    OptionsFlags;&#10;  ULONG    Reserved;&#10;} KSSTREAM_HEADER, *PKSSTREAM_HEADER;">KSSTREAM_HEADER</a> structure. Also see <strong><a href="ksstream_pointer_offset" title="typedef struct _KSSTREAM_POINTER_OFFSET {&#10;  union {&#10;    PUCHAR     Data;&#10;    PKSMAPPING Mappings;&#10;  };&#10;  PUCHAR Data;&#10;  PVOID  Alignment;&#10;  ULONG  Count;&#10;  ULONG  Remaining;&#10;} KSSTREAM_POINTER_OFFSET, *PKSSTREAM_POINTER_OFFSET;">KSSTREAM_POINTER_OFFSET</a></strong>.</p>
<h4>KSPIN_FLAG_DISTINCT_TRAILING_EDGE</h4>
<p>Indicates that the queue associated with the pin should have a trailing edge stream pointer. The trailing edge pointer is a special stream pointer that points to the oldest data in the queue unless clone pointers exist on older data. Any data frames in the window between the leading and trailing edge stream pointers are considered to have at least one reference count on them and are not completed until they move out of the window by advancing the trailing edge with <a href="kspingettrailingedgestreampointer" title="KSDDKAPI PKSSTREAM_POINTER KsPinGetTrailingEdgeStreamPointer(&#10;  [in] PKSPIN                 Pin,&#10;  [in] KSSTREAM_POINTER_STATE State&#10;);">KsPinGetTrailingEdgeStreamPointer</a> and one of the <strong><a href="ksstreampointeradvance" title="KSDDKAPI NTSTATUS KsStreamPointerAdvance(&#10;  [in] PKSSTREAM_POINTER StreamPointer&#10;);">KsStreamPointerAdvance</a></strong><em>Xxx</em> or <a href="ksstreampointerunlock" title="void KsStreamPointerUnlock(&#10;  [in] PKSSTREAM_POINTER StreamPointer,&#10;  [in] BOOLEAN           Eject&#10;);">KsStreamPointerUnlock</a> functions. Pins that do not specify this flag do not have a trailing edge stream pointer.</p>
<h4>KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY</h4>
<p>Indicates that AVStream should only call this pin to process when the pin is in KSSTATE_RUN. Changes the minimum processing state from pause to run. AVStream calls this pin to process <em>after</em> telling it to go to run state, even if frames arrive. Any pin that specifies this flag and is part of a filter-centric filter causes the filter not to process if the given pin is not in KSSTATE_RUN.</p>
<h4>KSPIN_FLAG_SPLITTER</h4>
<p>Indicates that this pin (an output pin) is a splitter. Pins that specify this flag should indicate a number of possible instances greater than one. When a second instance of this pin is created, AVStream automatically sets up a splitter so that frames sent to the original pin are copied to the new pin. Note that this copying is done automatically by AVStream. Clients <em>typically</em> can ignore process pins that have non-<strong>NULL</strong> <strong>DelegateBranch</strong> and <strong>CopySource</strong> pointers. These members indicate that the pin is part of a splitter branch and is handled automatically by AVStream. In releases post-DirectX 8.0, this flag works for pins on both filter-centric and pin-centric filters. Older releases support this flag only for pins on filter-centric filters.</p>
<h4>KSPIN_FLAG_USE_STANDARD_TRANSPORT</h4>
<p>This flag forces the pin to use the standard transport mechanism. It overrides all other checks (communication type, medium type, interface type, etc.) on the pin. Specifying both this flag and KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT results in the standard transport being used. This flag overrides all other checks.</p>
<h4>KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT</h4>
<p>Indicates that the pin does not use the standard transport mechanism. Pins that do not use the standard transport mechanism will not belong to a pipe section and will not have associated queues.</p>
<h4>KSPIN_FLAG_FIXED_FORMAT</h4>
<p>Indicates that this pin uses a fixed data format. Any attempt to set the data format returns STATUS_INVALID_DEVICE_REQUEST.</p>
<h4>KSPIN_FLAG_GENERATE_EOS_EVENTS</h4>
<p>Indicates that this pin handles connection event support requests.</p>
<h4>KSPIN_FLAG_RENDERER</h4>
<p>Specifies that this pin is capable of rendering frames.</p>
<h4>KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING</h4>
<p>When specified on a filter-centric filter pin, indicates that one or more instances of the pin type in question must have frames available in order to process data. Mutually exclusive with KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING.</p>
<p>Note that this behavior can be obtained through <a href="kspinattachorgate" title="void KsPinAttachOrGate(&#10;  [in]           PKSPIN  Pin,&#10;  [in, optional] PKSGATE OrGate&#10;);">KsPinAttachOrGate</a> by manually setting up an OR gate as the frame gate for every instance of the pin and attaching this OR gate to the filter's AND gate.</p>
<p>When using this flag, minidrivers cannot call <a href="kspinattachandgate" title="void KsPinAttachAndGate(&#10;  [in]           PKSPIN  Pin,&#10;  [in, optional] PKSGATE AndGate&#10;);">KsPinAttachAndGate</a> or <strong><a href="kspinattachorgate" title="void KsPinAttachOrGate(&#10;  [in]           PKSPIN  Pin,&#10;  [in, optional] PKSGATE OrGate&#10;);">KsPinAttachOrGate</a></strong> on the associated pin instances. (The flag effectively does this for you for the simple OR case.) Also see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/filter-centric-processing">Filter-Centric Processing</a>.</p>
<h4>KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE</h4>
<p>When specified on a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/filter-centric-processing">filter-centric</a> pin, indicates that processing may occur when one or more of the pin instances so flagged are in the run state. All non-stopped pins still must be in at least pause to process data. Do not use this flag if the corresponding pin is an output pin and this pin is involved in an in-place transform.</p>
<h4>KSPIN_FLAG_DENY_USERMODE_ACCESS</h4>
<p>This flag prevents user-mode access to this specific pin.</p>
<h4>KSPIN_FLAG_IMPLEMENT_CLOCK</h4>
<p>Indicates that this pin exposes a clock that can be selected by the graph manager as a master clock. Also see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/avstream-clocks">AVStream Clocks</a>.</p>
<h3><code>InstancesPossible</code></h3>
<p>Specifies a value of type <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> that contains a count of the maximum number of possible instances of this pin. Any attempt to instantiate more than this number of pins of the given type fails. Set to KSINSTANCE_INDETERMINATE to have no limit on number of pins instantiated.</p>
<h3><code>InstancesNecessary</code></h3>
<p>Specifies a value of type <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> that contains the minimum number of pins of a given pin type that are required to be in a state at or above the minimum processing level for proper functioning of the filter. By default the minimum processing level is KSSTATE_PAUSE, although the minidriver can modify the default behavior by setting the <strong>Flags</strong> member of this structure to either KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY or KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE. Any attempt to change the state of a filter that does not have this number of instances of this type of pin fails. See additional information in the Remarks section.</p>
<h3><code>AllocatorFraming</code></h3>
<p>A pointer to a <strong><a href="ksallocator_framing_ex" title="typedef struct {&#10;  ULONG           CountItems;&#10;  ULONG           PinFlags;&#10;  KS_COMPRESSION  OutputCompression;&#10;  ULONG           PinWeight;&#10;  KS_FRAMING_ITEM FramingItem[1];&#10;} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;">KSALLOCATOR_FRAMING_EX</a></strong> structure containing the allocator framing requirements for this pin type. Allocator framing specifies items such as memory alignment requirements, maximum frame size, and minimum frame size. This member can be <strong>NULL</strong>, which indicates that this pin does not support the allocator framing property.</p>
<h3><code>IntersectHandler</code></h3>
<p>A pointer to a driver-defined <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff567185(v=vs.85)">KStrIntersectHandlerEx</a> function to handle data-intersection. If this member is <strong>NULL</strong>, the pin handles data intersection queries for data ranges with the specifier KSDATAFORMAT_SPECIFIER_NONE. The intersection handler function receives a single data range from the query and a single data range from the pins list of data ranges. The type, subtype, and specifier GUIDs of these ranges are guaranteed to match, though some may be wildcards. The function either indicates the data ranges do not match, or it produces the best data format in the intersection of the two data ranges. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/data-range-intersections-in-avstream">Data Range Intersections in AVStream</a> for more information.</p>
<h2>Remarks</h2>
<p>AMCap and Blink might not be able to find tuner and crossbar interfaces on your AVStream driver if the <strong>InstancesNecessary</strong> member of KSPIN_DESCRIPTOR_EX is set to zero for the analog video input pin. To fix this problem, set <strong>InstancesNecessary</strong> for this pin to one.</p>
<p>Note that the allocator framing requirements of your pin may be ignored despite the fact that your allocator framing specifies that alignment or size is absolutely required to be a certain value. If your kernel-mode driver is connected to an upstream user-mode filter that allocates for it and the particular upstream filter's allocator does not understand framing requirements, this can happen (current particular examples include the MPEG-2 splitter).</p>
<p>Furthermore, if you specify KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING and the pin uses the standard transport mechanism, you must have a processing object. This means there must be some process dispatch provided (either at the filter level or at the pin level); even if this function is never called, it must be provided in this circumstance.</p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/data-range-intersections-in-avstream">Data Range Intersections in AVStream</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/stream/avstream-splitters">AVStream Splitters</a>.</p>
<h2>See also</h2>
<p><strong><a href="ksallocator_framing_ex" title="typedef struct {&#10;  ULONG           CountItems;&#10;  ULONG           PinFlags;&#10;  KS_COMPRESSION  OutputCompression;&#10;  ULONG           PinWeight;&#10;  KS_FRAMING_ITEM FramingItem[1];&#10;} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;">KSALLOCATOR_FRAMING_EX</a></strong></p>
<p><strong><a href="kspin_descriptor" title="typedef struct {&#10;  ULONG                 InterfacesCount;&#10;  const KSPIN_INTERFACE *Interfaces;&#10;  ULONG                 MediumsCount;&#10;  const KSPIN_MEDIUM    *Mediums;&#10;  ULONG                 DataRangesCount;&#10;  const PKSDATARANGE    *DataRanges;&#10;  KSPIN_DATAFLOW        DataFlow;&#10;  KSPIN_COMMUNICATION   Communication;&#10;  const GUID            *Category;&#10;  const GUID            *Name;&#10;  union {&#10;    LONGLONG Reserved;&#10;    struct {&#10;      ULONG        ConstrainedDataRangesCount;&#10;      PKSDATARANGE *ConstrainedDataRanges;&#10;    };&#10;  };&#10;} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;">KSPIN_DESCRIPTOR</a></strong></p>
<p><strong><a href="kspin_dispatch" title="typedef struct _KSPIN_DISPATCH {&#10;  PFNKSPINIRP                Create;&#10;  PFNKSPINIRP                Close;&#10;  PFNKSPIN                   Process;&#10;  PFNKSPINVOID               Reset;&#10;  PFNKSPINSETDATAFORMAT      SetDataFormat;&#10;  PFNKSPINSETDEVICESTATE     SetDeviceState;&#10;  PFNKSPIN                   Connect;&#10;  PFNKSPINVOID               Disconnect;&#10;  const KSCLOCK_DISPATCH     *Clock;&#10;  const KSALLOCATOR_DISPATCH *Allocator;&#10;} KSPIN_DISPATCH, *PKSPIN_DISPATCH;">KSPIN_DISPATCH</a></strong></p>
<p><a href="ksdeviceregisteradapterobject" title="void KsDeviceRegisterAdapterObject(&#10;  [in] PKSDEVICE       Device,&#10;  [in] PADAPTER_OBJECT AdapterObject,&#10;  [in] ULONG           MaxMappingsByteCount,&#10;  [in] ULONG           MappingTableStride&#10;);">KsDeviceRegisterAdapterObject</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ks/ns-ks-_kspin_descriptor_ex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ks/ns-ks-_kspin_descriptor_ex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
