<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtCreateFile - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtCreateFile - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtCreateFile - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTIOAPI_H

</span><span class="ntdoc-code-intro language-cpp">//
// System calls
//

/**
 * The NtCreateFile routine creates a new file or directory, or opens an existing file, device, directory, or volume.
 *
 * \param[out] FileHandle Pointer to a variable that receives a handle to the pipe.
 * \param[in] DesiredAccess The requested access to the object.
 * \param[in] ObjectAttributes Pointer to an <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> structure that contains the object attributes, including pipe name.
 * \param[out] IoStatusBlock Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the operation.
 * \param[in] AllocationSize The initial allocation size in bytes for the file. Specify a non-zero value to eliminate disk fragmentation, since the file system pre-allocates the file using a contiguous block.
 * \param[in] FileAttributes The file attributes. Explicitly specified attributes are applied only when the file is created, superseded, or, in some cases, overwritten.
 * \param[in] ShareAccess The type of share access that the caller would like to use in the file.
 * \param[in] CreateDisposition Specifies how the file should be handled when the file already exists.
 * \param[in] CreateOptions Specifies the options to be applied when creating or opening the file.
 * \param[in] EaBuffer Pointer to an EA buffer used to pass extended attributes.
 * \param[in] EaLength Length of the EA buffer.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa <a target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/Winternl/nf-winternl-ntcreatefile">https://learn.microsoft.com/en-us/windows/win32/api/Winternl/nf-winternl-ntcreatefile</a>
 */
</span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ <a href="pcobject_attributes" title="typedef const OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;">PCOBJECT_ATTRIBUTES</a> ObjectAttributes,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> FileAttributes,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ShareAccess,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CreateDisposition,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EaLength
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/57fdc63dd8b52d0d58cc2f04626153c4035537d7/phnt/include/ntioapi.h#L1822">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ <a href="pcobject_attributes" title="typedef const OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;">PCOBJECT_ATTRIBUTES</a> ObjectAttributes,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> FileAttributes,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ShareAccess,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CreateDisposition,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> EaLength
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/57fdc63dd8b52d0d58cc2f04626153c4035537d7/phnt/include/ntzwapi.h#L1018">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntifs.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtCreateFile(
  [out]          PHANDLE            FileHandle,
  [in]           ACCESS_MASK        DesiredAccess,
  [in]           <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>   IoStatusBlock,
  [in, optional] PLARGE_INTEGER     AllocationSize,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              FileAttributes,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              ShareAccess,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateDisposition,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateOptions,
  [in, optional] PVOID              EaBuffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              EaLength
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatefile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wdm.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwCreateFile(
  [out]          PHANDLE            FileHandle,
  [in]           ACCESS_MASK        DesiredAccess,
  [in]           <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>   IoStatusBlock,
  [in, optional] PLARGE_INTEGER     AllocationSize,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              FileAttributes,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              ShareAccess,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateDisposition,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateOptions,
  [in, optional] PVOID              EaBuffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              EaLength
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatefile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// winternl.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">__kernel_entry <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtCreateFile(
  [out]          PHANDLE            FileHandle,
  [in]           ACCESS_MASK        DesiredAccess,
  [in]           <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>   IoStatusBlock,
  [in, optional] PLARGE_INTEGER     AllocationSize,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              FileAttributes,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              ShareAccess,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateDisposition,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              CreateOptions,
  [in]           PVOID              EaBuffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              EaLength
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winternl/nf-winternl-ntcreatefile">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntcreatefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntcreatefile)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>NtCreateFile function</h1>
<h2>Description</h2>
<p>The <strong>NtCreateFile</strong> routine creates a new file or opens an existing file.</p>
<h2>Parameters</h2>
<h3><code>FileHandle</code> [out]</h3>
<p>A pointer to a HANDLE variable that receives a handle to the file.</p>
<h3><code>DesiredAccess</code> [in]</h3>
<p>Specifies an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a> value that determines the requested access to the object.</p>
<p>In addition to the <em>standard</em> access rights that are defined for all types of objects, the caller can specify any of the following <em>specific</em> access rights; that is, rights that are specific to files.</p>
<table>
<thead>
<tr>
<th>ACCESS_MASK flag</th>
<th>Allows caller to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILE_READ_DATA</td>
<td>Read data from the file.</td>
</tr>
<tr>
<td>FILE_READ_ATTRIBUTES</td>
<td>Read the attributes of the file. For more information, see the description of the <em>FileAttributes</em> parameter.</td>
</tr>
<tr>
<td>FILE_READ_EA</td>
<td>Read the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>FILE_WRITE_DATA</td>
<td>Write data to the file.</td>
</tr>
<tr>
<td>FILE_WRITE_ATTRIBUTES</td>
<td>Write the attributes of the file. For more information, see the description of the <em>FileAttributes</em> parameter.</td>
</tr>
<tr>
<td>FILE_WRITE_EA</td>
<td>Change the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>FILE_APPEND_DATA</td>
<td>Append data to the file.</td>
</tr>
<tr>
<td>FILE_EXECUTE</td>
<td>Use system paging I/O to read data from the file into memory. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!NOTE]
Do not specify FILE_READ_DATA, FILE_WRITE_DATA, FILE_APPEND_DATA, or FILE_EXECUTE when you create or open a directory.</p>
</blockquote>
<p>The caller can also specify the following <em>generic</em> access rights (rights that apply to all object types, where the meaning of each generic access right is specific to the object type). Generic access rights for file objects correspond to specific access rights as shown in the following table. (Note that &quot;correspond&quot; means &quot;maps to&quot; and does not mean that the value of the generic right is &quot;equal to&quot; the value of the bitwise OR of its specific rights mapping). The I/O manager defines the actual mapping.</p>
<table>
<thead>
<tr>
<th>Generic access right</th>
<th>Maps to these specific access rights</th>
</tr>
</thead>
<tbody>
<tr>
<td>GENERIC_READ</td>
<td>STANDARD_RIGHTS_READ, FILE_READ_DATA, FILE_READ_ATTRIBUTES, FILE_READ_EA, and SYNCHRONIZE</td>
</tr>
<tr>
<td>GENERIC_WRITE</td>
<td>STANDARD_RIGHTS_WRITE, FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, FILE_APPEND_DATA, and SYNCHRONIZE</td>
</tr>
<tr>
<td>GENERIC_EXECUTE</td>
<td>STANDARD_RIGHTS_EXECUTE, FILE_EXECUTE, FILE_READ_ATTRIBUTES, and SYNCHRONIZE. This value is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>GENERIC_ALL</td>
<td>FILE_ALL_ACCESS</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!NOTE]
<em>Generic</em> access rights can only be specified for a file; they cannot be specified for a directory.</p>
<p>Some <strong>CreateOptions</strong> flags require that certain access flags be set in <strong>DesiredAccess</strong> when <strong>NtCreateFile</strong> is called. See the <strong>CreateOptions</strong> parameter for these details.</p>
</blockquote>
<p>For example, if you specify GENERIC_READ for a file object, the routine maps this value to the FILE_GENERIC_READ bitmask of specific access rights. In the preceding table, the specific access rights that are listed for GENERIC_READ correspond to (but are not equal to) the access flags that are contained in the FILE_GENERIC_READ bitmask.</p>
<p>If the file is actually a directory, the caller can also specify the following generic access rights.</p>
<table>
<thead>
<tr>
<th><em>DesiredAccess</em> flag</th>
<th>Allows caller to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILE_LIST_DIRECTORY</td>
<td>List the files in the directory.</td>
</tr>
<tr>
<td>FILE_TRAVERSE</td>
<td>Traverse the directory, in other words, include the directory in the path of a file.</td>
</tr>
</tbody>
</table>
<p>For more information about access rights, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-rights">Access Rights</a>.</p>
<h3><code>ObjectAttributes</code> [in]</h3>
<p>A pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfwdm/ns-wudfwdm-_object_attributes">OBJECT_ATTRIBUTES</a> structure that specifies the object name and other attributes. Use <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfwdm/nf-wudfwdm-initializeobjectattributes">InitializeObjectAttributes</a> to initialize this structure. If the caller is not running in a system thread context, it must set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute when it calls <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong>.</p>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>A pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and other information about the requested operation. In particular, the <strong>Information</strong> member receives one of the following values:</p>
<ul>
<li><a href="file_created" title="#define FILE_CREATED 0x00000002">FILE_CREATED</a></li>
<li><a href="file_opened" title="#define FILE_OPENED 0x00000001">FILE_OPENED</a></li>
<li><a href="file_overwritten" title="#define FILE_OVERWRITTEN 0x00000003">FILE_OVERWRITTEN</a></li>
<li><a href="file_superseded" title="#define FILE_SUPERSEDED 0x00000000">FILE_SUPERSEDED</a></li>
<li><a href="file_exists" title="#define FILE_EXISTS 0x00000004">FILE_EXISTS</a></li>
<li><a href="file_does_not_exist" title="#define FILE_DOES_NOT_EXIST 0x00000005">FILE_DOES_NOT_EXIST</a></li>
</ul>
<h3><code>AllocationSize</code> [in, optional]</h3>
<p>A pointer to a LARGE_INTEGER that contains the initial allocation size, in bytes, for a file that is created or overwritten. If <em>AllocationSize</em> is <strong>NULL</strong>, no allocation size is specified. If no file is created or overwritten, <em>AllocationSize</em> is ignored.</p>
<h3><code>FileAttributes</code> [in]</h3>
<p>Specifies one or more FILE_ATTRIBUTE_<em>XXX</em> flags, which represent the file attributes to set if you create or overwrite a file. The caller usually specifies FILE_ATTRIBUTE_NORMAL, which sets the default attributes. For a list of valid FILE_ATTRIBUTE_<em>XXX</em> flags, see the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> routine in the Microsoft Windows SDK documentation. If no file is created or overwritten, <em>FileAttributes</em> is ignored.</p>
<h3><code>ShareAccess</code> [in]</h3>
<p>Type of share access, which is specified as zero or any combination of the following flags.</p>
<table>
<thead>
<tr>
<th><em>ShareAccess</em> flag</th>
<th>Allows other threads to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></td>
<td>Read the file</td>
</tr>
<tr>
<td><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></td>
<td>Write the file</td>
</tr>
<tr>
<td><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></td>
<td>Delete the file</td>
</tr>
</tbody>
</table>
<p>Device and intermediate drivers usually set <em>ShareAccess</em> to zero, which gives the caller exclusive access to the open file.</p>
<h3><code>CreateDisposition</code> [in]</h3>
<p>Specifies the action to perform if the file does or does not exist. <em>CreateDisposition</em> can be one of the values in the following table.</p>
<table>
<thead>
<tr>
<th><em>CreateDisposition</em> value</th>
<th>Action if file exists</th>
<th>Action if file does not exist</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></td>
<td>Replace the file.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></td>
<td>Return an error.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></td>
<td>Open the file.</td>
<td>Return an error.</td>
</tr>
<tr>
<td><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></td>
<td>Open the file.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></td>
<td>Open the file, and overwrite it.</td>
<td>Return an error.</td>
</tr>
<tr>
<td><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></td>
<td>Open the file, and overwrite it.</td>
<td>Create the file.</td>
</tr>
</tbody>
</table>
<h3><code>CreateOptions</code> [in]</h3>
<p>Specifies the options to apply when the driver creates or opens the file. Use one or more of the flags in the following table.</p>
<table>
<thead>
<tr>
<th>CreateOptions flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> (0x00000001)</td>
<td>The file is a directory. Compatible <strong>CreateOptions</strong> flags are <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>, <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, <a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a>, <a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a>, and <a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a>. The <strong>CreateDisposition</strong> parameter must be set to <a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a>, <a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a>, or <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>.</td>
</tr>
<tr>
<td><a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a> (0x00000002)</td>
<td>System services, file-system drivers, and drivers that write data to the file must actually transfer the data to the file before any requested write operation is considered complete.</td>
</tr>
<tr>
<td><a href="file_sequential_only" title="#define FILE_SEQUENTIAL_ONLY 0x00000004">FILE_SEQUENTIAL_ONLY</a> (0x00000004)</td>
<td>All access to the file will be sequential.</td>
</tr>
<tr>
<td><a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> (0x00000008)</td>
<td>The file cannot be cached or buffered in a driver's internal buffers. This flag is incompatible with the <strong>DesiredAccess</strong> parameter's FILE_APPEND_DATA flag.</td>
</tr>
<tr>
<td><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> (0x00000010)</td>
<td>All operations on the file are performed synchronously. Any wait on behalf of the caller is subject to premature termination from alerts. This flag also causes the I/O system to maintain the file-position pointer. If this flag is set, the SYNCHRONIZE flag must be set in the <strong>DesiredAccess</strong> parameter.</td>
</tr>
<tr>
<td><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> (0x00000020)</td>
<td>All operations on the file are performed synchronously. Waits in the system that synchronize I/O queuing and completion are not subject to alerts. This flag also causes the I/O system to maintain the file-position context. If this flag is set, the SYNCHRONIZE flag must be set in the <strong>DesiredAccess</strong> parameter.</td>
</tr>
<tr>
<td><a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a> (0x00000040)</td>
<td>The file is <em>not</em> a directory. The file object to open can represent a data file; a logical, virtual, or physical device; or a volume. Starting in Windows 11, version 24H2, NTFS now honors this flag when opening a $INDEX_ALLOCATION attribute.</td>
</tr>
<tr>
<td><a href="file_create_tree_connection" title="#define FILE_CREATE_TREE_CONNECTION 0x00000080">FILE_CREATE_TREE_CONNECTION</a> (0x00000080)</td>
<td>Create a tree connection for this file in order to open it over the network. This flag is not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_complete_if_oplocked" title="#define FILE_COMPLETE_IF_OPLOCKED 0x00000100">FILE_COMPLETE_IF_OPLOCKED</a> (0x00000100)</td>
<td>Complete this operation immediately with an alternate success code of STATUS_OPLOCK_BREAK_IN_PROGRESS if the target file is oplocked, rather than blocking the caller's thread. If the file is oplocked, another caller already has access to the file. This flag is not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_no_ea_knowledge" title="#define FILE_NO_EA_KNOWLEDGE 0x00000200">FILE_NO_EA_KNOWLEDGE</a> (0x00000200)</td>
<td>If the extended attributes (EAs) for an existing file being opened indicate that the caller must understand EAs to properly interpret the file, <strong>NtCreateFile</strong> should return an error. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_open_remote_instance" title="#define FILE_OPEN_REMOTE_INSTANCE 0x00000400">FILE_OPEN_REMOTE_INSTANCE</a> (0x00000400)</td>
<td>Reserved for system use; do not use.</td>
</tr>
<tr>
<td><a href="file_random_access" title="#define FILE_RANDOM_ACCESS 0x00000800">FILE_RANDOM_ACCESS</a> (0x00000800)</td>
<td>Access to the file can be random, so no sequential read-ahead operations should be performed by file-system drivers or by the system.</td>
</tr>
<tr>
<td><a href="file_delete_on_close" title="#define FILE_DELETE_ON_CLOSE 0x00001000">FILE_DELETE_ON_CLOSE</a> (0x00001000)</td>
<td>The system deletes the file when the last handle to the file is passed to <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></strong>. If this flag is set, the DELETE flag must be set in the <strong>DesiredAccess</strong> parameter.</td>
</tr>
<tr>
<td><a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a> (0x00002000)</td>
<td>The file name that is specified by the <strong>ObjectAttributes</strong> parameter includes a binary 8-byte or 16-byte file reference number or object ID for the file, depending on the file system. Optionally, a device name followed by a backslash character may proceed these binary values. See Remarks for additional details and an example.</td>
</tr>
<tr>
<td><a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a> (0x00004000)</td>
<td>The file is being opened for backup intent. Therefore, the system should check for certain access rights and grant the caller the appropriate access to the file—before checking the <strong>DesiredAccess</strong> parameter against the file's security descriptor. This flag not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_no_compression" title="#define FILE_NO_COMPRESSION 0x00008000">FILE_NO_COMPRESSION</a> (0x00008000)</td>
<td>Suppress inheritance of FILE_ATTRIBUTE_COMPRESSED from the parent directory. This allows creation of a non-compressed file in a directory that is marked compressed.</td>
</tr>
<tr>
<td><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> (0x00010000)</td>
<td>The file is being opened and an opportunistic lock (oplock) on the file is being requested as a single atomic operation. The file system checks for oplocks before it performs the create operation, and will fail the create with a return code of STATUS_CANNOT_BREAK_OPLOCK if the result would be to break an existing oplock. This flag is available starting with Windows 7 and Windows Server 2008 R2.</td>
</tr>
<tr>
<td><a href="file_disallow_exclusive" title="#define FILE_DISALLOW_EXCLUSIVE 0x00020000">FILE_DISALLOW_EXCLUSIVE</a> (0x00020000)</td>
<td>When opening an existing file, if <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> is not specified and file system access checks would not grant the caller write access to the file, fail this open with STATUS_ACCESS_DENIED. This was default behavior prior to Windows 7. This flag is available starting with Windows 7 and Windows Server 2008 R2.</td>
</tr>
<tr>
<td><a href="file_session_aware" title="#define FILE_SESSION_AWARE 0x00040000">FILE_SESSION_AWARE</a> (0x00040000)</td>
<td>The client opening the file or device is session aware and per session access is validated if necessary. This flag is available starting with Windows 8.</td>
</tr>
<tr>
<td><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> (0x00100000)</td>
<td>This flag allows an application to request a Filter opportunistic lock (oplock) to prevent other applications from getting share violations. If there are already open handles, the create request will fail with STATUS_OPLOCK_NOT_GRANTED. For more information, see the following Remarks section.</td>
</tr>
<tr>
<td><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> (0x00200000)</td>
<td>Open a file with a reparse point and bypass normal reparse point processing for the file. For more information, see the following Remarks section.</td>
</tr>
<tr>
<td><a href="file_open_no_recall" title="#define FILE_OPEN_NO_RECALL 0x00400000">FILE_OPEN_NO_RECALL</a> (0x00400000)</td>
<td>Instructs any filters that perform offline storage or virtualization to not recall the contents of the file as a result of this open.</td>
</tr>
<tr>
<td><a href="file_open_for_free_space_query" title="#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000">FILE_OPEN_FOR_FREE_SPACE_QUERY</a> (0x00800000)</td>
<td>This flag instructs the file system to capture the user associated with the calling thread. Any subsequent calls to <a href="fltqueryvolumeinformation" title="NTSTATUS FLTAPI FltQueryVolumeInformation(&#10;  [in]  PFLT_INSTANCE        Instance,&#10;  [out] PIO_STATUS_BLOCK     Iosb,&#10;  [out] PVOID                FsInformation,&#10;  [in]  ULONG                Length,&#10;  [in]  FS_INFORMATION_CLASS FsInformationClass&#10;);">FltQueryVolumeInformation</a> or <a href="ntqueryvolumeinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryVolumeInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FsInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FSINFOCLASS FsInformationClass&#10;    );">ZwQueryVolumeInformationFile</a> using the returned handle will assume the captured user, rather than the calling user at the time, for purposes of computing the free space available to the caller. This applies to the following FsInformationClass values: FileFsSizeInformation, FileFsFullSizeInformation, and FileFsFullSizeInformationEx.</td>
</tr>
<tr>
<td><a href="file_contains_extended_create_information" title="#define FILE_CONTAINS_EXTENDED_CREATE_INFORMATION 0x10000000">FILE_CONTAINS_EXTENDED_CREATE_INFORMATION</a> (0x10000000)</td>
<td>Interpret the <strong>EaBuffer</strong> parameter as an instance of <strong><a href="extended_create_information" title="typedef struct _EXTENDED_CREATE_INFORMATION&#10;{&#10;    LONGLONG ExtendedCreateFlags;&#10;    PVOID EaBuffer;&#10;    ULONG EaLength;&#10;    //PEXTENDED_CREATE_DUAL_OPLOCK_KEYS DualOplockKeys; // since 24H2&#10;} EXTENDED_CREATE_INFORMATION, *PEXTENDED_CREATE_INFORMATION;">EXTENDED_CREATE_INFORMATION</a></strong>. This flag is available starting in Windows 11, version 22H2.</td>
</tr>
</tbody>
</table>
<h3><code>EaBuffer</code> [in, optional]</h3>
<p>For device and intermediate drivers, this parameter must be a <strong>NULL</strong> pointer.</p>
<h3><code>EaLength</code> [in]</h3>
<p>For device and intermediate drivers, this parameter must be zero.</p>
<h2>Return value</h2>
<p><strong>NtCreateFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code on failure. In the latter case, the caller can determine the cause of the failure by checking the <em>IoStatusBlock</em> parameter.</p>
<blockquote>
<p>[!NOTE]
<strong>NtCreateFile</strong> might return STATUS_FILE_LOCK_CONFLICT as the return value or in the <strong>Status</strong> member of the <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that is pointed to by the <em>IoStatusBlock</em> parameter. This would occur only if the NTFS log file is full, and an error occurs while <strong>NtCreateFile</strong> tries to handle this situation.</p>
</blockquote>
<h2>Remarks</h2>
<p><strong>NtCreateFile</strong> supplies a handle that the caller can use to manipulate a file's data, or the file object's state and attributes. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>
<p>Once the handle pointed to by <em>FileHandle</em> is no longer in use, the driver must call <a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a> to close it.</p>
<p>If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/object-handles">Object Handles</a>.</p>
<p>There are two alternate ways to specify the name of the file to be created or opened with <strong>NtCreateFile</strong>:</p>
<ul>
<li>As a fully qualified pathname, supplied in the <strong>ObjectName</strong> member of the input <em>ObjectAttributes.</em></li>
<li>As pathname relative to the directory file represented by the handle in the <strong>RootDirectory</strong> member of the input <em>ObjectAttributes</em>.</li>
</ul>
<p>Setting certain flags in the <em>DesiredAccess</em> parameter results in the following effects:</p>
<ul>
<li>For a caller to synchronize an I/O completion by waiting for the returned <em>FileHandle</em>, the SYNCHRONIZE flag must be set. Otherwise, a caller that is a device or intermediate driver must synchronize an I/O completion by using an event object.</li>
<li>If the caller sets only the FILE_APPEND_DATA and SYNCHRONIZE flags, it can write only to the end of the file, and any offset information about write operations to the file is ignored. The file will automatically be extended as necessary for this type of operation.</li>
<li>Setting the FILE_WRITE_DATA flag for a file also allows the caller to write beyond the end of the file. Again, the file is automatically extended as necessary.</li>
<li>If the caller sets only the FILE_EXECUTE and SYNCHRONIZE flags, it cannot directly read or write any data to the file using the returned <em>FileHandle</em>. That is, all operations on the file occur through the system pager in response to instruction and data-access operations. Device and intermediate drivers should not set the FILE_EXECUTE flag.</li>
</ul>
<p>The <em>ShareAccess</em> parameter determines whether separate threads can access the same file, possibly simultaneously. Provided that both callers have the appropriate access privileges, the file can be successfully opened and shared. If the original caller of <strong>NtCreateFile</strong> does not specify <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a>, <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a>, or <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>, no other caller can open the file—that is, the original caller is granted exclusive access.</p>
<p>To successfully open a shared file, the <em>DesiredAccess</em> flags must be compatible with the <em>DesiredAccess</em> and <em>ShareAccess</em> flags of all the previous open operations that have not yet been released through . That is, the <em>DesiredAccess</em> specified to <strong>NtCreateFile</strong> for a given file must not conflict with the accesses that other openers of the file have disallowed.</p>
<p>The <em>CreateDisposition</em> value <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> requires that the caller have DELETE access to an existing file object. If so, a successful call to <strong>NtCreateFile</strong> with <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> on an existing file effectively deletes that file, and then recreates it. This implies that, if the file has already been opened by another thread, it opened the file by specifying a <em>ShareAccess</em> parameter with the <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a> flag set. Note that this type of disposition is consistent with the POSIX style of overwriting files.</p>
<p>The <em>CreateDisposition</em> values <a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a> and <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> are similar. If <strong>NtCreateFile</strong> is called with an existing file and either of these <em>CreateDisposition</em> values, the file will be replaced.</p>
<p>Overwriting a file is semantically equivalent to a supersede operation, except for the following:</p>
<ul>
<li>The caller must have write access to the file, rather than delete access. This implies that, if the file has already been opened by another thread, it opened the file with the <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> flag set in the input <em>ShareAccess</em>.</li>
<li>The specified file attributes are logically ORed with those already on the file. This implies that, if the file has already been opened by another thread, a subsequent caller of <strong>NtCreateFile</strong> cannot disable existing <em>FileAttributes</em> flags but can enable additional flags for the same file. Note that this style of overwriting files is consistent with MS-DOS, Microsoft Windows 3.1, and OS/2.</li>
</ul>
<p>The <a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> <em>CreateOptions</em> value specifies that the file to be created or opened is a directory. When a directory file is created, the file system creates an appropriate structure on the disk to represent an empty directory for that particular file system's on-disk structure. If this option was specified and the given file to be opened is not a directory file, or if the caller specified an inconsistent <em>CreateOptions</em> or <em>CreateDisposition</em> value, the call to <strong>NtCreateFile</strong> will fail.</p>
<p>The <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> <em>CreateOptions</em> flag prevents the file system from performing any intermediate buffering on behalf of the caller. Specifying this flag places the following restrictions on the caller's parameters to other <strong>Zw<em>Xxx</em>File</strong> routines.</p>
<ul>
<li>Any optional <em>ByteOffset</em> passed to <a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a> or <a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a> must be a multiple of the sector size.</li>
<li>The <em>Length</em> passed to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong> must be an integral of the sector size. Note that specifying a read operation to a buffer whose length is exactly the sector size might result in a lesser number of significant bytes being transferred to that buffer if the end of the file was reached during the transfer.</li>
<li>Buffers must be aligned in accordance with the alignment requirement of the underlying device. To obtain this information, call <strong>NtCreateFile</strong> to get a handle for the file object that represents the physical device, and pass that handle to <a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a>. For a list of the system's FILE_<em>XXX</em>_ALIGNMENT values, see <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a>.</li>
<li>Calls to <a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a> with the <em>FileInformationClass</em> parameter set to <strong>FilePositionInformation</strong> must specify an offset that is a multiple of the sector size.</li>
</ul>
<p>The <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> and <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> <em>CreateOptions</em> flags (which are mutually exclusive) specify that all I/O operations on the file will be synchronous, as long as the operations occur through the file object referred to by the returned <em>FileHandle</em>. All I/O on such a file is serialized across all threads using the returned handle. If either of these <em>CreateOptions</em> flags is set, the SYNCHRONIZE <em>DesiredAccess</em> flag must also be set to compel the I/O manager to use the file object as a synchronization object. In these cases, the I/O manager keeps track of the current file-position offset, which you can pass to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> and <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong>. Call <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong> or <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong> to get or set this position.</p>
<p>If the <em>CreateOptions</em> <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is <strong>not</strong> specified and <strong>NtCreateFile</strong> attempts to open a file with a reparse point, normal reparse point processing occurs for the file. If, on the other hand, the <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is specified, normal reparse processing does <em>not</em> occur and <strong>NtCreateFile</strong> attempts to directly open the reparse point file. In either case, if the open operation was successful, <strong>NtCreateFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>; otherwise, the routine returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code. <strong>NtCreateFile</strong> never returns STATUS_REPARSE.</p>
<p>The <em>CreateOptions</em> <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag eliminates the time between when you open the file and request an oplock that could potentially allow a third party to open the file and get a sharing violation. An application can use the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag on <strong>NtCreateFile</strong> and then request any oplock. This ensures that an oplock owner will be notified of any subsequent open request that causes a sharing violation.</p>
<p>In Windows 7, if other handles exist on the file when an application uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag, the create operation will fail with STATUS_OPLOCK_NOT_GRANTED. This restriction no longer exists starting with Windows 8.</p>
<p>If this create operation would break an oplock that already exists on the file, then setting the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag will cause the create operation to fail with STATUS_CANNOT_BREAK_OPLOCK. The existing oplock will not be broken by this create operation.</p>
<p>An application that uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag must request an oplock after this call succeeds, or all subsequent attempts to open the file will be blocked without the benefit of normal oplock processing. Similarly, if this call succeeds but the subsequent oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed. The application must not perform any other file system operation on the file before requesting the oplock (besides closing the file handle), otherwise a deadlock may occur.</p>
<blockquote>
<p>[!NOTE]
The <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag is available in Windows 7, Windows Server 2008 R2 and later Windows operating systems. The Microsoft file systems that implement this flag in Windows 7 are NTFS, FAT, and exFAT.</p>
</blockquote>
<p>The <em>CreateOptions</em> flag <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> allows an application to request a Level 1, Batch, or Filter oplock to prevent other applications from getting share violations. However, <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> is only practically useful for Filter oplocks. To use it, you must complete the following steps:</p>
<ol>
<li>Issue a create request with <em>CreateOptions</em> of <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>, <em>DesiredAccess</em> of exactly FILE_READ_ATTRIBUTES, and <em>ShareAccess</em> of exactly <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>.
<ul>
<li>If there are already open handles, the create request fails with STATUS_OPLOCK_NOT_GRANTED, and the next requested oplock also fails.</li>
<li>If you open with more access or less sharing will also cause a failure of STATUS_OPLOCK_NOT_GRANTED.</li>
</ul>
</li>
<li>If the create request succeeds, request an oplock.</li>
<li>Open another handle to the file to do I/O.</li>
</ol>
<p>Step 3 makes this practical only for Filter oplocks. The handle opened in step 3 can have a <em>DesiredAccess</em> that contains a maximum of FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL and still not break a Filter oplock. However, any <em>DesiredAccess</em> greater than FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE will break a Level 1 or Batch oplock and make the <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> flag useless for those oplock types.</p>
<p>NTFS is the only Microsoft file system that implements <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>.</p>
<p>For the <em>CreateOptions</em> <a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a> flag, an example device name will have the format:</p>
<pre><code class="language-syntax">\??\C:\&lt;FileID&gt;
\device\HardDiskVolume1\&lt;ObjectID&gt;
</code></pre>
<p>where <em>FileID</em> is 8 bytes and <em>ObjectID</em> is 16 bytes:</p>
<ul>
<li>On NTFS, this can be a 8-byte or 16-byte reference number or object ID. A 16-byte reference number is the same as an 8-byte number padded with zeros.</li>
<li>On ReFS, this can be an 8-byte or 16-byte reference number. A 16-byte number is not related to an 8-byte number. Object IDs are not supported.</li>
<li>The FAT, ExFAT, UDFS, and CDFS file systems do not support the <a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a> flag.</li>
</ul>
<p>This number is assigned by and specific to the particular file system. Because the filename field will partly contain a binary blob, it is incorrect to assume that this is a valid Unicode string, and more importantly may not be a null terminated string.</p>
<p>Callers of <strong>NtCreateFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>
<blockquote>
<p>[!NOTE]
If the call to this function occurs in user mode, you should use the name &quot;<strong>NtCreateFile</strong>&quot; instead of &quot;<strong>ZwCreateFile</strong>&quot;.</p>
</blockquote>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a></p>
<p><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></p>
<p><strong><a href="extended_create_information" title="typedef struct _EXTENDED_CREATE_INFORMATION&#10;{&#10;    LONGLONG ExtendedCreateFlags;&#10;    PVOID EaBuffer;&#10;    ULONG EaLength;&#10;    //PEXTENDED_CREATE_DUAL_OPLOCK_KEYS DualOplockKeys; // since 24H2&#10;} EXTENDED_CREATE_INFORMATION, *PEXTENDED_CREATE_INFORMATION;">EXTENDED_CREATE_INFORMATION</a></strong></p>
<p><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfwdm/nf-wudfwdm-initializeobjectattributes">InitializeObjectAttributes</a></p>
<p><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></p>
<p><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></p>
<p><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></p>
<p><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></p>
<p><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></p>
<p><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatefile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntcreatefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-zwcreatefile)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>
<p>The <strong>ZwCreateFile</strong> routine creates a new file or opens an existing file.</p>
<h2>Parameters</h2>
<h3><code>FileHandle</code> [out]</h3>
<p>A pointer to a HANDLE variable that receives a handle to the file.</p>
<h3><code>DesiredAccess</code> [in]</h3>
<p>Specifies an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a> value that determines the requested access to the object. In addition to the access rights that are defined for all types of objects, the caller can specify any of the following access rights, which are specific to files.</p>
<table>
<thead>
<tr>
<th>ACCESS_MASK flag</th>
<th>Allows caller to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILE_READ_DATA</td>
<td>Read data from the file.</td>
</tr>
<tr>
<td>FILE_READ_ATTRIBUTES</td>
<td>Read the attributes of the file. (For more information, see the description of the <em>FileAttributes</em> parameter.)</td>
</tr>
<tr>
<td>FILE_READ_EA</td>
<td>Read the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>FILE_WRITE_DATA</td>
<td>Write data to the file.</td>
</tr>
<tr>
<td>FILE_WRITE_ATTRIBUTES</td>
<td>Write the attributes of the file. (For more information, see the description of the <em>FileAttributes</em> parameter.)</td>
</tr>
<tr>
<td>FILE_WRITE_EA</td>
<td>Change the extended attributes (EAs) of the file. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>FILE_APPEND_DATA</td>
<td>Append data to the file.</td>
</tr>
<tr>
<td>FILE_EXECUTE</td>
<td>Use system paging I/O to read data from the file into memory. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
</tbody>
</table>
<p>Do not specify FILE_READ_DATA, FILE_WRITE_DATA, FILE_APPEND_DATA, or FILE_EXECUTE when you create or open a directory.</p>
<p>The caller can only specify a generic access right, GENERIC_<em>XXX</em>, for a file, not a directory. Generic access rights correspond to specific access rights as shown in the following table.</p>
<table>
<thead>
<tr>
<th>Generic access right</th>
<th>Set of specific access rights</th>
</tr>
</thead>
<tbody>
<tr>
<td>GENERIC_READ</td>
<td>STANDARD_RIGHTS_READ, FILE_READ_DATA, FILE_READ_ATTRIBUTES, FILE_READ_EA, and SYNCHRONIZE.</td>
</tr>
<tr>
<td>GENERIC_WRITE</td>
<td>STANDARD_RIGHTS_WRITE, FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, FILE_APPEND_DATA, and SYNCHRONIZE.</td>
</tr>
<tr>
<td>GENERIC_EXECUTE</td>
<td>STANDARD_RIGHTS_EXECUTE, FILE_EXECUTE, FILE_READ_ATTRIBUTES, and SYNCHRONIZE. This value is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td>GENERIC_ALL</td>
<td>FILE_ALL_ACCESS.</td>
</tr>
</tbody>
</table>
<p>For example, if you specify GENERIC_READ for a file object, the routine maps this value to the FILE_GENERIC_READ bitmask of specific access rights. In the preceding table, the specific access rights that are listed for GENERIC_READ correspond to the access flags that are contained in the FILE_GENERIC_READ bitmask.</p>
<p>If the file is actually a directory, the caller can also specify the following generic access rights.</p>
<table>
<thead>
<tr>
<th><em>DesiredAccess</em> flag</th>
<th>Allows caller to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td>FILE_LIST_DIRECTORY</td>
<td>List the files in the directory.</td>
</tr>
<tr>
<td>FILE_TRAVERSE</td>
<td>Traverse the directory, in other words, include the directory in the path of a file.</td>
</tr>
</tbody>
</table>
<p>For more information about access rights, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a>.</p>
<h3><code>ObjectAttributes</code> [in]</h3>
<p>A pointer to an <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> structure that specifies the object name and other attributes. Use <a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a> to initialize this structure. If the caller is not running in a system thread context, it must set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute when it calls <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong>.</p>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>A pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and other information about the requested operation. In particular, the <strong>Information</strong> member receives one of the following values:</p>
<ul>
<li>
<p><a href="file_created" title="#define FILE_CREATED 0x00000002">FILE_CREATED</a></p>
</li>
<li>
<p><a href="file_opened" title="#define FILE_OPENED 0x00000001">FILE_OPENED</a></p>
</li>
<li>
<p><a href="file_overwritten" title="#define FILE_OVERWRITTEN 0x00000003">FILE_OVERWRITTEN</a></p>
</li>
<li>
<p><a href="file_superseded" title="#define FILE_SUPERSEDED 0x00000000">FILE_SUPERSEDED</a></p>
</li>
<li>
<p><a href="file_exists" title="#define FILE_EXISTS 0x00000004">FILE_EXISTS</a></p>
</li>
<li>
<p><a href="file_does_not_exist" title="#define FILE_DOES_NOT_EXIST 0x00000005">FILE_DOES_NOT_EXIST</a></p>
</li>
</ul>
<h3><code>AllocationSize</code> [in, optional]</h3>
<p>A pointer to a LARGE_INTEGER that contains the initial allocation size, in bytes, for a file that is created or overwritten. If <em>AllocationSize</em> is <strong>NULL</strong>, no allocation size is specified. If no file is created or overwritten, <em>AllocationSize</em> is ignored.</p>
<h3><code>FileAttributes</code> [in]</h3>
<p>Specifies one or more FILE_ATTRIBUTE_<em>XXX</em> flags, which represent the file attributes to set if you create or overwrite a file. The caller usually specifies FILE_ATTRIBUTE_NORMAL, which sets the default attributes. For a list of valid FILE_ATTRIBUTE_<em>XXX</em> flags, see the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> routine. If no file is created or overwritten, <em>FileAttributes</em> is ignored.</p>
<h3><code>ShareAccess</code> [in]</h3>
<p>Type of share access, which is specified as zero or any combination of the following flags.</p>
<table>
<thead>
<tr>
<th><em>ShareAccess</em> flag</th>
<th>Allows other threads to do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></td>
<td>Read the file</td>
</tr>
<tr>
<td><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></td>
<td>Write the file</td>
</tr>
<tr>
<td><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></td>
<td>Delete the file</td>
</tr>
</tbody>
</table>
<p>Device and intermediate drivers usually set <em>ShareAccess</em> to zero, which gives the caller exclusive access to the open file.</p>
<h3><code>CreateDisposition</code> [in]</h3>
<p>Specifies the action to perform if the file does or does not exist. <em>CreateDisposition</em> can be one of the values in the following table.</p>
<table>
<thead>
<tr>
<th><em>CreateDisposition</em> value</th>
<th>Action if file exists</th>
<th>Action if file does not exist</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></td>
<td>Replace the file.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></td>
<td>Return an error.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></td>
<td>Open the file.</td>
<td>Return an error.</td>
</tr>
<tr>
<td><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></td>
<td>Open the file.</td>
<td>Create the file.</td>
</tr>
<tr>
<td><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></td>
<td>Open the file, and overwrite it.</td>
<td>Return an error.</td>
</tr>
<tr>
<td><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></td>
<td>Open the file, and overwrite it.</td>
<td>Create the file.</td>
</tr>
</tbody>
</table>
<h3><code>CreateOptions</code> [in]</h3>
<p>Specifies the options to apply when the driver creates or opens the file. Use one or more of the flags in the following table.</p>
<table>
<thead>
<tr>
<th><em>CreateOptions</em> flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a></td>
<td>The file is a directory. Compatible <em>CreateOptions</em> flags are <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>, <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, <a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a>, <a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a>, and <a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a>. The <em>CreateDisposition</em> parameter must be set to <a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a>, <a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a>, or <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>.</td>
</tr>
<tr>
<td><a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a></td>
<td>The file is not a directory. The file object to open can represent a data file; a logical, virtual, or physical device; or a volume.</td>
</tr>
<tr>
<td><a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a></td>
<td>System services, file-system drivers, and drivers that write data to the file must actually transfer the data to the file before any requested write operation is considered complete.</td>
</tr>
<tr>
<td><a href="file_sequential_only" title="#define FILE_SEQUENTIAL_ONLY 0x00000004">FILE_SEQUENTIAL_ONLY</a></td>
<td>All access to the file will be sequential.</td>
</tr>
<tr>
<td><a href="file_random_access" title="#define FILE_RANDOM_ACCESS 0x00000800">FILE_RANDOM_ACCESS</a></td>
<td>Access to the file can be random, so no sequential read-ahead operations should be performed by file-system drivers or by the system.</td>
</tr>
<tr>
<td><a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a></td>
<td>The file cannot be cached or buffered in a driver's internal buffers. This flag is incompatible with the <em>DesiredAccess</em> parameter's FILE_APPEND_DATA flag.</td>
</tr>
<tr>
<td><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></td>
<td>All operations on the file are performed synchronously. Any wait on behalf of the caller is subject to premature termination from alerts. This flag also causes the I/O system to maintain the file-position pointer. If this flag is set, the SYNCHRONIZE flag must be set in the <em>DesiredAccess</em> parameter.</td>
</tr>
<tr>
<td><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a></td>
<td>All operations on the file are performed synchronously. Waits in the system that synchronize I/O queuing and completion are not subject to alerts. This flag also causes the I/O system to maintain the file-position context. If this flag is set, the SYNCHRONIZE flag must be set in the <em>DesiredAccess</em> parameter.</td>
</tr>
<tr>
<td><a href="file_create_tree_connection" title="#define FILE_CREATE_TREE_CONNECTION 0x00000080">FILE_CREATE_TREE_CONNECTION</a></td>
<td>Create a tree connection for this file in order to open it over the network. This flag is not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_complete_if_oplocked" title="#define FILE_COMPLETE_IF_OPLOCKED 0x00000100">FILE_COMPLETE_IF_OPLOCKED</a></td>
<td>Complete this operation immediately with an alternate success code of STATUS_OPLOCK_BREAK_IN_PROGRESS if the target file is opportunistic locked (oplock), rather than blocking the caller's thread. If the file is oplocked, another caller already has access to the file. This flag is not used by device and intermediate drivers. For information about oplock, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">Opportunistic Locks</a>.</td>
</tr>
<tr>
<td><a href="file_no_ea_knowledge" title="#define FILE_NO_EA_KNOWLEDGE 0x00000200">FILE_NO_EA_KNOWLEDGE</a></td>
<td>If the extended attributes (EAs) for an existing file being opened indicate that the caller must understand EAs to properly interpret the file, <strong>ZwCreateFile</strong> should return an error. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a></td>
<td>Open a file with a reparse point and bypass normal reparse point processing for the file. For more information, see the following Remarks section. For information about reparse point, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/reparse-points">Reparse Points</a>.</td>
</tr>
<tr>
<td><a href="file_delete_on_close" title="#define FILE_DELETE_ON_CLOSE 0x00001000">FILE_DELETE_ON_CLOSE</a></td>
<td>The system deletes the file when the last handle to the file is passed to <a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a>. If this flag is set, the DELETE flag must be set in the <em>DesiredAccess</em> parameter.</td>
</tr>
<tr>
<td><a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a></td>
<td>The file name that is specified by the <em>ObjectAttributes</em> parameter includes a binary 8-byte or 16-byte file reference number or object ID for the file, depending on the file system as shown below. Optionally, a device name followed by a backslash character may proceed these binary values. For example, a device name will have the following format:<br /><br />\??\C:\<em>FileID</em><br />\device\HardDiskVolume1\<em>ObjectID</em><br /><br />where <em>FileID</em> is 8 bytes and <em>ObjectID</em> is 16 bytes.<br /><br />On NTFS, this can be an 8-byte or 16-byte reference number or object ID. A 16-byte reference number is the same as an 8-byte number padded with zeros.<br /><br />On ReFS, this can be an 8-byte or 16-byte reference number. A 16-byte number is not related to an 8-byte number. Object IDs are not supported.<br /><br />The FAT, ExFAT, UDFS, and CDFS file systems do not support this flag.<br /><br />This number is assigned by and specific to the particular file system.<br /><br />Because the filename field will partly contain a binary blob, it is incorrect to assume that this is a valid Unicode string, and more importantly may not be a null terminated string.</td>
</tr>
<tr>
<td><a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a></td>
<td>The file is being opened for backup intent. Therefore, the system should check for certain access rights and grant the caller the appropriate access to the file—before checking the <em>DesiredAccess</em> parameter against the file's security descriptor. This flag not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></td>
<td>This flag allows an application to request a Filter opportunistic lock (oplock) to prevent other applications from getting share violations. If there are already open handles, the create request will fail with STATUS_OPLOCK_NOT_GRANTED. For more information, see the following Remarks section. For information about oplock, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">Opportunistic Locks</a>.</td>
</tr>
<tr>
<td><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></td>
<td>The file is being opened and an opportunistic lock (oplock) on the file is being requested as a single atomic operation. The file system checks for oplocks before it performs the create operation, and will fail the create with a return code of STATUS_CANNOT_BREAK_OPLOCK if the result would be to break an existing oplock.<br /><br />The <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag is available in Windows 7, Windows Server 2008 R2 and later Windows operating systems.</td>
</tr>
<tr>
<td><a href="file_session_aware" title="#define FILE_SESSION_AWARE 0x00040000">FILE_SESSION_AWARE</a></td>
<td>The client opening the file or device is session aware and per session access is validated if necessary.<br /><br />The <a href="file_session_aware" title="#define FILE_SESSION_AWARE 0x00040000">FILE_SESSION_AWARE</a> flag is available starting withWindows 8.</td>
</tr>
</tbody>
</table>
<h3><code>EaBuffer</code> [in, optional]</h3>
<p>For device and intermediate drivers, this parameter must be a <strong>NULL</strong> pointer.</p>
<h3><code>EaLength</code> [in]</h3>
<p>For device and intermediate drivers, this parameter must be zero.</p>
<h2>Return value</h2>
<p><strong>ZwCreateFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code on failure. In the latter case, the caller can determine the cause of the failure by checking the <em>IoStatusBlock</em> parameter.</p>
<p><strong>ZwCreateFile</strong> might return STATUS_FILE_LOCK_CONFLICT as the return value or in the <strong>Status</strong> member of the <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that is pointed to by the <em>IoStatusBlock</em> parameter. This would occur only if the NTFS log file is full, and an error occurs while <strong>ZwCreateFile</strong> tries to handle this situation.</p>
<h2>Remarks</h2>
<p><strong>ZwCreateFile</strong> supplies a handle that the caller can use to manipulate a file's data, or the file object's state and attributes. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>
<p>Once the handle pointed to by <em>FileHandle</em> is no longer in use, the driver must call <a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a> to close it.</p>
<p>If the caller is not running in a system thread context, it must ensure that any handles it creates are private handles. Otherwise, the handle can be accessed by the process in whose context the driver is running. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/object-handles">Object Handles</a>.</p>
<p>There are two alternate ways to specify the name of the file to be created or opened with <strong>ZwCreateFile</strong>:</p>
<ol>
<li>
<p>As a fully qualified pathname, supplied in the <strong>ObjectName</strong> member of the input <em>ObjectAttributes</em>.</p>
</li>
<li>
<p>As pathname relative to the directory file represented by the handle in the <strong>RootDirectory</strong> member of the input <em>ObjectAttributes</em>.</p>
</li>
</ol>
<p>Setting certain flags in the <em>DesiredAccess</em> parameter results in the following effects:</p>
<ul>
<li>
<p>For a caller to synchronize an I/O completion by waiting for the returned <em>FileHandle</em>, the SYNCHRONIZE flag must be set. Otherwise, a caller that is a device or intermediate driver must synchronize an I/O completion by using an event object.</p>
</li>
<li>
<p>If the caller sets only the FILE_APPEND_DATA and SYNCHRONIZE flags, it can write only to the end of the file, and any offset information about write operations to the file is ignored. The file will automatically be extended as necessary for this type of operation.</p>
</li>
<li>
<p>Setting the FILE_WRITE_DATA flag for a file also allows the caller to write beyond the end of the file. Again, the file is automatically extended as necessary.</p>
</li>
<li>
<p>If the caller sets only the FILE_EXECUTE and SYNCHRONIZE flags, it cannot directly read or write any data to the file using the returned <em>FileHandle</em>. That is, all operations on the file occur through the system pager in response to instruction and data-access operations. Device and intermediate drivers should not set the FILE_EXECUTE flag.</p>
</li>
</ul>
<p>The <em>ShareAccess</em> parameter determines whether separate threads can access the same file, possibly simultaneously. Provided that both callers have the appropriate access privileges, the file can be successfully opened and shared. If the original caller of <strong>ZwCreateFile</strong> does not specify <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a>, <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a>, or <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>, no other caller can open the file—that is, the original caller is granted exclusive access.</p>
<p>To successfully open a shared file, the <em>DesiredAccess</em> flags must be compatible with the <em>DesiredAccess</em> and <em>ShareAccess</em> flags of all the previous open operations that have not yet been released through . That is, the <em>DesiredAccess</em> specified to <strong>ZwCreateFile</strong> for a given file must not conflict with the accesses that other openers of the file have disallowed.</p>
<p>The <em>CreateDisposition</em> value <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> requires that the caller have DELETE access to an existing file object. If so, a successful call to <strong>ZwCreateFile</strong> with <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> on an existing file effectively deletes that file, and then recreates it. This implies that, if the file has already been opened by another thread, it opened the file by specifying a <em>ShareAccess</em> parameter with the <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a> flag set. Note that this type of disposition is consistent with the POSIX style of overwriting files.</p>
<p>The <em>CreateDisposition</em> values <a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a> and <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> are similar. If <strong>ZwCreateFile</strong> is called with an existing file and either of these <em>CreateDisposition</em> values, the file will be replaced.</p>
<p>Overwriting a file is semantically equivalent to a supersede operation, except for the following:</p>
<ul>
<li>
<p>The caller must have write access to the file, rather than delete access. This implies that, if the file has already been opened by another thread, it opened the file with the <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> flag set in the input <em>ShareAccess</em>.</p>
</li>
<li>
<p>The specified file attributes are logically ORed with those already on the file. This implies that, if the file has already been opened by another thread, a subsequent caller of <strong>ZwCreateFile</strong> cannot disable existing <em>FileAttributes</em> flags but can enable additional flags for the same file.</p>
</li>
</ul>
<p>The <a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> <em>CreateOptions</em> value specifies that the file to be created or opened is a directory. When a directory file is created, the file system creates an appropriate structure on the disk to represent an empty directory for that particular file system's on-disk structure. If this option was specified and the given file to be opened is not a directory file, or if the caller specified an inconsistent <em>CreateOptions</em> or <em>CreateDisposition</em> value, the call to <strong>ZwCreateFile</strong> will fail.</p>
<p>The <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> <em>CreateOptions</em> flag prevents the file system from performing any intermediate buffering on behalf of the caller. Specifying this flag places the following restrictions on the caller's parameters to other <strong>Zw<em>Xxx</em>File</strong> routines:</p>
<ul>
<li>
<p>Any optional <em>ByteOffset</em> passed to <a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a> or <a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a> must be a multiple of the sector size.</p>
</li>
<li>
<p>The <em>Length</em> passed to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong> must be an integral of the sector size. Note that specifying a read operation to a buffer whose length is exactly the sector size might result in a lesser number of significant bytes being transferred to that buffer if the end of the file was reached during the transfer.</p>
</li>
<li>
<p>Buffers must be aligned in accordance with the alignment requirement of the underlying device. To obtain this information, call <strong>ZwCreateFile</strong> to get a handle for the file object that represents the physical device, and pass that handle to <a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a>. For a list of the system's FILE_<em>XXX</em>_ALIGNMENT values, see <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a>.</p>
</li>
<li>
<p>Calls to <a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a> with the <em>FileInformationClass</em> parameter set to <strong>FilePositionInformation</strong> must specify an offset that is a multiple of the sector size.</p>
</li>
</ul>
<p>The <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> and <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> <em>CreateOptions</em> flags, which are mutually exclusive as their names suggest, specify that all I/O operations on the file will be synchronous—as long as they occur through the file object referred to by the returned <em>FileHandle</em>. All I/O on such a file is serialized across all threads using the returned handle. If either of these <em>CreateOptions</em> flags is set, the SYNCHRONIZE <em>DesiredAccess</em> flag must also be set—to compel the I/O manager to use the file object as a synchronization object. In these cases, the I/O manager keeps track of the current file-position offset, which you can pass to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> and <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong>. Call <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong> or <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong> to get or set this position.</p>
<p>If the <em>CreateOptions</em> <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is not specified and <strong>ZwCreateFile</strong> attempts to open a file with a reparse point, normal reparse point processing occurs for the file. If, on the other hand, the <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is specified, normal reparse processing does not occur and <strong>ZwCreateFile</strong> attempts to directly open the reparse point file. In either case, if the open operation was successful, <strong>ZwCreateFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>; otherwise, the routine returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code. <strong>ZwCreateFile</strong> never returns STATUS_REPARSE.</p>
<p>The <em>CreateOptions</em> <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag eliminates the time between when you open the file and request an oplock that could potentially allow a third party to open the file and get a sharing violation. An application can use the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag on <strong>ZwCreateFile</strong> and then request any oplock. This ensures that an oplock owner will be notified of any subsequent open request that causes a sharing violation.</p>
<p>In Windows 7, if other handles exist on the file when an application uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag, the create operation will fail with STATUS_OPLOCK_NOT_GRANTED. This restriction no longer exists starting with Windows 8.</p>
<p>If this create operation would break an oplock that already exists on the file, then setting the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag will cause the create operation to fail with STATUS_CANNOT_BREAK_OPLOCK. The existing oplock will not be broken by this create operation.</p>
<p>An application that uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag must request an oplock after this call succeeds, or all subsequent attempts to open the file will be blocked without the benefit of normal oplock processing. Similarly, if this call succeeds but the subsequent oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed.</p>
<p>The <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag is available in Windows 7, Windows Server 2008 R2 and later Windows operating systems. The Microsoft file systems that implement this flag in Windows 7 are NTFS, FAT, and exFAT.</p>
<p>The <em>CreateOptions</em> flag <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> allows an application to request a Level 1, Batch, or Filter oplock to prevent other applications from getting share violations. However, <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> is only practically useful for Filter oplocks. To use it, you must complete the following steps:</p>
<ol>
<li>
<p>Issue a create request with <em>CreateOptions</em> of <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>, <em>DesiredAccess</em> of exactly FILE_READ_ATTRIBUTES, and <em>ShareAccess</em> of exactly <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>.</p>
<ul>
<li>
<p>If there are already open handles, the create request fails with STATUS_OPLOCK_NOT_GRANTED, and the next requested oplock also fails.</p>
</li>
<li>
<p>If you open with more access or less sharing will also cause a failure of STATUS_OPLOCK_NOT_GRANTED.</p>
</li>
</ul>
</li>
<li>
<p>If the create request succeeds, request an oplock.</p>
</li>
<li>
<p>Open another handle to the file to do I/O.</p>
</li>
</ol>
<p>Step three makes this practical only for Filter oplocks. The handle opened in step 3 can have a <em>DesiredAccess</em> that contains a maximum of FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL and still not break a Filter oplock. However, any <em>DesiredAccess</em> greater than FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE will break a Level 1 or Batch oplock and make the <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> flag useless for those oplock types.</p>
<p>NTFS is the only Microsoft file system that implements <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>.</p>
<p>Callers of <strong>ZwCreateFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>
<p>If the call to this function occurs in user mode, you should use the name &quot;<strong>NtCreateFile</strong>&quot; instead of &quot;<strong>ZwCreateFile</strong>&quot;.</p>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask">ACCESS_MASK</a></p>
<p><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></p>
<p><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></p>
<p><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a></p>
<p><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></p>
<p><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">ZwOpenFile</a></p>
<p><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></p>
<p><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></p>
<p><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></p>
<p><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">Opportunistic Locks</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/reparse-points">Reparse Points</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatefile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-zwcreatefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (nf-winternl-ntcreatefile)</h1>
</div>
<div class="ntdoc-description">
<h1>NtCreateFile function</h1>
<h2>Description</h2>
<p>Creates a new file or directory, or opens an existing file, device, directory, or volume.</p>
<p>This function is the user-mode equivalent to the <strong>ZwCreateFile</strong> function documented in the Windows Driver Kit (WDK).</p>
<h2>Parameters</h2>
<h3><code>FileHandle</code> [out]</h3>
<p>A pointer to a variable that receives the file handle if the call is successful.</p>
<h3><code>DesiredAccess</code> [in]</h3>
<p>The <strong>ACCESS_MASK</strong> value that expresses the type of access that the caller requires to the file or directory. The set of system-defined <em>DesiredAccess</em> flags determines the following specific access rights for file objects.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DELETE</strong></td>
<td>The file can be deleted.</td>
</tr>
<tr>
<td><strong>FILE_READ_DATA</strong></td>
<td>Data can be read from the file.</td>
</tr>
<tr>
<td><strong>FILE_READ_ATTRIBUTES</strong></td>
<td><em>FileAttributes</em> flags, described later, can be read.</td>
</tr>
<tr>
<td><strong>FILE_READ_EA</strong></td>
<td>Extended attributes associated with the file can be read. This flag is irrelevant to device and intermediate drivers.</td>
</tr>
<tr>
<td><strong>READ_CONTROL</strong></td>
<td>The access control list (<a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a>) and ownership information associated with the file can be read.</td>
</tr>
<tr>
<td><strong>FILE_WRITE_DATA</strong></td>
<td>Data can be written to the file.</td>
</tr>
<tr>
<td><strong>FILE_WRITE_ATTRIBUTES</strong></td>
<td><em>FileAttributes</em> flags can be written.</td>
</tr>
<tr>
<td><strong>FILE_WRITE_EA</strong></td>
<td>Extended attributes (EAs) associated with the file can be written. This flag is irrelevant to device and intermediate drivers.</td>
</tr>
<tr>
<td><strong>FILE_APPEND_DATA</strong></td>
<td>Data can be appended to the file.</td>
</tr>
<tr>
<td><strong>WRITE_DAC</strong></td>
<td>The discretionary access control list (DACL) associated with the file can be written.</td>
</tr>
<tr>
<td><strong>WRITE_OWNER</strong></td>
<td>Ownership information associated with the file can be written.</td>
</tr>
<tr>
<td><strong>SYNCHRONIZE</strong></td>
<td>The returned <em>FileHandle</em> can be waited on to synchronize with the completion of an I/O operation. If <em>FileHandle</em> was not opened for synchronous I/O, this value is ignored.</td>
</tr>
<tr>
<td><strong>FILE_EXECUTE</strong></td>
<td>Data can be read into memory from the file using system paging I/O. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
</tbody>
</table>
<p>Do not specify <strong>FILE_READ_DATA</strong>, <strong>FILE_WRITE_DATA</strong>, <strong>FILE_APPEND_DATA</strong>, or <strong>FILE_EXECUTE</strong> when you create or open a directory.</p>
<p>Callers of <strong>NtCreateFile</strong> can specify one or a combination of the following, possibly using a bitwise-OR with additional compatible flags from the preceding <em>DesiredAccess</em> flags list, for any file object that does not represent a directory file.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FILE_GENERIC_READ</strong></td>
<td><code>STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE</code></td>
</tr>
<tr>
<td><strong>FILE_GENERIC_WRITE</strong></td>
<td><code>STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE</code></td>
</tr>
<tr>
<td><strong>FILE_GENERIC_EXECUTE</strong></td>
<td><code>STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES | FILE_EXECUTE | SYNCHRONIZE</code></td>
</tr>
</tbody>
</table>
<p>The <strong>FILE_GENERIC_EXECUTE</strong> value is irrelevant for device and intermediate drivers.</p>
<p>The **STANDARD_RIGHTS_**<em>XXX</em> are predefined system values used to enforce security on system objects.</p>
<p>To open or create a directory file, as also indicated with the <em>CreateOptions</em> parameter, callers of <strong>NtCreateFile</strong> can specify one or a combination of the following, possibly using a bitwise-OR with one or more compatible flags from the preceding <em>DesiredAccess</em> flags list.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FILE_LIST_DIRECTORY</strong></td>
<td>Files in the directory can be listed.</td>
</tr>
<tr>
<td><strong>FILE_TRAVERSE</strong></td>
<td>The directory can be traversed: that is, it can be part of the pathname of a file.</td>
</tr>
</tbody>
</table>
<h3><code>ObjectAttributes</code> [in]</h3>
<p>A pointer to a structure already initialized with <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong>. Members of this structure for a file object include the following.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length</strong></td>
<td>Specifies the number of bytes of <em>ObjectAttributes</em> data supplied. This value must be at least sizeof(<a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a>).</td>
</tr>
<tr>
<td><strong>HANDLE RootDirectory</strong></td>
<td>Optionally specifies a handle to a directory obtained by a preceding call to <strong>NtCreateFile</strong>. If this value is <strong>NULL</strong>, the <strong>ObjectName</strong> member must be a fully qualified file specification that includes the full path to the target file. If this value is non-<strong>NULL</strong>, the <strong>ObjectName</strong> member specifies a file name relative to this directory.</td>
</tr>
<tr>
<td><strong><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">PUNICODE_STRING</a> ObjectName</strong></td>
<td>Points to a buffered Unicode string that names the file to be created or opened. This value must be a fully qualified file specification or the name of a device object, unless it is the name of a file relative to the directory specified by <strong>RootDirectory</strong>. For example, \Device\Floppy1\myfile.dat or ??\B:\myfile.dat could be the fully qualified file specification, provided that the floppy driver and overlying file system are already loaded. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.</td>
</tr>
<tr>
<td><strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Attributes</strong></td>
<td>Is a set of flags that controls the file object attributes. This value can be zero or <strong><a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a></strong>, which indicates that name-lookup code should ignore the case of the <strong>ObjectName</strong> member rather than performing an exact-match search. The value <strong><a href="obj_inherit" title="#define OBJ_INHERIT 0x00000002">OBJ_INHERIT</a></strong> is irrelevant to device and intermediate drivers.</td>
</tr>
<tr>
<td><strong>PSECURITY_DESCRIPTOR SecurityDescriptor</strong></td>
<td>Optionally specifies a security descriptor to be applied to a file. ACLs specified by such a security descriptor are applied to the file only when it is created. If the value is <strong>NULL</strong> when a file is created, the <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a> placed on the file is file-system-dependent; most file systems propagate some part of such an <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a> from the parent directory file combined with the caller's default <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a>. Device and intermediate drivers can set this member to <strong>NULL</strong>.</td>
</tr>
<tr>
<td><strong>PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService</strong></td>
<td>Specifies the access rights a server should be given to the client's security context. This value is non-<strong>NULL</strong> only when a connection to a protected server is established, allowing the caller to control which parts of the caller's security context are made available to the server and whether the server is allowed to impersonate the caller.</td>
</tr>
</tbody>
</table>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>A pointer to a variable that receives the final completion status and information about the requested operation. On return from <strong>NtCreateFile</strong>, the <strong>Information</strong> member contains one of the following values:</p>
<ul>
<li><strong><a href="file_created" title="#define FILE_CREATED 0x00000002">FILE_CREATED</a></strong></li>
<li><strong><a href="file_opened" title="#define FILE_OPENED 0x00000001">FILE_OPENED</a></strong></li>
<li><strong><a href="file_overwritten" title="#define FILE_OVERWRITTEN 0x00000003">FILE_OVERWRITTEN</a></strong></li>
<li><strong><a href="file_superseded" title="#define FILE_SUPERSEDED 0x00000000">FILE_SUPERSEDED</a></strong></li>
<li><strong><a href="file_exists" title="#define FILE_EXISTS 0x00000004">FILE_EXISTS</a></strong></li>
<li><strong><a href="file_does_not_exist" title="#define FILE_DOES_NOT_EXIST 0x00000005">FILE_DOES_NOT_EXIST</a></strong></li>
</ul>
<h3><code>AllocationSize</code> [in, optional]</h3>
<p>The initial allocation size in bytes for the file. A nonzero value has no effect unless the file is being created, overwritten, or superseded.</p>
<h3><code>FileAttributes</code> [in]</h3>
<p>The file attributes. Explicitly specified attributes are applied only when the file is created, superseded, or, in some cases, overwritten. By default, this value is a <strong>FILE_ATTRIBUTE_NORMAL</strong>, which can be overridden by an ORed combination of one or more **FILE_ATTRIBUTE_**<em>xxxx</em> flags, which are defined in Wdm.h and NtDdk.h. For a list of flags that can be used with <strong>NtCreateFile</strong>, see <strong>CreateFile</strong>.</p>
<h3><code>ShareAccess</code> [in]</h3>
<p>The type of share access that the caller would like to use in the file, as zero, or as one or a combination of the following values.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></strong></td>
<td>The file can be opened for read access by other threads' calls to <strong>NtCreateFile</strong>.</td>
</tr>
<tr>
<td><strong><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></strong></td>
<td>The file can be opened for write access by other threads' calls to <strong>NtCreateFile</strong>.</td>
</tr>
<tr>
<td><strong><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></strong></td>
<td>The file can be opened for delete access by other threads' calls to <strong>NtCreateFile</strong>.</td>
</tr>
</tbody>
</table>
<p>For more information, see the Windows SDK.</p>
<h3><code>CreateDisposition</code> [in]</h3>
<p>Specifies what to do, depending on whether the file already exists, as one of the following values.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></strong></td>
<td>If the file already exists, replace it with the given file. If it does not, create the given file.</td>
</tr>
<tr>
<td><strong><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></strong></td>
<td>If the file already exists, fail the request and do not create or open the given file. If it does not, create the given file.</td>
</tr>
<tr>
<td><strong><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></strong></td>
<td>If the file already exists, open it instead of creating a new file. If it does not, fail the request and do not create a new file.</td>
</tr>
<tr>
<td><strong><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></strong></td>
<td>If the file already exists, open it. If it does not, create the given file.</td>
</tr>
<tr>
<td><strong><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></strong></td>
<td>If the file already exists, open it and overwrite it. If it does not, fail the request.</td>
</tr>
<tr>
<td><strong><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></strong></td>
<td>If the file already exists, open it and overwrite it. If it does not, create the given file.</td>
</tr>
</tbody>
</table>
<h3><code>CreateOptions</code> [in]</h3>
<p>The options to be applied when creating or opening the file, as a compatible combination of the following flags.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a></strong></td>
<td>The file being created or opened is a directory file. With this flag, the <em>CreateDisposition</em> parameter must be set to <strong><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></strong>, <strong><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></strong>, or <strong><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></strong>. With this flag, other compatible <em>CreateOptions</em> flags include only the following: <strong><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></strong>, <strong>FILE_SYNCHRONOUS_IO _NONALERT</strong>, <strong><a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a></strong>, <strong><a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a></strong>, and <strong><a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a></strong>.</td>
</tr>
<tr>
<td><strong><a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a></strong></td>
<td>The file being opened must not be a directory file or this call fails. The file object being opened can represent a data file, a logical, virtual, or physical device, or a volume.</td>
</tr>
<tr>
<td><strong><a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a></strong></td>
<td>Applications that write data to the file must actually transfer the data into the file before any requested write operation is considered complete. This flag is automatically set if the <em>CreateOptions</em> flag <strong>FILE_NO_INTERMEDIATE _BUFFERING</strong> is set.</td>
</tr>
<tr>
<td><strong><a href="file_sequential_only" title="#define FILE_SEQUENTIAL_ONLY 0x00000004">FILE_SEQUENTIAL_ONLY</a></strong></td>
<td>All accesses to the file are sequential.</td>
</tr>
<tr>
<td><strong><a href="file_random_access" title="#define FILE_RANDOM_ACCESS 0x00000800">FILE_RANDOM_ACCESS</a></strong></td>
<td>Accesses to the file can be random, so no sequential read-ahead operations should be performed on the file by FSDs or the system.</td>
</tr>
<tr>
<td><strong><a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a></strong></td>
<td>The file cannot be cached or buffered in a driver's internal buffers. This flag is incompatible with the <em>DesiredAccess</em> <strong>FILE_APPEND_DATA</strong> flag.</td>
</tr>
<tr>
<td><strong><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></strong></td>
<td>All operations on the file are performed synchronously. Any wait on behalf of the caller is subject to premature termination from alerts. This flag also causes the I/O system to maintain the file position context. If this flag is set, the <em>DesiredAccess</em> <strong>SYNCHRONIZE</strong> flag also must be set.</td>
</tr>
<tr>
<td><strong><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a></strong></td>
<td>All operations on the file are performed synchronously. Waits in the system to synchronize I/O queuing and completion are not subject to alerts. This flag also causes the I/O system to maintain the file position context. If this flag is set, the <em>DesiredAccess</em> <strong>SYNCHRONIZE</strong> flag also must be set.</td>
</tr>
<tr>
<td><strong><a href="file_create_tree_connection" title="#define FILE_CREATE_TREE_CONNECTION 0x00000080">FILE_CREATE_TREE_CONNECTION</a></strong></td>
<td>Create a tree connection for this file in order to open it over the network. This flag is not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><strong><a href="file_no_ea_knowledge" title="#define FILE_NO_EA_KNOWLEDGE 0x00000200">FILE_NO_EA_KNOWLEDGE</a></strong></td>
<td>If the extended attributes on an existing file being opened indicate that the caller must understand EAs to properly interpret the file, fail this request because the caller does not understand how to deal with EAs. This flag is irrelevant for device and intermediate drivers.</td>
</tr>
<tr>
<td><strong><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a></strong></td>
<td>Open a file with a reparse point and bypass normal reparse point processing for the file. For more information, see the Remarks section.</td>
</tr>
<tr>
<td><strong><a href="file_delete_on_close" title="#define FILE_DELETE_ON_CLOSE 0x00001000">FILE_DELETE_ON_CLOSE</a></strong></td>
<td>Delete the file when the last handle to it is passed to <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></strong>. If this flag is set, the DELETE flag must be set in the <em>DesiredAccess</em> parameter.</td>
</tr>
<tr>
<td><strong><a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a></strong></td>
<td>The file name that is specified by the <em>ObjectAttributes</em> parameter includes the 8-byte file reference number for the file. This number is assigned by and specific to the particular file system. If the file is a reparse point, the file name will also include the name of a device. Note that the FAT file system does not support this flag. This flag is not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><strong><a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a></strong></td>
<td>The file is being opened for backup intent. Therefore, the system should check for certain access rights and grant the caller the appropriate access to the file before checking the <em>DesiredAccess</em> parameter against the file's security descriptor. This flag not used by device and intermediate drivers.</td>
</tr>
<tr>
<td><strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong></td>
<td>This flag allows an application to request a filter <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">opportunistic lock</a> to prevent other applications from getting share violations. If there are already open handles, the create request will fail with <strong>STATUS_OPLOCK_NOT_GRANTED</strong>. For more information, see the Remarks section.</td>
</tr>
<tr>
<td><strong><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></strong></td>
<td>The file is being opened and an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">opportunistic lock</a> on the file is being requested as a single atomic operation. The file system checks for oplocks before it performs the create operation and will fail the create with a return code of <strong>STATUS_CANNOT_BREAK_OPLOCK</strong> if the result would be to break an existing oplock. For more information, see the Remarks section.<br /><br /><strong>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:</strong> This flag is not supported.<br /><br />This flag is supported on the following file systems: NTFS, FAT, and exFAT.</td>
</tr>
<tr>
<td><strong><a href="file_complete_if_oplocked" title="#define FILE_COMPLETE_IF_OPLOCKED 0x00000100">FILE_COMPLETE_IF_OPLOCKED</a></strong></td>
<td>Complete this operation immediately with an alternate success code of <strong>STATUS_OPLOCK_BREAK_IN_PROGRESS</strong> if the target file is oplocked, rather than blocking the caller's thread. If the file is <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">oplocked</a>, another caller already has access to the file. This flag is not used by device and intermediate drivers.</td>
</tr>
</tbody>
</table>
<h3><code>EaBuffer</code> [in]</h3>
<p>Pointer to an EA buffer used to pass extended attributes.</p>
<p><strong>Note</strong> Some file systems may not support EA buffers.</p>
<h3><code>EaLength</code> [in]</h3>
<p>Length of the EA buffer.</p>
<h2>Return value</h2>
<p><strong>NtCreateFile</strong> returns either <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong> or an appropriate error status. If it returns an error status, the caller can find more information about the cause of the failure by checking the <em>IoStatusBlock</em>. To simplify this check, an application can use the <strong><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></strong>, <strong><a href="nt_error" title="#define NT_ERROR(Status) ((((ULONG)(Status)) &gt;&gt; 30) == 3)">NT_ERROR</a></strong>, and <strong><a href="nt_warning" title="#define NT_WARNING(Status) ((((ULONG)(Status)) &gt;&gt; 30) == 2)">NT_WARNING</a></strong> macros.</p>
<h2>Remarks</h2>
<p>The handle, given by <strong>NtCreateFile</strong>, can be used by subsequent calls to manipulate data within the file or the file object's state or attributes.</p>
<p>There are two alternate ways to specify the name of the file to be created or opened with <strong>NtCreateFile</strong>:</p>
<ul>
<li>As a fully qualified pathname, supplied in the <strong>ObjectName</strong> member of the input <em>ObjectAttributes</em></li>
<li>As a pathname relative to the directory file represented by the handle in the <strong>RootDirectory</strong> member of the input <em>ObjectAttributes</em></li>
</ul>
<p>Certain <em>DesiredAccess</em> flags and combinations of flags have the following effects:</p>
<ul>
<li>For a caller to synchronize an I/O completion by waiting on the returned <em>FileHandle</em>, the <strong>SYNCHRONIZE</strong> flag must be set.</li>
<li>Passing a zero to <em>DesiredAccess</em> is not valid.</li>
<li>If only the <strong>FILE_APPEND_DATA</strong> and <strong>SYNCHRONIZE</strong> flags are set, the caller can write only to the end of the file, and any offset information on writes to the file is ignored. However, the file is automatically extended as necessary for this type of write operation.</li>
<li>Setting the <strong>FILE_WRITE_DATA</strong> flag for a file also allows writes beyond the end of the file to occur. The file is automatically extended for this type of write, as well.</li>
<li>If only the <strong>FILE_EXECUTE</strong> and <strong>SYNCHRONIZE</strong> flags are set, the caller cannot directly read or write any data in the file using the returned <em>FileHandle</em>, that is, all operations on the file occur through the system pager in response to instruction and data accesses.</li>
</ul>
<p>The <em>ShareAccess</em> parameter determines whether separate threads can access the same file, possibly simultaneously. Provided that both file openers have the privilege to access a file in the specified manner, the file can be successfully opened and shared. If the original caller of <strong>NtCreateFile</strong> does not specify <strong><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></strong>, <strong><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></strong>, or <strong><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></strong>, no other open operations can be performed on the file; that is, the original caller is given exclusive access to the file.</p>
<p>For a shared file to be successfully opened, the requested <em>DesiredAccess</em> parameter to the file must be compatible with both the <em>DesiredAccess</em> and <em>ShareAccess</em> specifications of all preceding opens that have not yet been released with <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></strong>. That is, the <em>DesiredAccess</em> parameter specified to <strong>NtCreateFile</strong> for a given file must not conflict with the accesses that other openers of the file have disallowed.</p>
<p>The <em>CreateDisposition</em> value <strong><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></strong> requires that the caller have <strong>DELETE</strong> access to an existing file object. If so, a successful call to <strong>NtCreateFile</strong> with <strong><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></strong> on an existing file effectively deletes that file, and then re-creates it. This implies that, if the file has already been opened by another thread, it opened the file by specifying a <em>ShareAccess</em> parameter with the <strong><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></strong> flag set.</p>
<p>Note that this type of disposition is consistent with the POSIX style of overwriting files. The <em>CreateDisposition</em> values <strong><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></strong> and <strong><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></strong> are similar. If <strong>ZwCreateFile</strong> is called with an existing file and either of these <em>CreateDisposition</em> values, the file is replaced.</p>
<p>Overwriting a file is semantically equivalent to a supersede operation, except for the following:</p>
<ul>
<li>The caller must have write access to the file, rather than delete access. This implies that, if the file has already been opened by another thread, it opened the file with the <strong><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></strong> flag set in the input <em>ShareAccess</em> parameter.</li>
<li>The specified file attributes are logically ORed with those already on the file. This implies that, if the file has already been opened by another thread, a subsequent caller of <strong>NtCreateFile</strong> cannot disable existing <em>FileAttributes</em> flags but can enable additional flags for the same file. Note that this style of overwriting files is consistent with MS-DOS, Windows 3.1, and OS/2 operating systems.</li>
</ul>
<p>The <em>CreateOptions</em> <strong><a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a></strong> value specifies that the file to be created or opened is a
directory file. When a directory file is created, the file system creates an appropriate structure on the disk to
represent an empty directory for that particular file system's on-disk structure. If this option was specified
and the given file to be opened is not a directory file, or if the caller specified an inconsistent
<em>CreateOptions</em> or <em>CreateDisposition</em> value, the call to
<strong>NtCreateFile</strong> fails.</p>
<p>The <em>CreateOptions</em> <strong><a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a></strong> flag prevents the file system from performing any
intermediate buffering on behalf of the caller. Specifying this value places certain restrictions on the caller's
parameters to other <strong>Nt<em>XXX</em>File</strong> routines, including the
following:</p>
<ul>
<li>Any optional <em>ByteOffset</em> passed to the
<strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong> function must be an
integral of the sector size.</li>
<li>The <em>Length</em> passed to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> or
<strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong>, must be an integral of the sector size. Note that specifying a
read operation to a buffer whose length is exactly the sector size might result in a lesser number of
significant bytes being transferred to that buffer if the end of the file was reached during the transfer.</li>
<li>Buffers must be adjusted in accordance with the alignment requirement of the underlying device. This
information can be obtained by calling <strong>NtCreateFile</strong>
to get a handle for the file object that represents the physical device, and then calling
<strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong> with that handle. For a list of the system
<strong>FILE_<em><strong>XXX</strong></em>_ALIGNMENT</strong> values, see
the Windows SDK documentation.</li>
<li>Calls to <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong> with the
<em>FileInformationClass</em> parameter set to
<strong>FilePositionInformation</strong> must specify an offset that is an integral of the
sector size.</li>
</ul>
<p>The <em>CreateOptions</em> <strong><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></strong> and <strong><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a></strong> flags,
which are mutually exclusive as their names suggest, specify that all I/O operations on the file are to be
synchronous as long as they occur through the file object referred to by the returned
<em>FileHandle</em>. All I/O on such a file is serialized across all threads using the returned
handle. With either of these <em>CreateOptions</em>, the <em>DesiredAccess</em> <strong>SYNCHRONIZE</strong> flag must be set so that the I/O Manager uses the
file object as a synchronization object. With either of these <em>CreateOptions</em> set, the
I/O Manager maintains the &quot;file position context&quot; for the file object, an internal, current file position offset.
This offset can be used in calls to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong> and
<strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong>. Its position also can be queried or set with
<strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong> and
<strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong>.</p>
<p>If the <em>CreateOptions</em> parameter specifies the <strong><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a></strong> flag and <strong>NtCreateFile</strong> opens a file with a reparse point, normal reparse processing does not occur and <strong>NtCreateFile</strong> attempts to directly open the reparse point file. If the <strong><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a></strong> flag is not specified, normal reparse point processing occurs for the file. In either case, if the open operation was successful, <strong>NtCreateFile</strong> returns <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong>; otherwise, an error code. The <strong>NtCreateFile</strong> function never returns <strong>STATUS_REPARSE</strong>.</p>
<p>The <em>CreateOptions</em> parameter's <strong><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></strong> flag eliminates the time between when you open the file and request an oplock that could potentially allow a third party to open the file, which would cause a sharing violation. An application can use the <strong><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></strong> flag with <strong>NtCreateFile</strong> and then request any oplock. This ensures that an oplock owner will be notified of any subsequent open request that causes a sharing violation.</p>
<p>In Windows 7, if other handles exist on the file when an application uses this flag, the create operation will fail with <strong>STATUS_OPLOCK_NOT_GRANTED</strong>. This restriction no longer exists starting with Windows 8.</p>
<p>If this create operation would break an oplock that already exists on the file, then setting the <strong><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></strong> flag will cause the create operation to fail with <strong>STATUS_CANNOT_BREAK_OPLOCK</strong>. The existing oplock will not be broken by this create operation.</p>
<p>An application that uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag must request an oplock on the file after this call succeeds, or all subsequent attempts to open the file will be blocked without the benefit of normal oplock processing. Similarly, if this call succeeds but the subsequent oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed. The application must not perform any other file system operation on the file before requsting the oplock (besides closing the file handle), otherwise a deadlock may occur.</p>
<p><strong>Note</strong> The <strong><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a></strong> flag is available in Windows 7, Windows Server 2008 R2 and later operating systems for the following file systems: NTFS, FAT, and exFAT.</p>
<p>The <em>CreateOptions</em> parameter's <strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong> flag allows an application to request a Level 1, Batch, or Filter oplock to prevent other applications from getting share violations. However, in practical terms, the <strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong> is useful only for filter oplocks. To use it, you must complete the following steps:</p>
<ol>
<li>Issue a create request with <em>CreateOptions</em> of <strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong>, <em>DesiredAccess</em> of exactly <strong>FILE_READ_ATTRIBUTES</strong>, and <em>ShareAccess</em> of exactly <code>(<a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>)</code>. Possible failures are as follows:
<ul>
<li>If there are already open handles, the create request fails with <strong>STATUS_OPLOCK_NOT_GRANTED</strong>, and the next requested oplock also fails.</li>
<li>If you open with more access than <strong>FILE_READ_ATTRIBUTES</strong> or less sharing than <code>(<a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>)</code>, the request fails with <strong>STATUS_OPLOCK_NOT_GRANTED</strong>.</li>
</ul>
</li>
<li>If the create request succeeds, request an oplock.</li>
<li>Open another handle to the file to do I/O.</li>
</ol>
<p>Step three makes this practical only for filter oplocks. The handle opened in step three can have a <em>DesiredAccess</em> that contains a maximum of <code>(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL)</code> and still not break a filter oplock. However, any <em>DesiredAccess</em> greater than <code>(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE)</code> will break a Level 1 or Batch oplock and make the <strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong> flag useless for those oplock types.</p>
<p>NTFS is the only Microsoft file system that implements <strong><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a></strong>.</p>
<p>For more information on oplocks, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/fileio/opportunistic-locks">Opportunistic Locks</a>.</p>
<p>Note that the WDK header file NtDef.h is necessary for many constant definitions. You can also use the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to dynamically link to NtDll.dll.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winternl/nf-winternl-ntcreatefile">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winternl/nf-winternl-ntcreatefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntcreatefile">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwcreatefile">here</a>.</p>
<hr />
<p><em>(Available also in 2000 DDK.)</em></p>
<h3>FileHandle</h3>
<p>Result of call - <code>HANDLE</code> to File Object.</p>
<h3>DesiredAccess</h3>
<p>Access mask based on definitions in schema <code>FILE_*</code> from <strong>&lt;WinNT.h&gt;</strong>.</p>
<h3>ObjectAttributes</h3>
<p>Name of file to create (or open), optionally path in name string. You can also define root directory, security descriptor and attributes <code><a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a></code> and <code><a href="obj_inherit" title="#define OBJ_INHERIT 0x00000002">OBJ_INHERIT</a></code>.</p>
<h3>IoStatusBlock</h3>
<p>Pointer to <code><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></code> structure, that receive final status of function call. Can be one of:</p>
<ul>
<li><code><a href="file_created" title="#define FILE_CREATED 0x00000002">FILE_CREATED</a></code></li>
<li><code><a href="file_opened" title="#define FILE_OPENED 0x00000001">FILE_OPENED</a></code></li>
<li><code><a href="file_overwritten" title="#define FILE_OVERWRITTEN 0x00000003">FILE_OVERWRITTEN</a></code></li>
<li><code><a href="file_superseded" title="#define FILE_SUPERSEDED 0x00000000">FILE_SUPERSEDED</a></code></li>
<li><code><a href="file_exists" title="#define FILE_EXISTS 0x00000004">FILE_EXISTS</a></code></li>
<li><code><a href="file_does_not_exist" title="#define FILE_DOES_NOT_EXIST 0x00000005">FILE_DOES_NOT_EXIST</a></code></li>
</ul>
<h3>AllocationSize</h3>
<p>File size after creation.</p>
<h3>FileAttributes</h3>
<p>Attributes for newly created file, as follows:</p>
<ul>
<li><code>FILE_ATTRIBUTE_READONLY</code></li>
<li><code>FILE_ATTRIBUTE_HIDDEN</code></li>
<li><code>FILE_ATTRIBUTE_SYSTEM</code></li>
<li><code>FILE_ATTRIBUTE_ARCHIVE</code></li>
<li><code>FILE_ATTRIBUTE_NORMAL</code></li>
<li><code>FILE_ATTRIBUTE_TEMPORARY</code></li>
<li><code>FILE_ATTRIBUTE_OFFLINE</code></li>
<li><code>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</code></li>
</ul>
<h3>ShareAccess</h3>
<p>Specifies share method for opened object. Can be set to zero or any combination of flags:</p>
<ul>
<li><code><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></code></li>
<li><code><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></code></li>
<li><code><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></code></li>
</ul>
<h3>CreateDisposition</h3>
<p>Specifies disposition how to create or open object and can be one of:</p>
<ul>
<li><code><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></code> - If file exists, deletes it before creation of new one.</li>
<li><code><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></code> - Fails, if file not exists.</li>
<li><code><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></code> - Fails, if file exists.</li>
<li><code><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></code> - If file exists, opens it. If not, creates new one and then open it.</li>
<li><code><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></code> - If file not exists, create and open it. If exists, open them and reset content.</li>
<li><code><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></code> - As <code><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></code>, but fails if file not exists.</li>
</ul>
<h3>CreateOptions</h3>
<p>Creation options.</p>
<h3>EaBuffer</h3>
<p>Buffer for Extended Attributes contains one or more of <code><a href="file_full_ea_information" title="_Struct_size_bytes_(NextEntryOffset)&#10;typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></code> structures.</p>
<h3>EaLength</h3>
<p>Length of <code>EaBuffer</code>.</p>
<h1>Related Win32 API</h1>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea"><code>CreateFileA</code></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew"><code>CreateFileW</code></a></li>
</ul>
<h1>Documented by</h1>
<ul>
<li>Tomasz Nowak</li>
</ul>
<h1>See also</h1>
<ul>
<li><code><a href="file_full_ea_information" title="_Struct_size_bytes_(NextEntryOffset)&#10;typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></code></li>
<li><code><a href="ntdeletefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDeleteFile(&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes&#10;    );">NtDeleteFile</a></code></li>
<li><code><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></code></li>
<li><code><a href="ntseteafile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetEaFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length&#10;    );">NtSetEaFile</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntcreatefile.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
