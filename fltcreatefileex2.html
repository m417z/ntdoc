<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltCreateFileEx2 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltCreateFileEx2 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltCreateFileEx2 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltCreateFileEx2(
  [in]            PFLT_FILTER               Filter,
  [in, optional]  PFLT_INSTANCE             Instance,
  [out]           PHANDLE                   FileHandle,
  [out, optional] <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a>              *FileObject,
  [in]            ACCESS_MASK               DesiredAccess,
  [in]            <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a>        ObjectAttributes,
  [out]           <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>          IoStatusBlock,
  [in, optional]  PLARGE_INTEGER            AllocationSize,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     FileAttributes,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     ShareAccess,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     CreateDisposition,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     CreateOptions,
  [in, optional]  PVOID                     EaBuffer,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     EaLength,
  [in]            <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     Flags,
  [in, optional]  <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">PIO_DRIVER_CREATE_CONTEXT</a> DriverContext
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltcreatefileex2.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltcreatefileex2)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fltcreatefileex2-function">FltCreateFileEx2 function</h1>

<h2 id="description">Description</h2>

<p>Minifilter drivers call <strong>FltCreateFileEx2</strong> to create a new file or open an existing file. This routine includes an optional create context parameter (ECP).</p>

<h2 id="parameters">Parameters</h2>

<h3 id="filter-in"><code>Filter</code> [in]</h3>

<p>An opaque filter pointer for the caller.</p>

<h3 id="instance-in-optional"><code>Instance</code> [in, optional]</h3>

<p>An opaque instance pointer for the minifilter driver instance that the create request is to be sent to. The instance must be attached to the volume where the file or directory resides. This parameter is optional and can be <strong>NULL</strong>. If this parameter is <strong>NULL</strong>, the request is sent to the device object at the top of the file system driver stack for the volume. If this parameter is non-<strong>NULL</strong>, the request is sent only to minifilter driver instances that are attached below the specified instance.</p>

<h3 id="filehandle-out"><code>FileHandle</code> [out]</h3>

<p>A pointer to a caller-allocated variable that receives the file handle if the call to <strong>FltCreateFileEx2</strong> is successful.</p>

<h3 id="fileobject-out-optional"><code>FileObject</code> [out, optional]</h3>

<p>A pointer to a caller-allocated variable that receives the file object pointer if the call to <strong>FltCreateFileEx2</strong> is successful. This parameter is optional and can be <strong>NULL</strong>.</p>

<h3 id="desiredaccess-in"><code>DesiredAccess</code> [in]</h3>

<p>A bitmask of flags specifying the type of access to the file or directory that the caller requires. See the <em>DesiredAccess</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for more information about this parameter and for the list of flag values.</p>

<h3 id="objectattributes-in"><code>ObjectAttributes</code> [in]</h3>

<p>Pointer to an opaque <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> structure that is already initialized with <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong>. See the <em>ObjectAttributes</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for more information and for a description of each structure member.</p>

<h3 id="iostatusblock-out"><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that receives the final completion status and information about the requested operation. See the <strong>IoStatusBlock</strong> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for more information about this parameter.</p>

<h3 id="allocationsize-in-optional"><code>AllocationSize</code> [in, optional]</h3>

<p>Optionally specifies the initial allocation size, in bytes, for the file stream. A nonzero value has no effect unless the file is being created, overwritten, or superseded.</p>

<h3 id="fileattributes-in"><code>FileAttributes</code> [in]</h3>

<p>Specifies one or more FILE_ATTRIBUTE_<em>XXX</em> flags, which represent the file attributes to set if you are creating, superseding, or overwriting a file. See the <em>FileAttributes</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for more details and for the list of flags.</p>

<h3 id="shareaccess-in"><code>ShareAccess</code> [in]</h3>

<p>Specifies the type of share access to the file that the caller requires, as zero or one, or a combination of the flags. See the <em>ShareAccess</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for more details and for the list of flags.</p>

<h3 id="createdisposition-in"><code>CreateDisposition</code> [in]</h3>

<p>Specifies a value that determines the action to be taken, depending on whether the file already exists. See the <em>Disposition</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for the list of possible values.</p>

<h3 id="createoptions-in"><code>CreateOptions</code> [in]</h3>

<p>Specifies the options to be applied when creating or opening the file. This parameter is a compatible combination of the flags listed and described in the <em>CreateOptions</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong>.</p>

<h3 id="eabuffer-in-optional"><code>EaBuffer</code> [in, optional]</h3>

<p>A pointer to a caller-supplied <strong><a href="file_full_ea_information" title="typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></strong> buffer that contains extended attribute (EA) information to be applied to the file.</p>

<h3 id="ealength-in"><code>EaLength</code> [in]</h3>

<p>Length, in bytes, of <em>EaBuffer</em>.</p>

<h3 id="flags-in"><code>Flags</code> [in]</h3>

<p>Specifies options to be used during the creation of the create request. See the <em>Options</em> parameter of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for the list of possible options.</p>

<h3 id="drivercontext-in-optional"><code>DriverContext</code> [in, optional]</h3>

<p>Optional pointer to an <strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong> structure already initialized by <strong><a href="ioinitializedrivercreatecontext" title="VOID IoInitializeDriverCreateContext(&#10;  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoInitializeDriverCreateContext</a></strong>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>FltCreateFileEx2</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value. See the <strong>Return Value</strong> section of <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong> for a list of possible return codes.</p>

<blockquote>
  <p>[!NOTE]
  <strong>FltCreateFileEx2</strong> might return STATUS_FILE_LOCK_CONFLICT as the return value or in the <strong>Status</strong> member of the <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that is pointed to by the IoStatusBlock parameter. This would occur only if the NTFS log file is full, and an error occurs while <strong>FltCreateFileEx2</strong> tries to handle this situation.</p>
</blockquote>

<h2 id="remarks">Remarks</h2>

<p><strong>FltCreateFileEx2</strong> is similar to <strong><a href="fltcreatefile" title="NTSTATUS FLTAPI FltCreateFile(&#10;  [in]           PFLT_FILTER        Filter,&#10;  [in, optional] PFLT_INSTANCE      Instance,&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              CreateDisposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           ULONG              Flags&#10;);">FltCreateFile</a></strong> and <strong><a href="fltcreatefileex" title="NTSTATUS FLTAPI FltCreateFileEx(&#10;  [in]           PFLT_FILTER        Filter,&#10;  [in, optional] PFLT_INSTANCE      Instance,&#10;  [out]          PHANDLE            FileHandle,&#10;  [out]          PFILE_OBJECT       *FileObject,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              CreateDisposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           ULONG              Flags&#10;);">FltCreateFileEx</a></strong>, except that it supports the <em>DriverContext</em> input parameter.</p>

<p>To specify an ECP as part of a create operation, initialize the <strong>ExtraCreateParameter</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure with the <strong><a href="fltallocateextracreateparameterlist" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameterList(&#10;  [in]  PFLT_FILTER                  Filter,&#10;  [in]  FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,&#10;  [out] PECP_LIST                    *EcpList&#10;);">FltAllocateExtraCreateParameterList</a></strong> routine. If ECPs are used, they must be created, manipulated, and freed using the appropriate routines.</p>

<p>Filter drivers below the caller of <strong>FltCreateFileEx2</strong> should not add or delete ECPs on the caller. Consequently, upon returning from the call to <strong>FltCreateFileEx2</strong>, the ECP list should be unchanged and may be passed to additional calls of <strong>FltCreateFileEx2</strong> for other create operations. Note that the operating system does not automatically deallocate the ECP list structure - the caller of <strong>FltCreateFileEx2</strong> must deallocate this structure by calling the <strong><a href="fltfreeextracreateparameterlist" title="VOID FLTAPI FltFreeExtraCreateParameterList(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PECP_LIST   EcpList&#10;);">FltFreeExtraCreateParameterList</a></strong> routine.</p>

<p>To create/open a file in the context of a transaction, set the <strong>TxnParameters</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure to the value returned by the <strong><a href="iogettransactionparameterblock" title="PTXN_PARAMETER_BLOCK IoGetTransactionParameterBlock(&#10;  [in] PFILE_OBJECT FileObject&#10;);">IoGetTransactionParameterBlock</a></strong> routine.</p>

<p><strong>FltCreateFileEx2</strong> sends the create request only to the instances attached below the specified minifilter driver instance and to the file system. The specified instance and the instances attached above it do not receive the create request. If no instance is specified, the request goes to the top of the stack and is received by all instances and the file system.</p>

<p>There are two alternate ways to specify the name of the file to be created or opened with <strong>FltCreateFileEx2</strong>:</p>

<ul>
<li><p>As a fully qualified pathname, supplied in the <strong>ObjectName</strong> member of the input <em>ObjectAttributes</em>.</p></li>
<li><p>As a pathname that is relative to the directory file represented by the handle in the <strong>RootDirectory</strong> member of the input <em>ObjectAttributes</em>.</p></li>
</ul>

<p>Any <em>FileHandle</em> that is obtained from <strong>FltCreateFileEx2</strong> must eventually be released by calling <strong><a href="fltclose" title="NTSTATUS FLTAPI FltClose(&#10;  [in] HANDLE FileHandle&#10;);">FltClose</a></strong>. In addition, any returned <em>FileObject</em> pointer must be dereferenced when it is no longer needed by calling <strong><a href="obdereferenceobject" title="void ObDereferenceObject(&#10;  [in] a&#10;);">ObDereferenceObject</a></strong>.</p>

<p>Driver routines that do not run in the system process context must set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute for the <em>ObjectAttributes</em> parameter of <strong>FltCreateFileEx2</strong>. Setting this attribute restricts the use of the handle that is returned by <strong>FltCreateFileEx2</strong> to processes running in kernel mode. Otherwise, the handle can be accessed by the process in whose context the driver is running.</p>

<blockquote>
  <p>[!NOTE]
  Do not call this routine with a non-NULL top level <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> value, as this can cause a system deadlock.</p>
</blockquote>

<p>Certain <em>DesiredAccess</em> flags and combinations of flags have the following effects:</p>

<ul>
<li><p>For a caller to synchronize an I/O completion by waiting for the returned <em>FileHandle</em> to be set to the Signaled state, the SYNCHRONIZE flag must be set.</p></li>
<li><p>If only the FILE_APPEND_DATA and SYNCHRONIZE flags are set, the caller can write only to the end of the file, and any offset information about write requests to the file is ignored. However, the file is automatically extended as necessary for this type of write operation.</p></li>
<li><p>Setting the FILE_WRITE_DATA flag for a file also allows write requests beyond the end of the file to occur. The file is automatically extended for this type of write request, as well.</p></li>
<li><p>If only the FILE_EXECUTE and SYNCHRONIZE flags are set, the caller cannot use the handle returned in the <em>FileHandle</em> parameter to directly read or write any data to or from the file. That is, all operations on the file must use system paging I/O to read or write file data.</p></li>
</ul>

<p>The <em>ShareAccess</em> parameter determines whether separate threads can access the same file, possibly simultaneously. If both file openers have the privilege to access a file in the specified manner, the file can be successfully opened and shared. If the original caller of <strong>FltCreateFileEx2</strong> does not specify <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a>, <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a>, or <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>, no other open operations can be performed on the file because the original caller is given exclusive access to the file.</p>

<p>For a shared file to be successfully opened, the requested <em>DesiredAccess</em> to the file must be compatible with both the <em>DesiredAccess</em> and <em>ShareAccess</em> specifications of all preceding open requests that have not yet been released with <strong><a href="fltclose" title="NTSTATUS FLTAPI FltClose(&#10;  [in] HANDLE FileHandle&#10;);">FltClose</a></strong>. That is, the <em>DesiredAccess</em> parameter that is specified to <strong>FltCreateFileEx2</strong> for a given file must not conflict with the accesses that other openers of the file have disallowed.</p>

<blockquote>
  <p>[!NOTE]
  If IO_IGNORE_SHARE_ACCESS_CHECK is specified in the <em>Flags</em> parameter, the I/O manager ignores the <em>ShareAccess</em> parameter. However, the file system might still perform access checks. Thus, it is important to specify the sharing mode you would like for the <em>ShareAccess</em>parameter, even when using the IO_IGNORE_SHARE_ACCESS_CHECK flag. Additionally, note that when IO_IGNORE_SHARE_ACCESS_CHECK is specified, the file system does not track the current open's desired access or shared access. Because of this, subsequent open calls on the same file may succeed.</p>
</blockquote>

<p>The <em>CreateDisposition</em> value <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> requires that the caller have DELETE access to an existing file object. If so, a successful call to <strong>FltCreateFileEx2</strong> with <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> on an existing file effectively deletes that file and then recreates it. This implies that if the file has already been opened by another thread, it opened the file by specifying a <em>ShareAccess</em>parameter with the <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a> flag set. Note that this type of disposition is consistent with the POSIX style of overwriting files.</p>

<p>The <em>CreateDisposition</em> values <a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a> and <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> are similar. If <strong>FltCreateFileEx2</strong> is called with an existing file and either of these <em>CreateDisposition</em> values, the file is replaced.</p>

<p>Overwriting a file is semantically equivalent to a supersede operation, except for the following:</p>

<ul>
<li><p>The caller must have write access to the file, rather than delete access. This implies that, if the file has already been opened by another thread, it opened the file with the <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> flag set in the input <em>ShareAccess</em> parameter.</p></li>
<li><p>The specified file attributes are combined with those attributes that are already applied to the file by using a bitwise OR operation. This implies that if the file has already been opened by another thread, a subsequent caller of <strong>FltCreateFileEx2</strong> cannot disable existing <em>FileAttributes</em> flags but can enable additional flags for the same file. Note that this style of overwriting files is consistent with MS-DOS, Windows 3.1, and OS/2.</p></li>
</ul>

<p>The <em>CreateOptions</em> <a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> value specifies that the file to be created or opened is a directory file. When a directory file is created, the file system creates an appropriate structure on the disk to represent an empty directory for that particular file system's on-disk structure. If this option was specified and the given file to be opened is not a directory file or if the caller specified an inconsistent <em>CreateOptions</em> or <em>CreateDisposition</em> value, the call to <strong>FltCreateFileEx2</strong> fails.</p>

<p>The <em>CreateOptions</em> <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> flag prevents the file system from performing any intermediate buffering on behalf of the caller. Specifying this value places certain restrictions on the caller's parameters to other <strong>Flt..File</strong> routines or <strong>Zw..File</strong> routines, including the following:</p>

<ul>
<li><p>Any byte offset value passed to the <em>ByteOffset</em> parameter of <strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong>, <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong>, <strong><a href="fltwritefile" title="NTSTATUS FLTAPI FltWriteFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [in]            PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesWritten,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltWriteFile</a></strong>, or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong> must be a multiple of the sector size.</p></li>
<li><p>The <em>Length</em> parameter passed to <strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong>, <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong>, <strong><a href="fltwritefile" title="NTSTATUS FLTAPI FltWriteFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [in]            PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesWritten,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltWriteFile</a></strong>, or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong> must be a multiple of the sector size. Note that specifying a read operation to a buffer whose length is exactly the sector size might result in fewer significant bytes being transferred to that buffer if the end of the file was reached during the transfer.</p></li>
<li><p>Buffers must be aligned in accordance with the alignment requirement of the underlying storage device. This information can be obtained by calling <strong>FltCreateFileEx2</strong> to get a handle for the file object that represents the physical device and then calling <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong> with that handle, specifying <strong>FileAlignmentInformation</strong> as the value for <em>FileInformationClass</em> parameter. For more information about the system FILE_<em>XXX</em>_ALIGNMENT values, which are defined in <em>Ntifs.h</em>, see <strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/initializing-a-device-object"><strong>Initializing a Device Object</strong></a>.</p></li>
<li><p>Calls to <strong><a href="fltsetinformationfile" title="NTSTATUS FLTAPI FltSetInformationFile(&#10;  [in] PFLT_INSTANCE          Instance,&#10;  [in] PFILE_OBJECT           FileObject,&#10;  [in] PVOID                  FileInformation,&#10;  [in] ULONG                  Length,&#10;  [in] FILE_INFORMATION_CLASS FileInformationClass&#10;);">FltSetInformationFile</a></strong> or <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong> with the <em>FileInformationClass</em> parameter set to <strong>FilePositionInformation</strong> must specify an offset that is a multiple of the sector size.</p></li>
</ul>

<p>The <em>CreateOptions</em> <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> and <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> flags, which are mutually exclusive as their names suggest, specify that the file is being opened for synchronous I/O. This means that all I/O operations on the file are to be synchronous as long as they occur through the file object that the returned <em>FileHandle</em> refers to. All I/O on such a file is serialized across all threads by using the returned handle. With either of these <em>CreateOptions</em> flags set, the I/O Manager maintains the current file position offset in the file object's <strong>CurrentByteOffset</strong> field. This offset can be used in calls to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> and <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong>. It can also be queried or set by calling <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong> or <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong>.</p>

<p>If the <em>CreateOptions</em> <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is <em>not</em> specified and <strong>FltCreateFileEx2</strong> attempts to open a file with a reparse point, normal reparse point processing occurs for the file. If, on the other hand, the <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is specified, normal reparse processing does <em>not</em> occur and <strong>FltCreateFileEx2</strong> attempts to directly open the reparse point file. In either case, if the open operation was successful, <strong>FltCreateFileEx2</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>; otherwise, the routine returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code. <strong>FltCreateFileEx2</strong> never returns STATUS_REPARSE.</p>

<p>The <em>CreateOptions</em> <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag eliminates the time between when you open the file and request an oplock that could potentially enable a third party to open the file and get a sharing violation. An application can use the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag on <strong>FltCreateFileEx2</strong> and then request any oplock. This ensures that an oplock owner will be notified of any later open request that causes a sharing violation.</p>

<p>In Windows 7, if other handles exist on the file when an application uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag, the create operation will fail with STATUS_OPLOCK_NOT_GRANTED. This restriction no longer exists starting with Windows 8.</p>

<p>If this create operation would break an oplock that already exists on the file, then setting the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag will cause the create operation to fail with STATUS_CANNOT_BREAK_OPLOCK. The existing oplock will not be broken by this create operation.</p>

<p>An application that uses this flag must request an oplock after this call succeeds, or all later attempts to open the file will be blocked without the benefit of typical oplock processing. Similarly, if this call succeeds but the later oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed.</p>

<blockquote>
  <p>[!NOTE]
  The <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag is available in Windows 7, Windows Server 2008 R2 and later Windows operating systems. The Microsoft file systems that implement this flag in Windows 7 are NTFS, FAT, and exFAT.</p>
</blockquote>

<p>The <em>CreateOptions</em> flag <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> allows an application to request a level 1, batch, or filter oplock to prevent other applications from getting share violations. However, <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> is only practically useful for filter oplocks. To use it, you must complete the following steps:</p>

<ol>
<li><p>Issue a create request with <em>CreateOptions</em> of <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>, <em>DesiredAccess</em> of exactly FILE_READ_ATTRIBUTES, and <em>ShareAccess</em> of exactly <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>.</p>

<ul>
<li>If there are already open handles, the create request fails with STATUS_OPLOCK_NOT_GRANTED, and the next requested oplock also fails.</li>
<li>If you open with more access or less sharing will also cause a failure of STATUS_OPLOCK_NOT_GRANTED.</li>
</ul></li>
<li><p>If the create request succeeds, request an oplock.</p></li>
<li><p>Open another handle to the file to do I/O.</p></li>
</ol>

<p>Step three makes this practical only for filter oplocks. The handle opened in step 3 can have a DesiredAccess that contains a maximum of FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL and still not break a filter oplock. However, any DesiredAccess greater than FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE will break a level 1 or batch oplock and make the <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> flag useless for those oplock types.</p>

<p>NTFS is the only Microsoft file system that implements <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>.</p>

<p>Minifilter drivers must use <strong><a href="fltsetinformationfile" title="NTSTATUS FLTAPI FltSetInformationFile(&#10;  [in] PFLT_INSTANCE          Instance,&#10;  [in] PFILE_OBJECT           FileObject,&#10;  [in] PVOID                  FileInformation,&#10;  [in] ULONG                  Length,&#10;  [in] FILE_INFORMATION_CLASS FileInformationClass&#10;);">FltSetInformationFile</a></strong>, not <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong>, to rename a file.</p>

<blockquote>
  <p>[!NOTE]
  If you try to open a volume but only specify a combination of the following flags for the <em>DesiredAccess</em> parameter, <strong>FltCreateFileEx2</strong> will open a handle, independent of the file system, that has direct access to the storage device for the volume.</p>
  
  <ul>
  <li>FILE_READ_ATTRIBUTES</li>
  <li>READ_CONTROL</li>
  <li>WRITE_DAC</li>
  <li>WRITE_OWNER</li>
  <li>SYNCHRONIZE</li>
  </ul>
  
  <p>You must not use <strong>FltCreateFileEx2</strong> to open a handle with direct access to the storage device for the volume or you will leak system resources. If you want to open a handle with direct access to a storage device, call the <strong><a href="iocreatefileex" title="NTSTATUS IoCreateFileEx(&#10;  [out]          PHANDLE                   FileHandle,&#10;  [in]           ACCESS_MASK               DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER            AllocationSize,&#10;  [in]           ULONG                     FileAttributes,&#10;  [in]           ULONG                     ShareAccess,&#10;  [in]           ULONG                     Disposition,&#10;  [in]           ULONG                     CreateOptions,&#10;  [in, optional] PVOID                     EaBuffer,&#10;  [in]           ULONG                     EaLength,&#10;  [in]           CREATE_FILE_TYPE          CreateFileType,&#10;  [in, optional] PVOID                     InternalParameters,&#10;  [in]           ULONG                     Options,&#10;  [in, optional] PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoCreateFileEx</a></strong>, <strong><a href="iocreatefilespecifydeviceobjecthint" title="NTSTATUS IoCreateFileSpecifyDeviceObjectHint(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options,&#10;  [in, optional] PVOID              DeviceObject&#10;);">IoCreateFileSpecifyDeviceObjectHint</a></strong>, or <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong> function instead.</p>
</blockquote>

<p>When a caller of <strong>FltCreateFileEx2</strong> wishes to enable reparsing for a volume target, a <strong><a href="flt_createfile_target_ecp_context" title="typedef struct _FLT_CREATEFILE_TARGET_ECP_CONTEXT {&#10;  PFLT_INSTANCE               Instance;&#10;  PFLT_VOLUME                 Volume;&#10;  PFLT_FILE_NAME_INFORMATION  FileNameInformation;&#10;  FLT_CREATEFILE_TARGET_FLAGS Flags;&#10;} FLT_CREATEFILE_TARGET_ECP_CONTEXT, *PFLT_CREATEFILE_TARGET_ECP_CONTEXT;">FLT_CREATEFILE_TARGET_ECP_CONTEXT</a></strong> can be included as an ECP to the ECP list in the <em>DriverContext</em> parameter. If this ECP is present, <strong>FltCreateFileEx2</strong> will adjust the target device for the create operation and attempt for find a filtered instance of a volume appropriate for the given file information. Use of this ECP is available starting with Windows 8.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a></p>

<p><strong><a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a></strong></p>

<p><strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong></p>

<p><strong><a href="file_full_ea_information" title="typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></strong></p>

<p><strong><a href="fltacknowledgeecp" title="VOID FLTAPI FltAcknowledgeEcp(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltAcknowledgeEcp</a></strong></p>

<p><strong><a href="fltallocateextracreateparameter" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameter(&#10;  [in]           PFLT_FILTER                                    Filter,&#10;  [in]           LPCGUID                                        EcpType,&#10;  [in]           ULONG                                          SizeOfContext,&#10;  [in]           FSRTL_ALLOCATE_ECP_FLAGS                       Flags,&#10;  [in, optional] PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,&#10;  [in]           ULONG                                          PoolTag,&#10;  [out]          PVOID                                          *EcpContext&#10;);">FltAllocateExtraCreateParameter</a></strong></p>

<p><strong><a href="fltallocateextracreateparameterlist" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameterList(&#10;  [in]  PFLT_FILTER                  Filter,&#10;  [in]  FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,&#10;  [out] PECP_LIST                    *EcpList&#10;);">FltAllocateExtraCreateParameterList</a></strong></p>

<p><strong><a href="fltclose" title="NTSTATUS FLTAPI FltClose(&#10;  [in] HANDLE FileHandle&#10;);">FltClose</a></strong></p>

<p><strong><a href="fltfindextracreateparameter" title="NTSTATUS FLTAPI FltFindExtraCreateParameter(&#10;  [in]            PFLT_FILTER Filter,&#10;  [in]            PECP_LIST   EcpList,&#10;  [in]            LPCGUID     EcpType,&#10;  [out, optional] PVOID       *EcpContext,&#10;  [out, optional] ULONG       *EcpContextSize&#10;);">FltFindExtraCreateParameter</a></strong></p>

<p><strong><a href="fltfreeextracreateparameter" title="VOID FLTAPI FltFreeExtraCreateParameter(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltFreeExtraCreateParameter</a></strong></p>

<p><strong><a href="fltfreeextracreateparameterlist" title="VOID FLTAPI FltFreeExtraCreateParameterList(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PECP_LIST   EcpList&#10;);">FltFreeExtraCreateParameterList</a></strong></p>

<p><strong><a href="fltgetecplistfromcallbackdata" title="NTSTATUS FLTAPI FltGetEcpListFromCallbackData(&#10;  [in]  PFLT_FILTER        Filter,&#10;        PFLT_CALLBACK_DATA CallbackData,&#10;  [out] PECP_LIST          *EcpList&#10;);">FltGetEcpListFromCallbackData</a></strong></p>

<p><strong><a href="fltgetnextextracreateparameter" title="NTSTATUS FLTAPI FltGetNextExtraCreateParameter(&#10;  [in]            PFLT_FILTER Filter,&#10;  [in]            PECP_LIST   EcpList,&#10;  [in, optional]  PVOID       CurrentEcpContext,&#10;  [out, optional] LPGUID      NextEcpType,&#10;  [out, optional] PVOID       *NextEcpContext,&#10;  [out, optional] ULONG       *NextEcpContextSize&#10;);">FltGetNextExtraCreateParameter</a></strong></p>

<p><strong><a href="fltinsertextracreateparameter" title="NTSTATUS FLTAPI FltInsertExtraCreateParameter(&#10;  [in]      PFLT_FILTER Filter,&#10;  [in, out] PECP_LIST   EcpList,&#10;  [in, out] PVOID       EcpContext&#10;);">FltInsertExtraCreateParameter</a></strong></p>

<p><strong><a href="fltisecpacknowledged" title="BOOLEAN FLTAPI FltIsEcpAcknowledged(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltIsEcpAcknowledged</a></strong></p>

<p><strong><a href="fltisecpfromusermode" title="BOOLEAN FLTAPI FltIsEcpFromUserMode(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltIsEcpFromUserMode</a></strong></p>

<p><strong><a href="fltqueryinformationfile" title="NTSTATUS FLTAPI FltQueryInformationFile(&#10;  [in]            PFLT_INSTANCE          Instance,&#10;  [in]            PFILE_OBJECT           FileObject,&#10;  [out]           PVOID                  FileInformation,&#10;  [in]            ULONG                  Length,&#10;  [in]            FILE_INFORMATION_CLASS FileInformationClass,&#10;  [out, optional] PULONG                 LengthReturned&#10;);">FltQueryInformationFile</a></strong></p>

<p><strong><a href="fltreadfile" title="NTSTATUS FLTAPI FltReadFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [out]           PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesRead,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltReadFile</a></strong></p>

<p><strong><a href="fltremoveextracreateparameter" title="NTSTATUS FLTAPI FltRemoveExtraCreateParameter(&#10;  [in]            PFLT_FILTER Filter,&#10;  [in, out]       PECP_LIST   EcpList,&#10;  [in]            LPCGUID     EcpType,&#10;  [out]           PVOID       *EcpContext,&#10;  [out, optional] ULONG       *EcpContextSize&#10;);">FltRemoveExtraCreateParameter</a></strong></p>

<p><strong><a href="fltsetecplistintocallbackdata" title="NTSTATUS FLTAPI FltSetEcpListIntoCallbackData(&#10;  [in] PFLT_FILTER        Filter,&#10;       PFLT_CALLBACK_DATA CallbackData,&#10;  [in] PECP_LIST          EcpList&#10;);">FltSetEcpListIntoCallbackData</a></strong></p>

<p><strong><a href="fltsetinformationfile" title="NTSTATUS FLTAPI FltSetInformationFile(&#10;  [in] PFLT_INSTANCE          Instance,&#10;  [in] PFILE_OBJECT           FileObject,&#10;  [in] PVOID                  FileInformation,&#10;  [in] ULONG                  Length,&#10;  [in] FILE_INFORMATION_CLASS FileInformationClass&#10;);">FltSetInformationFile</a></strong></p>

<p><strong><a href="fltwritefile" title="NTSTATUS FLTAPI FltWriteFile(&#10;  [in]            PFLT_INSTANCE                    InitiatingInstance,&#10;  [in]            PFILE_OBJECT                     FileObject,&#10;  [in, optional]  PLARGE_INTEGER                   ByteOffset,&#10;  [in]            ULONG                            Length,&#10;  [in]            PVOID                            Buffer,&#10;  [in]            FLT_IO_OPERATION_FLAGS           Flags,&#10;  [out, optional] PULONG                           BytesWritten,&#10;  [in, optional]  PFLT_COMPLETED_ASYNC_IO_CALLBACK CallbackRoutine,&#10;  [in, optional]  PVOID                            CallbackContext&#10;);">FltWriteFile</a></strong></p>

<p><strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong></p>

<p><strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong></p>

<p><strong><a href="iocreatefile" title="NTSTATUS IoCreateFile(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options&#10;);">IoCreateFile</a></strong></p>

<p><strong><a href="iocreatefilespecifydeviceobjecthint" title="NTSTATUS IoCreateFileSpecifyDeviceObjectHint(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options,&#10;  [in, optional] PVOID              DeviceObject&#10;);">IoCreateFileSpecifyDeviceObjectHint</a></strong></p>

<p><strong><a href="ioinitializedrivercreatecontext" title="VOID IoInitializeDriverCreateContext(&#10;  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoInitializeDriverCreateContext</a></strong></p>

<p><strong><a href="obdereferenceobject" title="void ObDereferenceObject(&#10;  [in] a&#10;);">ObDereferenceObject</a></strong></p>

<p><strong><a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a></strong></p>

<p><strong><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a></strong></p>

<p><strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong></p>

<p><strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong></p>

<p><strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong></p>

<p><strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong></p>

<p><strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatefileex2">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltcreatefileex2.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
