<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltCbdqInitialize - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltCbdqInitialize - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltCbdqInitialize - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltCbdqInitialize(
  [in]      PFLT_INSTANCE                                 Instance,
  [in, out] <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a>                      Cbdq,
  [in]      PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            CbdqInsertIo,
  [in]      PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            CbdqRemoveIo,
  [in]      PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         CbdqPeekNextIo,
  [in]      PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              CbdqAcquire,
  [in]      PFLT_CALLBACK_DATA_QUEUE_RELEASE              CbdqRelease,
  [in]      PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CbdqCompleteCanceledIo
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcbdqinitialize">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltcbdqinitialize.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltcbdqinitialize)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fltcbdqinitialize-function">FltCbdqInitialize function</h1>

<h2 id="description">Description</h2>

<p>FltCbdqInitialize initializes a minifilter driver's callback data queue dispatch table.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="instance-in"><code>Instance</code> [in]</h3>

<p>Opaque instance pointer for the instance whose callback data queue is to be initialized.</p>

<h3 id="cbdq-in-out"><code>Cbdq</code> [in, out]</h3>

<p>Pointer to a callback data queue allocated by the minifilter driver.</p>

<h3 id="cbdqinsertio-in"><code>CbdqInsertIo</code> [in]</h3>

<p>Pointer to a caller-supplied insert callback routine. The Filter Manager calls this routine to insert the specified callback data structure into the queue. This routine is declared as follows:</p>

<pre><code>typedef <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
(*PFLT_CALLBACK_DATA_QUEUE_INSERT_IO)(
      _Inout_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _In_ <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> Cbd,
      _In_opt_ PVOID InsertContext
      );
</code></pre>

<h4 id="cbdq">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="cbd">Cbd</h4>

<p>Pointer to the callback data structure to be inserted into the queue.</p>

<h4 id="insertcontext">InsertContext</h4>

<p>Context information pointer that was passed as the <em>InsertContext</em> parameter to <a href="fltcbdqinsertio" title="NTSTATUS FLTAPI FltCbdqInsertIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE            Cbdq,&#10;  [in]           PFLT_CALLBACK_DATA                  Cbd,&#10;  [in, optional] PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context,&#10;  [in, optional] PVOID                               InsertContext&#10;);">FltCbdqInsertIo</a>.</p>

<h3 id="cbdqremoveio-in"><code>CbdqRemoveIo</code> [in]</h3>

<p>Pointer to a caller-supplied remove callback routine. The Filter Manager calls this routine to remove the specified callback data structure from the queue. This routine is declared as follows:</p>

<pre><code>typedef VOID
(*PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO)(
      _Inout_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _In_ <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> Cbd
      );
</code></pre>

<h4 id="cbdq-2">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="cbd-2">Cbd</h4>

<p>Pointer to the callback data structure to be removed from the queue.</p>

<h3 id="cbdqpeeknextio-in"><code>CbdqPeekNextIo</code> [in]</h3>

<p>Pointer to a caller-supplied peek callback routine. The Filter Manager calls this function to get a pointer to the next I/O operation matching <em>PeekContext</em> in the queue; or, if <em>Cbd</em> is <strong>NULL</strong>, to get a pointer to the first matching I/O operation in the queue. The minifilter driver entirely defines the meaning of <em>PeekContext</em> and defines when an I/O operation matches a given <em>PeekContext</em>. This routine is declared as follows:</p>

<pre><code>typedef <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a>
(*PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO)(
      _In_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _In_opt_ <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> Cbd,
      _In_opt_ PVOID PeekContext
      );
</code></pre>

<h4 id="cbdq-3">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="cbd-3">Cbd</h4>

<p>Pointer to the callback data structure marking the position in the queue to begin searching for a match to <em>PeekContext</em>. If <em>Cbd</em> is <strong>NULL</strong>, the search begins at the head of the queue.</p>

<h4 id="peekcontext">PeekContext</h4>

<p>Context information pointer that was passed as the <em>PeekContext</em> parameter to <a href="fltcbdqremovenextio" title="PFLT_CALLBACK_DATA FLTAPI FltCbdqRemoveNextIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE Cbdq,&#10;  [in, optional] PVOID                    PeekContext&#10;);">FltCbdqRemoveNextIo</a>.</p>

<h3 id="cbdqacquire-in"><code>CbdqAcquire</code> [in]</h3>

<p>Pointer to a caller-supplied acquire queue lock callback routine. The Filter Manager calls this routine to acquire the lock on the queue before attempting to insert or remove an item from the queue. This routine is declared as follows:</p>

<pre><code>typedef VOID
(*PFLT_CALLBACK_DATA_QUEUE_ACQUIRE)(
      _Inout_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _Out_opt_ <a href="kirql" title="typedef UCHAR KIRQL, *PKIRQL;">PKIRQL</a> Irql
      );
</code></pre>

<h4 id="cbdq-4">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="irql">Irql</h4>

<p>Pointer to a system-supplied variable that receives the current IRQL. The same variable is passed to the corresponding <em>CbdqRelease</em> routine.</p>

<h3 id="cbdqrelease-in"><code>CbdqRelease</code> [in]</h3>

<p>Pointer to a caller-supplied release queue lock callback routine. The Filter Manager calls this routine to release the lock that it obtained by calling the corresponding <em>CbdqAcquire</em> routine. This routine is declared as follows:</p>

<pre><code>typedef VOID
(*PFLT_CALLBACK_DATA_QUEUE_RELEASE)(
      _Inout_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _In_opt_ <a href="kirql" title="typedef UCHAR KIRQL, *PKIRQL;">KIRQL</a> Irql
      );
</code></pre>

<h4 id="cbdq-5">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="irql-2">Irql</h4>

<p>The same system-supplied variable that received the current IRQL as the <em>Irql</em> parameter to the corresponding <em>CbdqAcquire</em> routine.</p>

<h3 id="cbdqcompletecanceledio-in"><code>CbdqCompleteCanceledIo</code> [in]</h3>

<p>Pointer to a caller-supplied cancel routine. The Filter Manager calls this routine to signal to the minifilter driver to complete a canceled I/O operation. This routine is declared as follows:</p>

<pre><code>typedef VOID
(*PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO)(
      _Inout_ <a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">PFLT_CALLBACK_DATA_QUEUE</a> Cbdq,
      _Inout_ <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> Cbd
      );
</code></pre>

<h4 id="cbdq-6">Cbdq</h4>

<p>Pointer to the minifilter driver's cancel-safe callback data queue. This queue must have been initialized by calling <em>FltCbdqInitialize</em>.</p>

<h4 id="cbd-4">Cbd</h4>

<p>Pointer to the callback data structure for the canceled I/O operation.</p>

<h2 id="return-value">Return value</h2>

<p><em>FltCbdqInitialize</em> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value.</p>

<h2 id="remarks">Remarks</h2>

<p>The newly initialized callback data queue is in the enabled state, which means that callback data structure items can be inserted into the queue. The queue can be disabled by calling <a href="fltcbdqdisable" title="VOID FLTAPI FltCbdqDisable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqDisable</a> and reenabled by calling <a href="fltcbdqenable" title="VOID FLTAPI FltCbdqEnable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqEnable</a>.</p>

<p>Minifilter drivers can use the <strong>FltCbdq</strong><em>Xxx</em> routines to implement a callback data queue for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based I/O operations. By using these routines, minifilter drivers can make their queues cancel-safe; the system transparently handles I/O cancellation for the minifilter drivers.</p>

<p>The <strong>FltCbdq</strong><em>Xxx</em> routines can only be used for <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based I/O operations. To determine whether a given callback data structure represents an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based I/O operation, use the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)">FLT_IS_IRP_OPERATION</a> macro.</p>

<p>Minifilter drivers can use any internal implementation for the queue. The Filter Manager interacts with the minifilter driver's queue implementation solely through the set of dispatch routines provided by <em>FltCbdqInitialize</em>.</p>

<p>The system automatically locks and unlocks the queue as necessary. Minifilter drivers do not implement any locking inside their <em>CbdqInsertIo</em>, <em>CbdqRemoveIo</em>, and <em>CbdqPeekNextIo</em> routines.</p>

<p>Minifilter drivers can use any of the operating system's synchronization primitives as the locking mechanism in their <em>CbdqAcquire</em> and <em>CbdqRelease</em> routines, such as a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/spin-locks">spin lock</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mutex-objects">mutex object</a>, or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-exinitializeresourcelite">resource variable</a>. Note that if a minifilter driver uses a spin lock rather than a mutex or resource to protect the queue, it can call the <strong>FltCbdq</strong><em>Xxx</em> routines at IRQL &lt;= DISPATCH_LEVEL. If a mutex or resource is used, the minifilter driver must be running at IRQL &lt;= APC_LEVEL when it calls any of these routines except <em>FltCbdqInitialize</em>.</p>

<p>The minifilter driver does not manipulate the queue directly. Instead, it calls <a href="fltcbdqinsertio" title="NTSTATUS FLTAPI FltCbdqInsertIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE            Cbdq,&#10;  [in]           PFLT_CALLBACK_DATA                  Cbd,&#10;  [in, optional] PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context,&#10;  [in, optional] PVOID                               InsertContext&#10;);">FltCbdqInsertIo</a>, <a href="fltcbdqremoveio" title="PFLT_CALLBACK_DATA FLTAPI FltCbdqRemoveIo(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE            Cbdq,&#10;  [in]      PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context&#10;);">FltCbdqRemoveIo</a>, and <a href="fltcbdqremovenextio" title="PFLT_CALLBACK_DATA FLTAPI FltCbdqRemoveNextIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE Cbdq,&#10;  [in, optional] PVOID                    PeekContext&#10;);">FltCbdqRemoveNextIo</a> to add or remove a callback data structure. These routines in turn call the callback functions that the minifilter driver provided to <em>FltCbdqInitialize</em>.</p>

<p>Minifilter drivers should implement the queue routines as follows.</p>

<table>
<thead>
<tr>
  <th>Cbdq Routine</th>
  <th>Implementation</th>
</tr>
</thead>
<tbody>
<tr>
  <td><em>CbdqInsertIo</em></td>
  <td>Insert the specified callback data structure into the queue.</td>
</tr>
<tr>
  <td><em>CbdqRemoveIo</em></td>
  <td>Remove the specified callback data structure from the queue.</td>
</tr>
<tr>
  <td><em>CbdqPeekNextIo</em></td>
  <td>This routine should allow the system to loop through the callback data structures with matching <em>PeekContext</em> in the queue. <em>Cbd</em> = <em>CbdqPeekNextIo</em>(<em>Cbdq</em>, <strong>NULL</strong>, <em>PeekContext</em>) should return the first matching entry in the queue, and <em>CbdqPeekNextIo</em>(<em>Cbdq</em>, <em>Cbd</em>, <em>PeekContext</em>) should return the next matching entry after the given callback data structure in the queue. The minifilter driver entirely defines the meaning of <em>PeekContext</em> and defines when a callback data structure matches a <em>PeekContext</em> value.</td>
</tr>
<tr>
  <td><em>CbdqAcquire</em></td>
  <td>This routine should lock the queue so that no other thread can access it. Minifilter drivers can use any locking mechanism to lock the queue. If the minifilter driver uses the <a href="keacquirespinlock" title="void KeAcquireSpinLock(&#10;  SpinLock,&#10;  OldIrql&#10;);">KeAcquireSpinLock</a> routine, the minifilter driver can use the memory location pointed to by the routine's <em>Irql</em> parameter to store the IRQL. Otherwise, minifilter drivers can ignore that parameter.</td>
</tr>
<tr>
  <td><em>CbdqRelease</em></td>
  <td>This routine should unlock the queue created by <em>CbdqAcquire</em>. If the minifilter driver used a spin lock and returned the IRQL value in the <em>Irql</em> parameter of <em>CbdqAcquire</em>, the system passes that value in the <em>Irql</em> parameter of <em>CbdqRelease</em>. The minifilter driver can use the IRQL to unlock the spin lock by calling <a href="kereleasespinlock" title="VOID KeReleaseSpinLock(&#10;  PKSPIN_LOCK SpinLock,&#10;  KIRQL       NewIrql&#10;);">KeReleaseSpinLock</a>. Otherwise, minifilter drivers can ignore the <em>Irql</em> parameter.</td>
</tr>
<tr>
  <td><em>CbdqCompleteCanceledIo</em></td>
  <td>This routine should complete a canceled I/O operation. Normally, minifilter drivers can just call <a href="fltcompletependedpreoperation" title="VOID FLTAPI FltCompletePendedPreOperation(&#10;                 PFLT_CALLBACK_DATA        CallbackData,&#10;  [in]           FLT_PREOP_CALLBACK_STATUS CallbackStatus,&#10;  [in, optional] PVOID                     Context&#10;);">FltCompletePendedPreOperation</a>(Data, FLT_PREOP_COMPLETE, <strong>NULL</strong>). Minifilter drivers do not need to dequeue the callback data structure -- the Filter Manager automatically calls the queue's <em>CbdqRemoveIo</em> before calling <em>CbdqCompleteCanceledIo</em>.</td>
</tr>
</tbody>
</table>

<h2 id="see-also">See also</h2>

<p><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></p>

<p><a href="flt_callback_data_queue" title="typedef struct _FLT_CALLBACK_DATA_QUEUE {&#10;  IO_CSQ                                        Csq;&#10;  FLT_CALLBACK_DATA_QUEUE_FLAGS                 Flags;&#10;  PFLT_INSTANCE                                 Instance;&#10;  PFLT_CALLBACK_DATA_QUEUE_INSERT_IO            InsertIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO            RemoveIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO         PeekNextIo;&#10;  PFLT_CALLBACK_DATA_QUEUE_ACQUIRE              Acquire;&#10;  PFLT_CALLBACK_DATA_QUEUE_RELEASE              Release;&#10;  PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO CompleteCanceledIo;&#10;} FLT_CALLBACK_DATA_QUEUE, *PFLT_CALLBACK_DATA_QUEUE;">FLT_CALLBACK_DATA_QUEUE</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff544654(v=vs.85)">FLT_IS_IRP_OPERATION</a></p>

<p><a href="fltcbdqdisable" title="VOID FLTAPI FltCbdqDisable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqDisable</a></p>

<p><a href="fltcbdqenable" title="VOID FLTAPI FltCbdqEnable(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE Cbdq&#10;);">FltCbdqEnable</a></p>

<p><a href="fltcbdqinsertio" title="NTSTATUS FLTAPI FltCbdqInsertIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE            Cbdq,&#10;  [in]           PFLT_CALLBACK_DATA                  Cbd,&#10;  [in, optional] PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context,&#10;  [in, optional] PVOID                               InsertContext&#10;);">FltCbdqInsertIo</a></p>

<p><a href="fltcbdqremoveio" title="PFLT_CALLBACK_DATA FLTAPI FltCbdqRemoveIo(&#10;  [in, out] PFLT_CALLBACK_DATA_QUEUE            Cbdq,&#10;  [in]      PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT Context&#10;);">FltCbdqRemoveIo</a></p>

<p><a href="fltcbdqremovenextio" title="PFLT_CALLBACK_DATA FLTAPI FltCbdqRemoveNextIo(&#10;  [in, out]      PFLT_CALLBACK_DATA_QUEUE Cbdq,&#10;  [in, optional] PVOID                    PeekContext&#10;);">FltCbdqRemoveNextIo</a></p>

<p><a href="fltcompletependedpreoperation" title="VOID FLTAPI FltCompletePendedPreOperation(&#10;                 PFLT_CALLBACK_DATA        CallbackData,&#10;  [in]           FLT_PREOP_CALLBACK_STATUS CallbackStatus,&#10;  [in, optional] PVOID                     Context&#10;);">FltCompletePendedPreOperation</a></p>

<p><a href="keacquirespinlock" title="void KeAcquireSpinLock(&#10;  SpinLock,&#10;  OldIrql&#10;);">KeAcquireSpinLock</a></p>

<p><a href="kereleasespinlock" title="VOID KeReleaseSpinLock(&#10;  PKSPIN_LOCK SpinLock,&#10;  KIRQL       NewIrql&#10;);">KeReleaseSpinLock</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcbdqinitialize">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltcbdqinitialize.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
