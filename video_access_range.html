<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="VIDEO_ACCESS_RANGE - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>VIDEO_ACCESS_RANGE - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            VIDEO_ACCESS_RANGE - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// video.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">typedef struct _VIDEO_ACCESS_RANGE {
  <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> RangeStart;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            RangeLength;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            RangeInIoSpace;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            RangeVisible;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            RangeShareable;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            RangePassive;
} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/ns-video-_video_access_range">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/video_access_range.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-video-_video_access_range)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>_VIDEO_ACCESS_RANGE structure</h1>
<h2>Description</h2>
<p>The VIDEO_ACCESS_RANGE structure defines a device I/O port or memory range for the video adapter. Every miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a> function must set up an array of VIDEO_ACCESS_RANGE-type elements, called the <strong>access ranges array</strong>, for each video adapter the miniport driver supports.</p>
<p>For VGA-compatible miniport drivers, VIDEO_ACCESS_RANGE also defines an element in an array passed to <a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a> to enable or disable direct access to I/O ports by full-screen MS-DOS applications.</p>
<h2>Members</h2>
<h3><code>RangeStart</code></h3>
<p>Specifies the bus-relative base address of a memory or I/O port range for an element in the access ranges array passed to <a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a> or returned by <a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a>.</p>
<p>Specifies the bus-relative base address of an I/O port range for an array to be passed to <a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a>.</p>
<h3><code>RangeLength</code></h3>
<p>Specifies the number of I/O ports or size in bytes for the range.</p>
<h3><code>RangeInIoSpace</code></h3>
<p>Specifies whether the range is in I/O space or in memory space. A value of <strong>TRUE</strong> (1) indicates that the range is in I/O space; a value of <strong>FALSE</strong> (0) indicates the range is in memory space.</p>
<h3><code>RangeVisible</code></h3>
<p>Is ignored if the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a> function is setting up the access ranges array.</p>
<p>Is set to <strong>TRUE</strong> by VGA-compatible miniport drivers and passed to <strong><a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a></strong> to enable direct access to the I/O port range by a full-screen MS-DOS application. If set to <strong>FALSE</strong>, application-issued instructions continue to be trapped and forwarded to the miniport driver's <strong>SvgaHwIoXxx</strong> function for validation.</p>
<h3><code>RangeShareable</code></h3>
<p>Is set to <strong>TRUE</strong> if the access range described by this element can be shared with another driver and/or device or to <strong>FALSE</strong> if the range cannot be shared.</p>
<p>Is ignored by <a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a>.</p>
<h3><code>RangePassive</code></h3>
<p>Indicates whether the device actually uses the port. Values for this member are shown in the following table.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>VIDEO_RANGE_PASSIVE_DECODE</td>
<td>The device decodes the port but the driver does not use it.</td>
</tr>
<tr>
<td>VIDEO_RANGE_10_BIT_DECODE</td>
<td>The device decodes ten bits of the port address.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>The miniport driver must claim legacy resources in its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/driverentry-of-ide-controller-minidriver">DriverEntry</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_legacyresources">HwVidLegacyResources</a> function.</p>
<p>Otherwise, a miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a> function sets up the access ranges array for an adapter's PCI resources. It can use information returned by <a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a>. As an alternative, it can use information retrieved from the registry by calling <a href="videoportgetdevicedata" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetDeviceData(&#10;  PVOID                          HwDeviceExtension,&#10;  VIDEO_DEVICE_DATA_TYPE         DeviceDataType,&#10;  PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,&#10;  PVOID                          Context&#10;);">VideoPortGetDeviceData</a> with a miniport driver-supplied <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pminiport_query_device_routine">HwVidQueryDeviceCallback</a> function or <a href="videoportgetregistryparameters" title="VIDEOPORT_API VP_STATUS VideoPortGetRegistryParameters(&#10;       PVOID                          HwDeviceExtension,&#10;  [in] PWSTR                          ParameterName,&#10;       UCHAR                          IsParameterFileName,&#10;       PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,&#10;       PVOID                          Context&#10;);">VideoPortGetRegistryParameters</a> with a miniport driver-supplied <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pminiport_get_registry_routine">HwVidQueryNamedValueCallback</a> function. If calling these <strong>VideoPort</strong><strong>Xxx</strong> does not supply the bus-relative access range values, <strong>HwVidFindAdapter</strong> can set up access ranges elements using driver-supplied bus-relative default values.</p>
<h3>Claiming Access Ranges in the Registry</h3>
<p>The miniport driver should call <a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a> with any access ranges obtained from <strong><a href="videoportgetdevicedata" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetDeviceData(&#10;  PVOID                          HwDeviceExtension,&#10;  VIDEO_DEVICE_DATA_TYPE         DeviceDataType,&#10;  PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,&#10;  PVOID                          Context&#10;);">VideoPortGetDeviceData</a></strong>, <strong><a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a></strong>, or supplied as defaults by the miniport driver. If <strong><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></strong> returns NO_ERROR for such an array of access ranges, the <strong>HwVidFindAdapter</strong> or <strong>HwVidQueryDeviceCallback</strong> function can then map the ranges with <a href="videoportgetdevicebase" title="VIDEOPORT_DEPRECATED VIDEOPORT_API PVOID VideoPortGetDeviceBase(&#10;  PVOID            HwDeviceExtension,&#10;  PHYSICAL_ADDRESS IoAddress,&#10;  ULONG            NumberOfUchars,&#10;  UCHAR            InIoSpace&#10;);">VideoPortGetDeviceBase</a> and use the returned mapped logical addresses to access the adapter.</p>
<p>A successful call to <a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a> also claims the returned bus-relative access ranges in the registry for the caller. If the miniport driver modifies any of the returned values, it must call <strong><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></strong> with the full access range, including any unmodified elements. Each call to <strong><a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a></strong> or <strong><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></strong> for a particular video adapter overwrites the caller's claimed hardware resources in the registry.</p>
<p>A miniport driver must not attempt to use a range for which <strong><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></strong> or <strong><a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a></strong> does not return NO_ERROR.</p>
<h3>Mapping Access Ranges to Communicate with the Adapter</h3>
<p>After a miniport driver has claimed resources in the registry for an adapter, it cannot use bus-relative addresses to access or configure the adapter, because the HAL can remap all bus-relative device addresses to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">system space</a>.</p>
<p>The miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a> function must call <a href="videoportgetdevicebase" title="VIDEOPORT_DEPRECATED VIDEOPORT_API PVOID VideoPortGetDeviceBase(&#10;  PVOID            HwDeviceExtension,&#10;  PHYSICAL_ADDRESS IoAddress,&#10;  ULONG            NumberOfUchars,&#10;  UCHAR            InIoSpace&#10;);">VideoPortGetDeviceBase</a> to get mapped logical addresses for its access ranges. Only then can the miniport driver communicate with the video adapter by passing the returned mapped logical range addresses to <strong>VideoPortRead/<a href="writeport" title="BOOL WritePort(&#10;  _In_  HANDLE  hPort,&#10;  _In_  LPBYTE  pBuffer,&#10;        DWORD   cbBuf,&#10;  _Out_ LPDWORD pcbWritten&#10;);">WritePort</a></strong><strong>Xxx</strong> to access device memory in I/O space and/or <strong>VideoPortRead/WriteRegister</strong><strong>Xxx</strong> to access device memory in memory space.</p>
<h3>Determining whether an Access Range is Sharable</h3>
<p>Follow these guidelines to determine whether an access range can be shared:</p>
<ul>
<li>If the range of memory or I/O ports should be &quot;owned&quot; by this driver, and/or access to this range by any other driver can cause a problem, set <strong>RangeSharable</strong> to <strong>FALSE</strong>.</li>
<li>If the range can be shared with a cooperating device driver, set <strong>RangeSharable</strong> to <strong>TRUE</strong>.</li>
</ul>
<p>SVGA miniport drivers that implement all VGA functionality (declared in the registry as <strong>VgaCompatible</strong> set to one) should claim their access ranges as unsharable so the system VGA driver will not be loaded. On the other hand, miniport drivers for adapters such as the S3 or the XGA, which set <strong>VgaCompatible</strong> to zero in the registry, should claim all the resources they share with the system VGA driver as sharable.</p>
<p>However, miniport drivers for cards that work with a pass-through IOCTL and that can be connected to any VGA or SVGA card should not be using any system VGA ports or memory ranges. If they do, such a driver should not attempt to claim any of the VGA access ranges in the registry. Attempts to claim VGA resources by such a miniport driver are likely to cause a resource conflict because the driver of any SVGA card in the machine will have claimed these access ranges as unsharable.</p>
<h3>Passing I/O Port Range Elements to <a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a></h3>
<p>All VIDEO_ACCESS_RANGE-type array elements describing I/O port ranges are assumed to be invisible, unless a VGA-compatible miniport driver in an x86-based machine explicitly resets the <strong>RangeVisible</strong> member(s) to <strong>TRUE</strong> and calls <a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a> to enable one or more I/O port ranges. <strong><a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a></strong> ignores the <strong>RangeSharable</strong> members of the input array.</p>
<p>In an array of VIDEO_ACCESS_RANGE-type elements passed to <strong><a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a></strong>, the value of each element's <strong>RangeVisible</strong> member determines whether the given I/O port(s) can be accessed directly by the VDM (MS-DOS application running in full-screen on an x86-based machine) or whether such an application-issued I/O stream is trapped and forwarded to a miniport driver-supplied <strong>SvgaHwIoPortXxx</strong> function for validation first.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/driverentry-of-video-miniport-driver">DriverEntry of Video Miniport Driver</a></p>
<p><a href="emulator_access_entry" title="typedef struct _EMULATOR_ACCESS_ENTRY {&#10;  ULONG                     BasePort;&#10;  ULONG                     NumConsecutivePorts;&#10;  EMULATOR_PORT_ACCESS_TYPE AccessType;&#10;  UCHAR                     AccessMode;&#10;  UCHAR                     StringSupport;&#10;  PVOID                     Routine;&#10;} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;">EMULATOR_ACCESS_ENTRY</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pminiport_query_device_routine">HwVidQueryDeviceCallback</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pminiport_get_registry_routine">HwVidQueryNamedValueCallback</a></p>
<p><a href="video_hw_initialization_data" title="typedef struct _VIDEO_HW_INITIALIZATION_DATA {&#10;  ULONG                          HwInitDataSize;&#10;  INTERFACE_TYPE                 AdapterInterfaceType;&#10;  PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;&#10;  PVIDEO_HW_INITIALIZE           HwInitialize;&#10;  PVIDEO_HW_INTERRUPT            HwInterrupt;&#10;  PVIDEO_HW_START_IO             HwStartIO;&#10;  ULONG                          HwDeviceExtensionSize;&#10;  ULONG                          StartingDeviceNumber;&#10;  PVIDEO_HW_RESET_HW             HwResetHw;&#10;  PVIDEO_HW_TIMER                HwTimer;&#10;  PVIDEO_HW_START_DMA            HwStartDma;&#10;  PVIDEO_HW_POWER_SET            HwSetPowerState;&#10;  PVIDEO_HW_POWER_GET            HwGetPowerState;&#10;  PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;&#10;  PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;&#10;  ULONG                          HwChildDeviceExtensionSize;&#10;  PVIDEO_ACCESS_RANGE            HwLegacyResourceList;&#10;  ULONG                          HwLegacyResourceCount;&#10;  PVIDEO_HW_LEGACYRESOURCES      HwGetLegacyResources;&#10;...">VIDEO_HW_INITIALIZATION_DATA</a></p>
<p><a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a></p>
<p><a href="videoportgetdevicebase" title="VIDEOPORT_DEPRECATED VIDEOPORT_API PVOID VideoPortGetDeviceBase(&#10;  PVOID            HwDeviceExtension,&#10;  PHYSICAL_ADDRESS IoAddress,&#10;  ULONG            NumberOfUchars,&#10;  UCHAR            InIoSpace&#10;);">VideoPortGetDeviceBase</a></p>
<p><a href="videoportgetdevicedata" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetDeviceData(&#10;  PVOID                          HwDeviceExtension,&#10;  VIDEO_DEVICE_DATA_TYPE         DeviceDataType,&#10;  PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,&#10;  PVOID                          Context&#10;);">VideoPortGetDeviceData</a></p>
<p><a href="videoportgetregistryparameters" title="VIDEOPORT_API VP_STATUS VideoPortGetRegistryParameters(&#10;       PVOID                          HwDeviceExtension,&#10;  [in] PWSTR                          ParameterName,&#10;       UCHAR                          IsParameterFileName,&#10;       PMINIPORT_GET_REGISTRY_ROUTINE GetRegistryRoutine,&#10;       PVOID                          Context&#10;);">VideoPortGetRegistryParameters</a></p>
<p><a href="videoportinitialize" title="VIDEOPORT_API ULONG VideoPortInitialize(&#10;  PVOID                         Argument1,&#10;  PVOID                         Argument2,&#10;  PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,&#10;  PVOID                         HwContext&#10;);">VideoPortInitialize</a></p>
<p><a href="videoportsettrappedemulatorports" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortSetTrappedEmulatorPorts(&#10;       PVOID               HwDeviceExtension,&#10;       ULONG               NumAccessRanges,&#10;  [in] PVIDEO_ACCESS_RANGE AccessRange&#10;);">VideoPortSetTrappedEmulatorPorts</a></p>
<p><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/ns-video-_video_access_range">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/video/ns-video-_video_access_range.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
