<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtWriteFile - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtWriteFile - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtWriteFile - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTIOAPI_H

</span><span class="ntdoc-code-intro">/**
 * The NtWriteFile function writes data to an open file.
 *
 * \param[in] FileHandle A handle to the file object representing the file or directory on which the specified action is to be performed.
 * \param[in] Event A handle for a caller-created event. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state.
 * \param[in] ApcRoutine Address of a caller-supplied APC routine to be called when the requested operation completes. This parameter is optional and can be NULL.
 * \param[in] ApcContext Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object.
 * \param[out] IoStatusBlock Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the operation.
 * \param[in] Buffer Pointer to a caller-allocated buffer that contains the data to write to the file.
 * \param[in] Length The size, in bytes, of the buffer pointed to by Buffer.
 * \param[in] ByteOffset Pointer to a variable that specifies the starting byte offset in the file for beginning the write operation.
 * \param[in] Key Device and intermediate drivers should set this pointer to NULL.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwwritefile
 */
</span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/443d121781061210978931c1766974f1372e359a/phnt/include/ntioapi.h#L2386">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/443d121781061210978931c1766974f1372e359a/phnt/include/ntzwapi.h#L4951">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtWriteFile(
  [in]           HANDLE           FileHandle,
  [in, optional] HANDLE           Event,
  [in, optional] <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional] PVOID            ApcContext,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]           PVOID            Buffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in, optional] PLARGE_INTEGER   ByteOffset,
  [in, optional] PULONG           Key
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntwritefile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwWriteFile(
  [in]           HANDLE           FileHandle,
  [in, optional] HANDLE           Event,
  [in, optional] <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional] PVOID            ApcContext,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [in]           PVOID            Buffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in, optional] PLARGE_INTEGER   ByteOffset,
  [in, optional] PULONG           Key
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwwritefile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntwritefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntwritefile)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="ntwritefile-function">NtWriteFile function</h1>

<h2 id="description">Description</h2>

<p>The <strong>ZwWriteFile</strong> routine writes data to an open file.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="filehandle-in"><code>FileHandle</code> [in]</h3>

<p>Handle to the file object. This handle is created by a successful call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> or <strong><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></strong>.</p>

<h3 id="event-in-optional"><code>Event</code> [in, optional]</h3>

<p>Optionally, a handle to an event object to set to the signaled state after the write operation completes. Device and intermediate drivers should set this parameter to NULL.</p>

<h3 id="apcroutine-in-optional"><code>ApcRoutine</code> [in, optional]</h3>

<p>This parameter is reserved. Device and intermediate drivers should set this pointer to NULL.</p>

<h3 id="apccontext-in-optional"><code>ApcContext</code> [in, optional]</h3>

<p>This parameter is reserved. Device and intermediate drivers should set this pointer to NULL.</p>

<h3 id="iostatusblock-out"><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the requested write operation. The <strong>Information</strong> member receives the number of bytes actually written to the file.</p>

<h3 id="buffer-in"><code>Buffer</code> [in]</h3>

<p>Pointer to a caller-allocated buffer that contains the data to write to the file.</p>

<h3 id="length-in"><code>Length</code> [in]</h3>

<p>The size, in bytes, of the buffer pointed to by <strong>Buffer</strong>.</p>

<h3 id="byteoffset-in-optional"><code>ByteOffset</code> [in, optional]</h3>

<p>Pointer to a variable that specifies the starting byte offset in the file for beginning the write operation. If <strong>Length</strong> and <strong>ByteOffset</strong> specify a write operation past the current end-of-file mark, <strong>NtWriteFile</strong> automatically extends the file and updates the end-of-file mark; any bytes that are not explicitly written between such old and new end-of-file marks are defined to be zero.</p>

<p>If the call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> set only the <strong>DesiredAccess<em>* flag FILE_APPEND_DATA, *</em>ByteOffset</strong> is ignored. Data in the given <strong>Buffer</strong>, for <strong>Length</strong> bytes, is written starting at the current end of file.</p>

<p>If the call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> set either of the <strong>CreateOptions<em>* flags, <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, the I/O Manager maintains the current file position. If so, the caller of *</em>NtWriteFile</strong> can specify that the current file position offset be used instead of an explicit <strong>ByteOffset</strong> value. This specification can be made by using one of the following methods:</p>

<ul>
<li><em>Specify a pointer to a LARGE_INTEGER value with the *</em>HighPart** member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a>.</li>
<li>Pass a NULL pointer for <strong>ByteOffset</strong>.</li>
</ul>

<p><strong>NtWriteFile</strong> updates the current file position by adding the number of bytes written when it completes the write operation, if it is using the current file position maintained by the I/O Manager.</p>

<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <strong>ByteOffset</strong> value to <strong>NtWriteFile</strong>. Doing this automatically changes the current file position to that <strong>ByteOffset</strong>value, performs the write operation, and then updates the position according to the number of bytes actually written. This technique gives the caller atomic seek-and-write service.</p>

<p>It is also possible to cause a write operation to start at the current end of file by specifying for <strong>ByteOffset</strong> a pointer to a LARGE_INTEGER value with **HighPart** set to -1 and **LowPart** set to <a href="file_write_to_end_of_file" title="#define FILE_WRITE_TO_END_OF_FILE 0xffffffff">FILE_WRITE_TO_END_OF_FILE</a>. This works regardless of whether the I/O Manager is maintaining the current file position.</p>

<h3 id="key-in-optional"><code>Key</code> [in, optional]</h3>

<p>Device and intermediate drivers should set this pointer to NULL.</p>

<h2 id="return-value">Return value</h2>

<p><strong>NtWriteFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success or the appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code on failure.</p>

<h2 id="remarks">Remarks</h2>

<p>Callers of <strong>NtWriteFile</strong> must have already called <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> with the FILE_WRITE_DATA, FILE_APPEND_DATA, or GENERIC_WRITE flag set in the *<em>DesiredAccess</em>* parameter. Note that having only FILE_APPEND_DATA access to a file does not allow the caller to write anywhere in the file except at the current end-of-file mark, while having FILE_WRITE_DATA access to a file does not preclude the caller from writing to or beyond the end of a file.</p>

<p>If the preceding call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> set the <strong>CreateOptions<em>* flag <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a>, the *</em>Length</strong> and <strong>ByteOffset</strong> parameters to <strong>NtWriteFile</strong> must be an integral of the sector size. For more information, see <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong>.</p>

<p><strong>NtWriteFile</strong> begins the write operation to the file at <strong>ByteOffset</strong>, at the current file position, or at the end-of-file mark. It terminates the write operation when it has written <strong>Length</strong> bytes from <strong>Buffer</strong>. If necessary, it extends the length of the file and resets the end-of-file mark.</p>

<p>If the caller opened the file with the <strong>DesiredAccess</strong> SYNCHRONIZE flag set, the caller can wait for this routine to set the given <strong>FileHandle</strong> to the signaled state.</p>

<p>Drivers should call <strong>NtWriteFile</strong> in the context of the system process in three cases:</p>

<ul>
<li>The driver creates the file handle that it passes to <strong>NtWriteFile</strong>.</li>
<li><strong>NtWriteFile</strong> notifies the driver of I/O completion by means of an event created by the driver.</li>
<li><strong>NtWriteFile</strong> notifies the driver of I/O completion by means of an APC callback routine that the driver passes to <strong>NtWriteFile</strong>.</li>
</ul>

<p>File and event handles are only valid in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to <strong>NtWriteFile</strong> in the context of the system process instead of the process context that the driver is in.</p>

<p>Likewise, <strong>NtWriteFile</strong> should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread issuing the I/O request. If the driver calls <strong>NtWriteFile</strong> in the context of a process other than the system process, the APC could be delayed indefinitely, or it might not fire at all as the originating thread may never enter an alertable wait state.</p>

<p>For more information about working with files, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>

<p>Callers of <strong>NtWriteFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>

<p>If the call to this function occurs in user mode, you should use the name "<strong>NtWriteFile</strong>" instead of "<strong>ZwWriteFile</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></strong></p>

<p><strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong></p>

<p><strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong></p>

<p><strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></strong></p>

<p><strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntwritefile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntwritefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-zwwritefile)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>

<p>The <strong>ZwWriteFile</strong> routine writes data to an open file.</p>

<h2>Parameters</h2>

<h3><code>FileHandle</code> [in]</h3>

<p>Handle to the file object. This handle is created by a successful call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> or <a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">ZwOpenFile</a>.</p>

<h3><code>Event</code> [in, optional]</h3>

<p>Optionally, a handle to an event object to set to the signaled state after the write operation completes. Device and intermediate drivers should set this parameter to <strong>NULL</strong>.</p>

<h3><code>ApcRoutine</code> [in, optional]</h3>

<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>

<h3><code>ApcContext</code> [in, optional]</h3>

<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>

<h3><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the requested write operation. The <strong>Information</strong> member receives the number of bytes actually written to the file.</p>

<h3><code>Buffer</code> [in]</h3>

<p>Pointer to a caller-allocated buffer that contains the data to write to the file.</p>

<h3><code>Length</code> [in]</h3>

<p>The size, in bytes, of the buffer pointed to by <em>Buffer</em>.</p>

<h3><code>ByteOffset</code> [in, optional]</h3>

<p>Pointer to a variable that specifies the starting byte offset in the file for beginning the write operation. If <em>Length</em> and <em>ByteOffset</em> specify a write operation past the current end-of-file mark, <strong>ZwWriteFile</strong> automatically extends the file and updates the end-of-file mark; any bytes that are not explicitly written between such old and new end-of-file marks are defined to be zero.</p>

<p>If the call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> set only the <em>DesiredAccess</em> flag FILE_APPEND_DATA, <em>ByteOffset</em> is ignored. Data in the given <em>Buffer</em>, for <em>Length</em> bytes, is written starting at the current end of file.</p>

<p>If the call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> set either of the <em>CreateOptions</em> flags, <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, the I/O Manager maintains the current file position. If so, the caller of <strong>ZwWriteFile</strong> can specify that the current file position offset be used instead of an explicit <em>ByteOffset</em> value. This specification can be made by using one of the following methods:</p>

<ul>
<li><p>Specify a pointer to a LARGE_INTEGER value with the **HighPart** member set to -1 and the **LowPart** member set to the system-defined value <a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a>.</p></li>
<li><p>Pass a <strong>NULL</strong> pointer for <em>ByteOffset</em>.</p></li>
</ul>

<p><strong>ZwWriteFile</strong> updates the current file position by adding the number of bytes written when it completes the write operation, if it is using the current file position maintained by the I/O Manager.</p>

<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <em>ByteOffset</em> value to <strong>ZwWriteFile</strong>. Doing this automatically changes the current file position to that <em>ByteOffset</em>value, performs the write operation, and then updates the position according to the number of bytes actually written. This technique gives the caller atomic seek-and-write service.</p>

<p>It is also possible to cause a write operation to start at the current end of file by specifying for <em>ByteOffset</em> a pointer to a LARGE_INTEGER value with **HighPart** set to -1 and **LowPart** set to <a href="file_write_to_end_of_file" title="#define FILE_WRITE_TO_END_OF_FILE 0xffffffff">FILE_WRITE_TO_END_OF_FILE</a>. This works regardless of whether the I/O Manager is maintaining the current file position.</p>

<h3><code>Key</code> [in, optional]</h3>

<p>Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>

<h2>Return value</h2>

<p><strong>ZwWriteFile</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success or the appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code on failure.</p>

<h2>Remarks</h2>

<p>Callers of <strong>ZwWriteFile</strong> must have already called <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> with the FILE_WRITE_DATA, FILE_APPEND_DATA, or GENERIC_WRITE flag set in the *DesiredAccess* parameter. Note that having only FILE_APPEND_DATA access to a file does not allow the caller to write anywhere in the file except at the current end-of-file mark, while having FILE_WRITE_DATA access to a file does not preclude the caller from writing to or beyond the end of a file.</p>

<p>If the preceding call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> set the <em>CreateOptions</em> flag <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a>, the <em>Length</em> and <em>ByteOffset</em> parameters to <strong>ZwWriteFile</strong> must be an integral of the sector size. For more information, see <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong>.</p>

<p><strong>ZwWriteFile</strong> begins the write operation to the file at <em>ByteOffset</em>, at the current file position, or at the end-of-file mark. It terminates the write operation when it has written <em>Length</em> bytes from <em>Buffer</em>. If necessary, it extends the length of the file and resets the end-of-file mark.</p>

<p>If the caller opened the file with the <em>DesiredAccess</em> SYNCHRONIZE flag set, the caller can wait for this routine to set the given <em>FileHandle</em> to the signaled state.</p>

<p>Drivers should call <strong>ZwWriteFile</strong> in the context of the system process in three cases:</p>

<ol>
<li><p>The driver creates the file handle that it passes to <strong>ZwWriteFile</strong>.</p></li>
<li><p><strong>ZwWriteFile</strong> notifies the driver of I/O completion by means of an event created by the driver.</p></li>
<li><p><strong>ZwWriteFile</strong> notifies the driver of I/O completion by means of an APC callback routine that the driver passes to <strong>ZwWriteFile</strong>.</p></li>
</ol>

<p>File and event handles are only valid in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to <strong>ZwWriteFile</strong> in the context of the system process instead of the process context that the driver is in.</p>

<p>Likewise, <strong>ZwWriteFile</strong> should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread issuing the I/O request. If the driver calls <strong>ZwWriteFile</strong> in the context of a process other than the system process, the APC could be delayed indefinitely, or it might not fire at all as the originating thread may never enter an alertable wait state.</p>

<p>For more information about working with files, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>

<p>Callers of <strong>ZwWriteFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>

<p>If the call to this function occurs in user mode, you should use the name "NtWriteFile" instead of "<strong>ZwWriteFile</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2>See also</h2>

<p><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></p>

<p><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></p>

<p><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></p>

<p><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></p>

<p><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwwritefile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-zwwritefile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntwritefile">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwwritefile">here</a>.</p>

<hr />

<p><em>(Also described in Win 2000 DDK)</em></p>

<h3>FileHandle</h3>

<p><code>HANDLE</code> to File Object opened with <code>FILE_WRITE_DATA</code> access.</p>

<h3>Event</h3>

<p><code>HANDLE</code> to Event Object signaled when write finished.</p>

<h3>ApcRoutine</h3>

<p>User APC routine executed after writing is complete.</p>

<h3>ApcContext</h3>

<p>Parameter to <code>ApcRoutine</code>.</p>

<h3>IoStatusBlock</h3>

<p>IO result of call.</p>

<h3>Buffer</h3>

<p>Buffer with data to write.</p>

<h3>Length</h3>

<p>Length of <code>Buffer</code>, in bytes.</p>

<h3>ByteOffset</h3>

<p>Offset from beginning of file, where write starts.</p>

<h3>Key</h3>

<p>??? (See <code><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></code>).</p>

<h1>Related Win32 API</h1>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a> (Although it does more than just forwarding the arguments and invoking this procedure.)</li>
</ul>

<h1>Documented by</h1>

<ul>
<li>Tomasz Nowak</li>
</ul>

<h1>See also</h1>

<ul>
<li><code><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></code></li>
<li><code><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></code></li>
<li><code><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtReadFile</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntwritefile.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
