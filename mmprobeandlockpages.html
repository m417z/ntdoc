<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="MmProbeAndLockPages - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>MmProbeAndLockPages - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            MmProbeAndLockPages - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">VOID MmProbeAndLockPages(
  [in, out] <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a>            MemoryDescriptorList,
  [in]      KPROCESSOR_MODE AccessMode,
  [in]      <a href="lock_operation" title="typedef enum _LOCK_OPERATION {&#10;  IoReadAccess,&#10;  IoWriteAccess,&#10;  IoModifyAccess&#10;} LOCK_OPERATION;">LOCK_OPERATION</a>  Operation
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmprobeandlockpages">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/mmprobeandlockpages.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-mmprobeandlockpages)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>MmProbeAndLockPages function</h1>

<h2>Description</h2>

<p>The <strong>MmProbeAndLockPages</strong> routine probes the specified virtual memory pages, makes them resident, and locks them in memory (say for a DMA transfer). This ensures the pages cannot be freed and reallocated while a device driver (or hardware) is still using them.</p>

<h2>Parameters</h2>

<h3><code>MemoryDescriptorList</code> [in, out]</h3>

<p>A pointer to an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that specifies a virtual memory buffer. If the routine successfully locks the pages in memory, the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is updated to describe the underlying physical pages.</p>

<h3><code>AccessMode</code> [in]</h3>

<p>The access mode in which to probe the arguments, either <strong>KernelMode</strong> or <strong>UserMode</strong>.</p>

<h3><code>Operation</code> [in]</h3>

<p>The type of operation for which the caller wants the access rights probed and the pages locked. Set this parameter to <strong>IoReadAccess</strong>, <strong>IoWriteAccess</strong>, or <strong>IoModifyAccess</strong>. <strong>IoReadAccess</strong> indicates that the driver can examine the contents of the buffer but cannot change the contents. <strong>IoWriteAccess</strong> and <strong>IoModifyAccess</strong>, which are equivalent, indicate that the driver has both read and write access to the buffer.</p>

<h2>Remarks</h2>

<p>The highest-level driver in a chain of layered drivers that use direct I/O calls this routine. Drivers that use buffered I/O never call <strong>MmProbeAndLockPages</strong>.</p>

<p><strong>MmProbeAndLockPages</strong> performs the following operations:</p>

<ol>
<li>If the specified memory range is paged to a backing store (disk, network, and so on), <strong>MmProbeAndLockPages</strong> makes it resident.</li>
<li>The routine then confirms that the pages permit the operation specified by the <em>Operation</em> parameter.</li>
<li>If the memory range permits the specified operation, the routine locks the pages in memory so that they cannot be paged out. Use the <a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a> routine to unlock the pages.</li>
<li>Finally, the routine updates the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">page frame number</a> (PFN) array in the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to describe the locked physical pages.</li>
</ol>

<p>A successful call to <strong>MmProbeAndLockPages</strong> locks the pages in an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> and sets the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> structure to the locked state. Every such call must be matched by a corresponding call to <strong><a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a></strong> that unlocks the pages and sets the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to the unlocked state. After an <strong>MmProbeAndLockPages</strong> call sets an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to the locked state, a second call to MmProbeAndLockPages to lock the same <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is not allowed until <strong><a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a></strong> is first called to unlock the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<p>If two or more MDLs describe the same physical page, the page can be locked multiple timesâ€”once for each <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>. The page is unlocked when the last <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is set to the unlocked state.</p>

<p>A routine such as <a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a> or <a href="iobuildpartialmdl" title="VOID IoBuildPartialMdl(&#10;  [in]      PMDL  SourceMdl,&#10;  [in, out] PMDL  TargetMdl,&#10;  [in]      PVOID VirtualAddress,&#10;  [in]      ULONG Length&#10;);">IoBuildPartialMdl</a> updates an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to describe pages that are either nonpageable or already locked. A call to <strong>MmProbeAndLockPages</strong> or <strong><a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a></strong> to lock or unlock such an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is not allowed.</p>

<p>Calls to <strong>MmProbeAndLockPages</strong> must be enclosed in a <strong>try/except</strong> block. If the pages do not support the specified operation, the routine raises the STATUS_ACCESS_VIOLATION or other exceptions. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/handling-exceptions">Handling Exceptions</a>.</p>

<p>Callers of <strong>MmProbeAndLockPages</strong> must be running at IRQL &lt;= APC_LEVEL for pageable addresses, or at IRQL &lt;= DISPATCH_LEVEL for nonpageable addresses.</p>

<p>This routine does not provide any guarantees about the virtual address that describes these pages (that is, the virtual address might be unmapped, reused, and so on). However, the physical pages are guaranteed to be locked on successful return.</p>

<p>To avoid page faults, use <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtuallock"><strong>VirtualLock</strong></a> to lock the virtual address so it will not be trimmed unless the app unlocks it or explicitly frees it by calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualfree"><strong>VirtualFree</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-unmapviewoffile"><strong>UnmapViewOfFile</strong></a>.</p>

<h2>See also</h2>

<p><a href="iobuildpartialmdl" title="VOID IoBuildPartialMdl(&#10;  [in]      PMDL  SourceMdl,&#10;  [in, out] PMDL  TargetMdl,&#10;  [in]      PVOID VirtualAddress,&#10;  [in]      ULONG Length&#10;);">IoBuildPartialMdl</a></p>

<p><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></p>

<p><a href="mmunlockpages" title="VOID MmUnlockPages(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmUnlockPages</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmprobeandlockpages">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-mmprobeandlockpages.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
