<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IOCTL_TCP_QUERY_INFORMATION_EX - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IOCTL_TCP_QUERY_INFORMATION_EX - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IOCTL_TCP_QUERY_INFORMATION_EX - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// tcpioctl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0012, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_TCP_QUERY_INFORMATION_EX 0x00120003</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/tcpioctl/ni-tcpioctl-ioctl_tcp_query_information_ex">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ioctl_tcp_query_information_ex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (ni-tcpioctl-ioctl_tcp_query_information_ex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>IOCTL_TCP_QUERY_INFORMATION_EX IOCTL</h1>
<h2>Description</h2>
<p>[This control code may be altered or unavailable in future versions of Windows.
Use Internet Protocol Helper API instead of this
control code.]</p>
<p>Retrieves information from the TCP/IP driver.</p>
<p>To perform the <strong>IOCTL_TCP_QUERY_INFORMATION_EX</strong> operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>
function with the following parameters.</p>
<pre><code class="language-cpp">BOOL DeviceIoControl(
  (HANDLE) hDevice,                  // Open handle to the TCP driver
  IOCTL_TCP_QUERY_INFORMATION_EX,    // dwIoControlCode
  NULL,                              // lpInBuffer (the output buffer is used for input too)
  0,                                 // nInBufferSize
  (LPVOID) lpOutBuffer,              // Pointer to the output buffer
  (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>) nOutBufferSize,            // Size of the output buffer
  (LPDWORD) lpBytesReturned,         // Number of bytes returned (if called synchronously)
  (LPOVERLAPPED) lpOverlapped        // OVERLAPPED structure (if called asynchronously)
);
</code></pre>
<h2>Parameters</h2>
<h3>Input buffer</h3>
<h3>Input buffer length</h3>
<h3>Output buffer</h3>
<h3>Output buffer length</h3>
<h3>Input/output buffer</h3>
<h3>Input/output buffer length</h3>
<h3>Status block</h3>
<p>Irp-&gt;IoStatus.Status is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the request is successful.</p>
<p>Otherwise, Status to the appropriate error condition as a <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code.</p>
<p>For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/ntstatus-values">NTSTATUS Values</a>.</p>
<h2>Remarks</h2>
<p>To use <strong>IOCTL_TCP_QUERY_INFORMATION_EX</strong>, you should be familiar with Windows Driver Development, as documented in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/download-the-wdk">Windows Driver Kit (WDK)</a>, and specifically with Transport Driver Interface (TDI) drivers.</p>
<p><strong>Note</strong> To use this control code, include the Windows.h header file. In addition, specifically include Tcpioctl.h, a header file published in the Windows SDK for use with <strong>IOCTL_TCP_QUERY_INFORMATION_EX</strong>, and also Tdiinfo.h and Tdistat.h, header files published in the WDK for TDI driver development.</p>
<p><strong>Note</strong> Various flags and other constants defined in the Tdiinfo.h WDK header file for the <strong>IOCTL_TCP_QUERY_INFORMATION_EX</strong> operation use the following naming convention.</p>
<table>
<thead>
<tr>
<th>Letters</th>
<th>Stand for</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>&quot;AT&quot;</td>
<td>Address Translation</td>
<td>Address resolution such as that provided by ARP (Address Resolution Protocol).</td>
</tr>
<tr>
<td>&quot;NL&quot;</td>
<td>Network Layer</td>
<td>As in the Open Systems Interconnection (OSI) reference model.</td>
</tr>
<tr>
<td>&quot;TL&quot;</td>
<td>Transport Layer</td>
<td>As in the OSI reference model.</td>
</tr>
<tr>
<td>&quot;CL&quot;</td>
<td>Connection-Less</td>
<td>A connectionless protocol based on broadcast packets.</td>
</tr>
<tr>
<td>&quot;CO&quot;</td>
<td>Connected</td>
<td>A connected protocol based on directed packets.</td>
</tr>
<tr>
<td>&quot;ER&quot;</td>
<td>Echo Request/Reply</td>
<td>Packet types used by Ping to test TCP/IP connectivity.</td>
</tr>
<tr>
<td>&quot;IF&quot;</td>
<td>Interface</td>
<td>An interface in the sense used in SNMP.</td>
</tr>
</tbody>
</table>
<p>The <strong>IOCTL_TCP_QUERY_INFORMATION_EX</strong> operation
retrieves different kinds of information, depending on what the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tdiinfo/ns-tdiinfo-tcp_request_query_information_ex_w2k">TCP_REQUEST_QUERY_INFORMATION_EX</a> structure
pointed to by the <em>lpInBuffer</em> parameter contains, as described in the following paragraph and example code.</p>
<ol>
<li>Enumerate TDI Entities.</li>
</ol>
<p>To retrieve an array of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tdiinfo/ns-tdiinfo-tdientityid">TDIEntityID</a>
structures that identifies all the TCP entities on the machine, set the <strong>ID.toi_entity.tei_entity</strong>
member of the input structure to <strong>GENERIC_ENTITY</strong>. <strong>ID.toi_class</strong> must then
be set to <strong>INFO_CLASS_GENERIC</strong>, <strong>ID.toi_type</strong> must be set to
<strong>INFO_TYPE_PROVIDER</strong>, and <strong>ID.toi_id</strong> must be set to
<strong>ENTITY_LIST_ID</strong>, or the operation fails with a TDI_INVALID_PARAMETER error code.
The <strong>Context</strong> member of the input structure is ignored when a list is requested.
The output in this case is an array of <strong>TDIEntityID</strong> structures.
The <strong>GetEntityArray</strong> function in the first code example below shows how to retrieve such an array.</p>
<ol start="2">
<li>Obtain Type Information about a Specific TDI Entity.</li>
</ol>
<p>If the <strong>ID.toi_entity</strong> member of the input
structure identifies a specific entity (as in the case of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tdiinfo/ns-tdiinfo-tdientityid">TDIEntityID</a>
structures returned by the enumeration request above), then setting the <strong>ID.toi_class</strong> to
<strong>INFO_CLASS_GENERIC</strong>, the <strong>ID.toi_type</strong> to
<strong>INFO_TYPE_PROVIDER</strong>, and the <strong>ID.toi_id</strong> to
<strong>ENTITY_TYPE_ID</strong> causes one or more flag values to be returned into an <strong>unsigned long</strong> pointed to by the <em>lpOutBuffer</em> parameter. These flag values identify the type of the specified entity. Once again, the
<strong>Context</strong> member of the input structure is ignored.</p>
<p>The possible type-flag values that can be returned are shown in the following table.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Significance</th>
</tr>
</thead>
<tbody>
<tr>
<td>AT_ARP</td>
<td>Entity implements ARP (Address Resolution Protocol).</td>
</tr>
<tr>
<td>AT_NULL</td>
<td>Entity does no address translation.</td>
</tr>
<tr>
<td>CL_NL_IP</td>
<td>Entity implements IP (Internet Protocol), connectionless on the network layer.</td>
</tr>
<tr>
<td>CL_NL_IPX</td>
<td>Entity implements IPX (Internetwork Packet Exchange protocol), connectionless on the network layer.</td>
</tr>
<tr>
<td>CL_TL_NBF</td>
<td>Entity implements NBF (NetBEUI Frame protocol), connectionless on the transport layer.</td>
</tr>
<tr>
<td>CL_TL_UDP</td>
<td>Entity implements UDP (User Datagram Protocol) connectionless on the transport layer.</td>
</tr>
<tr>
<td>CO_TL_NBF</td>
<td>Entity implements NBF (NetBEUI Frame protocol), directed packets on the transport layer.</td>
</tr>
<tr>
<td>CO_TL_SPP</td>
<td>Entity implements SPP (Sequenced Packet Protocol), directed packets on the transport layer.</td>
</tr>
<tr>
<td>CO_TL_SPX</td>
<td>Entity implements SPX (Sequenced Packet Exchange protocol), directed packets on the transport layer.</td>
</tr>
<tr>
<td>CO_TL_TCP</td>
<td>Entity implements TCP (Transmission Control Protocol), directed packets on the transport layer.</td>
</tr>
<tr>
<td>ER_ICMP</td>
<td>Entity implements ICMP (Internet Control Message Protocol) for Echo Request/Reply.</td>
</tr>
<tr>
<td>IF_GENERIC</td>
<td>Entity implements a generic interface.</td>
</tr>
<tr>
<td>IF_MIB</td>
<td>Entity implements an interface with SNMP MIB-II support.</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>Obtain MIB-II Information about an Interface Entity.</li>
</ol>
<p>If the entity type is IF_MIB, then a MIB request can be sent to it that results in the return of an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ifentry">IFEntry</a> structure. Set the <strong>ID.toi_entity</strong> member of the input
structure to identify the entity, the <strong>ID.toi_class</strong> to
<strong>INFO_CLASS_PROTOCOL</strong>, the <strong>ID.toi_type</strong> to
<strong>INFO_TYPE_PROVIDER</strong>, and the <strong>ID.toi_id</strong> to
<strong>IF_MIB_STATS_ID</strong>.</p>
<p>Note that because <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ifentry">IFEntry</a> is a variable-length structure, the output buffer should be allocated not just as &quot;sizeof(IFEntry)&quot; but as &quot;sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1&quot;.</p>
<ol start="4">
<li>Obtain MIB-II Information about a Particular IP Entity.</li>
</ol>
<p>MIB information can also be retrieved from an IP entity (one whose type is <strong>CL_NL_ENTITY</strong>) by setting the <strong>ID.toi_entity</strong> member to identify the entity, the <strong>ID.toi_class</strong> to
<strong>INFO_CLASS_PROTOCOL</strong>, the <strong>ID.toi_type</strong> to
<strong>INFO_TYPE_PROVIDER</strong>, and the <strong>ID.toi_id</strong> to
<strong>IP_MIB_STATS_ID</strong>. In this case, an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ipsnmpinfo">IPSNMPInfo</a> structure is returned, and the output buffer can be allocated to &quot;sizeof(IPSNMPInfo)&quot;.</p>
<ol start="5">
<li>Obtain Address Information about a Particular IP Entity.</li>
</ol>
<p>If the <strong>ipsi_numaddr</strong> member of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ipsnmpinfo">IPSNMPInfo</a> structure returned for a particular IP entity is nonzero, an array of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ipaddrentry">IPAddrEntry</a> structures can be retrieved by setting the <strong>ID.toi_entity</strong> member to identify the entity, the <strong>ID.toi_class</strong> to
<strong>INFO_CLASS_PROTOCOL</strong>, the <strong>ID.toi_type</strong> to
<strong>INFO_TYPE_PROVIDER</strong>, and the <strong>ID.toi_id</strong> to
<strong>IP_MIB_ADDRTABLE_ENTRY_ID</strong>. In this case, the output buffer should be allocated to hold an array of size:</p>
<p><code>sizeof(IPAddrEntry) * pIpSnmpInfoReturned-&gt;ipsi_numaddr</code></p>
<ol start="6">
<li>Obtain Interface Information about a Particular IP Address.</li>
</ol>
<p>More interface information can be retrieved for a given IP address returned in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ipaddrentry">IPAddrEntry</a> array above by leaving the <strong>ID.toi_entity</strong> member set to identify the IP entity, the <strong>ID.toi_class</strong> set to
<strong>INFO_CLASS_PROTOCOL</strong>, and the <strong>ID.toi_type</strong> set to
<strong>INFO_TYPE_PROVIDER</strong>, and then by setting the <strong>ID.toi_id</strong> to
<strong>IP_INTFC_INFO_ID</strong> and the <strong>Context</strong> member of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tdiinfo/ns-tdiinfo-tcp_request_query_information_ex_w2k">TCP_REQUEST_QUERY_INFORMATION_EX</a> structure to the IPv4 or IPv6 address in question.</p>
<p>Allocate an output buffer large enough to contain <code>sizeof(IPINTERFACEINFO) + MAX_PHYSADDR_SIZE</code>.</p>
<p>On return, the output buffer contains a filled-in <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/tcpioctl/ns-tcpioctl-ipinterfaceinfo">IPInterfaceInfo</a> structure.</p>
<h4>Examples</h4>
<p>The following example shows how to obtain a list of the entities present
on the TCP adapter on the current machine.</p>
<pre><code class="language-cpp">#define  UNICODE
#define  _WIN32_WINNT  0x0500

#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;iptypes.h&gt;
#include &quot;winternl.h&quot;
#include &quot;tdiinfo.h&quot;
#include &quot;tdistat.h&quot;
#include &quot;tcpioctl.h&quot;

/*  Function:              GetTCPHandle
    Description:
      Opens a handle to the TCP driver
    Parameters:
      pTCPDriverHandle --  Pointer to a handle variable.
    Return Value (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>):  Returns TRUE if successful, and places
                           a valid handle to the TCP driver in the
                           handle pointed to by pTCPDriverHandle, or
                           returns FALSE otherwise, and sets the
                           handle to INVALID_HANDLE_VALUE.
*/
<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> GetTCPHandle( PHANDLE pTCPDriverHandle )
{
#define <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>                    0x00000003
#define <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>    0x00000020
#define <a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a>            0x00000040L

typedef <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> (NTAPI *P_NT_CREATE_FILE)(
    OUT PHANDLE              FileHandle,
    IN  ACCESS_MASK          DesiredAccess,
    IN  <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a>   ObjectAttributes,
    OUT <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>     IoStatusBlock,
    IN  PLARGE_INTEGER       AllocationSize OPTIONAL,
    IN  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                FileAttributes,
    IN  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                ShareAccess,
    IN  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                CreateDisposition,
    IN  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                CreateOptions,
    IN  PVOID                EaBuffer OPTIONAL,
    IN  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                EaLength );

  HINSTANCE hNtDLL;
  P_NT_CREATE_FILE pNtCreateFile;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> rVal;
  WCHAR TCPDriverName[] = <a href="dd_tcp_device_name" title="#define DD_TCP_DEVICE_NAME L&quot;\\Device\\Tcp&quot;">DD_TCP_DEVICE_NAME</a>;

  <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a>  objectAttributes;
  <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a>    ioStatusBlock;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>     UnicodeStr;

  *pTCPDriverHandle = INVALID_HANDLE_VALUE;

  if( ( hNtDLL = LoadLibrary( L&quot;ntdll&quot; ) ) == NULL )
    return( FALSE );

  pNtCreateFile = (P_NT_CREATE_FILE) GetProcAddress( hNtDLL,
            &quot;<a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a>&quot; );
  if( pNtCreateFile == NULL )
    return( FALSE );

  UnicodeStr.Buffer = TCPDriverName;
  UnicodeStr.Length = (<a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>)(wcslen(TCPDriverName) * sizeof(WCHAR));
  UnicodeStr.MaximumLength = UnicodeStr.Length + sizeof(UNICODE_NULL);

  objectAttributes.Length = sizeof( <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> );
  objectAttributes.ObjectName = &amp;UnicodeStr;
  objectAttributes.Attributes = <a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a>;
  objectAttributes.RootDirectory = NULL;
  objectAttributes.SecurityDescriptor = NULL;
  objectAttributes.SecurityQualityOfService = NULL;

  rVal = pNtCreateFile( pTCPDriverHandle,
                       SYNCHRONIZE | GENERIC_EXECUTE,
                       &amp;objectAttributes,
                       &amp;ioStatusBlock,
                       NULL,
                       FILE_ATTRIBUTE_NORMAL,
                       <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a>,
                       <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>,
                       <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>,
                       NULL,
                       0 );

  if( rVal &lt; 0 )
  {
    printf( &quot;\nFailed to create TCP Driver handle; NT status code = %d.&quot;, rVal );
    *pTCPDriverHandle = INVALID_HANDLE_VALUE;
    return( FALSE );
  }
  return( TRUE );
}

/*  Function:              GetEntityList
    Description:
      Allocates a buffer for and retrieves an array of TDIEntityID
    structures that identifies the entities supported by
    the TCP/IP device driver.
    Parameters:
      TCPDriverHandle  --  An open handle to the TCP Driver; if
            no such handle is available,
            may be INVALID_HANDLE_VALUE.
      lplpEntities     --  Pointer to a buffer that contains
            the array of TDIEntityID structures.
            Must be freed by the calling process
            using LocalFree( ).
    Return Value:
      <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>  --  the number of entity structures in the returned array
*/
<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> GetEntityArray( IN HANDLE TCPDriverHandle,
    OUT TDIEntityID **lplpEntities )
{
  TCP_REQUEST_QUERY_INFORMATION_EX  req;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> arrayLen = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> bufferLen = arrayLen;
  TDIEntityID * pEntity = NULL;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> status = TDI_SUCCESS;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> temporaryHandle = 0;
  int i;

// First, if the handle passed in is not valid, try to obtain one.
  if( TCPDriverHandle == INVALID_HANDLE_VALUE )
  {
    if( GetTCPHandle( &amp;TCPDriverHandle ) == FALSE )
    {
      *lplpEntities = NULL;
      return( 0 );
    }
    temporaryHandle = TRUE;
  }

// Next, set up the input structure for the IOCTL operation.
  req.ID.toi_entity.tei_entity    = GENERIC_ENTITY;
  req.ID.toi_entity.tei_instance  = 0;
  req.ID.toi_class                = INFO_CLASS_GENERIC;
  req.ID.toi_type                 = INFO_TYPE_PROVIDER;
  req.ID.toi_id                   = ENTITY_LIST_ID;

// The loop below is defensively engineered:
// (1)  In the first place, it is unlikely that more
//     than MAX_TDI_ENTITIES of TCP/IP entities exist,
//     so the loop should execute only once.
// (2)  Execution is limited to 4 iterations to rule out
//     infinite looping in case of parameter corruption. Only 2
//     iterations should ever be necessary unless entities are
//     being added while the loop is running.
  for( i = 0; i &lt; 4; ++i )
  {
    if( pEntity != NULL )
    {
      LocalFree( pEntity );
      pEntity = NULL;
      bufferLen = arrayLen;
    }

    if( arrayLen == 0 )
      break;

    pEntity = (TDIEntityID *) LocalAlloc( LMEM_FIXED, bufferLen );
    if( pEntity == NULL )
    {
      arrayLen = 0;
      break;
    }

    if( !DeviceIoControl( TCPDriverHandle, // Handle to TCP driver
                          IOCTL_TCP_QUERY_INFORMATION_EX, // Cmd code
                          &amp;req,            // Pointer to input buffer
                          sizeof(req),     // Size of ipt buffer
                          pEntity,         // Ptr to output buffer
                          bufferLen,       // Size of output buffer
                          &amp;arrayLen,       // Actual size of array
                          NULL ) )
      status = GetLastError( );

    // Even if the output buffer is too small, the TCP driver
    // returns a status of TDI_SUCCESS; it is the value returned in
    // arrayLen that indicates whether the entire array was
    // successfully copied to the output buffer.
    if( status == TDI_SUCCESS )
    {
      if( arrayLen &amp;&amp; ( arrayLen &lt;= bufferLen ) )
        break;
    }
    else
      arrayLen = 0;
  }
  if( temporaryHandle )
    CloseHandle( TCPDriverHandle );

  *lplpEntities = pEntity;
  return( (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>)( arrayLen / sizeof(TDIEntityID) ) );
}

int main( )
{
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> i;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a> entityCount;
  TDIEntityID
    *entityArray,
    *entityPtr;

  if( !( entityCount = GetEntityArray( INVALID_HANDLE_VALUE,
    &amp;entityArray ) ) )
    return( 1 );

  entityPtr = entityArray;
  printf( &quot;\n\nList of %d Transport Driver Interface Entities on this machine:\n&quot;, entityCount );

  for( i = 0; i &lt; entityCount; ++i )
  {
    printf( &quot;\n  Entity #%d:\n    Category (tei_entity) is &quot;, i );
    switch( entityPtr-&gt;tei_entity )
    {
      case GENERIC_ENTITY:
        printf( &quot;Generic.&quot; );
        break;
      case CL_NL_ENTITY:
        printf( &quot;Connectionless Network-Layer (CL_NL)&quot; );
        break;
      case CO_NL_ENTITY:
        printf( &quot;Connected Network-Layer (CO_NL)&quot; );
        break;
      case CL_TL_ENTITY:
        printf( &quot;Connectionless Transport-Layer (CL_TL)&quot; );
        break;
      case CO_TL_ENTITY:
        printf( &quot;Connected Transport-Layer (CO_TL)&quot; );
        break;
      case AT_ENTITY:
        printf( &quot;Address Translation (AT)&quot; );
        break;
      case IF_ENTITY:
        printf( &quot;Interface (IF)&quot; );
        break;
      case ER_ENTITY:
        printf( &quot;Echo Request/Response (ER)&quot; );
        break;
      default:
        printf( &quot;[Unidentified Entity Type] = 0x%x&quot;,
        entityPtr-&gt;tei_entity );
    }
    printf( &quot;\n Instance (tei_instance) = %d\n&quot;,
        entityPtr-&gt;tei_instance );

    ++entityPtr;
  }

//  Free the entity-array buffer before quitting.
    LocalFree( entityArray );

  return( 0 );
}

</code></pre>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/IpHlp/ip-helper-start-page">Internet Protocol Helper API</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/desktop/mib/management-information-base-reference">Management Information Base Reference</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/tcpioctl/ni-tcpioctl-ioctl_tcp_query_information_ex">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/tcpioctl/ni-tcpioctl-ioctl_tcp_query_information_ex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
