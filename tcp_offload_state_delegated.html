<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="TCP_OFFLOAD_STATE_DELEGATED - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>TCP_OFFLOAD_STATE_DELEGATED - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            TCP_OFFLOAD_STATE_DELEGATED - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ndischimney.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _TCP_OFFLOAD_STATE_DELEGATED {
  <a href="offload_state_header" title="typedef struct _OFFLOAD_STATE_HEADER {&#10;  ULONG Length;&#10;  ULONG RecognizedOptions;&#10;} OFFLOAD_STATE_HEADER, *POFFLOAD_STATE_HEADER;">OFFLOAD_STATE_HEADER</a>         Header;
  TCP_OFFLOAD_CONNECTION_STATE State;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                       Flags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        RcvNxt;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        RcvWnd;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SndUna;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SndNxt;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SndMax;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SndWnd;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        MaxSndWnd;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SendWL1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        CWnd;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SsThresh;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                       SRtt;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                       RttVar;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        TsRecent;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        TsRecentAge;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        TsTime;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        TotalRT;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                        DupAckCount;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                        SndWndProbeCount;
  struct {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> ProbeCount;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeoutDelta;
  } KeepAlive;
  struct {
    <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a> Count;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TimeoutDelta;
  } Retransmit;
  union {
    struct {
      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">PNET_BUFFER_LIST</a> SendDataHead;
      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">PNET_BUFFER_LIST</a> SendDataTail;
    };
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SendBacklogSize;
  };
  union {
    <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">PNET_BUFFER_LIST</a> BufferedData;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            ReceiveBacklogSize;
  };
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        DWnd;
} TCP_OFFLOAD_STATE_DELEGATED, *PTCP_OFFLOAD_STATE_DELEGATED;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/ns-ndischimney-_tcp_offload_state_delegated">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/tcp_offload_state_delegated.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-ndischimney-_tcp_offload_state_delegated)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_tcp_offload_state_delegated-structure">_TCP_OFFLOAD_STATE_DELEGATED structure</h1>

<h2 id="description">Description</h2>

<p>[The TCP chimney offload feature is deprecated and should not be used.]</p>

<p>The TCP_OFFLOAD_STATE_DELEGATED structure contains the delegated variables of a TCP connection state
object.</p>

<h2 id="members">Members</h2>

<h3 id="header"><code>Header</code></h3>

<p>An
<a rel="noopener" target="_blank" href="offload_state_header">OFFLOAD_STATE_HEADER</a> structure. NDIS
sets the
<strong>Length</strong> member of
<strong>Header</strong> to the size, in bytes, of the TCP_OFFLOAD_STATE_DELEGATED structure. The
<strong>RecognizedOptions</strong> member of
<strong>Header</strong> is reserved.</p>

<h3 id="state"><code>State</code></h3>

<p>The current state of the TCP connection (see RFC 793) as one of the following
TCP_OFFLOAD_CONNECTION_STATE values:</p>

<h4 id="tcpconnectionclosed">TcpConnectionClosed</h4>

<p>No connection state.</p>

<h4 id="tcpconnectionlisten">TcpConnectionListen</h4>

<p>Waiting for a connection request from any remote TCP and port.</p>

<h4 id="tcpconnectionsynsent">TcpConnectionSynSent</h4>

<p>Waiting for a matching connection request after having sent a connection request.</p>

<h4 id="tcpconnectionsynrcvd">TcpConnectionSynRcvd</h4>

<p>Waiting for a confirming connection request acknowledgment after having both received and sent a
connection request.</p>

<h4 id="tcpconnectionestablished">TcpConnectionEstablished</h4>

<p>An open connection: data received can be delivered to the user. The normal state for the data
transfer phase of the connection.</p>

<h4 id="tcpconnectionfinwait1">TcpConnectionFinWait1</h4>

<p>Waiting for a connection termination request from the remote TCP, or an acknowledgment of the
connection termination request that was previously sent.</p>

<h4 id="tcpconnectionfinwait2">TcpConnectionFinWait2</h4>

<p>Waiting for a connection termination request from the remote TCP.</p>

<h4 id="tcpconnectionclosewait">TcpConnectionCloseWait</h4>

<p>Waiting for a connection termination request from the local user.</p>

<h4 id="tcpconnectionclosing">TcpConnectionClosing</h4>

<p>Waiting for a connection termination request acknowledgment from the remote TCP.</p>

<h4 id="tcpconnectionlastack">TcpConnectionLastAck</h4>

<p>Waiting for an acknowledgment of the connection termination request previously sent to the
remote TCP, which includes an acknowledgment of its connection termination request.</p>

<h4 id="tcpconnectiontimewait">TcpConnectionTimeWait</h4>

<p>Waiting for enough time to pass to ensure that the remote TCP received the acknowledgment of its
connection termination request.</p>

<p>Note that the host stack can offload a TCP connection when the connection is in any state
except
<strong>TcpConnectionClosed</strong>,
<strong>TcpConnectionListen</strong>,
<strong>TcpConnectionSynRcvd</strong>,</p>

<p><strong>TcpConnectionSynSent</strong>, or
<strong>TcpConnectionTimeWait</strong> state. The host stack can query, update, invalidate, or terminate a TCP
connection regardless of the connection state.</p>

<h3 id="flags"><code>Flags</code></h3>

<p>Reserved for system use.</p>

<h3 id="rcvnxt"><code>RcvNxt</code></h3>

<p>The sequence number for the next receive segment (see RCV.NEXT in RFC 793).</p>

<h3 id="rcvwnd"><code>RcvWnd</code></h3>

<p>The receive window size, in bytes (see RCV.WND in RFC 793).</p>

<h3 id="snduna"><code>SndUna</code></h3>

<p>The sequence number for the first byte of unacknowledged data (see SND.UNA in RFC 793). For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/send-data-that-contains-data-to-be-retransmitted">Send Data That Contains Data to Be Retransmitted</a>.</p>

<h3 id="sndnxt"><code>SndNxt</code></h3>

<p>The sequence number for the next byte to send on the connection (see SND.NXT in RFC 793). For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/send-data-that-contains-data-to-be-retransmitted">Send Data That Contains Data to Be Retransmitted</a>.</p>

<h3 id="sndmax"><code>SndMax</code></h3>

<p>The maximum sequence number that has been sent on the connection. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/send-data-that-contains-data-to-be-retransmitted">Send Data That Contains Data to Be Retransmitted</a>.</p>

<h3 id="sndwnd"><code>SndWnd</code></h3>

<p>The send window size, in bytes (see SND.WND in RFC 793).</p>

<h3 id="maxsndwnd"><code>MaxSndWnd</code></h3>

<p>The maximum send window size, in bytes (see RFC 813).</p>

<h3 id="sendwl1"><code>SendWL1</code></h3>

<p>The segment sequence number used for the last window update (see SND.WL1 in RFC 793).</p>

<h3 id="cwnd"><code>CWnd</code></h3>

<p>The congestion window size, in bytes (see cwnd in RFC 2581).</p>

<h3 id="ssthresh"><code>SsThresh</code></h3>

<p>The slow start threshold, in bytes (see ssthresh in RFC 2581).</p>

<h3 id="srtt"><code>SRtt</code></h3>

<p>The smoothed round-trip time, in clock ticks (see SRTT in RFCs 793 and 2988). Maintained on a per
connection basis because it takes into account path, host, and sometimes application behavior.</p>

<h3 id="rttvar"><code>RttVar</code></h3>

<p>The round trip time variation, in clock ticks (see RTTVAR in RFC 2988).</p>

<h3 id="tsrecent"><code>TsRecent</code></h3>

<p>The timestamp value to send in the next ACK (see TS.Recent in RFC 1323)</p>

<h3 id="tsrecentage"><code>TsRecentAge</code></h3>

<p>The length of time, in clock ticks, since the most recent timestamp was received (see RFC
1323).</p>

<h3 id="tstime"><code>TsTime</code></h3>

<p>The current value of the adjusted timestamp.</p>

<h3 id="totalrt"><code>TotalRT</code></h3>

<p>The total time, in clock ticks, that has been spent retransmitting the current TCP segment.</p>

<h3 id="dupackcount"><code>DupAckCount</code></h3>

<p>The number of ACKs that have been accepted for the same sequence number (see RFC 1323).</p>

<h3 id="sndwndprobecount"><code>SndWndProbeCount</code></h3>

<p>The current send window probe round. For a description of the send window probe round, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/persist-timer">Persist Timer</a>.</p>

<h3 id="keepalive"><code>KeepAlive</code></h3>

<p>This member is a union that consists of the following members:</p>

<h3 id="keepaliveprobecount"><code>KeepAlive.ProbeCount</code></h3>

<p>The number of keepalive probes that have been sent that have not received a response (see RFC
1122).</p>

<h3 id="keepalivetimeoutdelta"><code>KeepAlive.TimeoutDelta</code></h3>

<p>The time remaining, in clock ticks, until the next keepalive timeout (see RFC 1122). Note that a
value of -1 immediately after the TCP connection was offloaded indicates that the keepalive timer was
not running when the connection was offloaded. If the offload target's keepalive timer is not running,
the offload target should return -1 in this member when responding to a call to the
MiniportQueryOffload function or the MiniportTerminateOffload function.</p>

<h3 id="retransmit"><code>Retransmit</code></h3>

<p>This member is a union that consists of the following members:</p>

<h3 id="retransmitcount"><code>Retransmit.Count</code></h3>

<p>The number of retransmits that have been sent (see RFC 2581).</p>

<h3 id="retransmittimeoutdelta"><code>Retransmit.TimeoutDelta</code></h3>

<p>The time, in clock ticks, remaining until the next retransmit timeout (see RFC 2581). Note that a
value of -1 immediately after the TCP connection was offloaded indicates that the retransmit timer was
not running when the connection was offloaded. The retransmit timer was not running because there was
no outstanding send data on the connection when the connection was offloaded. If the offload target's
retransmit timer is not running, the offload target should return -1 in this member when responding to
a call to the MiniportQueryOffload function or the MiniportTerminateOffload function.</p>

<h3 id="senddatahead"><code>SendDataHead</code></h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="net_buffer_list">NET_BUFFER_LIST</a> structure. This
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure is in the linked list that is pointed to by the
<strong>NetBufferListChain</strong> member of the
<a rel="noopener" target="_blank" href="ndis_miniport_offload_block_list">NDIS_MINIPORT_OFFLOAD_BLOCK_LIST</a> structure that immediately precedes the
TCP_OFFLOAD_STATE_DELEGATED structure. If the
<strong>NetBufferListChain</strong> pointer is <strong>NULL</strong>,
<strong>SendDataHead</strong> is not significant.</p>

<p>The
<strong>SendDataHead</strong> pointer points to the first <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure whose <a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a> structure
has buffered the send data associated with it.</p>

<p>This variable is used only in an initiate offload or terminate offload operation. For more
information about how this variable is used, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/handling-outstanding-send-data-during-and-after-an-offload-operation">Handling Outstanding Send Data During and After an Offload Operation</a> and
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/handling-outstanding-send-data-during-a-terminate-offload-operation">Handling Outstanding Send Data During a Terminate Offload Operation</a>.</p>

<h3 id="senddatatail"><code>SendDataTail</code></h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="net_buffer_list">NET_BUFFER_LIST</a> structure. This
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure is in the linked list that is pointed to by the NetBufferListChain member of
the <a href="ndis_miniport_offload_block_list" title="typedef struct _NDIS_MINIPORT_OFFLOAD_BLOCK_LIST {&#10;  IN NDIS_OBJECT_HEADER                Header;&#10;  IN _NDIS_MINIPORT_OFFLOAD_BLOCK_LIST *NextBlock;&#10;#if ...&#10;  struct                               _NDIS_MINIPORT_OFFLOAD_BLOCK_LIST;&#10;  IN _NDIS_MINIPORT_OFFLOAD_BLOCK_LIST *DependentBlockList;&#10;#else&#10;  struct                               _NDIS_MINIPORT_OFFLOAD_BLOCK_LIST;&#10;#endif&#10;  OUT NDIS_STATUS                      Status;&#10;  IN PVOID                             NdisReserved[2];&#10;  IN OUT PVOID                         *MiniportOffloadContext;&#10;  IN NDIS_HANDLE                       NdisOffloadHandle;&#10;  IN PVOID                             ProtocolReserved[2];&#10;  IN PVOID                             MiniportReserved[2];&#10;  IN PVOID                             ImReserved[2];&#10;  IN PVOID                             Scratch[2];&#10;  IN PVOID                             SourceHandle;&#10;  IN NDIS_PORT_NUMBER                  PortNumber;&#10;  IN OUT PNET_BUFFER_LIST              NetBufferListChain;&#10;...">NDIS_MINIPORT_OFFLOAD_BLOCK_LIST</a> structure that immediately precedes the
TCP_OFFLOAD_STATE_DELEGATED structure. If the NetBufferListChain pointer is <strong>NULL</strong>, SendDataTail is not
significant.</p>

<p>The SendDataTail pointer points to the last <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure whose <a href="net_buffer" title="typedef struct _NET_BUFFER {&#10;  union {&#10;    struct {&#10;      NET_BUFFER *Next;&#10;      MDL        *CurrentMdl;&#10;      ULONG      CurrentMdlOffset;&#10;      union {&#10;        ULONG  DataLength;&#10;        SIZE_T stDataLength;&#10;      };&#10;      MDL        *MdlChain;&#10;      ULONG      DataOffset;&#10;    };&#10;    SLIST_HEADER      Link;&#10;    NET_BUFFER_HEADER NetBufferHeader;&#10;  };&#10;  USHORT           ChecksumBias;&#10;  USHORT           Reserved;&#10;  NDIS_HANDLE      NdisPoolHandle;&#10;  PVOID            NdisReserved[2];&#10;...">NET_BUFFER</a> structure
has buffered the send data associated with it.</p>

<p>This variable is used only in an initiate offload or terminate offload operation. For more
information about how this variable is used, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/handling-outstanding-send-data-during-and-after-an-offload-operation">Handling Outstanding Send Data During and After an Offload
Operation</a> and
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/handling-outstanding-send-data-during-a-terminate-offload-operation">Handling Outstanding Send Data During a Terminate Offload
Operation</a></p>

<h3 id="sendbacklogsize"><code>SendBacklogSize</code></h3>

<p>The offload target specifies this value to indicate the number of data bytes that the host stack
should have outstanding at the offload target for optimum performance. (This is the number of send
bytes that have been passed to the offload target but that have not yet been completed by the offload
target.) The specific variables and algorithm that the offload target uses to calculate the send
backlog size are implementation-specific. The send backlog size can be a function of the roundtrip
time (RTT) for the connection, the interface bandwidth, and other parameters. An offload target could,
for example, use the minimum of the bandwidth/delay product and the advertised received window. Note
however, that the send backlog size does not vary according to the number of data bytes that are
currently posted for transmission on the connection.</p>

<p>The host stack can query the TCP delegated state for the connection to obtain the send backlog
size. In addition, the offload target can indicate a change in the send backlog size by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-ndis_tcp_offload_event_indicate">NdisTcpOffloadEventHandler</a> function.</p>

<p>If the offload target does not support the send-backlog-size feature, it must write a value of
0xFFFFFFFF to
<strong>SendBacklogSize</strong> when the TCP-delegated state for the connection is queried. The
<strong>SendBacklogSize</strong> variable is not used in the terminate offload operation.</p>

<h3 id="buffereddata"><code>BufferedData</code></h3>

<p>A pointer to buffered receive data. The host stack can pass such data to the offload target when
offloading a TCP connection. (For more information, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/handling-buffered-receive-data-during-and-after-an-offload-operation">Handling Buffered Receive Data During and After an Offload Operation</a>.) The
offload target can pass such data to the host stack when uploading a TCP connection. (For more
information, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/push-timer">Handling Buffered Receive Data During a Terminate Offload Operation</a>.)</p>

<h3 id="receivebacklogsize"><code>ReceiveBacklogSize</code></h3>

<p>The offload target specifies this value to indicate the number of receive data bytes that are
buffered in the offload target for the offloaded TCP connection. The host stack can query the TCP
delegated state for the connection to obtain this value. The host stack uses this value to post one or
more receive requests on the connection that are large enough to hold all of the buffered data.</p>

<p>If the offload target does not support the receive backlog size feature, it should write a value of
0xFFFFFFFF to
<strong>ReceiveBacklogSize</strong> .</p>

<h3 id="dwnd"><code>DWnd</code></h3>

<h2 id="remarks">Remarks</h2>

<p>The host stack provides initial values for the TCP delegated variables when it offloads these
variables to the offload target. After it is offloaded, the TCP delegated variables are owned and
maintained by the offload target. Only the offload target can change the value of an offloaded TCP
delegated variable. The offload target does not notify the host stack of changes to the values of
offloaded TCP delegated variables. However, the host stack can query the value of offloaded TCP delegated
variables, which causes NDIS to call the offload target's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_query_offload_handler">MiniportQueryOffload</a> function.
When the host stack terminates the offload of the TCP connection state object by causing NDIS to call the
offload target's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_terminate_offload_handler">MiniportTerminateOffload</a> function, the offload target passes the value of the TCP delegated
variables in the terminated TCP connection state object back to the host stack.</p>

<p>When passed to an offload target, a TCP_OFFLOAD_STATE_DELEGATED structure is associated with an
<a rel="noopener" target="_blank" href="ndis_miniport_offload_block_list">NDIS_MINIPORT_OFFLOAD_BLOCK_LIST</a> structure, which contains a header that is formatted as an
<a rel="noopener" target="_blank" href="ndis_object_header">NDIS_OBJECT_HEADER</a> structure. The
Revision member of the <a href="ndis_object_header" title="typedef struct _NDIS_OBJECT_HEADER {&#10;  UCHAR  Type;&#10;  UCHAR  Revision;&#10;  USHORT Size;&#10;} NDIS_OBJECT_HEADER, *PNDIS_OBJECT_HEADER;">NDIS_OBJECT_HEADER</a> structure, in this case, specifies the revision number of the
TCP_OFFLOAD_STATE_DELEGATED structure.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_query_offload_handler">MiniportQueryOffload</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/nc-ndischimney-w_terminate_offload_handler">MiniportTerminateOffload</a></p>

<p><a rel="noopener" target="_blank" href="ndis_object_header">NDIS_OBJECT_HEADER</a></p>

<p><a rel="noopener" target="_blank" href="offload_state_header">OFFLOAD_STATE_HEADER</a></p>

<p><a rel="noopener" target="_blank" href="tcp_offload_state_cached">TCP_OFFLOAD_STATE_CACHED</a></p>

<p><a rel="noopener" target="_blank" href="tcp_offload_state_const">TCP_OFFLOAD_STATE_CONST</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndischimney/ns-ndischimney-_tcp_offload_state_delegated">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ndischimney/ns-ndischimney-_tcp_offload_state_delegated.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
