<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="SCSI_WMI_REQUEST_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>SCSI_WMI_REQUEST_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            SCSI_WMI_REQUEST_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// minitape.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_WMI_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMISubFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Lun;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved1;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMIFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved2[2];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  TimeOutValue;
  PVOID  DataBuffer;
  PVOID  DataPath;
  PVOID  Reserved3;
  PVOID  OriginalRequest;
  PVOID  SrbExtension;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved4;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved6;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_WMI_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMISubFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Lun;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved1;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMIFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved2[2];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  TimeOutValue;
  PVOID  DataBuffer;
  PVOID  DataPath;
  PVOID  Reserved3;
  PVOID  OriginalRequest;
  PVOID  SrbExtension;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved4;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved6;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_WMI_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMISubFunction;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Lun;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved1;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  WMIFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved2[2];
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  TimeOutValue;
  PVOID  DataBuffer;
  PVOID  DataPath;
  PVOID  Reserved3;
  PVOID  OriginalRequest;
  PVOID  SrbExtension;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved4;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Reserved6;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>  Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/scsi_wmi_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-minitape-_scsi_wmi_request_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>_SCSI_WMI_REQUEST_BLOCK structure (minitape.h)</h1>
<h2>Description</h2>
<p>This structure is a special version of a <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> for use with WMI commands.</p>
<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size in bytes of this structure.</p>
<h3><code>Function</code></h3>
<p>SRB_FUNCTION_WMI, which specifies that the request is a WMI request. If this member is not set to SRB_FUNCTION_WMI, the miniport driver should fail the request.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the OS-specific driver that the request has completed by calling <a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a> with <strong>RequestComplete</strong>. The value of this member can be any value listed for <strong>SrbStatus</strong> in <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a>.</p>
<h3><code>WMISubFunction</code></h3>
<p>Indicates the WMI action to be performed. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>MinorFunction</em> set to this value. The subfunction value corresponds to the WMI minor <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> number that identifies the WMI operation.</p>
<h3><code>PathId</code></h3>
<p>Indicates the SCSI port or bus for the request. This value is zero-based. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>TargetId</code></h3>
<p>Indicates the target controller or device on the bus. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Lun</code></h3>
<p>Indicates the logical unit number of the device. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Reserved1</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>WMIFlags</code></h3>
<p>Indicates that the WMI request is for the adapter if SRB_WMI_FLAGS_ADAPTER_REQUEST is set and that <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong> are reserved. Otherwise, <strong>WMIFlags</strong> will be <strong>NULL</strong>, indicating that the request is for the device specified by <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>
<h3><code>Reserved2</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options about the request. <strong>SrbFlags</strong> is read-only. This member will be set to one or more of the following flags ORed together:</p>
<h4>SRB_FLAGS_DATA_IN</h4>
<p>Indicates data will be transferred from the device to the system.</p>
<h4>SRB_FLAGS_DATA_OUT</h4>
<p>Indicates data will be transferred from the system to the device.</p>
<h4>SRB_FLAGS_NO_DATA_TRANSFER</h4>
<p>Indicates no data transfer with this request. If this is set, the flags SRB_FLAGS_DATA_OUT, SRB_FLAGS_DATA_IN, and SRB_FLAGS_UNSPECIFIED_DIRECTION are clear.</p>
<h4>SRB_FLAGS_DISABLE_SYNCH_TRANSFER</h4>
<p>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</p>
<h4>SRB_FLAGS_DISABLE_DISCONNECT</h4>
<p>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size in bytes of the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>BufferSize</em> set to this value. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval in seconds that the request can execute before the OS-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>Buffer</em> set to this value. Miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for the HBA. A miniport driver cannot transfer data directly into the buffer using DMA.</p>
<h3><code>DataPath</code></h3>
<p>Specifies the WMI data path for this request. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>DataPath</em> set to this value.</p>
<h3><code>Reserved3</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>SrbExtension</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a>. The memory at <strong>SrbExtension</strong> is not initialized by the OS-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <a href="scsiportgetphysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortGetPhysicalAddress(&#10;  [in]  PVOID               HwDeviceExtension,&#10;  [in]  PSCSI_REQUEST_BLOCK Srb,&#10;  [in]  PVOID               VirtualAddress,&#10;  [out] ULONG               *Length&#10;);">ScsiPortGetPhysicalAddress</a> with the <strong>SrbExtension</strong> pointer.</p>
<h3><code>Reserved4</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>Reserved6</code></h3>
<p>Reserved for system use and not available for use by miniport drivers. This member is valid starting with Windows Server 2003 with SP1.</p>
<h3><code>Reserved5</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h2>Remarks</h2>
<p>Windows NT storage class and filter drivers can send WMI SRBs to the system port driver. The system port driver will handle certain WMI requests on behalf of miniport drivers. If the port driver cannot handle a WMI request, it forwards the request to the miniport driver.</p>
<p>A miniport driver receives WMI requests from the port driver only if the miniport driver set <strong>WmiDataProvider</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structure. If the miniport driver supports a request, it should process it and complete the request by calling <strong><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></strong> twice, first with <strong>RequestComplete</strong> and then with <strong>NextRequest</strong> (or <strong>NextLuRequest</strong>).</p>
<p>For information about supporting WMI in miniport drivers, see the <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/implementing-wmi">Windows Management Instrumentation</a>.</p>
<h2>See also</h2>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data">HW_INITIALIZATION_DATA (SCSI)</a></p>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">PORT_CONFIGURATION_INFORMATION (SCSI)</a></p>
<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>
<p><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></p>
<p><a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/minitape/ns-minitape-_scsi_wmi_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_scsi_wmi_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>_SCSI_WMI_REQUEST_BLOCK structure (srb.h)</h1>
<h2>Description</h2>
<p>This structure is a special version of a <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> for use with WMI commands.</p>
<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size in bytes of this structure.</p>
<h3><code>Function</code></h3>
<p>SRB_FUNCTION_WMI, which specifies that the request is a WMI request. If this member is not set to SRB_FUNCTION_WMI, the miniport driver should fail the request.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the OS-specific driver that the request has completed by calling <a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a> with <strong>RequestComplete</strong>. The value of this member can be any value listed for <strong>SrbStatus</strong> in <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a>.</p>
<h3><code>WMISubFunction</code></h3>
<p>Indicates the WMI action to be performed. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>MinorFunction</em> set to this value. The subfunction value corresponds to the WMI minor <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> number that identifies the WMI operation.</p>
<h3><code>PathId</code></h3>
<p>Indicates the SCSI port or bus for the request. This value is zero-based. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>TargetId</code></h3>
<p>Indicates the target controller or device on the bus. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Lun</code></h3>
<p>Indicates the logical unit number of the device. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Reserved1</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>WMIFlags</code></h3>
<p>Indicates that the WMI request is for the adapter if SRB_WMI_FLAGS_ADAPTER_REQUEST is set and that <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong> are reserved. Otherwise, <strong>WMIFlags</strong> will be <strong>NULL</strong>, indicating that the request is for the device specified by <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>
<h3><code>Reserved2</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options about the request. <strong>SrbFlags</strong> is read-only. This member will be set to one or more of the following flags ORed together:</p>
<h4>SRB_FLAGS_DATA_IN</h4>
<p>Indicates data will be transferred from the device to the system.</p>
<h4>SRB_FLAGS_DATA_OUT</h4>
<p>Indicates data will be transferred from the system to the device.</p>
<h4>SRB_FLAGS_NO_DATA_TRANSFER</h4>
<p>Indicates no data transfer with this request. If this is set, the flags SRB_FLAGS_DATA_OUT, SRB_FLAGS_DATA_IN, and SRB_FLAGS_UNSPECIFIED_DIRECTION are clear.</p>
<h4>SRB_FLAGS_DISABLE_SYNCH_TRANSFER</h4>
<p>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</p>
<h4>SRB_FLAGS_DISABLE_DISCONNECT</h4>
<p>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size in bytes of the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>BufferSize</em> set to this value. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval in seconds that the request can execute before the OS-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>Buffer</em> set to this value. Miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for the HBA. A miniport driver cannot transfer data directly into the buffer using DMA.</p>
<h3><code>DataPath</code></h3>
<p>Specifies the WMI data path for this request. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>DataPath</em> set to this value.</p>
<h3><code>Reserved3</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>SrbExtension</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a>. The memory at <strong>SrbExtension</strong> is not initialized by the OS-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <a href="scsiportgetphysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortGetPhysicalAddress(&#10;  [in]  PVOID               HwDeviceExtension,&#10;  [in]  PSCSI_REQUEST_BLOCK Srb,&#10;  [in]  PVOID               VirtualAddress,&#10;  [out] ULONG               *Length&#10;);">ScsiPortGetPhysicalAddress</a> with the <strong>SrbExtension</strong> pointer.</p>
<h3><code>Reserved4</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>Reserved6</code></h3>
<p>Reserved for system use and not available for use by miniport drivers. This member is valid starting with Windows Server 2003 with SP1.</p>
<h3><code>Reserved5</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h5>- SrbFlags.SRB_FLAGS_DATA_IN</h5>
<p>Indicates data will be transferred from the device to the system.</p>
<h5>- SrbFlags.SRB_FLAGS_DATA_OUT</h5>
<p>Indicates data will be transferred from the system to the device.</p>
<h5>- SrbFlags.SRB_FLAGS_DISABLE_DISCONNECT</h5>
<p>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</p>
<h5>- SrbFlags.SRB_FLAGS_DISABLE_SYNCH_TRANSFER</h5>
<p>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</p>
<h5>- SrbFlags.SRB_FLAGS_NO_DATA_TRANSFER</h5>
<p>Indicates no data transfer with this request. If this is set, the flags SRB_FLAGS_DATA_OUT, SRB_FLAGS_DATA_IN, and SRB_FLAGS_UNSPECIFIED_DIRECTION are clear.</p>
<h2>Remarks</h2>
<p>Windows NT storage class and filter drivers can send WMI SRBs to the system port driver. The system port driver will handle certain WMI requests on behalf of miniport drivers. If the port driver cannot handle a WMI request, it forwards the request to the miniport driver.</p>
<p>A miniport driver receives WMI requests from the port driver only if the miniport driver set <strong>WmiDataProvider</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structure. If the miniport driver supports a request, it should process it and complete the request by calling <strong><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></strong> twice, first with <strong>RequestComplete</strong> and then with <strong>NextRequest</strong> (or <strong>NextLuRequest</strong>).</p>
<p>For information about supporting WMI in miniport drivers, see the <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/implementing-wmi">Windows Management Instrumentation</a>.</p>
<h2>See also</h2>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data">HW_INITIALIZATION_DATA (SCSI)</a></p>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">PORT_CONFIGURATION_INFORMATION (SCSI)</a></p>
<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>
<p><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></p>
<p><a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_scsi_wmi_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_scsi_wmi_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>_SCSI_WMI_REQUEST_BLOCK structure (storport.h)</h1>
<h2>Description</h2>
<p>This structure is a special version of a <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> for use with WMI commands.</p>
<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size in bytes of this structure.</p>
<h3><code>Function</code></h3>
<p>SRB_FUNCTION_WMI, which specifies that the request is a WMI request. If this member is not set to SRB_FUNCTION_WMI, the miniport driver should fail the request.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the OS-specific driver that the request has completed by calling <a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a> with <strong>RequestComplete</strong>. The value of this member can be any value listed for <strong>SrbStatus</strong> in <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a>.</p>
<h3><code>WMISubFunction</code></h3>
<p>Indicates the WMI action to be performed. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>MinorFunction</em> set to this value. The subfunction value corresponds to the WMI minor <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> number that identifies the WMI operation.</p>
<h3><code>PathId</code></h3>
<p>Indicates the SCSI port or bus for the request. This value is zero-based. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>TargetId</code></h3>
<p>Indicates the target controller or device on the bus. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Lun</code></h3>
<p>Indicates the logical unit number of the device. If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in <strong>WMIFlags</strong>, this member is reserved.</p>
<h3><code>Reserved1</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>WMIFlags</code></h3>
<p>Indicates that the WMI request is for the adapter if SRB_WMI_FLAGS_ADAPTER_REQUEST is set and that <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong> are reserved. Otherwise, <strong>WMIFlags</strong> will be <strong>NULL</strong>, indicating that the request is for the device specified by <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>
<h3><code>Reserved2</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options about the request. <strong>SrbFlags</strong> is read-only. This member will be set to one or more of the following flags ORed together:</p>
<h4>SRB_FLAGS_DATA_IN</h4>
<p>Indicates data will be transferred from the device to the system.</p>
<h4>SRB_FLAGS_DATA_OUT</h4>
<p>Indicates data will be transferred from the system to the device.</p>
<h4>SRB_FLAGS_NO_DATA_TRANSFER</h4>
<p>Indicates no data transfer with this request. If this is set, the flags SRB_FLAGS_DATA_OUT, SRB_FLAGS_DATA_IN, and SRB_FLAGS_UNSPECIFIED_DIRECTION are clear.</p>
<h4>SRB_FLAGS_DISABLE_SYNCH_TRANSFER</h4>
<p>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</p>
<h4>SRB_FLAGS_DISABLE_DISCONNECT</h4>
<p>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size in bytes of the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>BufferSize</em> set to this value. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval in seconds that the request can execute before the OS-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>Buffer</em> set to this value. Miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for the HBA. A miniport driver cannot transfer data directly into the buffer using DMA.</p>
<h3><code>DataPath</code></h3>
<p>Specifies the WMI data path for this request. A miniport driver calls <a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a> with <em>DataPath</em> set to this value.</p>
<h3><code>Reserved3</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>SrbExtension</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a>. The memory at <strong>SrbExtension</strong> is not initialized by the OS-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <a href="scsiportgetphysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortGetPhysicalAddress(&#10;  [in]  PVOID               HwDeviceExtension,&#10;  [in]  PSCSI_REQUEST_BLOCK Srb,&#10;  [in]  PVOID               VirtualAddress,&#10;  [out] ULONG               *Length&#10;);">ScsiPortGetPhysicalAddress</a> with the <strong>SrbExtension</strong> pointer.</p>
<h3><code>Reserved4</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h3><code>Reserved6</code></h3>
<p>Reserved for system use and not available for use by miniport drivers. This member is valid starting with Windows Server 2003 with SP1.</p>
<h3><code>Reserved5</code></h3>
<p>Reserved for system use and not available for use by miniport drivers.</p>
<h5>- SrbFlags.SRB_FLAGS_DATA_IN</h5>
<p>Indicates data will be transferred from the device to the system.</p>
<h5>- SrbFlags.SRB_FLAGS_DATA_OUT</h5>
<p>Indicates data will be transferred from the system to the device.</p>
<h5>- SrbFlags.SRB_FLAGS_DISABLE_DISCONNECT</h5>
<p>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</p>
<h5>- SrbFlags.SRB_FLAGS_DISABLE_SYNCH_TRANSFER</h5>
<p>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</p>
<h5>- SrbFlags.SRB_FLAGS_NO_DATA_TRANSFER</h5>
<p>Indicates no data transfer with this request. If this is set, the flags SRB_FLAGS_DATA_OUT, SRB_FLAGS_DATA_IN, and SRB_FLAGS_UNSPECIFIED_DIRECTION are clear.</p>
<h2>Remarks</h2>
<p>Windows NT storage class and filter drivers can send WMI SRBs to the system port driver. The system port driver will handle certain WMI requests on behalf of miniport drivers. If the port driver cannot handle a WMI request, it forwards the request to the miniport driver.</p>
<p>A miniport driver receives WMI requests from the port driver only if the miniport driver set <strong>WmiDataProvider</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> structure. If the miniport driver supports a request, it should process it and complete the request by calling <strong><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></strong> twice, first with <strong>RequestComplete</strong> and then with <strong>NextRequest</strong> (or <strong>NextLuRequest</strong>).</p>
<p>For information about supporting WMI in miniport drivers, see the <a href="https://learn.microsoft.com/windows-hardware/drivers/kernel/implementing-wmi">Windows Management Instrumentation</a>.</p>
<h2>See also</h2>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_hw_initialization_data">HW_INITIALIZATION_DATA (SCSI)</a></p>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_port_configuration_information">PORT_CONFIGURATION_INFORMATION (SCSI)</a></p>
<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>
<p><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></p>
<p><a href="scsiportwmidispatchfunction" title="BOOLEAN ScsiPortWmiDispatchFunction(&#10;  [in] PSCSI_WMILIB_CONTEXT     WmiLibInfo,&#10;  [in] UCHAR                    MinorFunction,&#10;  [in] PVOID                    DeviceContext,&#10;  [in] PSCSIWMI_REQUEST_CONTEXT RequestContext,&#10;  [in] PVOID                    DataPath,&#10;  [in] ULONG                    BufferSize,&#10;  [in] PVOID                    Buffer&#10;);">ScsiPortWmiDispatchFunction</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_scsi_wmi_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_scsi_wmi_request_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
