<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltProcessFileLock - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltProcessFileLock - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltProcessFileLock - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// fltkernel.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">FLT_PREOP_CALLBACK_STATUS FLTAPI FltProcessFileLock(
  [in]           PFILE_LOCK         FileLock,
  [in]           <a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">PFLT_CALLBACK_DATA</a> CallbackData,
  [in, optional] PVOID              Context
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltprocessfilelock">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltprocessfilelock.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltprocessfilelock)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FltProcessFileLock function</h1>
<h2>Description</h2>
<p>The <strong>FltProcessFileLock</strong> routine processes and completes a file lock operation.</p>
<h2>Parameters</h2>
<h3><code>FileLock</code> [in]</h3>
<p>Pointer to the <strong><a href="file_lock" title="typedef struct _FILE_LOCK {&#10;  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;&#10;  PUNLOCK_ROUTINE            UnlockRoutine;&#10;  BOOLEAN                    FastIoIsQuestionable;&#10;  BOOLEAN                    SpareC[3];&#10;  PVOID                      LockInformation;&#10;  FILE_LOCK_INFO             LastReturnedLockInfo;&#10;  PVOID                      LastReturnedLock;&#10;  LONG                       LockRequestsInProgress;&#10;} FILE_LOCK;">FILE_LOCK</a></strong> structure for the file. This structure must have been initialized by a previous call to <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong> or <strong><a href="fltinitializefilelock" title="VOID FLTAPI FltInitializeFileLock(&#10;  [out] PFILE_LOCK FileLock&#10;);">FltInitializeFileLock</a></strong>.</p>
<h3><code>CallbackData</code> [in]</h3>
<p>Pointer to the callback data (<strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong>) structure for the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a> operation.</p>
<h3><code>Context</code> [in, optional]</h3>
<p>Context pointer to be used when completing the operation. This context pointer is passed to the <strong>CompleteLockCallbackDataRoutine</strong> and <strong>UnlockRoutine</strong> callback routines that the minifilter driver registered in a previous call to <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong>. This parameter is optional and can be NULL.</p>
<h2>Return value</h2>
<p><strong>FltProcessFileLock</strong> returns one of the following.</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT_PREOP_COMPLETE</td>
<td>The Filter Manager is done with the <strong>CallbackData</strong>, which can now be completed.</td>
</tr>
<tr>
<td>FLT_PREOP_DISALLOW_FASTIO</td>
<td>The <strong>CallbackData</strong> represents a fast I/O operation, and a minifilter driver in the stack has disallowed the fast I/O to be used for this operation. The Filter Manager does not send the operation to any minifilter drivers below the one that disallowed the operation. In this case, the Filter Manager only calls the postoperation callback routines (and <strong>CompleteLockCallbackDataRoutine</strong> callbacks) of the minifilter drivers above the minifilter driver that disallowed the fast I/O operation.</td>
</tr>
<tr>
<td>FLT_PREOP_PENDING</td>
<td>The lock operation has been pended.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p><strong>FltProcessFileLock</strong> processes a file lock (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a>) operation. The lock operation can be a fast I/O or <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-based operation.</p>
<p>For unlock operations, the Filter Manager calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nc-ntifs-punlock_routine"><strong>UnlockRoutine</strong></a> callback routine that the caller registered for the <strong><a href="file_lock" title="typedef struct _FILE_LOCK {&#10;  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;&#10;  PUNLOCK_ROUTINE            UnlockRoutine;&#10;  BOOLEAN                    FastIoIsQuestionable;&#10;  BOOLEAN                    SpareC[3];&#10;  PVOID                      LockInformation;&#10;  FILE_LOCK_INFO             LastReturnedLockInfo;&#10;  PVOID                      LastReturnedLock;&#10;  LONG                       LockRequestsInProgress;&#10;} FILE_LOCK;">FILE_LOCK</a></strong> structure in a previous call to <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong>.</p>
<p>When the lock operation is completed, the Filter Manager calls the <strong>CompleteLockCallbackDataRoutine</strong> (<strong><a href="pflt_complete_lock_callback_data_routine" title="PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE PfltCompleteLockCallbackDataRoutine;&#10;&#10;NTSTATUS PfltCompleteLockCallbackDataRoutine(&#10;  [in, optional] PVOID Context,&#10;  [in]           PFLT_CALLBACK_DATA CallbackData&#10;)&#10;{...}">PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE</a></strong>) completion callback routine that the caller registered for the <strong><a href="file_lock" title="typedef struct _FILE_LOCK {&#10;  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;&#10;  PUNLOCK_ROUTINE            UnlockRoutine;&#10;  BOOLEAN                    FastIoIsQuestionable;&#10;  BOOLEAN                    SpareC[3];&#10;  PVOID                      LockInformation;&#10;  FILE_LOCK_INFO             LastReturnedLockInfo;&#10;  PVOID                      LastReturnedLock;&#10;  LONG                       LockRequestsInProgress;&#10;} FILE_LOCK;">FILE_LOCK</a></strong> structure in a previous call to <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong>.</p>
<p>When the <strong>CallbackData</strong> parameter passed to <strong>FltProcessFileLock</strong> represents a fast I/O operation, the callback specified in <strong>CompleteLockCallbackDataRoutine</strong> parameter of the <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong> routine is not invoked. Only when the I/O operation in <strong>CallbackData</strong> is an <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>, and <strong>CompleteLockCallbackDataRoutine</strong> is not NULL, will the callback routine be called.</p>
<p>To determine whether the <strong>CallbackData</strong> represents a fast I/O operation, use the <strong><a href="flt_is_fastio_operation" title="void FLT_IS_FASTIO_OPERATION(&#10;  [in] Data&#10;);">FLT_IS_FASTIO_OPERATION</a></strong> macro.</p>
<p>To allocate and initialize a new file lock structure, call <strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong>.</p>
<p>To free an initialized <strong><a href="file_lock" title="typedef struct _FILE_LOCK {&#10;  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;&#10;  PUNLOCK_ROUTINE            UnlockRoutine;&#10;  BOOLEAN                    FastIoIsQuestionable;&#10;  BOOLEAN                    SpareC[3];&#10;  PVOID                      LockInformation;&#10;  FILE_LOCK_INFO             LastReturnedLockInfo;&#10;  PVOID                      LastReturnedLock;&#10;  LONG                       LockRequestsInProgress;&#10;} FILE_LOCK;">FILE_LOCK</a></strong> structure, call <strong><a href="fltfreefilelock" title="VOID FLTAPI FltFreeFileLock(&#10;  [in] PFILE_LOCK FileLock&#10;);">FltFreeFileLock</a></strong>.</p>
<h2>See also</h2>
<p><strong><a href="file_lock" title="typedef struct _FILE_LOCK {&#10;  PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;&#10;  PUNLOCK_ROUTINE            UnlockRoutine;&#10;  BOOLEAN                    FastIoIsQuestionable;&#10;  BOOLEAN                    SpareC[3];&#10;  PVOID                      LockInformation;&#10;  FILE_LOCK_INFO             LastReturnedLockInfo;&#10;  PVOID                      LastReturnedLock;&#10;  LONG                       LockRequestsInProgress;&#10;} FILE_LOCK;">FILE_LOCK</a></strong></p>
<p><strong><a href="flt_callback_data" title="typedef struct _FLT_CALLBACK_DATA {&#10;  FLT_CALLBACK_DATA_FLAGS     Flags;&#10;  PETHREAD                    Thread;&#10;  PFLT_IO_PARAMETER_BLOCK     Iopb;&#10;  IO_STATUS_BLOCK             IoStatus;&#10;  struct _FLT_TAG_DATA_BUFFER *TagData;&#10;  union {&#10;    struct {&#10;      LIST_ENTRY QueueLinks;&#10;      PVOID      QueueContext[2];&#10;    };&#10;    PVOID FilterContext[4];&#10;  };&#10;  KPROCESSOR_MODE             RequestorMode;&#10;} FLT_CALLBACK_DATA, *PFLT_CALLBACK_DATA;">FLT_CALLBACK_DATA</a></strong></p>
<p><strong><a href="flt_is_fastio_operation" title="void FLT_IS_FASTIO_OPERATION(&#10;  [in] Data&#10;);">FLT_IS_FASTIO_OPERATION</a></strong></p>
<p><strong><a href="fltallocatefilelock" title="PFILE_LOCK FLTAPI FltAllocateFileLock(&#10;  [in, optional] PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE CompleteLockCallbackDataRoutine,&#10;  [in, optional] PUNLOCK_ROUTINE                          UnlockRoutine&#10;);">FltAllocateFileLock</a></strong></p>
<p><strong><a href="fltchecklockforreadaccess" title="BOOLEAN FLTAPI FltCheckLockForReadAccess(&#10;  [in] PFILE_LOCK         FileLock,&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCheckLockForReadAccess</a></strong></p>
<p><strong><a href="fltchecklockforwriteaccess" title="BOOLEAN FLTAPI FltCheckLockForWriteAccess(&#10;  [in] PFILE_LOCK         FileLock,&#10;  [in] PFLT_CALLBACK_DATA CallbackData&#10;);">FltCheckLockForWriteAccess</a></strong></p>
<p><strong><a href="fltfreefilelock" title="VOID FLTAPI FltFreeFileLock(&#10;  [in] PFILE_LOCK FileLock&#10;);">FltFreeFileLock</a></strong></p>
<p><strong><a href="fltinitializefilelock" title="VOID FLTAPI FltInitializeFileLock(&#10;  [out] PFILE_LOCK FileLock&#10;);">FltInitializeFileLock</a></strong></p>
<p><strong><a href="fltuninitializefilelock" title="VOID FLTAPI FltUninitializeFileLock(&#10;  [in] PFILE_LOCK FileLock&#10;);">FltUninitializeFileLock</a></strong></p>
<p><strong><a href="fsrtlprocessfilelock" title="NTSTATUS FsRtlProcessFileLock(&#10;  [in]           PFILE_LOCK FileLock,&#10;  [in]           PIRP       Irp,&#10;  [in, optional] PVOID      Context&#10;);">FsRtlProcessFileLock</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a></p>
<p><strong><a href="pflt_complete_lock_callback_data_routine" title="PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE PfltCompleteLockCallbackDataRoutine;&#10;&#10;NTSTATUS PfltCompleteLockCallbackDataRoutine(&#10;  [in, optional] PVOID Context,&#10;  [in]           PFLT_CALLBACK_DATA CallbackData&#10;)&#10;{...}">PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE</a></strong></p>
<p><strong><a href="punlock_routine" title="PUNLOCK_ROUTINE PunlockRoutine;&#10;&#10;VOID PunlockRoutine(&#10;  PVOID Context,&#10;  PFILE_LOCK_INFO FileLockInfo&#10;)&#10;{...}">PUNLOCK_ROUTINE</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltprocessfilelock">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltprocessfilelock.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
