<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FltAllocateContext - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FltAllocateContext - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FltAllocateContext - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// fltkernel.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FLTAPI FltAllocateContext(
  [in]  PFLT_FILTER      Filter,
  [in]  FLT_CONTEXT_TYPE ContextType,
  [in]  <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>           ContextSize,
  [in]  <a href="pool_type" title="typedef enum _POOL_TYPE {&#10;    NonPagedPool,&#10;    NonPagedPoolExecute = NonPagedPool,&#10;    PagedPool,&#10;    NonPagedPoolMustSucceed = NonPagedPool + 2,&#10;    DontUseThisType,&#10;    NonPagedPoolCacheAligned = NonPagedPool + 4,&#10;    PagedPoolCacheAligned,&#10;    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,&#10;    MaxPoolType,&#10;    NonPagedPoolBase = 0,&#10;    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,&#10;    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,&#10;    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,&#10;    NonPagedPoolSession = 32,&#10;    PagedPoolSession = NonPagedPoolSession + 1,&#10;    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,&#10;    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,&#10;    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,&#10;    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,&#10;...">POOL_TYPE</a>        PoolType,
  [out] PFLT_CONTEXT     *ReturnedContext
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltallocatecontext">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fltallocatecontext.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fltkernel-fltallocatecontext)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FltAllocateContext function</h1>
<h2>Description</h2>
<p>The <strong>FltAllocateContext</strong> routine allocates a context structure for a specified context type.</p>
<h2>Parameters</h2>
<h3><code>Filter</code> [in]</h3>
<p>Opaque filter pointer for the caller. This parameter is required and cannot be <strong>NULL</strong>.</p>
<h3><code>ContextType</code> [in]</h3>
<p>A <strong>FLT_CONTEXT_TYPE</strong> value that indicates the type of context to allocate. <strong>ContextType</strong> can be one of the following:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT_VOLUME_CONTEXT (0x0001)</td>
<td>Allocate a volume context.</td>
</tr>
<tr>
<td>FLT_INSTANCE_CONTEXT (0x0002)</td>
<td>Allocate an instance context.</td>
</tr>
<tr>
<td>FLT_FILE_CONTEXT (0x0004)</td>
<td>Allocate a file context.</td>
</tr>
<tr>
<td>FLT_STREAM_CONTEXT (0x0008)</td>
<td>Allocate a stream context.</td>
</tr>
<tr>
<td>FLT_STREAMHANDLE_CONTEXT (0x0010)</td>
<td>Allocate a stream handle context.</td>
</tr>
<tr>
<td>FLT_TRANSACTION_CONTEXT (0x0020)</td>
<td>Allocate a transaction context.</td>
</tr>
<tr>
<td>FLT_SECTION_CONTEXT (0x0040)</td>
<td>Allocate a section context. Available starting in Windows 8.</td>
</tr>
</tbody>
</table>
<h3><code>ContextSize</code> [in]</h3>
<p>The size, in bytes, of the portion of the context defined by the minifilter driver. Must be greater than zero and less than or equal to <strong><a href="maxushort" title="#define MAXUSHORT 0xffff // winnt">MAXUSHORT</a></strong>; for fixed-size contexts, must be less than or equal to the <strong>Size</strong> specified in the <strong><a href="flt_context_registration" title="typedef struct _FLT_CONTEXT_REGISTRATION {&#10;  FLT_CONTEXT_TYPE               ContextType;&#10;  FLT_CONTEXT_REGISTRATION_FLAGS Flags;&#10;  PFLT_CONTEXT_CLEANUP_CALLBACK  ContextCleanupCallback;&#10;  SIZE_T                         Size;&#10;  ULONG                          PoolTag;&#10;  PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback;&#10;  PFLT_CONTEXT_FREE_CALLBACK     ContextFreeCallback;&#10;  PVOID                          Reserved1;&#10;} FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;">FLT_CONTEXT_REGISTRATION</a></strong> structure. A minifilter uses this portion of the context to maintain context information specific to itself. <em>FltMgr</em> treats this portion of the context structure as opaque. This parameter is required and cannot be zero.</p>
<h3><code>PoolType</code> [in]</h3>
<p>The type of pool to allocate. This parameter is required and must be one of the following. See <strong><a href="pool_type" title="typedef enum _POOL_TYPE {&#10;    NonPagedPool,&#10;    NonPagedPoolExecute = NonPagedPool,&#10;    PagedPool,&#10;    NonPagedPoolMustSucceed = NonPagedPool + 2,&#10;    DontUseThisType,&#10;    NonPagedPoolCacheAligned = NonPagedPool + 4,&#10;    PagedPoolCacheAligned,&#10;    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,&#10;    MaxPoolType,&#10;    NonPagedPoolBase = 0,&#10;    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,&#10;    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,&#10;    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,&#10;    NonPagedPoolSession = 32,&#10;    PagedPoolSession = NonPagedPoolSession + 1,&#10;    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,&#10;    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,&#10;    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,&#10;    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,&#10;...">POOL_TYPE</a></strong> for a detailed description of each type. See Remarks for more information.</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NonPagedPool</strong></td>
<td>Nonpageable system memory. <strong>PoolType</strong> must be <strong>NonPagedPool</strong> if <strong>ContextType</strong> is FLT_VOLUME_CONTEXT.</td>
</tr>
<tr>
<td><strong>PagedPool</strong></td>
<td>Pageable system memory.</td>
</tr>
<tr>
<td><strong>NonPagedPoolNx</strong></td>
<td>No-execute (NX) nonpaged pool.</td>
</tr>
</tbody>
</table>
<h3><code>ReturnedContext</code> [out]</h3>
<p>Pointer to a caller-allocated variable that receives the address of the newly allocated context. The caller is responsible for calling <strong><a href="fltreleasecontext" title="VOID FLTAPI FltReleaseContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltReleaseContext</a></strong> to release this context when it is no longer needed.</p>
<h2>Return value</h2>
<p><strong>FltAllocateContext</strong> returns <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong> or an appropriate <strong><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></strong> value, such as one of the following:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND</td>
<td>The allocation information for the context of the specified type was not provided at the time of filter registration. OR, for fixed-size contexts, the requested <strong>ContextSize</strong> is greater than the <strong>Size</strong> specified in the <strong><a href="flt_context_registration" title="typedef struct _FLT_CONTEXT_REGISTRATION {&#10;  FLT_CONTEXT_TYPE               ContextType;&#10;  FLT_CONTEXT_REGISTRATION_FLAGS Flags;&#10;  PFLT_CONTEXT_CLEANUP_CALLBACK  ContextCleanupCallback;&#10;  SIZE_T                         Size;&#10;  ULONG                          PoolTag;&#10;  PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback;&#10;  PFLT_CONTEXT_FREE_CALLBACK     ContextFreeCallback;&#10;  PVOID                          Reserved1;&#10;} FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;">FLT_CONTEXT_REGISTRATION</a></strong> structure for the specified <strong>ContextType</strong>.</td>
</tr>
<tr>
<td>STATUS_FLT_DELETING_OBJECT</td>
<td>The minifilter driver that is specified in the <strong>Filter</strong> parameter is being torn down. This is an error code.</td>
</tr>
<tr>
<td>STATUS_INSUFFICIENT_RESOURCES</td>
<td><strong>FltAllocateContext</strong> encountered a pool allocation failure. This is an error code.</td>
</tr>
<tr>
<td>STATUS_INVALID_BUFFER_SIZE</td>
<td><strong>ContextSize</strong> cannot be greater than <strong><a href="maxushort" title="#define MAXUSHORT 0xffff // winnt">MAXUSHORT</a></strong>. This is an error code.</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>An invalid value was specified for the <strong>ContextType</strong> or the <strong>ContextSize</strong> parameter. This is an error code.</td>
</tr>
<tr>
<td>STATUS_NOT_SUPPORTED</td>
<td>The file system does not support per-stream contexts. This is an error code.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>For more information about contexts, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/managing-contexts-in-a-minifilter-driver">About minifilter contexts</a>.</p>
<p><strong>FltAllocateContext</strong> allocates a context of the specified type from the specified pool. Starting in Windows 11, whether the memory that <strong>ReturnedContext</strong> points to is zeroed depends as follows:</p>
<ul>
<li>The memory is guaranteed to be zeroed for variable-sized contexts.</li>
<li>The memory content is implementation-defined for fixed-sized contexts allocated by a caller-provided callback function.</li>
<li>Otherwise, the memory can't be assumed to be zeroed for fixed-sized contexts because of lookaside list behavior. That is, an entry returned from the lookaside list might not be zeroed if it is memory that was previously freed to the lookaside list as opposed to a fresh allocation.</li>
</ul>
<p>Before Windows 11, the contents of the returned context are not zeroed.</p>
<p>Setting <strong>PoolType</strong> to an invalid value can result in unexpected behavior such as causing lookaside lists to be bypassed, resulting in the loss of the performance benefits of lookaside lists. For contexts that have a <strong>ContextAllocateCallback</strong> callback function, the behavior due to an invalid <strong>PoolType</strong> is implementation-dependent.</p>
<p>After the context is allocated, it can be set on an object by passing the <strong>ReturnedContext</strong> pointer to the appropriate set-context routine from the following table.</p>
<table>
<thead>
<tr>
<th>Context Type</th>
<th>Set-Context Routine</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT_FILE_CONTEXT</td>
<td><strong><a href="fltsetfilecontext" title="NTSTATUS FLTAPI FltSetFileContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  PFILE_OBJECT              FileObject,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetFileContext</a></strong> (starting with Windows Vista)</td>
</tr>
<tr>
<td>FLT_INSTANCE_CONTEXT</td>
<td><strong><a href="fltsetinstancecontext" title="NTSTATUS FLTAPI FltSetInstanceContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetInstanceContext</a></strong></td>
</tr>
<tr>
<td>FLT_SECTION_CONTEXT</td>
<td><strong><a href="fltcreatesectionfordatascan" title="NTSTATUS FLTAPI FltCreateSectionForDataScan(&#10;  [in]            PFLT_INSTANCE      Instance,&#10;  [in]            PFILE_OBJECT       FileObject,&#10;  [in]            PFLT_CONTEXT       SectionContext,&#10;  [in]            ACCESS_MASK        DesiredAccess,&#10;  [in, optional]  POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [in, optional]  PLARGE_INTEGER     MaximumSize,&#10;  [in]            ULONG              SectionPageProtection,&#10;  [in]            ULONG              AllocationAttributes,&#10;  [in]            ULONG              Flags,&#10;  [out]           PHANDLE            SectionHandle,&#10;  [out]           PVOID              *SectionObject,&#10;  [out, optional] PLARGE_INTEGER     SectionFileSize&#10;);">FltCreateSectionForDataScan</a></strong> (starting with Windows 8)</td>
</tr>
<tr>
<td>FLT_STREAM_CONTEXT</td>
<td><strong><a href="fltsetstreamcontext" title="NTSTATUS FLTAPI FltSetStreamContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  PFILE_OBJECT              FileObject,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetStreamContext</a></strong></td>
</tr>
<tr>
<td>FLT_STREAMHANDLE_CONTEXT</td>
<td><strong><a href="fltsetstreamhandlecontext" title="NTSTATUS FLTAPI FltSetStreamHandleContext(&#10;  [in]            PFLT_INSTANCE             Instance,&#10;  [in]            PFILE_OBJECT              FileObject,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetStreamHandleContext</a></strong></td>
</tr>
<tr>
<td>FLT_TRANSACTION_CONTEXT</td>
<td><strong><a href="fltsettransactioncontext" title="NTSTATUS FLTAPI FltSetTransactionContext(&#10;  [in]            PFLT_INSTANCE             Instance,&#10;  [in]            PKTRANSACTION             Transaction,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetTransactionContext</a></strong> (starting with Windows Vista)</td>
</tr>
<tr>
<td>FLT_VOLUME_CONTEXT</td>
<td><strong><a href="fltsetvolumecontext" title="NTSTATUS FLTAPI FltSetVolumeContext(&#10;  [in]            PFLT_VOLUME               Volume,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetVolumeContext</a></strong></td>
</tr>
</tbody>
</table>
<p>When a minifilter driver calls <strong><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></strong> from its <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine, it must register each context type that it uses. For more information, see the reference entry for the <strong><a href="flt_context_registration" title="typedef struct _FLT_CONTEXT_REGISTRATION {&#10;  FLT_CONTEXT_TYPE               ContextType;&#10;  FLT_CONTEXT_REGISTRATION_FLAGS Flags;&#10;  PFLT_CONTEXT_CLEANUP_CALLBACK  ContextCleanupCallback;&#10;  SIZE_T                         Size;&#10;  ULONG                          PoolTag;&#10;  PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback;&#10;  PFLT_CONTEXT_FREE_CALLBACK     ContextFreeCallback;&#10;  PVOID                          Reserved1;&#10;} FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;">FLT_CONTEXT_REGISTRATION</a></strong> structure, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/registering-context-types">Registering context types</a>.</p>
<p><strong>FltAllocateContext</strong> does not initialize the contents of the portion of the context structure specific to the minifilter driver.</p>
<p>To get the context for an object, call <strong><a href="fltgetcontexts" title="VOID FLTAPI FltGetContexts(&#10;  PCFLT_RELATED_OBJECTS FltObjects,&#10;  FLT_CONTEXT_TYPE      DesiredContexts,&#10;  PFLT_RELATED_CONTEXTS Contexts&#10;);">FltGetContexts</a></strong> or the appropriate get-context routine from the following table.</p>
<table>
<thead>
<tr>
<th>Context Type</th>
<th>Get-Context Routine</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT_FILE_CONTEXT</td>
<td><strong><a href="fltgetfilecontext" title="NTSTATUS FLTAPI FltGetFileContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetFileContext</a></strong> (starting with Windows Vista)</td>
</tr>
<tr>
<td>FLT_INSTANCE_CONTEXT</td>
<td><strong><a href="fltgetinstancecontext" title="NTSTATUS FLTAPI FltGetInstanceContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetInstanceContext</a></strong></td>
</tr>
<tr>
<td>FLT_SECTION_CONTEXT</td>
<td><strong><a href="fltgetsectioncontext" title="NTSTATUS FLTAPI FltGetSectionContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetSectionContext</a></strong> (starting with Windows 8)</td>
</tr>
<tr>
<td>FLT_STREAM_CONTEXT</td>
<td><strong><a href="fltgetstreamcontext" title="NTSTATUS FLTAPI FltGetStreamContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetStreamContext</a></strong></td>
</tr>
<tr>
<td>FLT_STREAMHANDLE_CONTEXT</td>
<td><strong><a href="fltgetstreamhandlecontext" title="NTSTATUS FLTAPI FltGetStreamHandleContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetStreamHandleContext</a></strong></td>
</tr>
<tr>
<td>FLT_TRANSACTION_CONTEXT</td>
<td><strong><a href="fltgettransactioncontext" title="NTSTATUS FLTAPI FltGetTransactionContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PKTRANSACTION Transaction,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetTransactionContext</a></strong> (starting with Windows Vista )</td>
</tr>
<tr>
<td>FLT_VOLUME_CONTEXT</td>
<td><strong><a href="fltgetvolumecontext" title="NTSTATUS FLTAPI FltGetVolumeContext(&#10;  [in]  PFLT_FILTER  Filter,&#10;  [in]  PFLT_VOLUME  Volume,&#10;  [out] PFLT_CONTEXT *Context&#10;);">FltGetVolumeContext</a></strong></td>
</tr>
</tbody>
</table>
<p>Contexts are reference-counted, and on a successful return from <strong>FltAllocateContext</strong>, the context pointed to by <strong>ReturnedContext</strong> has been initialized to have a reference count of 1. A context is freed automatically when its reference count reaches zero. To increment the reference count on a context, call <strong><a href="fltreferencecontext" title="VOID FLTAPI FltReferenceContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltReferenceContext</a></strong>.</p>
<p>To decrement the reference count on a context, call <strong><a href="fltreleasecontext" title="VOID FLTAPI FltReleaseContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltReleaseContext</a></strong>.</p>
<p>Because contexts are reference-counted, it is not usually necessary to delete them. To delete a context explicitly, call <strong><a href="fltdeletecontext" title="VOID FLTAPI FltDeleteContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltDeleteContext</a></strong> or the appropriate delete-context routine from the following table.</p>
<table>
<thead>
<tr>
<th>Context Type</th>
<th>Delete-Context Routine</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLT_FILE_CONTEXT</td>
<td><strong><a href="fltdeletefilecontext" title="NTSTATUS FLTAPI FltDeleteFileContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteFileContext</a></strong> (starting with Windows Vista)</td>
</tr>
<tr>
<td>FLT_INSTANCE_CONTEXT</td>
<td><strong><a href="fltdeleteinstancecontext" title="NTSTATUS FLTAPI FltDeleteInstanceContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteInstanceContext</a></strong></td>
</tr>
<tr>
<td>FLT_SECTION_CONTEXT</td>
<td><strong><a href="fltclosesectionfordatascan" title="NTSTATUS FLTAPI FltCloseSectionForDataScan(&#10;  [in] PFLT_CONTEXT SectionContext&#10;);">FltCloseSectionForDataScan</a></strong> (starting with Windows 8)</td>
</tr>
<tr>
<td>FLT_STREAM_CONTEXT</td>
<td><strong><a href="fltdeletestreamcontext" title="NTSTATUS FLTAPI FltDeleteStreamContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteStreamContext</a></strong></td>
</tr>
<tr>
<td>FLT_STREAMHANDLE_CONTEXT</td>
<td><strong><a href="fltdeletestreamhandlecontext" title="NTSTATUS FLTAPI FltDeleteStreamHandleContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteStreamHandleContext</a></strong></td>
</tr>
<tr>
<td>FLT_TRANSACTION_CONTEXT</td>
<td><strong><a href="fltdeletetransactioncontext" title="NTSTATUS FLTAPI FltDeleteTransactionContext(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PKTRANSACTION Transaction,&#10;  [out, optional] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteTransactionContext</a></strong> (starting with Windows Vista)</td>
</tr>
<tr>
<td>FLT_VOLUME_CONTEXT</td>
<td><strong><a href="fltdeletevolumecontext" title="NTSTATUS FLTAPI FltDeleteVolumeContext(&#10;  [in]            PFLT_FILTER  Filter,&#10;  [in]            PFLT_VOLUME  Volume,&#10;  [out, optional] PFLT_CONTEXT *OldContext&#10;);">FltDeleteVolumeContext</a></strong></td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<p><strong><a href="flt_context_registration" title="typedef struct _FLT_CONTEXT_REGISTRATION {&#10;  FLT_CONTEXT_TYPE               ContextType;&#10;  FLT_CONTEXT_REGISTRATION_FLAGS Flags;&#10;  PFLT_CONTEXT_CLEANUP_CALLBACK  ContextCleanupCallback;&#10;  SIZE_T                         Size;&#10;  ULONG                          PoolTag;&#10;  PFLT_CONTEXT_ALLOCATE_CALLBACK ContextAllocateCallback;&#10;  PFLT_CONTEXT_FREE_CALLBACK     ContextFreeCallback;&#10;  PVOID                          Reserved1;&#10;} FLT_CONTEXT_REGISTRATION, *PFLT_CONTEXT_REGISTRATION;">FLT_CONTEXT_REGISTRATION</a></strong></p>
<p><strong><a href="fltclosesectionfordatascan" title="NTSTATUS FLTAPI FltCloseSectionForDataScan(&#10;  [in] PFLT_CONTEXT SectionContext&#10;);">FltCloseSectionForDataScan</a></strong></p>
<p><strong><a href="fltcreatesectionfordatascan" title="NTSTATUS FLTAPI FltCreateSectionForDataScan(&#10;  [in]            PFLT_INSTANCE      Instance,&#10;  [in]            PFILE_OBJECT       FileObject,&#10;  [in]            PFLT_CONTEXT       SectionContext,&#10;  [in]            ACCESS_MASK        DesiredAccess,&#10;  [in, optional]  POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [in, optional]  PLARGE_INTEGER     MaximumSize,&#10;  [in]            ULONG              SectionPageProtection,&#10;  [in]            ULONG              AllocationAttributes,&#10;  [in]            ULONG              Flags,&#10;  [out]           PHANDLE            SectionHandle,&#10;  [out]           PVOID              *SectionObject,&#10;  [out, optional] PLARGE_INTEGER     SectionFileSize&#10;);">FltCreateSectionForDataScan</a></strong></p>
<p><strong><a href="fltdeletecontext" title="VOID FLTAPI FltDeleteContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltDeleteContext</a></strong></p>
<p><strong><a href="fltdeletefilecontext" title="NTSTATUS FLTAPI FltDeleteFileContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteFileContext</a></strong></p>
<p><strong><a href="fltdeleteinstancecontext" title="NTSTATUS FLTAPI FltDeleteInstanceContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteInstanceContext</a></strong></p>
<p><strong><a href="fltdeletestreamcontext" title="NTSTATUS FLTAPI FltDeleteStreamContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteStreamContext</a></strong></p>
<p><strong><a href="fltdeletestreamhandlecontext" title="NTSTATUS FLTAPI FltDeleteStreamHandleContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteStreamHandleContext</a></strong></p>
<p><strong><a href="fltdeletetransactioncontext" title="NTSTATUS FLTAPI FltDeleteTransactionContext(&#10;  [in]            PFLT_INSTANCE Instance,&#10;  [in]            PKTRANSACTION Transaction,&#10;  [out, optional] PFLT_CONTEXT  *OldContext&#10;);">FltDeleteTransactionContext</a></strong></p>
<p><strong><a href="fltdeletevolumecontext" title="NTSTATUS FLTAPI FltDeleteVolumeContext(&#10;  [in]            PFLT_FILTER  Filter,&#10;  [in]            PFLT_VOLUME  Volume,&#10;  [out, optional] PFLT_CONTEXT *OldContext&#10;);">FltDeleteVolumeContext</a></strong></p>
<p><strong><a href="fltgetcontexts" title="VOID FLTAPI FltGetContexts(&#10;  PCFLT_RELATED_OBJECTS FltObjects,&#10;  FLT_CONTEXT_TYPE      DesiredContexts,&#10;  PFLT_RELATED_CONTEXTS Contexts&#10;);">FltGetContexts</a></strong></p>
<p><strong><a href="fltgetfilecontext" title="NTSTATUS FLTAPI FltGetFileContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetFileContext</a></strong></p>
<p><strong><a href="fltgetinstancecontext" title="NTSTATUS FLTAPI FltGetInstanceContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetInstanceContext</a></strong></p>
<p><strong><a href="fltgetsectioncontext" title="NTSTATUS FLTAPI FltGetSectionContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetSectionContext</a></strong></p>
<p><strong><a href="fltgetstreamcontext" title="NTSTATUS FLTAPI FltGetStreamContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetStreamContext</a></strong></p>
<p><strong><a href="fltgetstreamhandlecontext" title="NTSTATUS FLTAPI FltGetStreamHandleContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PFILE_OBJECT  FileObject,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetStreamHandleContext</a></strong></p>
<p><strong><a href="fltgettransactioncontext" title="NTSTATUS FLTAPI FltGetTransactionContext(&#10;  [in]  PFLT_INSTANCE Instance,&#10;  [in]  PKTRANSACTION Transaction,&#10;  [out] PFLT_CONTEXT  *Context&#10;);">FltGetTransactionContext</a></strong></p>
<p><strong><a href="fltgetvolumecontext" title="NTSTATUS FLTAPI FltGetVolumeContext(&#10;  [in]  PFLT_FILTER  Filter,&#10;  [in]  PFLT_VOLUME  Volume,&#10;  [out] PFLT_CONTEXT *Context&#10;);">FltGetVolumeContext</a></strong></p>
<p><strong><a href="fltreferencecontext" title="VOID FLTAPI FltReferenceContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltReferenceContext</a></strong></p>
<p><strong><a href="fltregisterfilter" title="NTSTATUS FLTAPI FltRegisterFilter(&#10;  [in]  PDRIVER_OBJECT         Driver,&#10;  [in]  const FLT_REGISTRATION *Registration,&#10;  [out] PFLT_FILTER            *RetFilter&#10;);">FltRegisterFilter</a></strong></p>
<p><strong><a href="fltreleasecontext" title="VOID FLTAPI FltReleaseContext(&#10;  [in] PFLT_CONTEXT Context&#10;);">FltReleaseContext</a></strong></p>
<p><strong><a href="fltsetfilecontext" title="NTSTATUS FLTAPI FltSetFileContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  PFILE_OBJECT              FileObject,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetFileContext</a></strong></p>
<p><strong><a href="fltsetinstancecontext" title="NTSTATUS FLTAPI FltSetInstanceContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetInstanceContext</a></strong></p>
<p><strong><a href="fltsetstreamcontext" title="NTSTATUS FLTAPI FltSetStreamContext(&#10;  [in]  PFLT_INSTANCE             Instance,&#10;  [in]  PFILE_OBJECT              FileObject,&#10;  [in]  FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]  PFLT_CONTEXT              NewContext,&#10;  [out] PFLT_CONTEXT              *OldContext&#10;);">FltSetStreamContext</a></strong></p>
<p><strong><a href="fltsetstreamhandlecontext" title="NTSTATUS FLTAPI FltSetStreamHandleContext(&#10;  [in]            PFLT_INSTANCE             Instance,&#10;  [in]            PFILE_OBJECT              FileObject,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetStreamHandleContext</a></strong></p>
<p><strong><a href="fltsettransactioncontext" title="NTSTATUS FLTAPI FltSetTransactionContext(&#10;  [in]            PFLT_INSTANCE             Instance,&#10;  [in]            PKTRANSACTION             Transaction,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetTransactionContext</a></strong></p>
<p><strong><a href="fltsetvolumecontext" title="NTSTATUS FLTAPI FltSetVolumeContext(&#10;  [in]            PFLT_VOLUME               Volume,&#10;  [in]            FLT_SET_CONTEXT_OPERATION Operation,&#10;  [in]            PFLT_CONTEXT              NewContext,&#10;  [out, optional] PFLT_CONTEXT              *OldContext&#10;);">FltSetVolumeContext</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltallocatecontext">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/nf-fltkernel-fltallocatecontext.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
