<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="COPY_CHUNK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>COPY_CHUNK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            COPY_CHUNK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header"></span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">#define COPY_CHUNK /* IOCTL code */</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ioctl-copychunk">View the official Win32 development documentation</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header"></span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">#define COPY_CHUNK /* IOCTL code */</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ioctl-lmr-disable-local-buffering">View the official Win32 development documentation</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/copy_chunk.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 development documentation (ioctl-copychunk)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="ioctl_copychunk-control-code">IOCTL_COPYCHUNK control code</h1>

<p>The <strong>IOCTL_COPYCHUNK</strong> control code initiates a server-side copy of a range of data, also called a chunk.</p>

<p>To perform this operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> function with the following parameters.</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="n">BOOL</span><span class="w"> </span><span class="n">DeviceIoControl</span><span class="p">(</span>
<span class="w">  </span><span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="w"> </span><span class="n">hDevice</span><span class="p">,</span><span class="w">             </span><span class="c1">// handle to device</span>
<span class="w">  </span><span class="n">IOCTL_COPYCHUNK</span><span class="p">,</span><span class="w">              </span><span class="c1">// dwIoControlCode</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="n">lpInBuffer</span><span class="p">,</span><span class="w">          </span><span class="c1">// input buffer</span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="n">nInBufferSize</span><span class="p">,</span><span class="w">        </span><span class="c1">// size of input buffer</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="n">lpOutBuffer</span><span class="p">,</span><span class="w">         </span><span class="c1">// output buffer</span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="n">nOutBufferSize</span><span class="p">,</span><span class="w">       </span><span class="c1">// size of output buffer</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPDWORD</span><span class="p">)</span><span class="w"> </span><span class="n">lpBytesReturned</span><span class="p">,</span><span class="w">    </span><span class="c1">// number of bytes returned</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="w"> </span><span class="n">lpOverlapped</span><span class="w">   </span><span class="c1">// OVERLAPPED structure</span>
<span class="p">);</span>
</code></pre>
</div>

<h2 id="parameters">Parameters</h2>

<p><em>hDevice</em> [in]</p>

<p>A handle to the file that is the target of the server-side copy operation. To obtain this handle, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> function.</p>

<p><em>dwIoControlCode</em> [in]</p>

<p>The control code for the operation. Use <strong>IOCTL_COPYCHUNK</strong> for this operation.</p>

<p><em>lpInBuffer</em></p>

<p>A pointer to the input buffer, a <strong>SRV_COPYCHUNK_COPY</strong> structure. For more information, see the Remarks section.</p>

<p><em>nInBufferSize</em> [in]</p>

<p>The size of the input buffer, in bytes.</p>

<p><em>lpOutBuffer</em> [out]</p>

<p>A pointer to the output buffer, a <strong>SRV_COPYCHUNK_RESPONSE</strong> structure. For more information, see the Remarks section.</p>

<p><em>nOutBufferSize</em> [in]</p>

<p>The size of the output buffer, in bytes.</p>

<p><em>lpBytesReturned</em> [out]</p>

<p>A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.</p>

<p>If the output buffer is too small, the call fails, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a> function returns <strong>ERROR_INSUFFICIENT_BUFFER</strong>, and <em>lpBytesReturned</em> is zero.</p>

<p>If the <em>lpOverlapped</em> parameter is <strong>NULL</strong>, <em>lpBytesReturned</em> cannot be <strong>NULL</strong>. Even when an operation returns no output data and the <em>lpOutBuffer</em> parameter is <strong>NULL</strong>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> makes use of <em>lpBytesReturned</em>. After such an operation, the value of <em>lpBytesReturned</em> is meaningless.</p>

<p>If <em>lpOverlapped</em> is not <strong>NULL</strong>, <em>lpBytesReturned</em> can be <strong>NULL</strong>. If <em>lpOverlapped</em> is not <strong>NULL</strong> and the operation returns data, <em>lpBytesReturned</em> is meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult"><strong>GetOverlappedResult</strong></a> function. If the <em>hDevice</em> parameter is associated with an I/O completion port, you can retrieve the number of bytes returned by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><strong>GetQueuedCompletionStatus</strong></a> function.</p>

<p><em>lpOverlapped</em> [in]</p>

<p>A pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure.</p>

<p>If the <em>hDevice</em> parameter was opened without specifying <strong>FILE_FLAG_OVERLAPPED</strong>, <em>lpOverlapped</em> is ignored.</p>

<p>If <em>hDevice</em> was opened with the <strong>FILE_FLAG_OVERLAPPED</strong> flag, the operation is performed as an overlapped (asynchronous) operation. In this case, <em>lpOverlapped</em> must point to a valid <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways.</p>

<p>For overlapped operations, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns immediately, and the event object is signaled when the operation has been completed. Otherwise, the function does not return until the operation has been completed or until an error occurs.</p>

<h2 id="return-value">Return value</h2>

<p>If the operation completes successfully, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns a nonzero value.</p>

<p>If the operation fails or is pending, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns zero. To get extended error information, call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a>.</p>

<h2 id="remarks">Remarks</h2>

<p>This control code has no associated header file. You must define the control code and data structures as follows.</p>

<p><!-- CODE_MARKER --></p>

<pre><code>#define IOCTL_COPYCHUNK <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(FILE_DEVICE_NETWORK_FILE_SYSTEM, 262, METHOD_BUFFERED,  FILE_READ_ACCESS)

typedef struct _SRV_COPYCHUNK {
    LARGE_INTEGER SourceOffset;
    LARGE_INTEGER DestinationOffset;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>  Length;
} SRV_COPYCHUNK, *PSRV_COPYCHUNK;

typedef struct _SRV_COPYCHUNK_COPY {
    SRV_RESUME_KEY SourceFile;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          ChunkCount;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          Reserved;
    SRV_COPYCHUNK  Chunk[1];    // Array
} SRV_COPYCHUNK_COPY, *PSRV_COPYCHUNK_COPY;

typedef struct _SRV_COPYCHUNK_RESPONSE {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          ChunksWritten;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          ChunkBytesWritten;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>          TotalBytesWritten;
} SRV_COPYCHUNK_RESPONSE, *PSRV_COPYCHUNK_RESPONSE;
</code></pre>

<p>These members can be described as follows.</p>

<table>
<thead>
<tr>
  <th>Member</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>SourceOffset</strong><br></td>
  <td>The offset, in bytes, from the beginning of the source file to the chunk to be copied.<br></td>
</tr>
<tr>
  <td><strong>DestinationOffset</strong><br></td>
  <td>The offset, in bytes, from the beginning of the target file to the location where the chunk is to be copied.<br></td>
</tr>
<tr>
  <td><strong>Length</strong><br></td>
  <td>The number of bytes of data in the chunk to be copied. Must be greater than zero and less than or equal to 1 MB. <strong>Length</strong> * <strong>ChunkCount</strong> must be less than or equal to 16 MB.<br></td>
</tr>
<tr>
  <td><strong>SourceFile</strong><br></td>
  <td>A key that represents the source file with the data to be copied. This key is obtained through <strong><a href="fsctl_srv_request_resume_key" title="#define FSCTL_SRV_REQUEST_RESUME_KEY /* IOCTL code */">FSCTL_SRV_REQUEST_RESUME_KEY</a></strong>.<br></td>
</tr>
<tr>
  <td><strong>ChunkCount</strong><br></td>
  <td>The number of chunks to be copied. Must be greater than zero and less than or equal to 256.<br></td>
</tr>
<tr>
  <td><strong>Reserved</strong><br></td>
  <td>This member is reserved for system use; do not use.<br></td>
</tr>
<tr>
  <td><strong>Chunk</strong><br></td>
  <td>An array of <strong>ChunkCount</strong> <strong>SRV_COPYCHUNK</strong> structures, one for each chunk to be copied. The length, in bytes, of this array must be <strong>ChunkCount</strong> * sizeof(<strong>SRV_COPYCHUNK</strong>).<br></td>
</tr>
<tr>
  <td><strong>ChunksWritten</strong><br></td>
  <td>If the operation failed with <strong>ERROR_INVALID_PARAMETER</strong>, this value indicates the maximum number of chunks the server will accept in a single request, which is 256. Otherwise, this value indicates the number of chunks that were successfully written.<br></td>
</tr>
<tr>
  <td><strong>ChunkBytesWritten</strong><br></td>
  <td>If the operation failed with <strong>ERROR_INVALID_PARAMETER</strong>, this value indicates the maximum number of bytes the server will allow to be written in a single chunk, which is 1 MB. Otherwise, this value indicates the number of bytes that were successfully written in the last chunk that was not successfully processed (if a partial write occurred).<br></td>
</tr>
<tr>
  <td><strong>TotalBytesWritten</strong><br></td>
  <td>If the operation failed with <strong>ERROR_INVALID_PARAMETER</strong>, this value indicates the maximum number of bytes the server will copy in a single request, which is 16 MB. Otherwise, this value indicates the number of bytes that were successfully written.<br></td>
</tr>
</tbody>
</table>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a></p>

<p><strong><a href="fsctl_srv_request_resume_key" title="#define FSCTL_SRV_REQUEST_RESUME_KEY /* IOCTL code */">FSCTL_SRV_REQUEST_RESUME_KEY</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ioctl-copychunk">View the official Win32 development documentation</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/DevNotes/ioctl-copychunk.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 development documentation (ioctl-lmr-disable-local-buffering)</h1>
</div>
<div class="ntdoc-description">
<h1>IOCTL_LMR_DISABLE_LOCAL_BUFFERING control code</h1>

<p>The <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> control code disables local client-side in-memory caching of data when reading data from or writing data to a remote file. This is an internally-defined control code not available in a public header.</p>

<p>To perform this operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> function with the following parameters.</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="n">BOOL</span><span class="w"> </span><span class="n">DeviceIoControl</span><span class="p">(</span>
<span class="w">  </span><span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="w"> </span><span class="n">hDevice</span><span class="p">,</span><span class="w">             </span><span class="c1">// handle to device</span>
<span class="w">  </span><span class="n">IOCTL_LMR_DISABLE_LOCAL_BUFFERING</span><span class="p">,</span><span class="w"> </span><span class="c1">// dwIoControlCode</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                </span><span class="c1">// lpInBuffer</span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                    </span><span class="c1">// nInBufferSize</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                </span><span class="c1">// lpOutBuffer</span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">                    </span><span class="c1">// nOutBufferSize</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPDWORD</span><span class="p">)</span><span class="w"> </span><span class="n">lpBytesReturned</span><span class="p">,</span><span class="w">    </span><span class="c1">// number of bytes returned</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="w"> </span><span class="n">lpOverlapped</span><span class="w">   </span><span class="c1">// OVERLAPPED structure</span>
<span class="p">);</span>
</code></pre>
</div>

<h2>Parameters</h2>

<p><em>hDevice</em> [in]</p>

<p>A handle to the remote file. To obtain this handle, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea"><strong>CreateFile</strong></a> function.</p>

<p><em>dwIoControlCode</em> [in]</p>

<p>The control code for the operation. Use the value 0x140390 for this operation.</p>

<p><em>lpInBuffer</em></p>

<p>Not used, must be <strong>NULL</strong>.</p>

<p><em>nInBufferSize</em> [in]</p>

<p>The size of the input buffer, in bytes. Must be zero.</p>

<p><em>lpOutBuffer</em> [out]</p>

<p>Not used, must be <strong>NULL</strong>.</p>

<p><em>nOutBufferSize</em> [in]</p>

<p>The size of the output buffer, in bytes. Must be zero.</p>

<p><em>lpBytesReturned</em> [out]</p>

<p>A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.</p>

<p>If the output buffer is too small, then the call fails, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a> function returns <strong>ERROR_INSUFFICIENT_BUFFER</strong>, and <em>lpBytesReturned</em> is zero.</p>

<p>If the <em>lpOverlapped</em> parameter is <strong>NULL</strong>, <em>lpBytesReturned</em> cannot be <strong>NULL</strong>. Even when an operation returns no output data and the <em>lpOutBuffer</em> parameter is <strong>NULL</strong>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> makes use of <em>lpBytesReturned</em>. After such an operation, the value of <em>lpBytesReturned</em> is meaningless.</p>

<p>If <em>lpOverlapped</em> is not <strong>NULL</strong>, <em>lpBytesReturned</em> can be <strong>NULL</strong>. If <em>lpOverlapped</em> is not <strong>NULL</strong> and the operation returns data, <em>lpBytesReturned</em> is meaningless until the overlapped operation has completed. To retrieve the number of bytes returned, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult"><strong>GetOverlappedResult</strong></a> function. If the <em>hDevice</em> parameter is associated with an I/O completion port, you can retrieve the number of bytes returned by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus"><strong>GetQueuedCompletionStatus</strong></a> function.</p>

<p><em>lpOverlapped</em> [in]</p>

<p>A pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure.</p>

<p>If the <em>hDevice</em> parameter was opened without specifying <strong>FILE_FLAG_OVERLAPPED</strong>, <em>lpOverlapped</em> is ignored.</p>

<p>If <em>hDevice</em> was opened with the <strong>FILE_FLAG_OVERLAPPED</strong> flag, the operation is performed as an overlapped (asynchronous) operation. In this case, <em>lpOverlapped</em> must point to a valid <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure that contains a handle to an event object. Otherwise, the function fails in unpredictable ways.</p>

<p>For overlapped operations, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns immediately, and the event object is signaled when the operation has been completed. Otherwise, the function does not return until the operation has been completed or until an error occurs.</p>

<h2>Return value</h2>

<p>If the operation completes successfully, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns a nonzero value.</p>

<p>If the operation fails or is pending, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> returns zero. To get extended error information, call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror"><strong>GetLastError</strong></a>.</p>

<h2>Remarks</h2>

<p>The <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> control code is defined internally by the system as 0x140390 and not in a public header file. It is used by special-purpose applications to disable local client-side in-memory caching of data when reading data from or writing data to a remote file. After local buffering is disabled, the setting remains in effect until all open handles to the file are closed and the redirector cleans up its internal data structures.</p>

<p>General-purpose applications should not use <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong>, because it can result in excessive network traffic and associated loss of performance. The <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> control code should be used only in specialized applications moving large amounts of data over the network while attempting to maximize use of network bandwidth. For example, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfile"><strong>CopyFile</strong></a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfileexa"><strong>CopyFileEx</strong></a> functions use <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> to improve large file copy performance.</p>

<p><strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> is not implemented by local file systems and will fail with the error <strong>ERROR_INVALID_FUNCTION</strong>. Issuing the <strong>IOCTL_LMR_DISABLE_LOCAL_BUFFERING</strong> control code on remote directory handles will fail with the error <strong>ERROR_NOT_SUPPORTED</strong>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ioctl-lmr-disable-local-buffering">View the official Win32 development documentation</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/DevNotes/ioctl-lmr-disable-local-buffering.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
