<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="DXGKDDI_RENDER - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>DXGKDDI_RENDER - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            DXGKDDI_RENDER - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dkmddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">DXGKDDI_RENDER DxgkddiRender;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> DxgkddiRender(
  [in]     IN_CONST_HANDLE hContext,
  [in/out] INOUT_PDXGKARG_RENDER pRender
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_render">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/dxgkddi_render.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-d3dkmddi-dxgkddi_render)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="dxgkddi_render-callback-function">DXGKDDI_RENDER callback function</h1>

<h2 id="description">Description</h2>

<p>The <em>DxgkDdiRender</em> function generates a direct memory access (DMA) buffer from the command buffer that the user-mode display driver passed.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="hcontext-in"><code>hContext</code> [in]</h3>

<p>A handle to the device context for the DMA and command buffers. The display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createcontext">DxgkDdiCreateContext</a> function previously returned this handle in the <strong>hContext</strong> member of the <a href="dxgkarg_createcontext" title="typedef struct _DXGKARG_CREATECONTEXT {&#10;  [out] HANDLE                  hContext;&#10;  [in]  UINT                    NodeOrdinal;&#10;  [in]  UINT                    EngineAffinity;&#10;  [in]  DXGK_CREATECONTEXTFLAGS Flags;&#10;  [in]  VOID                    *pPrivateDriverData;&#10;  [in]  UINT                    PrivateDriverDataSize;&#10;  [out] DXGK_CONTEXTINFO        ContextInfo;&#10;} DXGKARG_CREATECONTEXT;">DXGKARG_CREATECONTEXT</a> structure that the <em>pCreateContext</em> parameter of <em>DxgkDdiCreateContext</em> points to.</p>

<p>If the driver does not support context creation, the Microsoft DirectX graphics kernel subsystem replaces the handle to the context with a handle to the device. The display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createdevice">DxgkDdiCreateDevice</a> function previously returned the device handle in the <strong>hDevice</strong> member of the <a href="dxgkarg_createdevice" title="typedef struct _DXGKARG_CREATEDEVICE {&#10;  HANDLE hDevice;&#10;  union {&#10;    DXGK_CREATEDEVICEFLAGS Flags;&#10;    DXGK_DEVICEINFO        *pInfo;&#10;  };&#10;  ULONG  Pasid;&#10;  HANDLE hKmdProcess;&#10;} DXGKARG_CREATEDEVICE;">DXGKARG_CREATEDEVICE</a> structure that the <em>pCreateDevice</em> parameter of <em>DxgkDdiCreateDevice</em> points to.</p>

<h3 id="prender-inout"><code>pRender</code> [in/out]</h3>

<p>A pointer to a <a href="dxgkarg_render" title="typedef struct _DXGKARG_RENDER {&#10;  [in]     const VOID               *pCommand;&#10;  [in]     UINT                     CommandLength;&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;  [in]     UINT                     AllocationListSize;&#10;  [in]     D3DDDI_PATCHLOCATIONLIST *pPatchLocationListIn;&#10;  [in]     UINT                     PatchLocationListInSize;&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in/out] UINT                     MultipassOffset;&#10;  [in]     UINT                     DmaBufferSegmentId;&#10;  [in]     PHYSICAL_ADDRESS         DmaBufferPhysicalAddress;&#10;} DXGKARG_RENDER;">DXGKARG_RENDER</a> structure that contains information about the DMA and command buffers.</p>

<h2 id="return-value">Return value</h2>

<p><em>DxgkDdiRender</em> returns one of the following values:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></td>
  <td>The entire command buffer was translated.</td>
</tr>
<tr>
  <td>STATUS_NO_MEMORY</td>
  <td>DxgkDdiRender could not allocate memory that was required for it to complete.</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER</td>
  <td>The current DMA buffer is depleted.</td>
</tr>
<tr>
  <td>STATUS_PRIVILEGED_INSTRUCTION</td>
  <td>DxgkDdiRender detected nonprivileged instructions (that is, instructions that access memory beyond the privilege of the current central processing unit [CPU] process).</td>
</tr>
<tr>
  <td>STATUS_ILLEGAL_INSTRUCTION</td>
  <td>DxgkDdiRender detected instructions that graphics hardware could not support.</td>
</tr>
<tr>
  <td>STATUS_INVALID_PARAMETER</td>
  <td>DxgkDdiRender detected instruction parameters that graphics hardware could not support; however, the graphics hardware can support the instructions themselves. The driver is not required to return this error code. Instead, it can return STATUS_ILLEGAL_INSTRUCTION when it detects unsupported instruction parameters.</td>
</tr>
<tr>
  <td>STATUS_INVALID_USER_BUFFER</td>
  <td>DxgkDdiRender detected data or instruction underrun or overrun. That is, the driver received less or more instructions or data than expected. The driver is not required to return this error code. Instead, it can return STATUS_ILLEGAL_INSTRUCTION when it detects data or instruction underrun or overrun.</td>
</tr>
<tr>
  <td>STATUS_INVALID_HANDLE</td>
  <td>DxgkDdiRender detected an invalid handle in the command buffer.</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_DRIVER_MISMATCH</td>
  <td>The display miniport driver is not compatible with the user-mode display driver that initiated the call to DxgkDdiRender (that is, submitted the command buffer).</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE</td>
  <td>The display miniport driver detected an error in the DMA stream. The graphics context device is placed in a lost state if the driver returns this error code.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>The DirectX graphics kernel subsystem calls the display miniport driver's <em>DxgkDdiRender</em> function to generate a DMA buffer from the command buffer that the user-mode display driver passed. When the display miniport driver translates from the command buffer to the DMA buffer, the driver should also validate the command buffer to ensure that the command buffer does not contain any privileged commands or commands that can be used to access memory that does not belong to the process. In addition to the output DMA buffer, the display miniport driver should also generate a list of output patch locations. The video memory manager uses this list to split and patch DMA buffers appropriately.</p>

<p>Both the command buffer <strong>pCommand</strong> and the input patch-location list <strong>pPatchLocationListIn</strong> that the user-mode display driver generates are allocated from the user-mode address space and are passed to the display miniport driver untouched. The display miniport driver must use <code>__try/__except</code> code on any access to the buffer and list and must validate the content of the buffer and list before copying the content to the respective kernel buffers (that is, before copying the content of the <strong>pCommand</strong> member to the <strong>pDmaBuffer</strong> member and the content of the <strong>pPatchLocationListIn</strong> member to the <strong>pPatchLocationListOut</strong> member, which are all members of the <a href="dxgkarg_render" title="typedef struct _DXGKARG_RENDER {&#10;  [in]     const VOID               *pCommand;&#10;  [in]     UINT                     CommandLength;&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;  [in]     UINT                     AllocationListSize;&#10;  [in]     D3DDDI_PATCHLOCATIONLIST *pPatchLocationListIn;&#10;  [in]     UINT                     PatchLocationListInSize;&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in/out] UINT                     MultipassOffset;&#10;  [in]     UINT                     DmaBufferSegmentId;&#10;  [in]     PHYSICAL_ADDRESS         DmaBufferPhysicalAddress;&#10;} DXGKARG_RENDER;">DXGKARG_RENDER</a> structure that the <em>pRender</em> parameter points to).</p>

<p>Here's an example of how display miniport drivers should access these buffers using <code>__try</code> and <code>__except</code> logic. <strong>AllocationListIn</strong> points to the user-mode buffer.</p>

<p><!-- CODE_MARKER --></p>

<div class="codehilite">
<pre><span></span><code><span class="kr">__try</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">AllocationListInSize</span><span class="p">;</span><span class="w"> </span><span class="n">AllocationTable</span><span class="o">++</span><span class="p">,</span>
<span class="w">           </span><span class="n">AllocationListIn</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">AllocationListOut</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">D3DKMT_HANDLE</span><span class="w"> </span><span class="n">AllocationHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllocationListIn</span><span class="o">-&gt;</span><span class="n">hAllocation</span><span class="p">;</span>
<span class="w">      </span><span class="p">.</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="p">.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="kr">__except</span><span class="p">(</span><span class="n">EXCEPTION_EXECUTE_HANDLER</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
<span class="w">    </span><span class="n">SAMPLE_LOG_ERROR</span><span class="p">(</span>
<span class="w">  </span><span class="s">&quot;Exception occurred accessing user-mode allocation list. Returning Status=0x%I64x&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="n">Status</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">cleanup</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</code></pre>
</div>

<blockquote>
  <p>[!NOTE]
  Access to the kernel buffers does not require protection from <code>try/except</code> code.</p>
</blockquote>

<p>The display miniport driver is not required to use information that the user-mode display driver provides if recreating the information is more optimal. For example, if <strong>pPatchLocationListIn</strong> is empty because the user-mode display driver did not provide an input patch-location list, the display miniport driver can generate the content of <strong>pPatchLocationListOut</strong> based on the content of the command buffer instead.</p>

<p>The allocation list that the user-mode display driver provides is validated, copied, and converted into a kernel-mode allocation list during the kernel transition. The DirectX graphics kernel subsystem converts each <a href="d3dddi_allocationlist" title="typedef struct _D3DDDI_ALLOCATIONLIST {&#10;  D3DKMT_HANDLE hAllocation;&#10;  union {&#10;    struct {&#10;      UINT WriteOperation : 1;&#10;      UINT DoNotRetireInstance : 1;&#10;      UINT OfferPriority : 3;&#10;#if ...&#10;      UINT Reserved : 27;&#10;#else&#10;      UINT Reserved : 30;&#10;#endif&#10;    };&#10;    UINT Value;&#10;  };&#10;} D3DDDI_ALLOCATIONLIST;">D3DDDI_ALLOCATIONLIST</a> element into a <a href="dxgk_allocationlist" title="typedef struct _DXGK_ALLOCATIONLIST&#10;{&#10;    HANDLE              hDeviceSpecificAllocation;&#10;    struct&#10;    {&#10;        UINT            WriteOperation  : 1;    // 0x00000001&#10;        UINT            SegmentId       : 5;    // 0x0000002E&#10;        UINT            Reserved        : 26;   // 0xFFFFFFC0&#10;    };&#10;#if (DXGKDDI_INTERFACE_VERSION &gt;= DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;    union&#10;    {&#10;        PHYSICAL_ADDRESS        PhysicalAddress;&#10;        D3DGPU_VIRTUAL_ADDRESS  VirtualAddress;&#10;    };&#10;#else // (DXGKDDI_INTERFACE_VERSION &lt; DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;    PHYSICAL_ADDRESS    PhysicalAddress;&#10;#endif // (DXGKDDI_INTERFACE_VERSION &gt;= DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;} DXGK_ALLOCATIONLIST;">DXGK_ALLOCATIONLIST</a> element by converting the D3DKMT_HANDLE-typed handle that the user-mode display driver provides into a device-specific handle, which the display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_openallocationinfo">DxgkDdiOpenAllocation</a> function returns. The index of each allocation and the write status of the allocation (that is, the setting of the <strong>WriteOperation</strong> bit-field flag) remains constant during the conversion.</p>

<p>In addition to the device-specific handle, the DirectX graphics kernel subsystem provides the display miniport driver with the last known GPU segment address for each allocation. If allocation index <em>N</em> is currently paged out, the DirectX graphics kernel subsystem sets the <strong>SegmentId</strong> member of the <em>N</em>th element of the <strong>pAllocationList</strong> member of <a href="dxgkarg_render" title="typedef struct _DXGKARG_RENDER {&#10;  [in]     const VOID               *pCommand;&#10;  [in]     UINT                     CommandLength;&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;  [in]     UINT                     AllocationListSize;&#10;  [in]     D3DDDI_PATCHLOCATIONLIST *pPatchLocationListIn;&#10;  [in]     UINT                     PatchLocationListInSize;&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in/out] UINT                     MultipassOffset;&#10;  [in]     UINT                     DmaBufferSegmentId;&#10;  [in]     PHYSICAL_ADDRESS         DmaBufferPhysicalAddress;&#10;} DXGKARG_RENDER;">DXGKARG_RENDER</a> to zero. If the <strong>SegmentId</strong> member of the <em>N</em>th element of the allocation list is not set to zero, the display miniport driver must pre-patch the generated DMA buffer with the provided segment address information. The driver must pre-patch when requested because the DirectX graphics kernel subsystem might not call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a> function on a DMA buffer that the driver should have properly pre-patched.</p>

<blockquote>
  <p>[!NOTE]
  Even though the driver's <em>DxgkDdiRender</em> function pre-patches the DMA buffer, the driver must still insert all of the references to allocations into the output patch-location list that the <strong>pPatchLocationListOut</strong> member of <a href="dxgkarg_render" title="typedef struct _DXGKARG_RENDER {&#10;  [in]     const VOID               *pCommand;&#10;  [in]     UINT                     CommandLength;&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;  [in]     UINT                     AllocationListSize;&#10;  [in]     D3DDDI_PATCHLOCATIONLIST *pPatchLocationListIn;&#10;  [in]     UINT                     PatchLocationListInSize;&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in/out] UINT                     MultipassOffset;&#10;  [in]     UINT                     DmaBufferSegmentId;&#10;  [in]     PHYSICAL_ADDRESS         DmaBufferPhysicalAddress;&#10;} DXGKARG_RENDER;">DXGKARG_RENDER</a> specifies. This list must contain all of the references because the addresses of the allocations might change before the DMA buffer is submitted to the GPU; therefore, the DirectX graphics kernel subsystem will call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a> function to repatch the DMA buffer.</p>
</blockquote>

<p>To unbind an allocation, the display miniport driver can specify an element in the allocation list that references a <strong>NULL</strong> handle and then can use a patch-location element that references that <strong>NULL</strong> allocation. Typically, the driver should use the first element of the allocation list (element 0) as the <strong>NULL</strong> element.</p>

<p>When the display miniport driver translates a command buffer to a DMA buffer, the display miniport driver and user-mode display driver should perform the following actions for the following situations:</p>

<ul>
<li><p>In guaranteed contract DMA mode (for more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/using-the-guaranteed-contract-dma-buffer-model">Using the Guaranteed Contract DMA Buffer Model</a>), the user-mode display driver must guarantee enough resources for the translation command. If enough resources do not exist for the translation, the display miniport driver must reject the DMA buffer.</p></li>
<li><p>The user-mode display driver should always split up commands that might translate to more than the size of a single DMA buffer because the display miniport driver's <em>DxgkDdiRender</em> function cannot handle a single command that is larger than the size of the DMA buffer and that cannot be split.</p></li>
</ul>

<p><em>DxgkDdiRender</em> should be made pageable.</p>

<p>Support for the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_renderkm">DxgkDdiRenderKm</a> function was added beginning with Windows 7 for display adapters that support <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/gdi-hardware-acceleration">GDI Hardware Acceleration</a>.</p>

<h2 id="see-also">See also</h2>

<p><a href="d3dddi_allocationlist" title="typedef struct _D3DDDI_ALLOCATIONLIST {&#10;  D3DKMT_HANDLE hAllocation;&#10;  union {&#10;    struct {&#10;      UINT WriteOperation : 1;&#10;      UINT DoNotRetireInstance : 1;&#10;      UINT OfferPriority : 3;&#10;#if ...&#10;      UINT Reserved : 27;&#10;#else&#10;      UINT Reserved : 30;&#10;#endif&#10;    };&#10;    UINT Value;&#10;  };&#10;} D3DDDI_ALLOCATIONLIST;">D3DDDI_ALLOCATIONLIST</a></p>

<p><a href="dxgkarg_createcontext" title="typedef struct _DXGKARG_CREATECONTEXT {&#10;  [out] HANDLE                  hContext;&#10;  [in]  UINT                    NodeOrdinal;&#10;  [in]  UINT                    EngineAffinity;&#10;  [in]  DXGK_CREATECONTEXTFLAGS Flags;&#10;  [in]  VOID                    *pPrivateDriverData;&#10;  [in]  UINT                    PrivateDriverDataSize;&#10;  [out] DXGK_CONTEXTINFO        ContextInfo;&#10;} DXGKARG_CREATECONTEXT;">DXGKARG_CREATECONTEXT</a></p>

<p><a href="dxgkarg_createdevice" title="typedef struct _DXGKARG_CREATEDEVICE {&#10;  HANDLE hDevice;&#10;  union {&#10;    DXGK_CREATEDEVICEFLAGS Flags;&#10;    DXGK_DEVICEINFO        *pInfo;&#10;  };&#10;  ULONG  Pasid;&#10;  HANDLE hKmdProcess;&#10;} DXGKARG_CREATEDEVICE;">DXGKARG_CREATEDEVICE</a></p>

<p><a href="dxgkarg_render" title="typedef struct _DXGKARG_RENDER {&#10;  [in]     const VOID               *pCommand;&#10;  [in]     UINT                     CommandLength;&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;  [in]     UINT                     AllocationListSize;&#10;  [in]     D3DDDI_PATCHLOCATIONLIST *pPatchLocationListIn;&#10;  [in]     UINT                     PatchLocationListInSize;&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in/out] UINT                     MultipassOffset;&#10;  [in]     UINT                     DmaBufferSegmentId;&#10;  [in]     PHYSICAL_ADDRESS         DmaBufferPhysicalAddress;&#10;} DXGKARG_RENDER;">DXGKARG_RENDER</a></p>

<p><a href="dxgk_allocationlist" title="typedef struct _DXGK_ALLOCATIONLIST&#10;{&#10;    HANDLE              hDeviceSpecificAllocation;&#10;    struct&#10;    {&#10;        UINT            WriteOperation  : 1;    // 0x00000001&#10;        UINT            SegmentId       : 5;    // 0x0000002E&#10;        UINT            Reserved        : 26;   // 0xFFFFFFC0&#10;    };&#10;#if (DXGKDDI_INTERFACE_VERSION &gt;= DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;    union&#10;    {&#10;        PHYSICAL_ADDRESS        PhysicalAddress;&#10;        D3DGPU_VIRTUAL_ADDRESS  VirtualAddress;&#10;    };&#10;#else // (DXGKDDI_INTERFACE_VERSION &lt; DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;    PHYSICAL_ADDRESS    PhysicalAddress;&#10;#endif // (DXGKDDI_INTERFACE_VERSION &gt;= DXGKDDI_INTERFACE_VERSION_WDDM2_0)&#10;} DXGK_ALLOCATIONLIST;">DXGK_ALLOCATIONLIST</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createcontext">DxgkDdiCreateContext</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createdevice">DxgkDdiCreateDevice</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_openallocationinfo">DxgkDdiOpenAllocation</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_renderkm">DxgkDdiRenderKm</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_render">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dkmddi/nc-d3dkmddi-dxgkddi_render.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
