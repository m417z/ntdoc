<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="STORAGE_REQUEST_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>STORAGE_REQUEST_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            STORAGE_REQUEST_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// minitape.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _STORAGE_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                SrbStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Signature;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Version;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFunction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                RequestTag;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestPriority;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestAttribute;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                TimeOutValue;
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemStatus;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> RequestTagHigh4Bytes;
  } DUMMYUNIONNAME;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SystemStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ZeroGuard1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                AddressOffset;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                NumSrbExData;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                DataTransferLength;
  PVOID POINTER_ALIGN                  DataBuffer;
  PVOID POINTER_ALIGN                  ZeroGuard2;
  PVOID POINTER_ALIGN                  OriginalRequest;
  PVOID POINTER_ALIGN                  ClassContext;
  PVOID POINTER_ALIGN                  PortContext;
  PVOID POINTER_ALIGN                  MiniportContext;
  _STORAGE_REQUEST_BLOCK POINTER_ALIGN *NextSrb;
  struct                               _STORAGE_REQUEST_BLOCK;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbExDataOffset[ANYSIZE_ARRAY];
} STORAGE_REQUEST_BLOCK, *PSTORAGE_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_storage_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _STORAGE_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                SrbStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Signature;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Version;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFunction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                RequestTag;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestPriority;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestAttribute;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                TimeOutValue;
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemStatus;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> RequestTagHigh4Bytes;
  } DUMMYUNIONNAME;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SystemStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ZeroGuard1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                AddressOffset;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                NumSrbExData;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                DataTransferLength;
  PVOID POINTER_ALIGN                  DataBuffer;
  PVOID POINTER_ALIGN                  ZeroGuard2;
  PVOID POINTER_ALIGN                  OriginalRequest;
  PVOID POINTER_ALIGN                  ClassContext;
  PVOID POINTER_ALIGN                  PortContext;
  PVOID POINTER_ALIGN                  MiniportContext;
  _STORAGE_REQUEST_BLOCK POINTER_ALIGN *NextSrb;
  struct                               _STORAGE_REQUEST_BLOCK;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbExDataOffset[ANYSIZE_ARRAY];
} STORAGE_REQUEST_BLOCK, *PSTORAGE_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_storage_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _STORAGE_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                                SrbStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Signature;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                Version;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFunction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ReservedUlong2;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                RequestTag;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestPriority;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                               RequestAttribute;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                TimeOutValue;
  union {
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> SystemStatus;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> RequestTagHigh4Bytes;
  } DUMMYUNIONNAME;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SystemStatus;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                ZeroGuard1;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                AddressOffset;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                NumSrbExData;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                DataTransferLength;
  PVOID POINTER_ALIGN                  DataBuffer;
  PVOID POINTER_ALIGN                  ZeroGuard2;
  PVOID POINTER_ALIGN                  OriginalRequest;
  PVOID POINTER_ALIGN                  ClassContext;
  PVOID POINTER_ALIGN                  PortContext;
  PVOID POINTER_ALIGN                  MiniportContext;
  _STORAGE_REQUEST_BLOCK POINTER_ALIGN *NextSrb;
  struct                               _STORAGE_REQUEST_BLOCK;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                SrbExDataOffset[ANYSIZE_ARRAY];
} STORAGE_REQUEST_BLOCK, *PSTORAGE_REQUEST_BLOCK;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_storage_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/storage_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-minitape-_storage_request_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>STORAGE_REQUEST_BLOCK structure (minitape.h)</h1>
<h2>Description</h2>
<p>The <strong>STORAGE_REQUEST_BLOCK</strong> is the extended format SCSI Request Block (SRB) structure. The structure provides for the addition of extended data associated with an SRB function.</p>
<blockquote>
  <p>[!NOTE]
  The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
</blockquote>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size of the SRB header for compatibility with the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure. This is equal to the offset of the <strong>Signature</strong> member of this structure.</p>
<h3><code>Function</code></h3>
<p>Set to <strong>SRB_FUNCTION_STORAGE_REQUEST_BLOCK</strong> to indicate that this is an extended SRB. Unlike in <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>, the SRB function identifier is in the <strong>SrbFunction</strong> member instead.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the operating system-specific driver that the request has completed by calling <strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong> with <strong>RequestComplete</strong>. <strong>SrbStatus</strong> can be one of the following values.</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_STATUS_PENDING</td>
  <td>Indicates the request is in progress. The operating system-specific port driver initializes <strong>SrbStatus</strong> to this value.</td>
</tr>
<tr>
  <td>SRB_STATUS_SUCCESS</td>
  <td>Indicates the request was completed successfully.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORTED</td>
  <td>Indicates the request was aborted as directed by the port driver. A miniport driver sets this status in the <strong>NextSrb</strong> member for a successful SRB_FUNCTION_ABORT_COMMAND request.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORT_FAILED</td>
  <td>Indicates an attempt to abort the request failed. Return this status for an SRB_FUNCTION_ABORT_COMMAND request when the specified request cannot be located.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR</td>
  <td>Indicates the request was completed with an error in the SCSI bus status.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUSY</td>
  <td>Indicates the miniport driver or target device could not accept the request at this time. The operating system-specific port driver will resubmit the request later.</td>
</tr>
<tr>
  <td>SRB_STATUS_INTERNAL_ERROR</td>
  <td>Indicates that the Storport driver could not deliver the request to the miniport driver or target device. In such cases, status is recorded in <strong>InternalStatus</strong>.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_REQUEST</td>
  <td>Indicates the miniport driver does not support the given request.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_DEVICE</td>
  <td>Indicates the device did not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_TIMEOUT</td>
  <td>Indicates the request timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_SELECTION_TIMEOUT</td>
  <td>Indicates the SCSI device selection timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_COMMAND_TIMEOUT</td>
  <td>Indicates the target did not complete the command within the time limit.</td>
</tr>
<tr>
  <td>SRB_STATUS_MESSAGE_REJECTED</td>
  <td>Indicates the target rejected a message. This is normally returned only for such message-type requests as SRB_FUNCTION_TERMINATE_IO.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUS_RESET</td>
  <td>Indicates a bus reset occurred while this request was being executed.</td>
</tr>
<tr>
  <td>SRB_STATUS_PARITY_ERROR</td>
  <td>Indicates a parity error occurred on the SCSI bus and that a retry failed.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_SENSE_FAILED</td>
  <td>Indicates the request-sense command failed. This is returned only if the host bus adapter (HBA) performs auto request sense and the miniport driver set <strong>AutoRequestSense</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for this HBA.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_HBA</td>
  <td>Indicates the HBA does not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_DATA_OVERRUN</td>
  <td>Indicates that a data overrun or underrun error occurred. The miniport driver also must update the SRB's <strong>DataTransferLength</strong> member to indicate how much data actually was transferred if an underrun occurs.</td>
</tr>
<tr>
  <td>SRB_STATUS_UNEXPECTED_BUS_FREE</td>
  <td>Indicates the target disconnected unexpectedly.</td>
</tr>
<tr>
  <td>SRB_STATUS_PHASE_SEQUENCE_FAILURE</td>
  <td>Indicates the HBA detected an illegal phase sequence failure error.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_FLUSHED</td>
  <td>Indicates the request for status was stopped.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_FUNCTION</td>
  <td>Indicates the SRB <strong>Function</strong> code is not supported.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_PATH_ID</td>
  <td>Indicates the <strong>PathId</strong> specified in the SRB does not exist.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_TARGET_ID</td>
  <td>Indicates the <strong>TargetID</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_LUN</td>
  <td>Indicates the <strong>Lun</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR_RECOVERY</td>
  <td>Indicates the request was completed with an error in the SCSI bus status and that the SCSI INITIATE RECOVERY message was received.</td>
</tr>
<tr>
  <td>SRB_STATUS_AUTOSENSE_VALID</td>
  <td>Indicates information returned in the <strong>SenseInfoBuffer</strong> is valid.</td>
</tr>
<tr>
  <td>SRB_STATUS_QUEUE_FROZEN</td>
  <td>A miniport driver should never set the <strong>SrbStatus</strong> member to this value. The Windows port driver can set this value to inform a storage class driver that its queue of requests for a particular peripheral has been frozen.</td>
</tr>
<tr>
  <td>SRB_STATUS_NOT_POWERED</td>
  <td>A indicates the request failed because the target is not powered. For requests with SRB_FLAGS_NO_KEEP_AWAKE set in <strong>SrbFlags</strong>, requests sent to LUNs that are powered down will fail with this status.</td>
</tr>
<tr>
  <td>SRB_STATUS_LINK_DOWN</td>
  <td>Indicates the request failed because link is down.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_SRB_BLOCK_LENGTH</td>
  <td>Indicates the request failed because SRB length was invalid.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong1</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>Signature</code></h3>
<p>The signature of the extended SRB format. This is set to SRB_SIGNATURE.</p>
<h3><code>Version</code></h3>
<p>The version of the structure used. The current version is <strong>STORAGE_REQUEST_BLOCK_VERSION_1</strong>.</p>
<h3><code>SrbLength</code></h3>
<p>The length of this extended SRB, in bytes, including this structure, address and any SRB extended data.</p>
<h3><code>SrbFunction</code></h3>
<p>Specifies the operation to be performed, which can be one of these values:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FUNCTION_EXECUTE_SCSI (0x00)</td>
  <td>A SCSI device I/O request should be executed on the target logical unit. When <strong>NumSrbExData</strong> &gt; 0, one or more following extended request block structures are located at the offsets specified in <strong>SrbExDataOffset</strong>: <strong><a href="srbex_data_scsi_cdb16" title="typedef struct _SRBEX_DATA_SCSI_CDB16 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[16];&#10;} SRBEX_DATA_SCSI_CDB16, *PSRBEX_DATA_SCSI_CDB16;">SRBEX_DATA_SCSI_CDB16</a></strong>, <strong><a href="srbex_data_scsi_cdb32" title="typedef struct _SRBEX_DATA_SCSI_CDB32 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[32];&#10;} SRBEX_DATA_SCSI_CDB32, *PSRBEX_DATA_SCSI_CDB32;">SRBEX_DATA_SCSI_CDB32</a></strong>, <strong><a href="srbex_data_scsi_cdb_var" title="typedef struct _SRBEX_DATA_SCSI_CDB_VAR {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               Reserved[2];&#10;  ULONG               CdbLength;&#10;  ULONG               Reserved1[2];&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[ANYSIZE_ARRAY];&#10;} SRBEX_DATA_SCSI_CDB_VAR, *PSRBEX_DATA_SCSI_CDB_VAR;">SRBEX_DATA_SCSI_CDB_VAR</a></strong>, <strong><a href="srbex_data_bidirectional" title="typedef struct _SRBEX_DATA_BIDIRECTIONAL {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  ULONG               DataInTransferLength;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataInBuffer;&#10;} SRBEX_DATA_BIDIRECTIONAL, *PSRBEX_DATA_BIDIRECTIONAL;">SRBEX_DATA_BIDIRECTIONAL</a></strong>, <strong><a href="srbex_data_io_info" title="typedef struct _SRBEX_DATA_IO_INFO {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  ULONG         Flags;&#10;  ULONG         Key;&#10;  ULONG         RWLength;&#10;  BOOLEAN       IsWriteRequest;&#10;  UCHAR         CachePriority;&#10;  UCHAR         Reserved[2];&#10;  ULONG         Reserved1[2];&#10;} SRBEX_DATA_IO_INFO, *PSRBEX_DATA_IO_INFO;">SRBEX_DATA_IO_INFO</a></strong></td>
</tr>
<tr>
  <td>SRB_FUNCTION_ABORT_COMMAND (0x10)</td>
  <td>A SCSIMESS_ABORT message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If this is a tagged-queue request, a SCSIMESS_ABORT_WITH_TAG message should be used instead. If the indicated request has been completed, this request should be completed normally. Extended SRB data is not required for this function. <strong>NOTE</strong>: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_DEVICE (0x16)</td>
  <td>The SCSI target controller should be reset using the SCSIMESS_BUS_DEVICE_RESET message. The miniport driver should complete any active requests for the target controller. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_LOGICAL_UNIT (0x20)</td>
  <td>The logical unit should be reset, if possible. The HBA miniport driver should complete any active requests for the logical unit. Extended SRB data is not required for this function. Storport supports this type of reset, but SCSI port does not.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_BUS (0x12)</td>
  <td>The SCSI bus should be reset using the SCSIMESS_BUS_DEVICE_RESET message. A miniport driver receives this request only if a given request has timed out and a subsequent request to abort the timed-out request also has timed out. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_TERMINATE_IO (0x14)</td>
  <td>A SCSIMESS_TERMINATE_IO_PROCESS message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If the indicated request has already completed, this request should be completed normally. Extended SRB data is not required for this function. <strong>NOTE</strong>: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RELEASE_RECOVERY (0x11)</td>
  <td>A SCSIMESS_RELEASE_RECOVERY message should be sent to the target controller. Extended SRB data is not required for this function. <strong>NOTE</strong>: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RECEIVE_EVENT (0x03)</td>
  <td>The HBA should be prepared to receive an asynchronous event notification from the addressed target. The SRB <strong>DataBuffer</strong> member indicates where the data should be placed. <strong>NOTE</strong>: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_SHUTDOWN (0x07)</td>
  <td>The system is being shut down. A miniport driver can receive several of these notifications before all system activity actually stops. However, the last shutdown notification will occur after the last start I/O. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FLUSH (0x08)</td>
  <td>The miniport driver should flush any cached data for the target device. This request is sent to the miniport driver only if it set <strong>CachesData</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_IO_CONTROL (0x02)</td>
  <td>The request is an I/O control request, originating in a user-mode application with a dedicated HBA. The SRB <strong>DataBuffer</strong> points to an <strong><a href="srb_io_control" title="typedef struct _SRB_IO_CONTROL {&#10;  ULONG HeaderLength;&#10;  UCHAR Signature[8];&#10;  ULONG Timeout;&#10;  ULONG ControlCode;&#10;  ULONG ReturnCode;&#10;  ULONG Length;&#10;} SRB_IO_CONTROL, *PSRB_IO_CONTROL;">SRB_IO_CONTROL</a></strong> header followed by the data area. The value in <strong>DataBuffer</strong> can be used by the driver, regardless of the value of <strong>MapBuffers</strong>. Only the SRB <strong>Function</strong>, <strong>SrbFlags</strong>, <strong>TimeOutValue</strong>, <strong>DataBuffer</strong>, and <strong>DataTransferLength</strong> members are valid, along with the <strong>SrbExtension</strong> member if the miniport driver requested SRB extensions when it initialized. If a miniport driver controls an application-dedicated HBA so that it supports this request, the miniport driver should execute the request and notify the operating system-specific port driver when the SRB has completed, using the normal mechanism of calls to <strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong> with <strong>RequestComplete</strong> and <strong>NextRequest</strong>.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_LOCK_QUEUE (0x18)</td>
  <td>Holds requests that are queued by the port driver for a particular logical unit, typically while a power request is being processed. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. When the queue is locked, only requests with <strong>SrbFlags</strong> ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong> will be processed. SCSI miniport drivers do not process <strong>SRB_FUNCTION_LOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_UNLOCK_QUEUE (0x19)</td>
  <td>Releases the port driver's queue for a logical unit that was previously locked with <strong>SRB_FUNCTION_LOCK_QUEUE</strong>. The <strong>SrbFlags</strong> of the unlock request must be ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong>. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. SCSI miniport drivers do not process <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_DUMP_POINTERS (0x26)</td>
  <td>A request with this function is sent to a Storport miniport driver that is used to control the disk that holds the crash dump data. The request collects information needed from the miniport driver to support crash dump and hibernation. See the <strong><a href="miniport_dump_pointers" title="typedef struct _MINIPORT_DUMP_POINTERS {&#10;  USHORT                 Version;&#10;  USHORT                 Size;&#10;  WCHAR                  DriverName[DUMP_MINIPORT_NAME_LENGTH];&#10;  struct _ADAPTER_OBJECT *AdapterObject;&#10;  PVOID                  MappedRegisterBase;&#10;  ULONG                  CommonBufferSize;&#10;  PVOID                  MiniportPrivateDumpData;&#10;  ULONG                  SystemIoBusNumber;&#10;  INTERFACE_TYPE         AdapterInterfaceType;&#10;  ULONG                  MaximumTransferLength;&#10;  ULONG                  NumberOfPhysicalBreaks;&#10;  ULONG                  AlignmentMask;&#10;  ULONG                  NumberOfAccessRanges;&#10;  ACCESS_RANGE( )          *AccessRanges[];&#10;  UCHAR                  NumberOfBuses;&#10;  BOOLEAN                Master;&#10;  BOOLEAN                MapBuffers;&#10;  UCHAR                  MaximumNumberOfTargets;&#10;} MINIPORT_DUMP_POINTERS, *PMINIPORT_DUMP_POINTERS;">MINIPORT_DUMP_POINTERS</a></strong> structure. A physical miniport driver must set the STOR_FEATURE_DUMP_POINTERS flag in the <strong>FeatureSupport</strong> member of its <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> to receive a request with this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FREE_DUMP_POINTERS (0x27)</td>
  <td>A request with this function is sent to a Storport miniport driver to release any resources allocated during a previous request for SRB_FUNCTION_DUMP_POINTERS.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_QUIESCE_DEVICE (0x1A)</td>
  <td>The request is only between a storage class and storage port driver and is not be sent to miniport. This function serves as a wait by the class driver for port driver to complete all outstanding I/Os.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_PNP (0x25)</td>
  <td>The request is a PnP extended request formatted as a <strong><a href="srbex_data_pnp" title="typedef struct _SRBEX_DATA_PNP {&#10;  SRBEXDATATYPE   Type;&#10;  ULONG           Length;&#10;  UCHAR           PnPSubFunction;&#10;  UCHAR           Reserved[3];&#10;  STOR_PNP_ACTION PnPAction;&#10;  ULONG           SrbPnPFlags;&#10;  ULONG           Reserved1;&#10;} SRBEX_DATA_PNP, *PSRBEX_DATA_PNP;">SRBEX_DATA_PNP</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_POWER (0x24)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_power" title="typedef struct _SRBEX_DATA_POWER {&#10;  SRBEXDATATYPE           Type;&#10;  ULONG                   Length;&#10;  UCHAR                   SrbPowerFlags;&#10;  UCHAR                   Reserved[3];&#10;  STOR_DEVICE_POWER_STATE DevicePowerState;&#10;  STOR_POWER_ACTION       PowerAction;&#10;} SRBEX_DATA_POWER, *PSRBEX_DATA_POWER;">SRBEX_DATA_POWER</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_WMI (0x17)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_wmi" title="typedef struct _SRBEX_DATA_WMI {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               WMISubFunction;&#10;  UCHAR               WMIFlags;&#10;  UCHAR               Reserved[2];&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataPath;&#10;} SRBEX_DATA_WMI, *PSRBEX_DATA_WMI;">SRBEX_DATA_WMI</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
</tbody>
</table>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options for the request. <strong>SrbFlags</strong> is read-only, except when <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> is set and miniport drivers of subordinate DMA adapters are required to update <strong>SRB_FLAGS_DATA_IN</strong> or <strong>SRB_FLAGS_DATA_OUT</strong>. This member can have one or more of these flags set.</p>
<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FLAGS_QUEUE_ACTION_ENABLE</td>
  <td>Indicates tagged-queue actions are to be enabled.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_AUTOSENSE</td>
  <td>Indicates request-sense information should not be returned.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_IN</td>
  <td>Indicates data will be transferred from the device to the system.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_OUT</td>
  <td>Indicates data will be transferred from the system to the device.</td>
</tr>
<tr>
  <td>SRB_FLAGS_UNSPECIFIED_DIRECTION</td>
  <td>Defined for backward compatibility with the ASPI/CAM SCSI interfaces, this flag indicates that the transfer direction could be either of the preceding, because both of the preceding flags are set. If this flag is set, a miniport driver should determine the transfer direction by examining the data phase for the target on the SCSI bus.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_DATA_TRANSFER</td>
  <td>Indicates no data transfer with this request. If this is set, the flags <strong>SRB_FLAGS_DATA_OUT</strong>, <strong>SRB_FLAGS_DATA_IN</strong>, and <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> are clear.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_SYNCH_TRANSFER</td>
  <td>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_DISCONNECT</td>
  <td>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_FROZEN_QUEUE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_QUEUE_FREEZE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_IS_ACTIVE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_ALLOCATED_FROM_ZONE</td>
  <td>This flag is irrelevant to miniport drivers and is obsolete to new Windows class drivers. To a Windows legacy class driver, this indicates whether the SRB was allocated from a zone buffer. If this flag is set, the class driver must call <strong><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mmcreatemdl">ExInterlockedFreeToZone</a></strong> to release the SRB; otherwise, it must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong>. New class drivers should use lookaside lists rather than zone buffers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_SGLIST_FROM_POOL</td>
  <td>This flag is irrelevant to miniport drivers. To the class driver, this indicates that memory for a scatter/gather list was allocated from a nonpaged pool. If this flag is set, the class driver must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong> to release the memory after the SRB is completed.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_LOCKED_QUEUE</td>
  <td>This flag is irrelevant to miniport drivers. To the port driver, this flag indicates that the request should be processed whether the logical-unit queue is locked or not. A higher-level driver must set this flag to send an <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_KEEP_AWAKE</td>
  <td>This flag is irrelevant to miniport drivers. A Windows class driver uses this flag to indicate to the port driver to fail the request rather than powering up the device to handle this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_FREE_SENSE_BUFFER</td>
  <td>Indicates that either the port or the miniport driver has allocated a buffer for sense data. This informs the class driver that it must free the sense data buffer after extracting the data.</td>
</tr>
<tr>
  <td>SRB_FLAGS_D3_PROCESSING</td>
  <td>Indicates that the request is part of D3 processing. Miniports that support runtime power control should not call <strong><a href="storportpofxactivatecomponent" title="ULONG StorPortPoFxActivateComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxActivateComponent</a></strong> or <strong><a href="storportpofxidlecomponent" title="ULONG StorPortPoFxIdleComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxIdleComponent</a></strong> with these requests</td>
</tr>
<tr>
  <td>SRB_FLAGS_ADAPTER_CACHE_ENABLE</td>
  <td>Indicates that the adapter can cache data.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong2</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>RequestTag</code></h3>
<p>Contains the queue-tag value assigned by the operating system-specific port driver. If this member is used for tagged queuing, the HBA supports internal queuing of requests to logical units (LUs) and the miniport driver set <strong>TaggedQueueing</strong> to <strong>TRUE</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for this HBA.</p>
<h3><code>RequestPriority</code></h3>
<p>The priority assignment for the SRB.</p>
<h3><code>RequestAttribute</code></h3>
<p>Indicates the tagged-queuing message to be used when the <strong>SRB_FLAGS_QUEUE_ACTION_ENABLE</strong> flag is set. The value can be one of the following: <strong>SRB_SIMPLE_TAG_REQUEST</strong>, <strong>SRB_HEAD_OF_QUEUE_TAG_REQUEST</strong>, or <strong>SRB_ORDERED_QUEUE_TAG_REQUEST</strong>.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval, in seconds, that the request can execute before the operating system-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DUMMYUNIONNAME</code></h3>
<p>Union containing Windows 10 and later fields.</p>
<h3><code>DUMMYUNIONNAME.SystemStatus</code></h3>
<p>Used to store system failure status information in SrbStatus failure conditions (e.g. SRB_STATUS_INTERNAL_ERROR).</p>
<h3><code>DUMMYUNIONNAME.RequestTagHigh4Bytes</code></h3>
<p>Used to store high four bytes of unique tag if unique tag feature is enabled.</p>
<h3><code>SystemStatus</code></h3>
<p>Used by the Storport driver, instead of <strong>SrbStatus</strong>, to report the status of the completed request whenever the request cannot be delivered to the miniport driver. In such cases, <strong>SrbStatus</strong> is set to <strong>SRB_STATUS_INTERNAL_ERROR</strong>. This member is used exclusively for communication between the Storport and the class driver and should not be used by miniport drivers.</p>
<h3><code>ZeroGuard1</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>AddressOffset</code></h3>
<p>The offset of the storage request address from the beginning of this structure. This offset locates a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure that contains the address for the request.</p>
<h3><code>NumSrbExData</code></h3>
<p>The count of extended SRB data blocks for this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size, in bytes, of the data buffer. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. Miniport drivers should not use this value as a data pointer unless the miniport driver set <strong>MapBuffers</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. In the case of SRB_FUNCTION_IO_CONTROL requests, however, miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong>.</p>
<h3><code>ZeroGuard2</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>ClassContext</code></h3>
<p>Points to a class driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>PortContext</code></h3>
<p>Points to a port driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>MiniportContext</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong>. The memory at <strong>MiniportContext</strong> is not initialized by the operating system-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <strong><a href="storportgetphysicaladdress" title="STORPORT_API STOR_PHYSICAL_ADDRESS StorPortGetPhysicalAddress(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           PVOID               VirtualAddress,&#10;  [out]          ULONG               *Length&#10;);">StorPortGetPhysicalAddress</a></strong> with the <strong>MiniportContext</strong> pointer.</p>
<h3><code>NextSrb</code></h3>
<p>Indicates the <strong>STORAGE_REQUEST_BLOCK</strong> to which this request applies. Only a small subset of requests use a second SRB, for example SRB_FUNCTION_ABORT_COMMAND.</p>
<h3><code>_STORAGE_REQUEST_BLOCK</code></h3>
<h3><code>SrbExDataOffset[ANYSIZE_ARRAY]</code></h3>
<p>An array of offsets specifying the location of extended data blocks for the SRB. This array is empty if <strong>NumSrbExData</strong> = 0.</p>
<h2>Remarks</h2>
<p>Starting in Windows 8, an extended SRB type is supported with the use of the <strong>STORAGE_REQUEST_BLOCK</strong> structure. <strong>STORAGE_REQUEST_BLOCK</strong> extends SRB functions, allowing extended data blocks for the SRB function to be added to the request. Support for SRB requests using the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure will continue.</p>
<p>If <strong>NumSrbExData</strong> &gt; 0, the offsets for the SRB extended data blocks are in the <strong>SrbExDataOffset</strong> array. Each offset is relative to the beginning of this structure and points to a <strong><a href="srbex_data" title="typedef struct _SRBEX_DATA {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  UCHAR         Data[ANYSIZE_ARRAY];&#10;} SRBEX_DATA, *PSRBEX_DATA;">SRBEX_DATA</a></strong> structure containing the extended data block.</p>
<p>The target device address for the SRB is in a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure indicated by <strong>AddressOffset</strong>.</p>
<h2>See also</h2>
<ul>
<li><strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_storage_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/minitape/ns-minitape-_storage_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_storage_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>STORAGE_REQUEST_BLOCK structure (srb.h)</h1>
<h2>Description</h2>
<p>The <strong>STORAGE_REQUEST_BLOCK</strong> is the extended format SCSI Request Block (SRB) structure. The structure provides for the addition of extended data associated with an SRB function.</p>
<blockquote>
  <p>[!NOTE]
  The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Use the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models instead.</p>
</blockquote>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size of the SRB header for compatibility with the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure. This is equal to the offset of the <strong>Signature</strong> member of this structure.</p>
<h3><code>Function</code></h3>
<p>Set to <strong>SRB_FUNCTION_STORAGE_REQUEST_BLOCK</strong> to indicate that this is an extended SRB. Unlike in <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>, the SRB function identifier is in the <strong>SrbFunction</strong> member instead.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the operating system-specific driver that the request has completed by calling <strong><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></strong> with <strong>RequestComplete</strong>. The value of this member can be one of the following:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_STATUS_PENDING (0x00)</td>
  <td>Indicates the request is in progress. The operating system-specific port driver initializes <strong>SrbStatus</strong> to this value.</td>
</tr>
<tr>
  <td>SRB_STATUS_SUCCESS (0x01)</td>
  <td>Indicates the request was completed successfully.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORTED (0x02)</td>
  <td>Indicates the request was aborted as directed by the port driver. A miniport driver sets this status in the <strong>NextSrb</strong> member for a successful SRB_FUNCTION_ABORT_COMMAND request.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORT_FAILED (0x03)</td>
  <td>Indicates an attempt to abort the request failed. Return this status for an SRB_FUNCTION_ABORT_COMMAND request when the specified request cannot be located.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR (0x04)</td>
  <td>Indicates the request was completed with an error in the SCSI bus status.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUSY (0x05)</td>
  <td>Indicates the miniport driver or target device could not accept the request at this time. The operating system-specific port driver will resubmit the request later.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_REQUEST (0x06)</td>
  <td>Indicates the miniport driver does not support the given request.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_PATH_ID (0x07)</td>
  <td>Indicates the <strong>PathId</strong> specified in the SRB does not exist.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_DEVICE (0x08)</td>
  <td>Indicates the device did not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_TIMEOUT (0x09)</td>
  <td>Indicates the request timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_SELECTION_TIMEOUT (0x0A)</td>
  <td>Indicates the SCSI device selection timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_COMMAND_TIMEOUT (0x0B)</td>
  <td>Indicates the target did not complete the command within the time limit.</td>
</tr>
<tr>
  <td>SRB_STATUS_MESSAGE_REJECTED (0x0D)</td>
  <td>Indicates the target rejected a message. This is normally returned only for such message-type requests as SRB_FUNCTION_TERMINATE_IO.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUS_RESET (0x0E)</td>
  <td>Indicates a bus reset occurred while this request was being executed.</td>
</tr>
<tr>
  <td>SRB_STATUS_PARITY_ERROR (0x0F)</td>
  <td>Indicates a parity error occurred on the SCSI bus and that a retry failed.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_SENSE_FAILED (0x10)</td>
  <td>Indicates the request-sense command failed. This is returned only if the host bus adapter (HBA) performs auto request sense and the miniport driver set <strong>AutoRequestSense</strong> to TRUE in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for this HBA.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_HBA (0x11)</td>
  <td>Indicates the HBA does not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_DATA_OVERRUN (0x12)</td>
  <td>Indicates that a data overrun or underrun error occurred. The miniport driver also must update the SRB's <strong>DataTransferLength</strong> member to indicate how much data actually was transferred if an underrun occurs.</td>
</tr>
<tr>
  <td>SRB_STATUS_UNEXPECTED_BUS_FREE (0x13)</td>
  <td>Indicates the target disconnected unexpectedly.</td>
</tr>
<tr>
  <td>SRB_STATUS_PHASE_SEQUENCE_FAILURE (0x14)</td>
  <td>Indicates the HBA detected an illegal phase sequence failure error.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_SRB_BLOCK_LENGTH (0x15)</td>
  <td>Indicates the request failed because SRB length was invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_FLUSHED (0x16)</td>
  <td>Indicates the request for status was stopped.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_LUN (0x20)</td>
  <td>Indicates the <strong>Lun</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_TARGET_ID (0x21)</td>
  <td>Indicates the <strong>TargetID</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_FUNCTION (0x22)</td>
  <td>Indicates the SRB <strong>Function</strong> code is not supported.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR_RECOVERY (0x23)</td>
  <td>Indicates the request was completed with an error in the SCSI bus status and that the SCSI INITIATE RECOVERY message was received.</td>
</tr>
<tr>
  <td>SRB_STATUS_NOT_POWERED (0x24)</td>
  <td>A indicates the request failed because the target is not powered. For requests with SRB_FLAGS_NO_KEEP_AWAKE set in <strong>SrbFlags</strong>, requests sent to LUNs that are powered down will fail with this status.</td>
</tr>
<tr>
  <td>SRB_STATUS_LINK_DOWN (0x25)</td>
  <td>Indicates the request failed because link is down.</td>
</tr>
<tr>
  <td>SRB_STATUS_INTERNAL_ERROR (0x30)</td>
  <td>Indicates that the Storport driver could not deliver the request to the miniport driver or target device. In such cases, status is recorded in <strong>InternalStatus</strong>.</td>
</tr>
<tr>
  <td>SRB_STATUS_QUEUE_FROZEN (0x40)</td>
  <td>A miniport driver should never set the <strong>SrbStatus</strong> member to this value. The Windows port driver can set this value to inform a storage class driver that its queue of requests for a particular peripheral has been frozen.</td>
</tr>
<tr>
  <td>SRB_STATUS_AUTOSENSE_VALID (0x80)</td>
  <td>Indicates information returned in the <strong>SenseInfoBuffer</strong> is valid.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong1</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>Signature</code></h3>
<p>The signature of the extended SRB format. This is set to SRB_SIGNATURE.</p>
<h3><code>Version</code></h3>
<p>The version of the structure used. The current version is <strong>STORAGE_REQUEST_BLOCK_VERSION_1</strong>.</p>
<h3><code>SrbLength</code></h3>
<p>The length of this extended SRB, in bytes, including this structure, address and any SRB extended data.</p>
<h3><code>SrbFunction</code></h3>
<p>Specifies the operation to be performed, which can be one of these values:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FUNCTION_EXECUTE_SCSI (0x00)</td>
  <td>A SCSI device I/O request should be executed on the target logical unit. When <strong>NumSrbExData</strong> &gt; 0, one or more of the following extended request block structures are located at the offsets specified in <strong>SrbExDataOffset</strong>: <strong><a href="srbex_data_scsi_cdb16" title="typedef struct _SRBEX_DATA_SCSI_CDB16 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[16];&#10;} SRBEX_DATA_SCSI_CDB16, *PSRBEX_DATA_SCSI_CDB16;">SRBEX_DATA_SCSI_CDB16</a></strong>, <strong><a href="srbex_data_scsi_cdb32" title="typedef struct _SRBEX_DATA_SCSI_CDB32 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[32];&#10;} SRBEX_DATA_SCSI_CDB32, *PSRBEX_DATA_SCSI_CDB32;">SRBEX_DATA_SCSI_CDB32</a></strong>, <strong><a href="srbex_data_scsi_cdb_var" title="typedef struct _SRBEX_DATA_SCSI_CDB_VAR {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               Reserved[2];&#10;  ULONG               CdbLength;&#10;  ULONG               Reserved1[2];&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[ANYSIZE_ARRAY];&#10;} SRBEX_DATA_SCSI_CDB_VAR, *PSRBEX_DATA_SCSI_CDB_VAR;">SRBEX_DATA_SCSI_CDB_VAR</a></strong>, <strong><a href="srbex_data_bidirectional" title="typedef struct _SRBEX_DATA_BIDIRECTIONAL {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  ULONG               DataInTransferLength;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataInBuffer;&#10;} SRBEX_DATA_BIDIRECTIONAL, *PSRBEX_DATA_BIDIRECTIONAL;">SRBEX_DATA_BIDIRECTIONAL</a></strong>, <strong><a href="srbex_data_io_info" title="typedef struct _SRBEX_DATA_IO_INFO {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  ULONG         Flags;&#10;  ULONG         Key;&#10;  ULONG         RWLength;&#10;  BOOLEAN       IsWriteRequest;&#10;  UCHAR         CachePriority;&#10;  UCHAR         Reserved[2];&#10;  ULONG         Reserved1[2];&#10;} SRBEX_DATA_IO_INFO, *PSRBEX_DATA_IO_INFO;">SRBEX_DATA_IO_INFO</a></strong></td>
</tr>
<tr>
  <td>SRB_FUNCTION_IO_CONTROL (0x02)</td>
  <td>The request is an I/O control request, originating in a user-mode application with a dedicated HBA. The SRB <strong>DataBuffer</strong> points to an <strong><a href="srb_io_control" title="typedef struct _SRB_IO_CONTROL {&#10;  ULONG HeaderLength;&#10;  UCHAR Signature[8];&#10;  ULONG Timeout;&#10;  ULONG ControlCode;&#10;  ULONG ReturnCode;&#10;  ULONG Length;&#10;} SRB_IO_CONTROL, *PSRB_IO_CONTROL;">SRB_IO_CONTROL</a></strong> header followed by the data area. The value in <strong>DataBuffer</strong> can be used by the driver, regardless of the value of <strong>MapBuffers</strong>. Only the SRB <strong>Function</strong>, <strong>SrbFlags</strong>, <strong>TimeOutValue</strong>, <strong>DataBuffer</strong>, and <strong>DataTransferLength</strong> members are valid, along with the <strong>SrbExtension</strong> member if the miniport driver requested SRB extensions when it initialized. If a miniport driver controls an application-dedicated HBA so that it supports this request, the miniport driver should execute the request and notify the operating system-specific port driver when the SRB has completed, using the normal mechanism of calls to <strong><a href="scsiportnotification" title="SCSIPORT_API VOID ScsiPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">ScsiPortNotification</a></strong> with <strong>RequestComplete</strong> and <strong>NextRequest</strong>.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RECEIVE_EVENT (0x03)</td>
  <td>The HBA should be prepared to receive an asynchronous event notification from the addressed target. The SRB <strong>DataBuffer</strong> member indicates where the data should be placed. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_SHUTDOWN (0x07)</td>
  <td>The system is being shut down. A miniport driver can receive several of these notifications before all system activity actually stops. However, the last shutdown notification will occur after the last start I/O. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FLUSH (0x08)</td>
  <td>The miniport driver should flush any cached data for the target device. This request is sent to the miniport driver only if it set <strong>CachesData</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_ABORT_COMMAND (0x10)</td>
  <td>A SCSIMESS_ABORT message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If this is a tagged-queue request, a SCSIMESS_ABORT_WITH_TAG message should be used instead. If the indicated request has been completed, this request should be completed normally. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RELEASE_RECOVERY (0x11)</td>
  <td>A SCSIMESS_RELEASE_RECOVERY message should be sent to the target controller. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_BUS (0x12)</td>
  <td>The SCSI bus should be reset using the SCSIMESS_BUS_DEVICE_RESET message. A miniport driver receives this request only if a given request has timed out and a subsequent request to abort the timed-out request also has timed out. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_TERMINATE_IO (0x14)</td>
  <td>A SCSIMESS_TERMINATE_IO_PROCESS message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If the indicated request has already completed, this request should be completed normally. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_DEVICE (0x16)</td>
  <td>The SCSI target controller should be reset using the SCSIMESS_BUS_DEVICE_RESET message. The miniport driver should complete any active requests for the target controller. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_WMI (0x17)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_wmi" title="typedef struct _SRBEX_DATA_WMI {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               WMISubFunction;&#10;  UCHAR               WMIFlags;&#10;  UCHAR               Reserved[2];&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataPath;&#10;} SRBEX_DATA_WMI, *PSRBEX_DATA_WMI;">SRBEX_DATA_WMI</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_LOCK_QUEUE (0x18)</td>
  <td>Holds requests that are queued by the port driver for a particular logical unit, typically while a power request is being processed. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. When the queue is locked, only requests with <strong>SrbFlags</strong> ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong> will be processed. SCSI miniport drivers do not process <strong>SRB_FUNCTION_LOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_UNLOCK_QUEUE (0x19)</td>
  <td>Releases the port driver's queue for a logical unit that was previously locked with <strong>SRB_FUNCTION_LOCK_QUEUE</strong>. The <strong>SrbFlags</strong> of the unlock request must be ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong>. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. SCSI miniport drivers do not process <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_QUIESCE_DEVICE (0x1A)</td>
  <td>The request is only between a storage class and storage port driver and is not be sent to miniport. This function serves as a wait by the class driver for port driver to complete all outstanding I/Os.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_LOGICAL_UNIT (0x20)</td>
  <td>The logical unit should be reset, if possible. The HBA miniport driver should complete any active requests for the logical unit. Extended SRB data is not required for this function. Storport supports this type of reset, but SCSI port does not.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_POWER (0x24)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_power" title="typedef struct _SRBEX_DATA_POWER {&#10;  SRBEXDATATYPE           Type;&#10;  ULONG                   Length;&#10;  UCHAR                   SrbPowerFlags;&#10;  UCHAR                   Reserved[3];&#10;  STOR_DEVICE_POWER_STATE DevicePowerState;&#10;  STOR_POWER_ACTION       PowerAction;&#10;} SRBEX_DATA_POWER, *PSRBEX_DATA_POWER;">SRBEX_DATA_POWER</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_PNP (0x25)</td>
  <td>The request is a PnP extended request formatted as a <strong><a href="srbex_data_pnp" title="typedef struct _SRBEX_DATA_PNP {&#10;  SRBEXDATATYPE   Type;&#10;  ULONG           Length;&#10;  UCHAR           PnPSubFunction;&#10;  UCHAR           Reserved[3];&#10;  STOR_PNP_ACTION PnPAction;&#10;  ULONG           SrbPnPFlags;&#10;  ULONG           Reserved1;&#10;} SRBEX_DATA_PNP, *PSRBEX_DATA_PNP;">SRBEX_DATA_PNP</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_DUMP_POINTERS (0x26)</td>
  <td>A request with this function is sent to a Storport miniport driver that is used to control the disk that holds the crash dump data. The request collects information needed from the miniport driver to support crash dump and hibernation. See the <strong><a href="miniport_dump_pointers" title="typedef struct _MINIPORT_DUMP_POINTERS {&#10;  USHORT                 Version;&#10;  USHORT                 Size;&#10;  WCHAR                  DriverName[DUMP_MINIPORT_NAME_LENGTH];&#10;  struct _ADAPTER_OBJECT *AdapterObject;&#10;  PVOID                  MappedRegisterBase;&#10;  ULONG                  CommonBufferSize;&#10;  PVOID                  MiniportPrivateDumpData;&#10;  ULONG                  SystemIoBusNumber;&#10;  INTERFACE_TYPE         AdapterInterfaceType;&#10;  ULONG                  MaximumTransferLength;&#10;  ULONG                  NumberOfPhysicalBreaks;&#10;  ULONG                  AlignmentMask;&#10;  ULONG                  NumberOfAccessRanges;&#10;  ACCESS_RANGE( )          *AccessRanges[];&#10;  UCHAR                  NumberOfBuses;&#10;  BOOLEAN                Master;&#10;  BOOLEAN                MapBuffers;&#10;  UCHAR                  MaximumNumberOfTargets;&#10;} MINIPORT_DUMP_POINTERS, *PMINIPORT_DUMP_POINTERS;">MINIPORT_DUMP_POINTERS</a></strong> structure. A physical miniport driver must set the STOR_FEATURE_DUMP_POINTERS flag in the <strong>FeatureSupport</strong> member of its <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> to receive a request with this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FREE_DUMP_POINTERS (0x27)</td>
  <td>A request with this function is sent to a Storport miniport driver to release any resources allocated during a previous request for SRB_FUNCTION_DUMP_POINTERS.</td>
</tr>
</tbody>
</table>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options for the request. <strong>SrbFlags</strong> is read-only, except when <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> is set and miniport drivers of subordinate DMA adapters are required to update <strong>SRB_FLAGS_DATA_IN</strong> or <strong>SRB_FLAGS_DATA_OUT</strong>. This member can have one or more of these flags set.</p>
<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FLAGS_NO_DATA_TRANSFER (0x00000000)</td>
  <td>Indicates no data transfer with this request. If this is set, the flags <strong>SRB_FLAGS_DATA_OUT</strong>, <strong>SRB_FLAGS_DATA_IN</strong>, and <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> are clear.</td>
</tr>
<tr>
  <td>SRB_FLAGS_QUEUE_ACTION_ENABLE (0x00000002)</td>
  <td>Indicates tagged-queue actions are to be enabled.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_DISCONNECT (0x00000004)</td>
  <td>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_SYNCH_TRANSFER (0x00000008)</td>
  <td>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_FROZEN_QUEUE (0x00000010)</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_AUTOSENSE (0x00000020)</td>
  <td>Indicates request-sense information should not be returned.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_IN (0x00000040)</td>
  <td>Indicates data will be transferred from the device to the system.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_OUT (0x00000080)</td>
  <td>Indicates data will be transferred from the system to the device.</td>
</tr>
<tr>
  <td>SRB_FLAGS_UNSPECIFIED_DIRECTION (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)</td>
  <td>Defined for backward compatibility with the ASPI/CAM SCSI interfaces, this flag indicates that the transfer direction could be either of the preceding, because both of the preceding flags are set. If this flag is set, a miniport driver should determine the transfer direction by examining the data phase for the target on the SCSI bus.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_QUEUE_FREEZE (0x00000100)</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_ADAPTER_CACHE_ENABLE (0x00000200)</td>
  <td>Indicates that the adapter can cache data.</td>
</tr>
<tr>
  <td>SRB_FLAGS_FREE_SENSE_BUFFER (0x00000400)</td>
  <td>Indicates that either the port or the miniport driver has allocated a buffer for sense data. This informs the class driver that it must free the sense data buffer after extracting the data.</td>
</tr>
<tr>
  <td>SRB_FLAGS_D3_PROCESSING (0x00000800)</td>
  <td>Indicates that the request is part of D3 processing. Miniports that support runtime power control should not call <strong><a href="storportpofxactivatecomponent" title="ULONG StorPortPoFxActivateComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxActivateComponent</a></strong> or <strong><a href="storportpofxidlecomponent" title="ULONG StorPortPoFxIdleComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxIdleComponent</a></strong> with these requests.</td>
</tr>
<tr>
  <td>SRB_FLAGS_SEQUENTIAL_REQUIRED (0x00001000)</td>
  <td>Indicates that the LBA range falls into the sequential write required zone.</td>
</tr>
<tr>
  <td>SRB_FLAGS_IS_ACTIVE (0x00010000)</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_ALLOCATED_FROM_ZONE (0x00020000)</td>
  <td>This flag is irrelevant to miniport drivers and is obsolete to new Windows class drivers. To a Windows legacy class driver, this indicates whether the SRB was allocated from a zone buffer. If this flag is set, the class driver must call <strong><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mmcreatemdl">ExInterlockedFreeToZone</a></strong> to release the SRB; otherwise, it must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong>. New class drivers should use lookaside lists rather than zone buffers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_SGLIST_FROM_POOL (0x00040000)</td>
  <td>This flag is irrelevant to miniport drivers. To the class driver, this indicates that memory for a scatter/gather list was allocated from a nonpaged pool. If this flag is set, the class driver must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong> to release the memory after the SRB is completed.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_LOCKED_QUEUE (0x00080000)</td>
  <td>This flag is irrelevant to miniport drivers. To the port driver, this flag indicates that the request should be processed whether the logical-unit queue is locked or not. A higher-level driver must set this flag to send an <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_KEEP_AWAKE (0x00100000)</td>
  <td>This flag is irrelevant to miniport drivers. A Windows class driver uses this flag to indicate to the port driver to fail the request rather than powering up the device to handle this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_PORT_DRIVER_ALLOCSENSE (0x00200000)</td>
  <td>The port driver needs to allocate the sense buffer for the SRB.</td>
</tr>
<tr>
  <td>SRB_FLAGS_PORT_DRIVER_SENSEHASPORT (0x00400000)</td>
  <td>Deprecated; do not use.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DONT_START_NEXT_PACKET (0x00800000)</td>
  <td>Deprecated; do not use.</td>
</tr>
<tr>
  <td>SRB_FLAGS_PORT_DRIVER_RESERVED (0x0F000000)</td>
  <td>Reserved for system use.</td>
</tr>
<tr>
  <td>SRB_FLAGS_CLASS_DRIVER_RESERVED (0xF0000000)</td>
  <td>Reserved for system use.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong2</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>RequestTag</code></h3>
<p>Contains the queue-tag value assigned by the operating system-specific port driver. If this member is used for tagged queuing, the HBA supports internal queuing of requests to logical units (LUs) and the miniport driver set <strong>TaggedQueueing</strong> to <strong>TRUE</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for this HBA.</p>
<h3><code>RequestPriority</code></h3>
<p>The priority assignment for the SRB. This is one of the following <strong>_STOR_IO_PRIORITY_HINT</strong> values:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>StorIoPriorityVeryLow (0)</td>
  <td>Very low priority.</td>
</tr>
<tr>
  <td>StorIoPriorityLow (1)</td>
  <td>Low priority.</td>
</tr>
<tr>
  <td>StorIoPriorityNormal (2)</td>
  <td>Normal priority.</td>
</tr>
<tr>
  <td>StorIoPriorityHigh (3)</td>
  <td>High priority.</td>
</tr>
<tr>
  <td>StorIoPriorityCritical (4)</td>
  <td>Critical priority.</td>
</tr>
</tbody>
</table>
<h3><code>RequestAttribute</code></h3>
<p>Indicates the tagged-queuing message to be used when the <strong>SRB_FLAGS_QUEUE_ACTION_ENABLE</strong> flag is set. The value can be one of the following: <strong>SRB_SIMPLE_TAG_REQUEST</strong>, <strong>SRB_HEAD_OF_QUEUE_TAG_REQUEST</strong>, or <strong>SRB_ORDERED_QUEUE_TAG_REQUEST</strong>.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval, in seconds, that the request can execute before the operating system-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DUMMYUNIONNAME</code></h3>
<p>Embedded union.</p>
<h3><code>DUMMYUNIONNAME.SystemStatus</code></h3>
<p>Used to store system failure status information in SrbStatus failure conditions (for example, SRB_STATUS_INTERNAL_ERROR).</p>
<h3><code>DUMMYUNIONNAME.RequestTagHigh4Bytes</code></h3>
<p>Used to store high four bytes of unique tag if unique tag feature is enabled.</p>
<h3><code>SystemStatus</code></h3>
<p>Used by the Storport driver, instead of <strong>SrbStatus</strong>, to report the status of the completed request whenever the request cannot be delivered to the miniport driver. In such cases, <strong>SrbStatus</strong> is set to <strong>SRB_STATUS_INTERNAL_ERROR</strong>. This member is used exclusively for communication between the Storport and the class driver and should not be used by miniport drivers.</p>
<h3><code>ZeroGuard1</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>AddressOffset</code></h3>
<p>The offset of the storage request address from the beginning of this structure. This offset locates a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure that contains the address for the request.</p>
<h3><code>NumSrbExData</code></h3>
<p>The count of extended SRB data blocks for this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size, in bytes, of the data buffer. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. Miniport drivers should not use this value as a data pointer unless the miniport driver set <strong>MapBuffers</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. In the case of SRB_FUNCTION_IO_CONTROL requests, however, miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong>.</p>
<h3><code>ZeroGuard2</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>ClassContext</code></h3>
<p>Points to a class driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>PortContext</code></h3>
<p>Points to a port driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>MiniportContext</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong>. The memory at <strong>MiniportContext</strong> is not initialized by the operating system-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <strong><a href="scsiportgetphysicaladdress" title="SCSIPORT_API SCSI_PHYSICAL_ADDRESS ScsiPortGetPhysicalAddress(&#10;  [in]  PVOID               HwDeviceExtension,&#10;  [in]  PSCSI_REQUEST_BLOCK Srb,&#10;  [in]  PVOID               VirtualAddress,&#10;  [out] ULONG               *Length&#10;);">ScsiPortGetPhysicalAddress</a></strong> with the <strong>MiniportContext</strong> pointer.</p>
<h3><code>NextSrb</code></h3>
<p>Indicates the <strong>STORAGE_REQUEST_BLOCK</strong> to which this request applies. Only a small subset of requests use a second SRB, for example SRB_FUNCTION_ABORT_COMMAND.</p>
<h3><code>_STORAGE_REQUEST_BLOCK</code></h3>
<h3><code>SrbExDataOffset[ANYSIZE_ARRAY]</code></h3>
<p>An array of offsets specifying the location of extended data blocks for the SRB. This array is empty if <strong>NumSrbExData</strong> = 0.</p>
<h2>Remarks</h2>
<p>Starting in Windows 8, an extended SRB type is supported with the use of the <strong>STORAGE_REQUEST_BLOCK</strong> structure. <strong>STORAGE_REQUEST_BLOCK</strong> extends SRB functions, allowing extended data blocks for the SRB function to be added to the request. Support for SRB requests using the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure will continue.</p>
<p>If <strong>NumSrbExData</strong> &gt; 0, the offsets for the SRB extended data blocks are in the <strong>SrbExDataOffset</strong> array. Each offset is relative to the beginning of this structure and points to a <strong><a href="srbex_data" title="typedef struct _SRBEX_DATA {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  UCHAR         Data[ANYSIZE_ARRAY];&#10;} SRBEX_DATA, *PSRBEX_DATA;">SRBEX_DATA</a></strong> structure containing the extended data block.</p>
<p>The target device address for the SRB is in a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure indicated by <strong>AddressOffset</strong>.</p>
<h2>See also</h2>
<ul>
<li><strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong></li>
<li><strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_storage_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_storage_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_storage_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>STORAGE_REQUEST_BLOCK structure (storport.h)</h1>
<h2>Description</h2>
<p>The <strong>STORAGE_REQUEST_BLOCK</strong> is the extended format SCSI Request Block (SRB) structure. The structure provides for the addition of extended data associated with an SRB function.</p>
<blockquote>
  <p>[!NOTE]</p>
  
  <p>The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport driver</a> models.</p>
</blockquote>
<h2>Members</h2>
<h3><code>Length</code></h3>
<p>Specifies the size of the SRB header for compatibility with the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure. This is equal to the offset of the <strong>Signature</strong> member of this structure.</p>
<h3><code>Function</code></h3>
<p>Set to <strong>SRB_FUNCTION_STORAGE_REQUEST_BLOCK</strong> to indicate that this is an extended SRB. Unlike in <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>, the SRB function identifier is in the <strong>SrbFunction</strong> member instead.</p>
<h3><code>SrbStatus</code></h3>
<p>Returns the status of the completed request. This member should be set by the miniport driver before it notifies the operating system-specific driver that the request has completed by calling <strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong> with <strong>RequestComplete</strong>. The value of this member can be one of the following:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_STATUS_PENDING</td>
  <td>Indicates the request is in progress. The operating system-specific port driver initializes <strong>SrbStatus</strong> to this value.</td>
</tr>
<tr>
  <td>SRB_STATUS_SUCCESS</td>
  <td>Indicates the request was completed successfully.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORTED</td>
  <td>Indicates the request was aborted as directed by the port driver. A miniport driver sets this status in the <strong>NextSrb</strong> member for a successful SRB_FUNCTION_ABORT_COMMAND request.</td>
</tr>
<tr>
  <td>SRB_STATUS_ABORT_FAILED</td>
  <td>Indicates an attempt to abort the request failed. Return this status for an SRB_FUNCTION_ABORT_COMMAND request when the specified request cannot be located.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR</td>
  <td>Indicates the request was completed with an error in the SCSI bus status.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUSY</td>
  <td>Indicates the miniport driver or target device could not accept the request at this time. The operating system-specific port driver will resubmit the request later.</td>
</tr>
<tr>
  <td>SRB_STATUS_INTERNAL_ERROR</td>
  <td>Indicates that the Storport driver could not deliver the request to the miniport driver or target device. In such cases, status is recorded in <strong>InternalStatus</strong>.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_REQUEST</td>
  <td>Indicates the miniport driver does not support the given request.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_DEVICE</td>
  <td>Indicates the device did not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_TIMEOUT</td>
  <td>Indicates the request timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_SELECTION_TIMEOUT</td>
  <td>Indicates the SCSI device selection timed out.</td>
</tr>
<tr>
  <td>SRB_STATUS_COMMAND_TIMEOUT</td>
  <td>Indicates the target did not complete the command within the time limit.</td>
</tr>
<tr>
  <td>SRB_STATUS_MESSAGE_REJECTED</td>
  <td>Indicates the target rejected a message. This is normally returned only for such message-type requests as SRB_FUNCTION_TERMINATE_IO.</td>
</tr>
<tr>
  <td>SRB_STATUS_BUS_RESET</td>
  <td>Indicates a bus reset occurred while this request was being executed.</td>
</tr>
<tr>
  <td>SRB_STATUS_PARITY_ERROR</td>
  <td>Indicates a parity error occurred on the SCSI bus and that a retry failed.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_SENSE_FAILED</td>
  <td>Indicates the request-sense command failed. This is returned only if the host bus adapter (HBA) performs auto request sense and the miniport driver set <strong>AutoRequestSense</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for this HBA.</td>
</tr>
<tr>
  <td>SRB_STATUS_NO_HBA</td>
  <td>Indicates the HBA does not respond.</td>
</tr>
<tr>
  <td>SRB_STATUS_DATA_OVERRUN</td>
  <td>Indicates that a data overrun or underrun error occurred. The miniport driver also must update the SRB's <strong>DataTransferLength</strong> member to indicate how much data actually was transferred if an underrun occurs.</td>
</tr>
<tr>
  <td>SRB_STATUS_UNEXPECTED_BUS_FREE</td>
  <td>Indicates the target disconnected unexpectedly.</td>
</tr>
<tr>
  <td>SRB_STATUS_PHASE_SEQUENCE_FAILURE</td>
  <td>Indicates the HBA detected an illegal phase sequence failure error.</td>
</tr>
<tr>
  <td>SRB_STATUS_REQUEST_FLUSHED</td>
  <td>Indicates the request for status was stopped.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_FUNCTION</td>
  <td>Indicates the SRB <strong>Function</strong> code is not supported.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_PATH_ID</td>
  <td>Indicates the <strong>PathId</strong> specified in the SRB does not exist.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_TARGET_ID</td>
  <td>Indicates the <strong>TargetID</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_INVALID_LUN</td>
  <td>Indicates the <strong>Lun</strong> value in the SRB is invalid.</td>
</tr>
<tr>
  <td>SRB_STATUS_ERROR_RECOVERY</td>
  <td>Indicates the request was completed with an error in the SCSI bus status and that the SCSI INITIATE RECOVERY message was received.</td>
</tr>
<tr>
  <td>SRB_STATUS_AUTOSENSE_VALID</td>
  <td>Indicates information returned in the <strong>SenseInfoBuffer</strong> is valid.</td>
</tr>
<tr>
  <td>SRB_STATUS_QUEUE_FROZEN</td>
  <td>A miniport driver should never set the <strong>SrbStatus</strong> member to this value. The Windows port driver can set this value to inform a storage class driver that its queue of requests for a particular peripheral has been frozen.</td>
</tr>
<tr>
  <td>SRB_STATUS_NOT_POWERED</td>
  <td>A indicates the request failed because the target is not powered. For requests with SRB_FLAGS_NO_KEEP_AWAKE set in <strong>SrbFlags</strong>, requests sent to LUNs that are powered down will fail with this status.</td>
</tr>
<tr>
  <td>SRB_STATUS_LINK_DOWN</td>
  <td>Indicates the request failed because link is down.</td>
</tr>
<tr>
  <td>SRB_STATUS_BAD_SRB_BLOCK_LENGTH</td>
  <td>Indicates the request failed because SRB length was invalid.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong1</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>Signature</code></h3>
<p>The signature of the extended SRB format. This is set to SRB_SIGNATURE.</p>
<h3><code>Version</code></h3>
<p>The version of the structure used. The current version is <strong>STORAGE_REQUEST_BLOCK_VERSION_1</strong>.</p>
<h3><code>SrbLength</code></h3>
<p>The length of this extended SRB, in bytes, including this structure, address and any SRB extended data.</p>
<h3><code>SrbFunction</code></h3>
<p>Specifies the operation to be performed, which can be one of these values:</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FUNCTION_EXECUTE_SCSI (0x00)</td>
  <td>A SCSI device I/O request should be executed on the target logical unit. When <strong>NumSrbExData</strong> &gt; 0, one or more of the following extended request block structures are located at the offsets specified in <strong>SrbExDataOffset</strong>: <a href="srbex_data_scsi_cdb16" title="typedef struct _SRBEX_DATA_SCSI_CDB16 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[16];&#10;} SRBEX_DATA_SCSI_CDB16, *PSRBEX_DATA_SCSI_CDB16;">SRBEX_DATA_SCSI_CDB16</a>, <a href="srbex_data_scsi_cdb32" title="typedef struct _SRBEX_DATA_SCSI_CDB32 {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               CdbLength;&#10;  UCHAR               Reserved;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[32];&#10;} SRBEX_DATA_SCSI_CDB32, *PSRBEX_DATA_SCSI_CDB32;">SRBEX_DATA_SCSI_CDB32</a>, <a href="srbex_data_scsi_cdb_var" title="typedef struct _SRBEX_DATA_SCSI_CDB_VAR {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               ScsiStatus;&#10;  UCHAR               SenseInfoBufferLength;&#10;  UCHAR               Reserved[2];&#10;  ULONG               CdbLength;&#10;  ULONG               Reserved1[2];&#10;  PVOID POINTER_ALIGN SenseInfoBuffer;&#10;  UCHAR POINTER_ALIGN Cdb[ANYSIZE_ARRAY];&#10;} SRBEX_DATA_SCSI_CDB_VAR, *PSRBEX_DATA_SCSI_CDB_VAR;">SRBEX_DATA_SCSI_CDB_VAR</a>, <a href="srbex_data_bidirectional" title="typedef struct _SRBEX_DATA_BIDIRECTIONAL {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  ULONG               DataInTransferLength;&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataInBuffer;&#10;} SRBEX_DATA_BIDIRECTIONAL, *PSRBEX_DATA_BIDIRECTIONAL;">SRBEX_DATA_BIDIRECTIONAL</a>, <a href="srbex_data_io_info" title="typedef struct _SRBEX_DATA_IO_INFO {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  ULONG         Flags;&#10;  ULONG         Key;&#10;  ULONG         RWLength;&#10;  BOOLEAN       IsWriteRequest;&#10;  UCHAR         CachePriority;&#10;  UCHAR         Reserved[2];&#10;  ULONG         Reserved1[2];&#10;} SRBEX_DATA_IO_INFO, *PSRBEX_DATA_IO_INFO;">SRBEX_DATA_IO_INFO</a></td>
</tr>
<tr>
  <td>SRB_FUNCTION_IO_CONTROL (0x02)</td>
  <td>The request is an I/O control request, originating in a user-mode application with a dedicated HBA. The SRB <strong>DataBuffer</strong> points to an <strong><a href="srb_io_control" title="typedef struct _SRB_IO_CONTROL {&#10;  ULONG HeaderLength;&#10;  UCHAR Signature[8];&#10;  ULONG Timeout;&#10;  ULONG ControlCode;&#10;  ULONG ReturnCode;&#10;  ULONG Length;&#10;} SRB_IO_CONTROL, *PSRB_IO_CONTROL;">SRB_IO_CONTROL</a></strong> header followed by the data area. The value in <strong>DataBuffer</strong> can be used by the driver, regardless of the value of <strong>MapBuffers</strong>. Only the SRB <strong>Function</strong>, <strong>SrbFlags</strong>, <strong>TimeOutValue</strong>, <strong>DataBuffer</strong>, and <strong>DataTransferLength</strong> members are valid, along with the <strong>SrbExtension</strong> member if the miniport driver requested SRB extensions when it initialized. If a miniport driver controls an application-dedicated HBA so that it supports this request, the miniport driver should execute the request and notify the operating system-specific port driver when the SRB has completed, using the normal mechanism of calls to <strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong> with <strong>RequestComplete</strong> and <strong>NextRequest</strong>.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RECEIVE_EVENT (0x03)</td>
  <td>The HBA should be prepared to receive an asynchronous event notification from the addressed target. The SRB <strong>DataBuffer</strong> member indicates where the data should be placed. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_SHUTDOWN (0x07)</td>
  <td>The system is being shut down. A miniport driver can receive several of these notifications before all system activity actually stops. However, the last shutdown notification will occur after the last start I/O. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FLUSH (0x08)</td>
  <td>The miniport driver should flush any cached data for the target device. This request is sent to the miniport driver only if it set <strong>CachesData</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_ABORT_COMMAND (0x10)</td>
  <td>A SCSIMESS_ABORT message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If this is a tagged-queue request, a SCSIMESS_ABORT_WITH_TAG message should be used instead. If the indicated request has been completed, this request should be completed normally. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RELEASE_RECOVERY (0x11)</td>
  <td>A SCSIMESS_RELEASE_RECOVERY message should be sent to the target controller. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_BUS (0x12)</td>
  <td>The SCSI bus should be reset using the SCSIMESS_BUS_DEVICE_RESET message. A miniport driver receives this request only if a given request has timed out and a subsequent request to abort the timed-out request also has timed out. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_TERMINATE_IO (0x14)</td>
  <td>A SCSIMESS_TERMINATE_IO_PROCESS message should be sent to cancel the request pointed to by the <strong>NextSrb</strong> member. If the indicated request has already completed, this request should be completed normally. Extended SRB data is not required for this function. NOTE: This function is not sent to the miniport by Storport.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_DEVICE (0x16)</td>
  <td>The SCSI target controller should be reset using the SCSIMESS_BUS_DEVICE_RESET message. The miniport driver should complete any active requests for the target controller. Extended SRB data is not required for this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_WMI (0x17)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_wmi" title="typedef struct _SRBEX_DATA_WMI {&#10;  SRBEXDATATYPE       Type;&#10;  ULONG               Length;&#10;  UCHAR               WMISubFunction;&#10;  UCHAR               WMIFlags;&#10;  UCHAR               Reserved[2];&#10;  ULONG               Reserved1;&#10;  PVOID POINTER_ALIGN DataPath;&#10;} SRBEX_DATA_WMI, *PSRBEX_DATA_WMI;">SRBEX_DATA_WMI</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_LOCK_QUEUE (0x18)</td>
  <td>Holds requests that are queued by the port driver for a particular logical unit, typically while a power request is being processed. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. When the queue is locked, only requests with <strong>SrbFlags</strong> ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong> will be processed. SCSI miniport drivers do not process <strong>SRB_FUNCTION_LOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_UNLOCK_QUEUE (0x19)</td>
  <td>Releases the port driver's queue for a logical unit that was previously locked with <strong>SRB_FUNCTION_LOCK_QUEUE</strong>. The <strong>SrbFlags</strong> of the unlock request must be ORed with <strong>SRB_FLAGS_BYPASS_LOCKED_QUEUE</strong>. Only the SRB <strong>Length</strong>, <strong>Function</strong>, <strong>SrbFlags</strong>, and <strong>OriginalRequest</strong> members are valid. SCSI miniport drivers do not process <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> requests.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_QUIESCE_DEVICE (0x1A)</td>
  <td>The request is only between a storage class and storage port driver and is not be sent to miniport. This function serves as a wait by the class driver for port driver to complete all outstanding I/Os.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_RESET_LOGICAL_UNIT (0x20)</td>
  <td>The logical unit should be reset, if possible. The HBA miniport driver should complete any active requests for the logical unit. Extended SRB data is not required for this function. Storport supports this type of reset, but SCSI port does not.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_POWER (0x24)</td>
  <td>The request is a power extended request formatted as a <strong><a href="srbex_data_power" title="typedef struct _SRBEX_DATA_POWER {&#10;  SRBEXDATATYPE           Type;&#10;  ULONG                   Length;&#10;  UCHAR                   SrbPowerFlags;&#10;  UCHAR                   Reserved[3];&#10;  STOR_DEVICE_POWER_STATE DevicePowerState;&#10;  STOR_POWER_ACTION       PowerAction;&#10;} SRBEX_DATA_POWER, *PSRBEX_DATA_POWER;">SRBEX_DATA_POWER</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_PNP (0x25)</td>
  <td>The request is a PnP extended request formatted as a <strong><a href="srbex_data_pnp" title="typedef struct _SRBEX_DATA_PNP {&#10;  SRBEXDATATYPE   Type;&#10;  ULONG           Length;&#10;  UCHAR           PnPSubFunction;&#10;  UCHAR           Reserved[3];&#10;  STOR_PNP_ACTION PnPAction;&#10;  ULONG           SrbPnPFlags;&#10;  ULONG           Reserved1;&#10;} SRBEX_DATA_PNP, *PSRBEX_DATA_PNP;">SRBEX_DATA_PNP</a></strong> structure. The offset to extended request data is located at <strong>SrbExDataOffset</strong>[0].</td>
</tr>
<tr>
  <td>SRB_FUNCTION_DUMP_POINTERS (0x26)</td>
  <td>A request with this function is sent to a Storport miniport driver that is used to control the disk that holds the crash dump data. The request collects information needed from the miniport driver to support crash dump and hibernation. See the <strong><a href="miniport_dump_pointers" title="typedef struct _MINIPORT_DUMP_POINTERS {&#10;  USHORT                 Version;&#10;  USHORT                 Size;&#10;  WCHAR                  DriverName[DUMP_MINIPORT_NAME_LENGTH];&#10;  struct _ADAPTER_OBJECT *AdapterObject;&#10;  PVOID                  MappedRegisterBase;&#10;  ULONG                  CommonBufferSize;&#10;  PVOID                  MiniportPrivateDumpData;&#10;  ULONG                  SystemIoBusNumber;&#10;  INTERFACE_TYPE         AdapterInterfaceType;&#10;  ULONG                  MaximumTransferLength;&#10;  ULONG                  NumberOfPhysicalBreaks;&#10;  ULONG                  AlignmentMask;&#10;  ULONG                  NumberOfAccessRanges;&#10;  ACCESS_RANGE( )          *AccessRanges[];&#10;  UCHAR                  NumberOfBuses;&#10;  BOOLEAN                Master;&#10;  BOOLEAN                MapBuffers;&#10;  UCHAR                  MaximumNumberOfTargets;&#10;} MINIPORT_DUMP_POINTERS, *PMINIPORT_DUMP_POINTERS;">MINIPORT_DUMP_POINTERS</a></strong> structure. A physical miniport driver must set the STOR_FEATURE_DUMP_POINTERS flag in the <strong>FeatureSupport</strong> member of its <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> to receive a request with this function.</td>
</tr>
<tr>
  <td>SRB_FUNCTION_FREE_DUMP_POINTERS (0x27)</td>
  <td>A request with this function is sent to a Storport miniport driver to release any resources allocated during a previous request for SRB_FUNCTION_DUMP_POINTERS.</td>
</tr>
</tbody>
</table>
<h3><code>SrbFlags</code></h3>
<p>Indicates various parameters and options for the request. <strong>SrbFlags</strong> is read-only, except when <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> is set and miniport drivers of subordinate DMA adapters are required to update <strong>SRB_FLAGS_DATA_IN</strong> or <strong>SRB_FLAGS_DATA_OUT</strong>. This member can have one or more of these flags set.</p>
<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>SRB_FLAGS_QUEUE_ACTION_ENABLE</td>
  <td>Indicates tagged-queue actions are to be enabled.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_AUTOSENSE</td>
  <td>Indicates request-sense information should not be returned.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_IN</td>
  <td>Indicates data will be transferred from the device to the system.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DATA_OUT</td>
  <td>Indicates data will be transferred from the system to the device.</td>
</tr>
<tr>
  <td>SRB_FLAGS_UNSPECIFIED_DIRECTION</td>
  <td>Defined for backward compatibility with the ASPI/CAM SCSI interfaces, this flag indicates that the transfer direction could be either of the preceding, because both of the preceding flags are set. If this flag is set, a miniport driver should determine the transfer direction by examining the data phase for the target on the SCSI bus.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_DATA_TRANSFER</td>
  <td>Indicates no data transfer with this request. If this is set, the flags <strong>SRB_FLAGS_DATA_OUT</strong>, <strong>SRB_FLAGS_DATA_IN</strong>, and <strong>SRB_FLAGS_UNSPECIFIED_DIRECTION</strong> are clear.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_SYNCH_TRANSFER</td>
  <td>Indicates the HBA, if possible, should perform asynchronous I/O for this transfer request. If synchronous I/O was negotiated previously, the HBA must renegotiate for asynchronous I/O before performing the transfer.</td>
</tr>
<tr>
  <td>SRB_FLAGS_DISABLE_DISCONNECT</td>
  <td>Indicates the HBA should not allow the target to disconnect from the SCSI bus during processing of this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_FROZEN_QUEUE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_QUEUE_FREEZE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_IS_ACTIVE</td>
  <td>This flag is irrelevant to miniport drivers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_ALLOCATED_FROM_ZONE</td>
  <td>This flag is irrelevant to miniport drivers and is obsolete to new Windows class drivers. To a Windows legacy class driver, this indicates whether the SRB was allocated from a zone buffer. If this flag is set, the class driver must call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mmcreatemdl"><strong>ExInterlockedFreeToZone</strong></a> to release the SRB; otherwise, it must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong>. New class drivers should use lookaside lists rather than zone buffers.</td>
</tr>
<tr>
  <td>SRB_FLAGS_SGLIST_FROM_POOL</td>
  <td>This flag is irrelevant to miniport drivers. To the class driver, this indicates that memory for a scatter/gather list was allocated from a nonpaged pool. If this flag is set, the class driver must call <strong><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></strong> to release the memory after the SRB is completed.</td>
</tr>
<tr>
  <td>SRB_FLAGS_BYPASS_LOCKED_QUEUE</td>
  <td>This flag is irrelevant to miniport drivers. To the port driver, this flag indicates that the request should be processed whether the logical-unit queue is locked or not. A higher-level driver must set this flag to send an <strong>SRB_FUNCTION_UNLOCK_QUEUE</strong> request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_NO_KEEP_AWAKE</td>
  <td>This flag is irrelevant to miniport drivers. A Windows class driver uses this flag to indicate to the port driver to fail the request rather than powering up the device to handle this request.</td>
</tr>
<tr>
  <td>SRB_FLAGS_FREE_SENSE_BUFFER</td>
  <td>Indicates that either the port or the miniport driver has allocated a buffer for sense data. This informs the class driver that it must free the sense data buffer after extracting the data.</td>
</tr>
<tr>
  <td>SRB_FLAGS_D3_PROCESSING</td>
  <td>Indicates that the request is part of D3 processing. Miniports that support runtime power control should not call <strong><a href="storportpofxactivatecomponent" title="ULONG StorPortPoFxActivateComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxActivateComponent</a></strong> or <strong><a href="storportpofxidlecomponent" title="ULONG StorPortPoFxIdleComponent(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSTOR_ADDRESS       Address,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           ULONG               Component,&#10;  [in]           ULONG               Flags&#10;);">StorPortPoFxIdleComponent</a></strong> with these requests.</td>
</tr>
<tr>
  <td>SRB_FLAGS_ADAPTER_CACHE_ENABLE</td>
  <td>Indicates that the adapter can cache data.</td>
</tr>
</tbody>
</table>
<h3><code>ReservedUlong2</code></h3>
<p>Reserved. Set to 0.</p>
<h3><code>RequestTag</code></h3>
<p>Contains the queue-tag value assigned by the operating system-specific port driver. If this member is used for tagged queuing, the HBA supports internal queuing of requests to logical units (LUs) and the miniport driver set <strong>TaggedQueueing</strong> to <strong>TRUE</strong> in the <a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a> for this HBA.</p>
<h3><code>RequestPriority</code></h3>
<p>The priority assignment for the SRB. Can be one of the following values.</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>StorIoPriorityVeryLow (0)</td>
  <td>Very low priority.</td>
</tr>
<tr>
  <td>StorIoPriorityLow (1)</td>
  <td>Low priority.</td>
</tr>
<tr>
  <td>StorIoPriorityNormal (2)</td>
  <td>Normal priority.</td>
</tr>
<tr>
  <td>StorIoPriorityHigh (3)</td>
  <td>High priority.</td>
</tr>
<tr>
  <td>StorIoPriorityCritical (4)</td>
  <td>Critical priority.</td>
</tr>
</tbody>
</table>
<h3><code>RequestAttribute</code></h3>
<p>Indicates the tagged-queuing message to be used when the <strong>SRB_FLAGS_QUEUE_ACTION_ENABLE</strong> flag is set. The value can be one of the following: <strong>SRB_SIMPLE_TAG_REQUEST</strong>, <strong>SRB_HEAD_OF_QUEUE_TAG_REQUEST</strong>, or <strong>SRB_ORDERED_QUEUE_TAG_REQUEST</strong>.</p>
<h3><code>TimeOutValue</code></h3>
<p>Indicates the interval, in seconds, that the request can execute before the operating system-specific port driver might consider it timed out. Miniport drivers are not required to time requests because the port driver already does.</p>
<h3><code>DUMMYUNIONNAME</code></h3>
<p>Embedded union.</p>
<h3><code>DUMMYUNIONNAME.SystemStatus</code></h3>
<p>Used to store system failure status information in SrbStatus failure conditions (for example, SRB_STATUS_INTERNAL_ERROR).</p>
<h3><code>DUMMYUNIONNAME.RequestTagHigh4Bytes</code></h3>
<p>Used to store high four bytes of unique tag if unique tag feature is enabled.</p>
<h3><code>SystemStatus</code></h3>
<p>Used by the Storport driver, instead of <strong>SrbStatus</strong>, to report the status of the completed request whenever the request cannot be delivered to the miniport driver. In such cases, <strong>SrbStatus</strong> is set to <strong>SRB_STATUS_INTERNAL_ERROR</strong>. This member is used exclusively for communication between the Storport and the class driver and should not be used by miniport drivers.</p>
<h3><code>ZeroGuard1</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>AddressOffset</code></h3>
<p>The offset of the storage request address from the beginning of this structure. This offset locates a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure that contains the address for the request.</p>
<h3><code>NumSrbExData</code></h3>
<p>The count of extended SRB data blocks for this request.</p>
<h3><code>DataTransferLength</code></h3>
<p>Indicates the size, in bytes, of the data buffer. If an underrun occurs, the miniport driver must update this member to the number of bytes actually transferred.</p>
<h3><code>DataBuffer</code></h3>
<p>Points to the data buffer. Miniport drivers should not use this value as a data pointer unless the miniport driver set <strong>MapBuffers</strong> to <strong>TRUE</strong> in the <strong><a href="port_configuration_information" title="typedef struct _PORT_CONFIGURATION_INFORMATION {&#10;  ULONG           Length;&#10;  ULONG           SystemIoBusNumber;&#10;  INTERFACE_TYPE  AdapterInterfaceType;&#10;  ULONG           BusInterruptLevel;&#10;  ULONG           BusInterruptVector;&#10;  KINTERRUPT_MODE InterruptMode;&#10;  ULONG           MaximumTransferLength;&#10;  ULONG           NumberOfPhysicalBreaks;&#10;  ULONG           DmaChannel;&#10;  ULONG           DmaPort;&#10;  DMA_WIDTH       DmaWidth;&#10;  DMA_SPEED       DmaSpeed;&#10;  ULONG           AlignmentMask;&#10;  ULONG           NumberOfAccessRanges;&#10;  ACCESS_RANGE( )   *AccessRanges[];&#10;  PVOID           Reserved;&#10;  UCHAR           NumberOfBuses;&#10;  UCHAR           InitiatorBusId[8];&#10;  BOOLEAN         ScatterGather;&#10;...">PORT_CONFIGURATION_INFORMATION</a></strong> for the HBA. In the case of SRB_FUNCTION_IO_CONTROL requests, however, miniport drivers can use this value as a data pointer regardless of the value of <strong>MapBuffers</strong>.</p>
<h3><code>ZeroGuard2</code></h3>
<p>A guard area to protect against drivers that interpret this structure as <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong>. Set to 0.</p>
<h3><code>OriginalRequest</code></h3>
<p>Points to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>ClassContext</code></h3>
<p>Points to a class driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>PortContext</code></h3>
<p>Points to a port driver context data for this request. This member is irrelevant to miniport drivers.</p>
<h3><code>MiniportContext</code></h3>
<p>Points to the Srb extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong>. The memory at <strong>MiniportContext</strong> is not initialized by the operating system-specific port driver, and the miniport driver-determined data can be accessed directly by the HBA. The corresponding physical address can be obtained by calling <strong><a href="storportgetphysicaladdress" title="STORPORT_API STOR_PHYSICAL_ADDRESS StorPortGetPhysicalAddress(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           PVOID               VirtualAddress,&#10;  [out]          ULONG               *Length&#10;);">StorPortGetPhysicalAddress</a></strong> with the <strong>MiniportContext</strong> pointer.</p>
<h3><code>NextSrb</code></h3>
<p>Indicates the <strong>STORAGE_REQUEST_BLOCK</strong> to which this request applies. Only a small subset of requests use a second SRB, for example SRB_FUNCTION_ABORT_COMMAND.</p>
<h3><code>_STORAGE_REQUEST_BLOCK</code></h3>
<h3><code>SrbExDataOffset[ANYSIZE_ARRAY]</code></h3>
<p>An array of offsets specifying the location of extended data blocks for the SRB. This array is empty if <strong>NumSrbExData</strong> = 0.</p>
<h2>Remarks</h2>
<p>Starting in Windows 8, an extended SRB type is supported with the use of the <strong>STORAGE_REQUEST_BLOCK</strong> structure. <strong>STORAGE_REQUEST_BLOCK</strong> extends SRB functions, allowing extended data blocks for the SRB function to be added to the request. Support for SRB requests using the <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> structure will continue.</p>
<p>If <strong>NumSrbExData</strong> &gt; 0, the offsets for the SRB extended data blocks are in the <strong>SrbExDataOffset</strong> array. Each offset is relative to the beginning of this structure and points to a <strong><a href="srbex_data" title="typedef struct _SRBEX_DATA {&#10;  SRBEXDATATYPE Type;&#10;  ULONG         Length;&#10;  UCHAR         Data[ANYSIZE_ARRAY];&#10;} SRBEX_DATA, *PSRBEX_DATA;">SRBEX_DATA</a></strong> structure containing the extended data block.</p>
<p>The target device address for the SRB is in a <strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong> structure indicated by <strong>AddressOffset</strong>.</p>
<h2>See also</h2>
<ul>
<li><strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong></li>
<li><strong><a href="stor_address" title="typedef struct _STOR_ADDRESS {&#10;  USHORT Type;&#10;  USHORT Port;&#10;  ULONG  AddressLength;&#10;  UCHAR  AddressData[ANYSIZE_ARRAY];&#10;} STOR_ADDRESS, *PSTOR_ADDRESS;">STOR_ADDRESS</a></strong></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_storage_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_storage_request_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
