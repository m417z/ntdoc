<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PMRX_CALLDOWN - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PMRX_CALLDOWN - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PMRX_CALLDOWN - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// mrx.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PMRX_CALLDOWN PmrxCalldown;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PmrxCalldown(
  [in, out] IN OUT <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">PRX_CONTEXT</a> RxContext
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_calldown">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pmrx_calldown.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-mrx-pmrx_calldown)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pmrx_calldown-callback-function">PMRX_CALLDOWN callback function</h1>

<h2 id="description">Description</h2>

<p>This callback is called by RDBSS to request that the network mini-redirector perform an action based in the supplied <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="rxcontext-in-out"><code>RxContext</code> [in, out]</h3>

<p>A pointer to the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure. This parameter contains the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that is requesting the operation.</p>

<h2 id="return-value">Return value</h2>

<p>This callback returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value, such as the following:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STATUS_ACCESS_DENIED</td>
  <td>A request was made to stop or start the network mini-redirector, but the caller lacked the proper security for this operation.</td>
</tr>
<tr>
  <td>STATUS_BUFFER_OVERFLOW</td>
  <td>The buffer to receive the extended attribute information was too small. This return value should be considered success and as much valid data as possible should be returned in the <strong>Info.Buffer</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter.</td>
</tr>
<tr>
  <td>STATUS_BUFFER_TOO_SMALL</td>
  <td>The buffer is too small to receive the requested data. If this value is returned, the <strong>InformationToReturn</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter should be set to the minimum size of the expected buffer for the call to succeed.</td>
</tr>
<tr>
  <td>STATUS_CONNECTION_DISCONNECTED</td>
  <td>The connection was disconnected.</td>
</tr>
<tr>
  <td>STATUS_EA_CORRUPT_ERROR</td>
  <td>Invalid extended attribute information was received from the remote server.</td>
</tr>
<tr>
  <td>STATUS_EA_TOO_LARGE</td>
  <td>The extended attribute information that is passed is larger than the size that is supported by the remote share.</td>
</tr>
<tr>
  <td>STATUS_FILE_CLOSED</td>
  <td>The FCB structure was acquired, but the associated SRV_OPEN structure has been closed.</td>
</tr>
<tr>
  <td>STATUS_INSUFFICIENT_RESOURCES</td>
  <td>There were insufficient resources to complete the operation.</td>
</tr>
<tr>
  <td>STATUS_INTERNAL_ERROR</td>
  <td>An internal error occurred in the network mini-redirector.</td>
</tr>
<tr>
  <td>STATUS_INVALID_BUFFER_SIZE</td>
  <td>The requested buffer size was too large.</td>
</tr>
<tr>
  <td>STATUS_INVALID_DEVICE_REQUEST</td>
  <td>An invalid device request was sent to the network mini-redirector.</td>
</tr>
<tr>
  <td>STATUS_INVALID_NETWORK_RESPONSE</td>
  <td>An invalid response was received from the remote server.</td>
</tr>
<tr>
  <td>STATUS_INVALID_PARAMETER</td>
  <td>An invalid parameter was specified in <strong>RxContext</strong>.</td>
</tr>
<tr>
  <td>STATUS_LINK_FAILED</td>
  <td>The attempt to reconnect to a remote server to complete the request failed.</td>
</tr>
<tr>
  <td>STATUS_MORE_PROCESSING_REQUIRED</td>
  <td>A network mini-redirector returns this value to disable collapsing of this open request.</td>
</tr>
<tr>
  <td>STATUS_NETWORK_ACCESS_DENIED</td>
  <td>Network access was denied. This error can be returned if the network mini-redirector was asked to open a new file on a read-only share.</td>
</tr>
<tr>
  <td>STATUS_NETWORK_NAME_DELETED</td>
  <td>A network name was deleted.</td>
</tr>
<tr>
  <td>STATUS_NONEXISTENT_EA_ENTRY</td>
  <td>There are no extended attributes on the file object and the user supplied an extended attribute index.</td>
</tr>
<tr>
  <td>STATUS_NOT_IMPLEMENTED</td>
  <td>A feature that is requested, such as remote boot or a remote page file, is not implemented.</td>
</tr>
<tr>
  <td>STATUS_NOT_SUPPORTED</td>
  <td>A feature that is requested, such as extended attributes, is not supported.</td>
</tr>
<tr>
  <td>STATUS_OBJECT_NAME_COLLISION</td>
  <td>The network mini-redirector was asked to create a file that already exists.</td>
</tr>
<tr>
  <td>STATUS_OBJECT_NAME_NOT_FOUND</td>
  <td>The object name was not found. This error can be returned if the network mini-redirector was asked to open a file that doesn't exist.</td>
</tr>
<tr>
  <td>STATUS_OBJECT_PATH_NOT_FOUND</td>
  <td>The object path was not found. This error can be returned if an NTFS stream object was requested and the remote file system does not support streams.</td>
</tr>
<tr>
  <td>STATUS_ONLY_IF_CONNECTED</td>
  <td>The SRV_OPEN structure is not connected.</td>
</tr>
<tr>
  <td>STATUS_REDIRECTOR_HAS_OPEN_HANDLES</td>
  <td>This was a request to stop the network mini-redirector, but the redirector has open handles that prevent it from stopping at this time.</td>
</tr>
<tr>
  <td>STATUS_REDIRECTOR_NOT_STARTED</td>
  <td>This was a request to stop the network mini-redirector, but the redirector was not started.</td>
</tr>
<tr>
  <td>STATUS_REDIRECTOR_STARTED</td>
  <td>This was a request to start the network mini-redirector, but the redirector was already started.</td>
</tr>
<tr>
  <td>STATUS_REPARSE</td>
  <td>A reparse is required to handle a symbolic link.</td>
</tr>
<tr>
  <td>STATUS_REQUEST_ABORTED</td>
  <td>The network request was aborted.</td>
</tr>
<tr>
  <td>STATUS_RETRY</td>
  <td>The operation should be retried. This error can be returned if the network mini-redirector encountered a sharing violation or an access denied error.</td>
</tr>
<tr>
  <td>STATUS_SHARING_VIOLATION</td>
  <td>A sharing violation occurred.</td>
</tr>
<tr>
  <td>STATUS_UNSUCCESSFUL</td>
  <td>The call was unsuccessful.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>The <strong>MRxCloseSrvOpen</strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that the network mini-redirector close an SRV_OPEN structure.</p>

<p><strong>MRxCloseSrvOpen</strong> is called by RDBSS as part of cleanup and close operations on a file object. It is assumed that the network mini-redirector will close a file across the network.</p>

<p>Before calling <strong>MRxCloseSrvOpen</strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure, pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>MajorFunction</strong> is set to <a href="irp_mj_close" title="#define IRP_MJ_CLOSE 0x02">IRP_MJ_CLOSE</a></p>

<p><strong>pFcb</strong> is set to the FCB structure for which close processing is to be initiated</p>

<p><strong>pFobx</strong> is set to the FOBX structure for which close processing is to be initiated</p>

<p>RDBSS and a network mini-redirector do not necessarily close the SRV_OPEN structures when the user closes a file. To improve performance in some cases, a network mini-redirector may try to reuse the SRV_OPEN and the cached data without any contact with the server. Some Microsoft Windows applications exhibit behavior that opens, reads, and closes a file and then quickly reopens the same file. In these cases, reusing the SRV_OPEN structures can improve performance.</p>

<p>RDBSS calls <strong>MRxCloseSrvOpen</strong> for delayed close processing while scavenging an FOBX structure. This happens when the close processing was delayed in anticipation of an open request and no open requests were forthcoming.</p>

<p><strong>MRxCloseSrvOpen</strong> cannot return a value of STATUS_RETRY indicating that the call should be retried. If a retry loop is necessary, it must be handled internally in the <strong>MRxCloseSrvOpen</strong> routine by the network mini-redirector.</p>

<p>The <strong><a href="mrxcollapseopen" title="PMRX_CALLDOWN MRxCollapseOpen;&#10;&#10;NTSTATUS MRxCollapseOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCollapseOpen</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that the network mini-redirector collapse an open file system request onto an existing SRV_OPEN structure.</p>

<p><strong><a href="mrxcollapseopen" title="PMRX_CALLDOWN MRxCollapseOpen;&#10;&#10;NTSTATUS MRxCollapseOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCollapseOpen</a></strong> is called by RDBSS to collapse an SRV_OPEN structure locally. The network mini-redirector is consulted to determine if a collapse is possible so there is no reason to call the network mini-redirector twice. If the network mini-redirector decides to collapse the SRV_OPEN structure, then it will do so and pass back a returnable status. A return value of <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> is a terminating return value. A different return value, for example, STATUS_MORE_PROCESSING_REQUIRED, is considered a non-terminating return value.</p>

<p>Before calling <strong><a href="mrxcollapseopen" title="PMRX_CALLDOWN MRxCollapseOpen;&#10;&#10;NTSTATUS MRxCollapseOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCollapseOpen</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>pRelevantSrvOpen</strong> is set to the SRV_OPEN structure to collapse.</p>

<p><strong>Create.pSrvCall</strong> is set to the SRV_CALL structure associated with the SRV_OPEN.</p>

<p>If the network mini-redirector decides to collapse the SRV_OPEN structure, then the <strong>SrvOpen</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure must be set to the collapsed SRV_OPEN structure.</p>

<p>The<strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that the network mini-redirector create a file system object.</p>

<p><strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> is called by RDBSS to request that the network mini-redirector open a file system object across the network. This call is issued by RDBSS in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a> request.</p>

<p>Before calling <strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>pRelevantSrvOpen</strong> is set to the SRV_OPEN structure.</p>

<p><strong>Create.pSrvCall</strong> is set to the SRV_CALL structure.</p>

<p><strong>Create.NtCreateParameters</strong> is set to the requested NT_CREATE_PARAMETERS.</p>

<p>In the context of a network mini-redirector, a file object refers to the associated file control block (FCB) and file object extension (FOBX) structures. There is a one to one correspondence between file objects and FOBXs. Many file objects will refer to the same FCB, which represents a single file on a remote server. A client can have several different open requests (<a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a> requests) on the same FCB and each of these will create a new file object. RDBSS and network mini-redirectors can choose to send fewer <strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> requests than the <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a> requests received, in effect sharing an SRV_OPEN structure among several FOBXs.</p>

<p>If the <strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> request was for a file overwrite and <strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> returned <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>, then RDBSS will acquire the paging I/O resource and truncate the file. If the file is being cached by cache manager, RDBSS will update the sizes the cache manager has with the ones just received from the server.</p>

<p>Before returning,<strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong> must set the <strong>CurrentIrp->IoStatus.Information</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter.</p>

<p>The <strong><a href="mrxdevfcbxxxcontrolfile" title="PMRX_CALLDOWN MRxDevFcbXXXControlFile;&#10;&#10;NTSTATUS MRxDevFcbXXXControlFile(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxDevFcbXXXControlFile</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to pass a device FCB control request (an IOCTL or FSCTL request) to the network mini-redirector.</p>

<p><strong><a href="mrxdevfcbxxxcontrolfile" title="PMRX_CALLDOWN MRxDevFcbXXXControlFile;&#10;&#10;NTSTATUS MRxDevFcbXXXControlFile(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxDevFcbXXXControlFile</a></strong> handles IOCTL and FSCTL requests related to the device FCB that are sent to the network mini-redirector.</p>

<p>Before calling <strong><a href="mrxdevfcbxxxcontrolfile" title="PMRX_CALLDOWN MRxDevFcbXXXControlFile;&#10;&#10;NTSTATUS MRxDevFcbXXXControlFile(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxDevFcbXXXControlFile</a></strong>, RDBSS modifies the following member in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>MajorFunction</strong> is set to the major function of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></p>

<p>If this was an <a href="irp_mj_file_system_control" title="#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d">IRP_MJ_FILE_SYSTEM_CONTROL</a> request, then RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>LowIoContext.ParamsFor.FsCtl.MinorFunction</strong> is set to the minor function code for the FSCTL code</p>

<p><strong>LowIoContext.ParamsFor.FsCtl.FsControlCode</strong> is set to the FSCTL code for the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></p>

<p>If this was an <a href="irp_mj_device_control" title="#define IRP_MJ_DEVICE_CONTROL 0x0e">IRP_MJ_DEVICE_CONTROL</a> or <a href="irp_mj_internal_device_control" title="#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f">IRP_MJ_INTERNAL_DEVICE_CONTROL</a> request, then RDBSS modifies the following member in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p><strong>LowIoContext.ParamsFor.FsCtl.FsControlCode</strong> is set to the control code for the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<p>If <strong><a href="mrxdevfcbxxxcontrolfile" title="PMRX_CALLDOWN MRxDevFcbXXXControlFile;&#10;&#10;NTSTATUS MRxDevFcbXXXControlFile(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxDevFcbXXXControlFile</a></strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>, then the routine was successful. Any other return value indicates that an error occurred.</p>

<p>The <strong><a href="mrxflush" title="PMRX_CALLDOWN MRxFlush;&#10;&#10;NTSTATUS MRxFlush(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxFlush</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector write the contents of a file system object to storage. RDBSS issues this call in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-flush-buffers"><strong>IRP_MJ_FLUSH_BUFFERS</strong></a> request.</p>

<p><strong><a href="mrxflush" title="PMRX_CALLDOWN MRxFlush;&#10;&#10;NTSTATUS MRxFlush(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxFlush</a></strong> handles network requests for file flush.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-exclusivelock-"><strong>MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector open an exclusive lock on a file object.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-exclusivelock-"><strong>MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a> request with a minor code of IRP_MN_LOCK if <strong>IrpSp->Flags</strong> has the <a href="sl_exclusive_lock" title="#define SL_EXCLUSIVE_LOCK 0x02">SL_EXCLUSIVE_LOCK</a> bit set.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-exclusivelock-"><strong>MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_EXCLUSIVELOCK.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.ByteOffset</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.ByteOffset.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Key</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Key</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Flags</strong> member is set to the value of <strong>IrpSp->Flags</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Length</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Length.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.Operation</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure specifies the low I/O operation to perform. It is possible for several of the low I/O routines to point to the same routine in a network mini-redirector because this <strong>LowIoContext.Operation</strong> member can be used to differentiate the low I/O operation that is requested. For example, all the I/O calls related to file locks could call the same low I/O routine in the network mini-redirector and that routine could use the <strong>LowIoContext.Operation</strong> member to differentiate between the lock and unlock operation that is requested.</p>

<p>If the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-exclusivelock-"><strong>MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]</strong></a> routine can take a long time to complete, the network mini-redirector driver should release the FCB structure before initiating the network communication. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>. While the <strong>MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]</strong> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-"><strong>MRxLowIOSubmit[LOWIO_OP_FSCTL]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector issue file system control request on remote file.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-"><strong>MRxLowIOSubmit[LOWIO_OP_FSCTL]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control"><strong>IRP_MJ_FILE_SYSTEM_CONTROL</strong></a> request.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-"><strong>MRxLowIOSubmit[LOWIO_OP_FSCTL]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_FSCTL.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.FsControlCode</strong> member is set to the FSCTL major control code.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.MinorFunction</strong> member is set to the FSCTL minor control code.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.pInputBuffer</strong> member is set to the input buffer.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.InputBufferLength</strong> member is set to the input buffer length.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.pOutputBuffer</strong> member is set to the output buffer.</p>

<p>The <strong>LowIoContext.ParamsFor.FsCtl.OutputBufferLength</strong> member is set to the output buffer length.</p>

<p>The file system control code (FSCTL) requests handled by a network mini-redirector can be classified into one of several categories:</p>

<ul>
<li><p>FSCTLs that are implemented and used by RDBSS and the network mini redirector</p></li>
<li><p>FSCTLs that are implemented and used only by the network mini-redirector</p></li>
<li><p>FSCTLs which should never be seen by the network mini-redirector. These FSCTLs are solely intended as a debugging aid.</p></li>
</ul>

<p>While the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-fsctl-"><strong>MRxLowIOSubmit[LOWIO_OP_FSCTL]</strong></a> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS. The <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> can be used to release the input resource on behalf of another thread. When an asynchronous routine completes, the input resource that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-"><strong>MRxLowIOSubmit[LOWIO_OP_IOCTL]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to issue an I/O system control request to the network mini-redirector.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-"><strong>MRxLowIOSubmit[LOWIO_OP_IOCTL]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-device-control"><strong>IRP_MJ_DEVICE_CONTROL</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-internal-device-control"><strong>IRP_MJ_INTERNAL_DEVICE_CONTROL</strong></a> requests.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-"><strong>MRxLowIOSubmit[LOWIO_OP_IOCTL]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_IOCTL.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.IoCtl.IoControlCode</strong> member is set to the IOCTL control code.</p>

<p>The <strong>LowIoContext.ParamsFor.IoCtl.pInputBuffer</strong> member is set to the input buffer.</p>

<p>The <strong>LowIoContext.ParamsFor.IoCtl.InputBufferLength</strong> member is set to the input buffer length.</p>

<p>The <strong>LowIoContext.ParamsFor.IoCtl.pOutputBuffer</strong> member is set to the output buffer.</p>

<p>The <strong>LowIoContext.ParamsFor.IoCtl.OutputBufferLength</strong> member is set to the output buffer length.</p>

<p>While the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-ioctl-"><strong>MRxLowIOSubmit[LOWIO_OP_IOCTL]</strong></a> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS. The <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> can be used to release the input resource on behalf of another thread. When an asynchronous routine completes, the input resource that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-notify-change-directory-"><strong>MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to issue a request to the network mini-redirector for a directory change notification operation.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-notify-change-directory-"><strong>MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-directory-control"><strong>IRP_MJ_DIRECTORY_CONTROL</strong></a> request.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-notify-change-directory-"><strong>MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_NOTIFY_CHANGE_DIRECTORY.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.NotifyChangeDirectory.WatchTree</strong> member is set to <strong>TRUE</strong> if the <strong>IrpSp->Flags</strong> has the <a href="sl_watch_tree" title="#define SL_WATCH_TREE 0x01">SL_WATCH_TREE</a> bit set.</p>

<p>The <strong>LowIoContext.ParamsFor.NotifyChangeDirectory.CompletionFilter</strong> member is set to the value of <strong>IrpSp->Parameters.NotifyDirectory.CompletionFilter</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.NotifyChangeDirectory.NotificationBufferLength</strong> member is set to the value of <strong>IrpSp->Parameters.NotifyDirectory.Length</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.NotifyChangeDirectory.pNotificationBuffer</strong> member is set to the value returned by calling <strong><a href="mmgetsystemaddressformdlsafe" title="PVOID MmGetSystemAddressForMdlSafe(&#10;  [in] PMDL  Mdl,&#10;  [in] ULONG Priority&#10;);">MmGetSystemAddressForMdlSafe</a></strong> passing in the <strong>Irp->MdlAddress</strong> and NormalPagePriority. The user buffer also is probed and locked for write access.</p>

<p>A directory change notification operation is normally implemented by a network mini-redirector as an asynchronous operation because it can take considerable time. The operation usually consists of sending a network request to the remote server requesting change notification. The response is obtained when the desired change is affected on the server. This is an example of an operation for which the network mini-redirector may need to register a unique context value for handling cancellations initiated locally.</p>

<p>While the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-notify-change-directory-"><strong>MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY]</strong></a> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS. The <strong>LowIoContext.ResourceThreadId</strong> member can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-read-"><strong>MRxLowIOSubmit[LOWIO_OP_READ]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to issue a read request to the network mini-redirector.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-read-"><strong>MRxLowIOSubmit[LOWIO_OP_READ]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-read"><strong>IRP_MJ_READ</strong></a> request.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-read-"><strong>MRxLowIOSubmit[LOWIO_OP_READ]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_READ.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.ReadWrite.Key</strong> member is set to the value of <strong>IrpSp->Parameters.Read.Key</strong>.</p>

<p>The <strong>ParamsFor.ReadWrite.Flags</strong> member has the LOWIO_READWRITEFLAG_PAGING_IO bit is set on if <strong>Irp->Flags</strong> has the <a href="irp_paging_io" title="#define IRP_PAGING_IO 0x00000002">IRP_PAGING_IO</a> bit on.</p>

<p>The <strong>ParamsFor.ReadWrite.Buffer</strong> member is set to the user buffer locked for IoReadAccess.</p>

<p>The <strong>LowIoContext.ParamsFor.ReadWrite.ByteCount</strong> member is set to the value of IrpSp->Parameters.Read.Length.</p>

<p>A read request is normally implemented by a network mini-redirector as an asynchronous operation because it can take considerable time. The operation usually consists of sending a network request to the remote server. The response is obtained when the read request is completed on the server. This is an example of an operation for which the network mini-redirector may need to register a context for handling cancellations initiated locally.</p>

<p>While the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-read-"><strong>MRxLowIOSubmit[LOWIO_OP_READ]</strong></a> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS. The <strong>LowIoContext.ResourceThreadId</strong> member can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-sharedlock-"><strong>MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network redirector open a shared lock on a file object.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-sharedlock-"><strong>MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a> request with a minor code of IRP_MN_LOCK if <strong>IrpSp->Flags</strong> does not have the <a href="sl_exclusive_lock" title="#define SL_EXCLUSIVE_LOCK 0x02">SL_EXCLUSIVE_LOCK</a> bit set.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-sharedlock-"><strong>MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_SHAREDLOCK.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.ByteOffset</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.ByteOffset.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Key</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Key</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Flags</strong> member is set to the value of <strong>IrpSp->Flags</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Length</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Length.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.Operation</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure specifies the low I/O operation to perform. It is possible for several of the low I/O routines to point to the same routine in a network mini-redirector because the <strong>LowIoContext.Operation</strong> member can be used to differentiate the low I/O operation that is requested. For example, all the I/O calls related to file locks could call the same low I/O routine in the network mini-redirector and this routine could use the <strong>LowIoContext.Operation</strong> member to differentiate between the lock and unlock operation that is requested.</p>

<p>If the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-sharedlock-"><strong>MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]</strong></a> routine can take a long time to complete, the network mini-redirector driver should release the FCB structure before initiating the network communication. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>. While the <strong>MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]</strong> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector remove a single lock on a file object.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a> request with a minor code of IRP_MN_UNLOCK_SINGLE.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_UNLOCK.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.ByteOffset</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.ByteOffset.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Key</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Key</strong>.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.Length</strong> member is set to the value of <strong>IrpSp->Parameters.LockControl.Length.QuadPart</strong>.</p>

<p>The <strong>LowIoContext.Operation</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure specifies the low I/O operation to perform. It is possible for several of the low I/O routines to point to the same routine in a network mini-redirector because this <strong>LowIoContext.Operation</strong> member can be used to differentiate the low I/O operation that is requested. For example, all the I/O calls related to file locks could call the same low I/O routine in the network mini-redirector and this routine could use the <strong>LowIoContext.Operation</strong> member to differentiate between the lock and unlock operation that is requested.</p>

<p>If the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK]</strong></a> routine can take a long time to complete, the network mini-redirector driver should release the FCB structure before initiating the network communication. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>. While the <strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK]</strong> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-multiple-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that the network mini-redirector remove multiple locks held on a file object.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-multiple-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-lock-control"><strong>IRP_MJ_LOCK_CONTROL</strong></a> request with a minor code of IRP_MN_UNLOCK_ALL or IRP_MN_UNLOCK_ALL_BY_KEY.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-multiple-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_UNLOCK_MULTIPLE.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.Locks.LockList</strong> member is set to a list of LOWIO_LOCK_LIST elements. Each element specifies a range to be unlocked.</p>

<p>The byte ranges to be unlocked are specified in the <strong>LowIoContext.ParamsFor.Locks.LockList</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure. The LOWIO_LOCK_LIST structure is as follows:</p>

<div class="codehilite">
<pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_LOWIO_LOCK_LIST</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w">  </span><span class="nc">_LOWIO_LOCK_LIST</span><span class="w">  </span><span class="o">*</span><span class="n">Next</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w">  </span><span class="n">LockNumber</span><span class="p">;</span>
<span class="w">  </span><span class="n">RXVBO</span><span class="w">  </span><span class="n">ByteOffset</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="longlong" title="typedef __int64 LONGLONG;">LONGLONG</a></span><span class="w">  </span><span class="n">Length</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w">  </span><span class="n">Key</span><span class="p">;</span>
<span class="w">  </span><span class="n">BOOLEAN</span><span class="w">  </span><span class="n">ExclusiveLock</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">LOWIO_LOCK_LIST</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">PLOWIO_LOCK_LIST</span><span class="p">;</span>
</code></pre>
</div>

<p>The <strong>LowIoContext.Operation</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> specifies the low I/O operation to perform. It is possible for several of the low I/O routines to point to the same routine in a network mini-redirector because the <strong>LowIoContext.Operation</strong> member can be used to differentiate the low I/O operation that is requested. For example, all the I/O calls related to file locks could call the same low I/O routine in the network mini-redirector and this routine could use the <strong>LowIoContext.Operation</strong> member to differentiate between the lock and unlock operation that is requested.</p>

<p>If the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-unlock-multiple-"><strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE]</strong></a> routine can take a long time to complete, the network mini-redirector driver should release the FCB structure before initiating the network communication. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>. While the <strong>MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE]</strong> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released.</p>

<p>The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-write-"><strong>MRxLowIOSubmit[LOWIO_OP_WRITE]</strong></a> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to issue a write request to the network mini-redirector.</p>

<p>RDBSS calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-write-"><strong>MRxLowIOSubmit[LOWIO_OP_WRITE]</strong></a> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write"><strong>IRP_MJ_WRITE</strong></a> request.</p>

<p>Before calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-write-"><strong>MRxLowIOSubmit[LOWIO_OP_WRITE]</strong></a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>LowIoContext.Operation</strong> member is set to LOWIO_OP_WRITE.</p>

<p>The <strong>LowIoContext.ResourceThreadId</strong> member is set to the thread of the process that initiated the operation in RDBSS.</p>

<p>The <strong>LowIoContext.ParamsFor.ReadWrite.Key</strong> member is set to the value of <strong>IrpSp->Parameters.Read.Key</strong>.</p>

<p>The <strong>ParamsFor.ReadWrite.Flags</strong> member has the LOWIO_READWRITEFLAG_PAGING_IO bit is set on if <strong>Irp->Flags</strong> has the <a href="irp_paging_io" title="#define IRP_PAGING_IO 0x00000002">IRP_PAGING_IO</a> bit on.</p>

<p>The <strong>ParamsFor.ReadWrite.Buffer</strong> member is set to the user buffer locked for IoWriteAccess.</p>

<p>The <strong>LowIoContext.ParamsFor.ReadWrite.ByteCount</strong> member is set to the value of <strong>IrpSp->Parameters.Write.Length</strong>.</p>

<p>A write request is normally implemented by a network mini-redirector as an asynchronous operation because it can take considerable time. The operation usually consists of sending a network request to the remote server. The response is obtained when the write request is completed on the server. This is an example of an operation for which the network mini-redirector may need to register a context for handling cancellations initiated locally.</p>

<p>While the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mrxlowiosubmit-lowio-op-write-"><strong>MRxLowIOSubmit[LOWIO_OP_WRITE]</strong></a> routine is processing, the <strong>LowIoContext.ResourceThreadId</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> is guaranteed to indicate the thread of the process that initiated the operation in RDBSS. The <strong>LowIoContext.ResourceThreadId</strong> member can be used to release the FCB structure on behalf of another thread. When an asynchronous routine completes, the FCB structure that was acquired from the initial thread can be released. The FCB structure can be released by calling <strong><a href="rxreleasefcbresourceforthreadinmrx" title="VOID RxReleaseFcbResourceForThreadInMRx(&#10;  [in]      IN PRX_CONTEXT      pRxContext,&#10;  [in, out] IN OUT PMRX_FCB     MrxFcb,&#10;  [in]      IN ERESOURCE_THREAD ResourceThreadId&#10;);">RxReleaseFcbResourceForThreadInMRx</a></strong>.</p>

<p>The <strong><a href="mrxquerydirectory" title="PMRX_CALLDOWN MRxQueryDirectory;&#10;&#10;NTSTATUS MRxQueryDirectory(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryDirectory</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query information on a file directory.</p>

<p>Before calling <strong><a href="mrxquerydirectory" title="PMRX_CALLDOWN MRxQueryDirectory;&#10;&#10;NTSTATUS MRxQueryDirectory(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryDirectory</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FileInformationClass</strong> member is set to <strong>IrpSp->Parameters.QueryDirectory.FileInformationClass</strong>.</p>

<p>The <strong>Info.Buffer</strong> member is set to user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryDirectory.Length</strong>.</p>

<p>The <strong>QueryDirectory.FileIndex</strong> member is set to <strong>IrpSp->Parameters.QueryDirectory.FileIndex</strong>.</p>

<p>The <strong>QueryDirectory.RestartScan</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_restart_scan" title="#define SL_RESTART_SCAN 0x01">SL_RESTART_SCAN</a> bit on.</p>

<p>The <strong>QueryDirectory.ReturnSingleEntry</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_return_single_entry" title="#define SL_RETURN_SINGLE_ENTRY 0x02">SL_RETURN_SINGLE_ENTRY</a> bit on.</p>

<p>The <strong>QueryDirectory.IndexSpecified</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a> bit on.</p>

<p>The <strong>QueryDirectory.InitialQuery</strong> member is set to nonzero if <strong>UnicodeQueryTemplate.Buffer</strong> member of the associated FOBX is NULL and the <strong>Flags</strong> member of the FOBX does not have the FOBX_FLAG_MATCH_ALL bit on.</p>

<p>For a wild card query ("<em>.</em>", for example), RDBSS will set the <strong>UnicodeQueryTemplate.Buffer</strong> member of the associated FOBX to the wild card query passed.</p>

<p>If the <strong>PostRequest</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure is <strong>TRUE</strong> on return from <strong><a href="mrxquerydirectory" title="PMRX_CALLDOWN MRxQueryDirectory;&#10;&#10;NTSTATUS MRxQueryDirectory(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryDirectory</a></strong>, then RDBSS will call <strong><a href="rxfsdpostrequest" title="NTSTATUS RxFsdPostRequest(&#10;  [in] IN PRX_CONTEXT RxContext&#10;);">RxFsdPostRequest</a></strong> passing the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to a worker queue for processing by the file system process (FSP).</p>

<p>The <strong><a href="mrxqueryeainfo" title="PMRX_CALLDOWN MRxQueryEaInfo;&#10;&#10;NTSTATUS MRxQueryEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryEaInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query extended attribute information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxqueryeainfo" title="PMRX_CALLDOWN MRxQueryEaInfo;&#10;&#10;NTSTATUS MRxQueryEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryEaInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-ea"><strong>IRP_MJ_QUERY_EA</strong></a> request.</p>

<p>Before calling <strong><a href="mrxqueryeainfo" title="PMRX_CALLDOWN MRxQueryEaInfo;&#10;&#10;NTSTATUS MRxQueryEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryEaInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member is set to the user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryEa.Length</strong>.</p>

<p>The <strong>QueryEa.UserEaList</strong> member is set to <strong>IrpSp->Parameters.QueryEa.EaList</strong>.</p>

<p>The <strong>QueryEa.UserEaListLength</strong> member is set to <strong>IrpSp->Parameters.QueryEa.EaListLength</strong>.</p>

<p>The <strong>QueryEa.UserEaIndex</strong> member is set to <strong>IrpSp->Parameters.QueryEa.EaIndex</strong>.</p>

<p>The <strong>QueryEa.RestartScan</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_restart_scan" title="#define SL_RESTART_SCAN 0x01">SL_RESTART_SCAN</a> bit on.</p>

<p>The <strong>QueryEa.ReturnSingleEntry</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_return_single_entry" title="#define SL_RETURN_SINGLE_ENTRY 0x02">SL_RETURN_SINGLE_ENTRY</a> bit on.</p>

<p>The <strong>QueryEa.IndexSpecified</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a> bit on.</p>

<p>On success, <strong><a href="mrxqueryeainfo" title="PMRX_CALLDOWN MRxQueryEaInfo;&#10;&#10;NTSTATUS MRxQueryEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryEaInfo</a></strong> should set the <strong>Info.LengthRemaininging</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the length of extended attribute information returned and also update the <strong>Fobx->OffsetOfNextEaToReturn</strong> member. If the call to <strong><a href="mrxqueryeainfo" title="PMRX_CALLDOWN MRxQueryEaInfo;&#10;&#10;NTSTATUS MRxQueryEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryEaInfo</a></strong> was successful, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to <strong>IrpSp->Parameters.QueryEa.Length</strong> minus the <strong>Info.LengthRemaining</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a>.</p>

<p>The <strong><a href="mrxqueryfileinfo" title="PMRX_CALLDOWN MRxQueryFileInfo;&#10;&#10;NTSTATUS MRxQueryFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryFileInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query file information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxqueryfileinfo" title="PMRX_CALLDOWN MRxQueryFileInfo;&#10;&#10;NTSTATUS MRxQueryFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryFileInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-information"><strong>IRP_MJ_QUERY_INFORMATION</strong></a> request.</p>

<p>Before calling <strong><a href="mrxqueryfileinfo" title="PMRX_CALLDOWN MRxQueryFileInfo;&#10;&#10;NTSTATUS MRxQueryFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryFileInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FileInformationClass</strong> member is set to <strong>IrpSp->Parameters.QueryFile.FileInformationClass</strong>, the requested <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> value.</p>

<p>The <strong>Info.Buffer</strong> member is set to the user buffer from the I/O request packet.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryFile.Length</strong>.</p>

<p>The <strong>QueryDirectory.FileIndex</strong> member is set to <strong>IrpSp->Parameters.QueryDirectory.FileIndex</strong>.</p>

<p>The <strong>QueryDirectory.RestartScan</strong> member is set if <strong>IrpSp->Flags</strong> has the <a href="sl_restart_scan" title="#define SL_RESTART_SCAN 0x01">SL_RESTART_SCAN</a> bit set.</p>

<p>The <strong>QueryDirectory.ReturnSingleEntry</strong> member is set if <strong>IrpSp->Flags</strong> has <a href="sl_return_single_entry" title="#define SL_RETURN_SINGLE_ENTRY 0x02">SL_RETURN_SINGLE_ENTRY</a> bit set.</p>

<p>The <strong>QueryDirectory.InitialQuery</strong> member is set if <strong>Fobx->UnicodeQueryTemplate.Buffer</strong> is NULL and <strong>Fobx->Flags</strong> does not have the FOBX_FLAG_MATCH_ALL bit set.</p>

<p>On success, the network mini-redirector should set the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to <strong>Info.Length</strong> member minus the length of the file information returned. If the call to <strong><a href="mrxqueryfileinfo" title="PMRX_CALLDOWN MRxQueryFileInfo;&#10;&#10;NTSTATUS MRxQueryFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryFileInfo</a></strong> was successful, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to <strong>IrpSp->Parameters.QueryFile.Length</strong> minus The <strong>Info.LengthRemaining</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a>.</p>

<p>RDBSS does not support requests with the <a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a> bit of the <strong>IrpSp->Flags</strong> set. A network mini-redirector will not receive calls to <strong><a href="mrxqueryfileinfo" title="PMRX_CALLDOWN MRxQueryFileInfo;&#10;&#10;NTSTATUS MRxQueryFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryFileInfo</a></strong> with the <a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a> bit of <strong>IrpSp->Flags</strong> set.</p>

<p>The <strong><a href="mrxqueryquotainfo" title="PMRX_CALLDOWN MRxQueryQuotaInfo;&#10;&#10;NTSTATUS MRxQueryQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryQuotaInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query quota information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxqueryquotainfo" title="PMRX_CALLDOWN MRxQueryQuotaInfo;&#10;&#10;NTSTATUS MRxQueryQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryQuotaInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-quota"><strong>IRP_MJ_QUERY_QUOTA</strong></a> request.</p>

<p>Before calling <strong><a href="mrxqueryquotainfo" title="PMRX_CALLDOWN MRxQueryQuotaInfo;&#10;&#10;NTSTATUS MRxQueryQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryQuotaInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member is set to user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryQuota.Length</strong>.</p>

<p>The <strong>QueryQuota.SidList</strong> member is set to <strong>IrpSp->Parameters.QueryQuota.SidList</strong>.</p>

<p>The <strong>QueryQuota.SidListLength</strong> member is set to <strong>IrpSp->Parameters.QueryQuota.SidListLength</strong>.</p>

<p>The <strong>QueryQuota.StartSid</strong> member is set to <strong>IrpSp->Parameters.QueryQuota.StartSid</strong>.</p>

<p>The <strong>QueryQuota.Length</strong> member is set to <strong>IrpSp->Parameters.QueryQuota.Length</strong>.</p>

<p>The <strong>QueryQuota.RestartScan</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_restart_scan" title="#define SL_RESTART_SCAN 0x01">SL_RESTART_SCAN</a> bit set.</p>

<p>The <strong>QueryQuota.ReturnSingleEntry</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_return_single_entry" title="#define SL_RETURN_SINGLE_ENTRY 0x02">SL_RETURN_SINGLE_ENTRY</a> bit set.</p>

<p>The <strong>QueryQuota.IndexSpecified</strong> member is set to nonzero if <strong>IrpSp->Flags</strong> has the <a href="sl_index_specified" title="#define SL_INDEX_SPECIFIED 0x04">SL_INDEX_SPECIFIED</a> bit set.</p>

<p>On success, the network mini-redirector should set the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the length of the quota information to return. If the call to <strong><a href="mrxqueryquotainfo" title="PMRX_CALLDOWN MRxQueryQuotaInfo;&#10;&#10;NTSTATUS MRxQueryQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryQuotaInfo</a></strong> was successful, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the <strong>Info.LengthRemaining</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a>.</p>

<p>If the call to <strong><a href="mrxqueryquotainfo" title="PMRX_CALLDOWN MRxQueryQuotaInfo;&#10;&#10;NTSTATUS MRxQueryQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryQuotaInfo</a></strong> is successful, the <strong>InformationToReturn</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure should be set to the length of quota information returned. If the call is unsuccessful, the <strong>InformationToReturn</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> should be set to zero.</p>

<p>The <strong><a href="mrxquerysdinfo" title="PMRX_CALLDOWN MRxQuerySdInfo;&#10;&#10;NTSTATUS MRxQuerySdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQuerySdInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query security descriptor information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxquerysdinfo" title="PMRX_CALLDOWN MRxQuerySdInfo;&#10;&#10;NTSTATUS MRxQuerySdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQuerySdInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-security"><strong>IRP_MJ_QUERY_SECURITY</strong></a> request.</p>

<p>Before calling <strong><a href="mrxquerysdinfo" title="PMRX_CALLDOWN MRxQuerySdInfo;&#10;&#10;NTSTATUS MRxQuerySdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQuerySdInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>QuerySecurity.SecurityInformation</strong> member is set to <strong>IrpSp->Parameters.QuerySecurity.SecurityInformation</strong>.</p>

<p>The <strong>Info.Buffer</strong> member is set to user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QuerySecurity.Length</strong>.</p>

<p>On success, the network mini-redirector should set the <strong>InformationToReturn</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the length of the security information returned. If the call to <strong><a href="mrxquerysdinfo" title="PMRX_CALLDOWN MRxQuerySdInfo;&#10;&#10;NTSTATUS MRxQuerySdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQuerySdInfo</a></strong> was successful, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the <strong>InformationToReturn</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a>.</p>

<p>The <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector query volume information.</p>

<p>RDBSS issues a call to <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> in either of the following cases:</p>

<ul>
<li><p>RDBSS receives an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-query-volume-information"><strong>IRP_MJ_QUERY_VOLUME_INFORMATION</strong></a> request.</p></li>
<li><p>RDBSS receives an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control"><strong>IRP_MJ_FILE_SYSTEM_CONTROL</strong></a> request for an <a href="fsctl_lmr_get_link_tracking_information" title="// CTL_CODE(0x0014, 0x03a, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_LMR_GET_LINK_TRACKING_INFORMATION 0x001400E8">FSCTL_LMR_GET_LINK_TRACKING_INFORMATION</a> control code.</p></li>
</ul>

<p>Before calling <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> in the case of an <a href="irp_mj_query_volume_information" title="#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a">IRP_MJ_QUERY_VOLUME_INFORMATION</a> request, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FsInformationClass</strong> member is set to <strong>IrpSp->Parameters.QueryVolume.FsInformationClass</strong>.</p>

<p>The <strong>Info.Buffer</strong> member is set to <strong>Irp->AssociatedIrp.SystemBuffer</strong>.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryVolume.Length</strong>.</p>

<p>For an <a href="irp_mj_query_volume_information" title="#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a">IRP_MJ_QUERY_VOLUME_INFORMATION</a> request, if the <strong>PostRequest</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure is <strong>TRUE</strong> on return from <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong>, RDBSS will call <strong><a href="rxfsdpostrequest" title="NTSTATUS RxFsdPostRequest(&#10;  [in] IN PRX_CONTEXT RxContext&#10;);">RxFsdPostRequest</a></strong> to post the request. For this case, the <a href="irp_mj_query_volume_information" title="#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a">IRP_MJ_QUERY_VOLUME_INFORMATION</a> request will pass the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to queue <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> to a worker queue for processing by the file system process (FSP).</p>

<p>If the <strong>PostRequest</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure is <strong>FALSE</strong> on return from <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong>, the network mini-redirector must set the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the length of the volume information returned. RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to <strong>IrpSp->Parameters.QueryVolume.Length</strong> minus the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure.</p>

<p>If the call to <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> is successful, the network mini-redirector should set the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the <strong>Info.Length</strong> member minus the length of the volume information returned. If the call to <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> was successful, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to <strong>IrpSp->Parameters.QueryVolume.Length</strong> minus the <strong>Info.LengthRemaining</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure.</p>

<p>For an <a href="irp_mj_query_volume_information" title="#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a">IRP_MJ_QUERY_VOLUME_INFORMATION</a> request with the <strong>Info.FsInformationClass</strong> member set to <strong>FileFsDeviceInformation</strong>, the network mini-redirector returns the following information in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member contains an <a href="file_fs_device_information" title="typedef struct _FILE_FS_DEVICE_INFORMATION&#10;{&#10;    DEVICE_TYPE DeviceType;&#10;    ULONG Characteristics;&#10;} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;">FILE_FS_DEVICE_INFORMATION</a> structure</p>

<p>The <strong>Info.Buffer.Characteristics</strong> member is set to the characteristics of the volume, which must include <a href="file_remote_device" title="#define FILE_REMOTE_DEVICE 0x00000010">FILE_REMOTE_DEVICE</a> as one of the options.</p>

<p>The <strong>Info.Buffer.DeviceType</strong> member is set to the <strong>DeviceType</strong> member of the associated NET_ROOT structure. If the <strong>Type</strong> member of the associated NET_ROOT is NET_ROOT_PIPE, <strong>Info.Buffer.DeviceType</strong> member is set to FILE_DEVICE_NAMED_PIPE.</p>

<p>For an <a href="irp_mj_query_volume_information" title="#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a">IRP_MJ_QUERY_VOLUME_INFORMATION</a> request with the <strong>Info.FsInformationClass</strong> member set to <strong>FileFsVolumeInformation</strong>, the network mini-redirector returns the following information in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member contains a <a href="file_fs_volume_information" title="typedef struct _FILE_FS_VOLUME_INFORMATION&#10;{&#10;    LARGE_INTEGER VolumeCreationTime;&#10;    ULONG VolumeSerialNumber;&#10;    ULONG VolumeLabelLength;&#10;    BOOLEAN SupportsObjects;&#10;    _Field_size_bytes_(VolumeLabelLength) WCHAR VolumeLabel[1];&#10;} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;">FILE_FS_VOLUME_INFORMATION</a> structure.</p>

<p>The <strong>Info.Buffer</strong> member is set to the <strong>VolumeInfo</strong> member of the associated NET_ROOT structure.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to the <strong>VolumeInfoLength</strong> member of the associated NET_ROOT structure.</p>

<p>An <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> call from RDBSS for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-file-system-control"><strong>IRP_MJ_FILE_SYSTEM_CONTROL</strong></a> is a request for the link tracking information. Before calling <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> for <a href="irp_mj_file_system_control" title="#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d">IRP_MJ_FILE_SYSTEM_CONTROL</a>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FsInformationClass</strong> member is set to <strong>FileFsObjectIdInformation</strong>.</p>

<p>The <strong>Info.Buffer</strong> member is set to a <a href="file_fs_objectid_information" title="typedef struct _FILE_FS_OBJECTID_INFORMATION&#10;{&#10;    UCHAR ObjectId[16];&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            UCHAR BirthVolumeId[16];&#10;            UCHAR BirthObjectId[16];&#10;            UCHAR DomainId[16];&#10;        };&#10;        UCHAR ExtendedInfo[48];&#10;    };&#10;} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;">FILE_FS_OBJECTID_INFORMATION</a> structure.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>sizeof</strong>(<a href="file_fs_objectid_information" title="typedef struct _FILE_FS_OBJECTID_INFORMATION&#10;{&#10;    UCHAR ObjectId[16];&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            UCHAR BirthVolumeId[16];&#10;            UCHAR BirthObjectId[16];&#10;            UCHAR DomainId[16];&#10;        };&#10;        UCHAR ExtendedInfo[48];&#10;    };&#10;} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;">FILE_FS_OBJECTID_INFORMATION</a>).</p>

<p>For this case of an <a href="irp_mj_file_system_control" title="#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d">IRP_MJ_FILE_SYSTEM_CONTROL</a> request, the <strong>AssociatedIrp.SystemBuffer</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> points to a <a href="link_tracking_information" title="typedef struct _LINK_TRACKING_INFORMATION {&#10;  LINK_TRACKING_INFORMATION_TYPE Type;&#10;  UCHAR                          VolumeId[16];&#10;} LINK_TRACKING_INFORMATION, *PLINK_TRACKING_INFORMATION;">LINK_TRACKING_INFORMATION</a> structure.</p>

<p>If a request is initiated as an <a href="irp_mj_file_system_control" title="#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d">IRP_MJ_FILE_SYSTEM_CONTROL</a> to <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> with a return value of <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or STATUS_BUFFER_OVERFLOW, RDBSS copies the <strong>ObjectId</strong> member of the <a href="file_fs_objectid_information" title="typedef struct _FILE_FS_OBJECTID_INFORMATION&#10;{&#10;    UCHAR ObjectId[16];&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            UCHAR BirthVolumeId[16];&#10;            UCHAR BirthObjectId[16];&#10;            UCHAR DomainId[16];&#10;        };&#10;        UCHAR ExtendedInfo[48];&#10;    };&#10;} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION;">FILE_FS_OBJECTID_INFORMATION</a> structure passed in the <strong>Info.Buffer</strong> member of <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure to the <strong>NetRoot->DiskParameters.VolumeId</strong> member of the FCB structure and to the <strong>AssociatedIrp.SystemBuffer.VolumeId</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. If the call to <strong><a href="mrxqueryvolumeinfo" title="PMRX_CALLDOWN MRxQueryVolumeInfo;&#10;&#10;NTSTATUS MRxQueryVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxQueryVolumeInfo</a></strong> was successful, RDBSS sets the <strong>Type</strong> member of the <a href="link_tracking_information" title="typedef struct _LINK_TRACKING_INFORMATION {&#10;  LINK_TRACKING_INFORMATION_TYPE Type;&#10;  UCHAR                          VolumeId[16];&#10;} LINK_TRACKING_INFORMATION, *PLINK_TRACKING_INFORMATION;">LINK_TRACKING_INFORMATION</a> structure. If the <strong>NetRoot->Flags</strong> member of the FCB structure has the NETROOT_FLAG_DFS_AWARE_NETROOT bit set, the <strong>Type</strong> member is set by RDBSS to <strong>DfsLinkTrackingInformation</strong>. If the <strong>NetRoot->Flags</strong> member of the FCB structure does not have the NETROOT_FLAG_DFS_AWARE_NETROOT bit set, the <strong>Type</strong> member is set by RDBSS to <strong>NtfsLinkTrackingInformation</strong>. On success, RDBSS sets the <strong>IoStatus.Information</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the size of a <a href="link_tracking_information" title="typedef struct _LINK_TRACKING_INFORMATION {&#10;  LINK_TRACKING_INFORMATION_TYPE Type;&#10;  UCHAR                          VolumeId[16];&#10;} LINK_TRACKING_INFORMATION, *PLINK_TRACKING_INFORMATION;">LINK_TRACKING_INFORMATION</a> structure.</p>

<p>The <strong><a href="mrxseteainfo" title="PMRX_CALLDOWN MRxSetEaInfo;&#10;&#10;NTSTATUS MRxSetEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetEaInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set extended attribute information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxseteainfo" title="PMRX_CALLDOWN MRxSetEaInfo;&#10;&#10;NTSTATUS MRxSetEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetEaInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-ea"><strong>IRP_MJ_SET_EA</strong></a> request.</p>

<p>Before calling <strong><a href="mrxseteainfo" title="PMRX_CALLDOWN MRxSetEaInfo;&#10;&#10;NTSTATUS MRxSetEaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetEaInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member is set to the user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.QueryEa.Length</strong>.</p>

<p>The <strong><a href="mrxsetfileinfo" title="PMRX_CALLDOWN MRxSetFileInfo;&#10;&#10;NTSTATUS MRxSetFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set file information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxsetfileinfo" title="PMRX_CALLDOWN MRxSetFileInfo;&#10;&#10;NTSTATUS MRxSetFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-information"><strong>IRP_MJ_SET_INFORMATION</strong></a> request.</p>

<p>Before calling <strong><a href="mrxsetfileinfo" title="PMRX_CALLDOWN MRxSetFileInfo;&#10;&#10;NTSTATUS MRxSetFileInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FileInformationClass</strong> member is set to <strong>IrpSp->Parameters.SetFile.FileInformationClass</strong>, the specified <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> value.</p>

<p>The <strong>Info.Buffer</strong> member is set to <strong>Irp->AssociatedIrp.SystemBuffer</strong>.</p>

<p>The <strong>Info.Length</strong> member is set to <strong>IrpSp->Parameters.SetFile.Length</strong>.</p>

<p>The <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set file information on a file system object at cleanup.</p>

<p>RDBSS issues a call to <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong> during cleanup, when the last handle to a file object is closed. This is different than the close operation which is invoked when the last reference to a file object is deleted.</p>

<p><strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong> is called by RDBSS if the timestamps on a file or the size of a file have changed. The calls to <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong> by RDBSS are made separately for each of these changes. If both the file size and the timestamps have changed, then RDBSS makes two calls to <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong>.</p>

<p>Before calling <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter if the timestamps on a file have changed:</p>

<p>The <strong>Info.FileInformationClass</strong> member is set to a <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> value of FileBasicInformation.</p>

<p>The <strong>Info.Buffer</strong> member is set to a <a href="file_basic_information" title="typedef struct _FILE_BASIC_INFORMATION&#10;{&#10;    LARGE_INTEGER CreationTime;         // Specifies the time that the file was created.&#10;    LARGE_INTEGER LastAccessTime;       // Specifies the time that the file was last accessed.&#10;    LARGE_INTEGER LastWriteTime;        // Specifies the time that the file was last written to.&#10;    LARGE_INTEGER ChangeTime;           // Specifies the last time the file was changed.&#10;    ULONG FileAttributes;               // Specifies one or more FILE_ATTRIBUTE_XXX flags.&#10;} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;">FILE_BASIC_INFORMATION</a> structure allocated on the stack.</p>

<p>The <strong>Info.Length</strong> member is set to the sizeof a <a href="file_basic_information" title="typedef struct _FILE_BASIC_INFORMATION&#10;{&#10;    LARGE_INTEGER CreationTime;         // Specifies the time that the file was created.&#10;    LARGE_INTEGER LastAccessTime;       // Specifies the time that the file was last accessed.&#10;    LARGE_INTEGER LastWriteTime;        // Specifies the time that the file was last written to.&#10;    LARGE_INTEGER ChangeTime;           // Specifies the last time the file was changed.&#10;    ULONG FileAttributes;               // Specifies one or more FILE_ATTRIBUTE_XXX flags.&#10;} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;">FILE_BASIC_INFORMATION</a> structure.</p>

<p>Before calling <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter if the size of a file has changed:</p>

<p>The <strong>Info.FileInformationClass</strong> member is set to a <a href="file_information_class" title="typedef enum _FILE_INFORMATION_CLASS&#10;{&#10;    FileDirectoryInformation = 1,                   // q: FILE_DIRECTORY_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileFullDirectoryInformation,                   // q: FILE_FULL_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBothDirectoryInformation,                   // q: FILE_BOTH_DIR_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileBasicInformation,                           // qs: FILE_BASIC_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileStandardInformation,                        // q: FILE_STANDARD_INFORMATION, FILE_STANDARD_INFORMATION_EX&#10;    FileInternalInformation,                        // q: FILE_INTERNAL_INFORMATION&#10;    FileEaInformation,                              // q: FILE_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileAccessInformation,                          // q: FILE_ACCESS_INFORMATION&#10;    FileNameInformation,                            // q: FILE_NAME_INFORMATION&#10;    FileRenameInformation,                          // s: FILE_RENAME_INFORMATION (requires DELETE) // 10&#10;    FileLinkInformation,                            // s: FILE_LINK_INFORMATION&#10;    FileNamesInformation,                           // q: FILE_NAMES_INFORMATION (requires FILE_LIST_DIRECTORY) (NtQueryDirectoryFile[Ex])&#10;    FileDispositionInformation,                     // s: FILE_DISPOSITION_INFORMATION (requires DELETE)&#10;    FilePositionInformation,                        // qs: FILE_POSITION_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileFullEaInformation,                          // q: FILE_FULL_EA_INFORMATION (requires FILE_READ_EA)&#10;    FileModeInformation,                            // qs: FILE_MODE_INFORMATION (q: requires FILE_READ_ATTRIBUTES; s: requires FILE_WRITE_ATTRIBUTES)&#10;    FileAlignmentInformation,                       // q: FILE_ALIGNMENT_INFORMATION&#10;    FileAllInformation,                             // q: FILE_ALL_INFORMATION&#10;...">FILE_INFORMATION_CLASS</a> value of FileEndOfFileInformation.</p>

<p>The <strong>Info.Buffer</strong> member is set to a <a href="file_end_of_file_information" title="typedef struct _FILE_END_OF_FILE_INFORMATION&#10;{&#10;    LARGE_INTEGER EndOfFile;&#10;} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;">FILE_END_OF_FILE_INFORMATION</a> structure allocated on the stack.</p>

<p>The <strong>Info.Length</strong> member is set to <strong>sizeof(</strong><a href="file_end_of_file_information" title="typedef struct _FILE_END_OF_FILE_INFORMATION&#10;{&#10;    LARGE_INTEGER EndOfFile;&#10;} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;">FILE_END_OF_FILE_INFORMATION</a><strong>)</strong>.</p>

<p>RDBSS ignores the return value from <strong><a href="mrxsetfileinfoatcleanup" title="PMRX_CALLDOWN MRxSetFileInfoAtCleanup;&#10;&#10;NTSTATUS MRxSetFileInfoAtCleanup(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetFileInfoAtCleanup</a></strong>.</p>

<p>A network mini-redirector can choose to do nothing in this routine and return <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. Any changes to the file size or timestamps will be handled during the cleanup operation.</p>

<p>The <strong><a href="mrxsetquotainfo" title="PMRX_CALLDOWN MRxSetQuotaInfo;&#10;&#10;NTSTATUS MRxSetQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetQuotaInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set quota information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxsetquotainfo" title="PMRX_CALLDOWN MRxSetQuotaInfo;&#10;&#10;NTSTATUS MRxSetQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetQuotaInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-quota"><strong>IRP_MJ_SET_QUOTA</strong></a> request.</p>

<p>Before calling <strong><a href="mrxsetquotainfo" title="PMRX_CALLDOWN MRxSetQuotaInfo;&#10;&#10;NTSTATUS MRxSetQuotaInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetQuotaInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.Buffer</strong> member is set to the user buffer from I/O request packet. This buffer has already been locked by RDBSS if needed.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.SetQuota.Length</strong>.</p>

<p>The <strong><a href="mrxsetsdinfo" title="PMRX_CALLDOWN MRxSetSdInfo;&#10;&#10;NTSTATUS MRxSetSdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetSdInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set security descriptor information on a file system object.</p>

<p>RDBSS issues a call to <strong><a href="mrxsetsdinfo" title="PMRX_CALLDOWN MRxSetSdInfo;&#10;&#10;NTSTATUS MRxSetSdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetSdInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-security"><strong>IRP_MJ_SET_SECURITY</strong></a> request.</p>

<p>Before calling <strong><a href="mrxsetsdinfo" title="PMRX_CALLDOWN MRxSetSdInfo;&#10;&#10;NTSTATUS MRxSetSdInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetSdInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>SetSecurity.SecurityInformation</strong> member is set to <strong>IrpSp->Parameters.SetSecurity.SecurityInformation</strong>.</p>

<p>The <strong>SetSecurity.SecurityDescriptor</strong> member is set to <strong>IrpSp->Parameters.SetSecurity.SecurityDescriptor</strong>.</p>

<p>The <strong><a href="mrxsetvolumeinfo" title="PMRX_CALLDOWN MRxSetVolumeInfo;&#10;&#10;NTSTATUS MRxSetVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetVolumeInfo</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector set volume information.</p>

<p>RDBSS issues a call to <strong><a href="mrxsetvolumeinfo" title="PMRX_CALLDOWN MRxSetVolumeInfo;&#10;&#10;NTSTATUS MRxSetVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetVolumeInfo</a></strong> in response to receiving an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-set-volume-information"><strong>IRP_MJ_SET_VOLUME_INFORMATION</strong></a> request.</p>

<p>Before calling <strong><a href="mrxsetvolumeinfo" title="PMRX_CALLDOWN MRxSetVolumeInfo;&#10;&#10;NTSTATUS MRxSetVolumeInfo(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxSetVolumeInfo</a></strong>, RDBSS modifies the following members in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>Info.FsInformationClass</strong> member is set to <strong>IrpSp->Parameters.SetVolume.FsInformationClass</strong>.</p>

<p>The <strong>Info.Buffer</strong> member is set to <strong>Irp->AssociatedIrp.SystemBuffer</strong>.</p>

<p>The <strong>Info.LengthRemaining</strong> member is set to <strong>IrpSp->Parameters.SetVolume.Length</strong>.</p>

<p>The <strong><a href="mrxshouldtrytocollapsethisopen" title="PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;&#10;&#10;NTSTATUS MRxShouldTryToCollapseThisOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxShouldTryToCollapseThisOpen</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector indicate if RDBSS should try and collapse an open request onto an existing file system object.</p>

<p><strong><a href="mrxshouldtrytocollapsethisopen" title="PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;&#10;&#10;NTSTATUS MRxShouldTryToCollapseThisOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxShouldTryToCollapseThisOpen</a></strong> is called to determine if an open request should not be collapsed.</p>

<p>Before calling <strong><a href="mrxshouldtrytocollapsethisopen" title="PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;&#10;&#10;NTSTATUS MRxShouldTryToCollapseThisOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxShouldTryToCollapseThisOpen</a></strong>, RDBSS modifies the following member in the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure pointed to by the <strong>RxContext</strong> parameter:</p>

<p>The <strong>pRelevantSrvOpen</strong> member is set to the SRV_OPEN.</p>

<p>The call to <strong><a href="mrxshouldtrytocollapsethisopen" title="PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;&#10;&#10;NTSTATUS MRxShouldTryToCollapseThisOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxShouldTryToCollapseThisOpen</a></strong> could be a change notify request for a directory. Therefore, the network mini-redirector might not allow collapsing open requests so that change notification works correctly.</p>

<p>RDBSS disallows collapsing opens if the <strong>Create.NtCreateParameters.CreateOptions</strong> member of the <a href="rx_context" title="typedef struct _RX_CONTEXT {&#10;  NODE_TYPE_CODE         NodeTypeCode;&#10;  NODE_BYTE_SIZE         NodeByteSize;&#10;  __volatile ULONG       ReferenceCount;&#10;  LIST_ENTRY             ContextListEntry;&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  BOOLEAN                PendingReturned;&#10;  BOOLEAN                PostRequest;&#10;  PDEVICE_OBJECT         RealDevice;&#10;  PIRP                   CurrentIrp;&#10;  PIO_STACK_LOCATION     CurrentIrpSp;&#10;  PMRX_FCB               pFcb;&#10;  PMRX_FOBX              pFobx;&#10;  PMRX_SRV_OPEN          pRelevantSrvOpen;&#10;  PNON_PAGED_FCB         NonPagedFcb;&#10;  PRDBSS_DEVICE_OBJECT   RxDeviceObject;&#10;  PETHREAD               OriginalThread;&#10;  PETHREAD               LastExecutionThread;&#10;  __volatile PVOID       LockManagerContext;&#10;...">RX_CONTEXT</a> structure has the <a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a> option or the <a href="file_delete_on_close" title="#define FILE_DELETE_ON_CLOSE 0x00001000">FILE_DELETE_ON_CLOSE</a> option set.</p>

<p>The <strong><a href="mrxtruncate" title="PMRX_CALLDOWN MRxTruncate;&#10;&#10;NTSTATUS MRxTruncate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxTruncate</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector truncate the contents of a file system object.</p>

<p><strong><a href="mrxtruncate" title="PMRX_CALLDOWN MRxTruncate;&#10;&#10;NTSTATUS MRxTruncate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxTruncate</a></strong> is called as part of cleanup operations if both of the following conditions are true:</p>

<ul>
<li><p>The file object corresponds to a disk file or directory</p></li>
<li><p>This is the last cleanup call and the file object was marked for truncation.</p></li>
</ul>

<p>The file object is marked for truncation if the <strong>fcbstate</strong> member of the FCB structure has the FCB_STATE_TRUNCATE_ON_CLOSE bit set. RDBSS will uninitialize the cache map at some later time.</p>

<p>A call to <strong><a href="mrxtruncate" title="PMRX_CALLDOWN MRxTruncate;&#10;&#10;NTSTATUS MRxTruncate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxTruncate</a></strong> will be followed by a call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff549841(v=vs.85)"><strong>MRxCleanupFobx</strong></a> as part of the cleanup operation.</p>

<p>RDBSS ignores the return value from <strong><a href="mrxtruncate" title="PMRX_CALLDOWN MRxTruncate;&#10;&#10;NTSTATUS MRxTruncate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxTruncate</a></strong>.</p>

<p>The <strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong> routine is called by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/the-rdbss-driver-and-library">RDBSS</a> to request that a network mini-redirector truncate the contents of a file system object.</p>

<p><strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong> is called as part of cleanup operations if the file object was not marked for deletion and the file object is not a paging file. <strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong> is called to ensure that the portion between the valid data length and the file size is zero-extended. After calling <strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong>, RDBSS sets the <strong>Header.ValidDataLength.QuadPart</strong> member of the structure of an FCB structure equal to the <strong>Header.FileSize.QuadPart</strong> member of the FCB structure.</p>

<p>A call to <strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong> will be followed by a call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff549841(v=vs.85)"><strong>MRxCleanupFobx</strong></a> as part of the cleanup operation.</p>

<p>RDBSS ignores the return value from <strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong>.</p>

<p>The <a href="mrxcleanupfobx" title="PMRX_CALLDOWN MRxCleanupFobx;&#10;&#10;NTSTATUS MRxCleanupFobx(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCleanupFobx</a> routine is called by RDBSS to request the network mini-redirector to close a file system object extension. RDBSS issues this call in response to receiving an <a href="irp_mj_cleanup" title="#define IRP_MJ_CLEANUP 0x12">IRP_MJ_CLEANUP</a> request on a file object.</p>

<p><a href="mrxcleanupfobx" title="PMRX_CALLDOWN MRxCleanupFobx;&#10;&#10;NTSTATUS MRxCleanupFobx(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCleanupFobx</a> is called by RDBSS as part of cleanup and close operations on a file object.</p>

<p><a href="mrxcleanupfobx" title="PMRX_CALLDOWN MRxCleanupFobx;&#10;&#10;NTSTATUS MRxCleanupFobx(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCleanupFobx</a> cannot return a value of STATUS_RETRY indicating that the call should be retried. If a retry loop is necessary, it must be handled internally in the <a href="mrxcleanupfobx" title="PMRX_CALLDOWN MRxCleanupFobx;&#10;&#10;NTSTATUS MRxCleanupFobx(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCleanupFobx</a> routine by the network mini-redirector.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_chkfcb_calldown"><strong>MRxAreFilesAliased</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff549841(v=vs.85)"><strong>MRxCleanupFobx</strong></a></p>

<p><strong><a href="mrxcollapseopen" title="PMRX_CALLDOWN MRxCollapseOpen;&#10;&#10;NTSTATUS MRxCollapseOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCollapseOpen</a></strong></p>

<p><strong><a href="mrxcreate" title="PMRX_CALLDOWN MRxCreate;&#10;&#10;NTSTATUS MRxCreate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxCreate</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_deallocate_for_fobx"><strong>MRxDeallocateForFobx</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_deallocate_for_fobx"><strong>MRxDeallocateForFobx</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_extendfile_calldown"><strong>MRxExtendForCache</strong></a></p>

<p><strong><a href="mrxextendfornoncache" title="PMRX_EXTENDFILE_CALLDOWN MRxExtendForNonCache;&#10;&#10;ULONG MRxExtendForNonCache(&#10;  _Inout_ PRX_CONTEXT    RxContext,&#10;  _Inout_ PLARGE_INTEGER pNewFileSize,&#10;  _Out_   PLARGE_INTEGER pNewAllocationSize&#10;)&#10;{ ... }">MRxExtendForNonCache</a></strong></p>

<p><strong><a href="mrxflush" title="PMRX_CALLDOWN MRxFlush;&#10;&#10;NTSTATUS MRxFlush(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxFlush</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_forceclosed_calldown"><strong>MRxForceClosed</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_is_lock_realizable"><strong>MRxIsLockRealizable</strong></a></p>

<p><strong><a href="mrxshouldtrytocollapsethisopen" title="PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;&#10;&#10;NTSTATUS MRxShouldTryToCollapseThisOpen(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxShouldTryToCollapseThisOpen</a></strong></p>

<p><strong><a href="mrxtruncate" title="PMRX_CALLDOWN MRxTruncate;&#10;&#10;NTSTATUS MRxTruncate(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxTruncate</a></strong></p>

<p><strong><a href="mrxzeroextend" title="PMRX_CALLDOWN MRxZeroExtend;&#10;&#10;NTSTATUS MRxZeroExtend(&#10;  _Inout_ PRX_CONTEXT RxContext&#10;)&#10;{ ... }">MRxZeroExtend</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/rxprocs/nf-rxprocs-rxfinalizenetfcb"><strong>RxFinalizeNetFCB</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/mrx/nc-mrx-pmrx_calldown">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/mrx/nc-mrx-pmrx_calldown.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
