<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FsRtlCopyRead - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FsRtlCopyRead - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FsRtlCopyRead - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">BOOLEAN FsRtlCopyRead(
  [in]  <a href="file_object" title="typedef struct _FILE_OBJECT {&#10;  CSHORT                                Type;&#10;  CSHORT                                Size;&#10;  PDEVICE_OBJECT                        DeviceObject;&#10;  PVPB                                  Vpb;&#10;  PVOID                                 FsContext;&#10;  PVOID                                 FsContext2;&#10;  PSECTION_OBJECT_POINTERS              SectionObjectPointer;&#10;  PVOID                                 PrivateCacheMap;&#10;  NTSTATUS                              FinalStatus;&#10;  struct _FILE_OBJECT                   *RelatedFileObject;&#10;  BOOLEAN                               LockOperation;&#10;  BOOLEAN                               DeletePending;&#10;  BOOLEAN                               ReadAccess;&#10;  BOOLEAN                               WriteAccess;&#10;  BOOLEAN                               DeleteAccess;&#10;  BOOLEAN                               SharedRead;&#10;  BOOLEAN                               SharedWrite;&#10;  BOOLEAN                               SharedDelete;&#10;  ULONG                                 Flags;&#10;...">PFILE_OBJECT</a>     FileObject,
  [in]  PLARGE_INTEGER   FileOffset,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in]  BOOLEAN          Wait,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            LockKey,
  [out] PVOID            Buffer,
  [out] <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatus,
  [in]  <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>   DeviceObject
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlcopyread">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fsrtlcopyread.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlcopyread)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fsrtlcopyread-function">FsRtlCopyRead function</h1>

<h2 id="description">Description</h2>

<p>The <strong>FsRtlCopyRead</strong> routine copies data from a cached file to a user buffer.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="fileobject-in"><code>FileObject</code> [in]</h3>

<p>Pointer to a file object for the cached file from which the data is to be read.</p>

<h3 id="fileoffset-in"><code>FileOffset</code> [in]</h3>

<p>Starting byte offset within the cached file.</p>

<h3 id="length-in"><code>Length</code> [in]</h3>

<p>Length in bytes of the data to be read.</p>

<h3 id="wait-in"><code>Wait</code> [in]</h3>

<p>Set to TRUE if the caller can be put into a wait state until all the data has been copied, FALSE otherwise.</p>

<h3 id="lockkey-in"><code>LockKey</code> [in]</h3>

<p>A value that is associated with the byte range to lock. If the range to lock overlaps another range that is already locked with a nonexclusive lock, or if the range to read is a subrange of another range that is already locked nonexclusively, the value in this parameter must be the key for that nonexclusive lock The lock must be held by the parent process of the calling thread. Otherwise, this parameter has no effect.</p>

<h3 id="buffer-out"><code>Buffer</code> [out]</h3>

<p>Pointer to a buffer into which the data is to be copied.</p>

<h3 id="iostatus-out"><code>IoStatus</code> [out]</h3>

<p>Pointer to a caller-allocated structure that receives the final completion status and information about the operation. If the data is copied successfully, <strong>IoStatus.Status</strong> contains <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. If not all of the data is copied successfully, <strong>IoStatus.Information</strong> contains the actual number of bytes that were copied.</p>

<h3 id="deviceobject-in"><code>DeviceObject</code> [in]</h3>

<p>The device object for the device that holds the file data.</p>

<h2 id="return-value">Return value</h2>

<p><strong>FsRtlCopyRead</strong> returns TRUE if the copy request was completed, FALSE otherwise. Note that a return value of TRUE does not necessarily mean that the copy operation was successful.</p>

<p>If <strong>FsRtlCopyRead</strong> returns FALSE, or if the contents of <strong>IoStatus</strong> indicate that the copy operation failed, the caller must allocate a read <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> instead of calling <strong>FsRtlCopyRead</strong>.</p>

<h2 id="remarks">Remarks</h2>

<p>Rather than implementing a file-system-specific fast I/O read routine, developers of file systems that support file caching should consider using <strong>FsRtlCopyRead</strong> as the file system's entry point for processing fast I/O read requests. This requires that the file system's <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine set the <strong>FastIoRead</strong> entry point to <strong>FsRtlCopyRead</strong> in the <a href="fast_io_dispatch" title="typedef struct _FAST_IO_DISPATCH {&#10;  ULONG                                  SizeOfFastIoDispatch;&#10;  PFAST_IO_CHECK_IF_POSSIBLE             FastIoCheckIfPossible;&#10;  PFAST_IO_READ                          FastIoRead;&#10;  PFAST_IO_WRITE                         FastIoWrite;&#10;  PFAST_IO_QUERY_BASIC_INFO              FastIoQueryBasicInfo;&#10;  PFAST_IO_QUERY_STANDARD_INFO           FastIoQueryStandardInfo;&#10;  PFAST_IO_LOCK                          FastIoLock;&#10;  PFAST_IO_UNLOCK_SINGLE                 FastIoUnlockSingle;&#10;  PFAST_IO_UNLOCK_ALL                    FastIoUnlockAll;&#10;  PFAST_IO_UNLOCK_ALL_BY_KEY             FastIoUnlockAllByKey;&#10;  PFAST_IO_DEVICE_CONTROL                FastIoDeviceControl;&#10;  PFAST_IO_ACQUIRE_FILE                  AcquireFileForNtCreateSection;&#10;  PFAST_IO_RELEASE_FILE                  ReleaseFileForNtCreateSection;&#10;  PFAST_IO_DETACH_DEVICE                 FastIoDetachDevice;&#10;  PFAST_IO_QUERY_NETWORK_OPEN_INFO       FastIoQueryNetworkOpenInfo;&#10;  PFAST_IO_ACQUIRE_FOR_MOD_WRITE         AcquireForModWrite;&#10;  PFAST_IO_MDL_READ                      MdlRead;&#10;  PFAST_IO_MDL_READ_COMPLETE             MdlReadComplete;&#10;  PFAST_IO_PREPARE_MDL_WRITE             PrepareMdlWrite;&#10;...">FAST_IO_DISPATCH</a> structure of the file system driver object. In addition, the file system must do the following:</p>

<ol>
<li><p>For each file on which fast I/O might be performed, the file system must allocate and initialize an <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure.</p>

<p>In most file systems, this is accomplished by including the <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure in a file control block (FCB) or comparable structure that is used to maintain the state of an open file.</p>

<p>Storage for the <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure is typically allocated from paged pool.</p></li>
<li><p>For each file on which fast I/O might be performed, the file system must link any file objects for the file to the <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure. This is done by setting each file object's <strong>FsContext</strong> member to point to this structure (or the FCB or other structure that contains the <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure).</p></li>
<li><p>When caching a file, the file system must set the <strong>IsFastIoPossible</strong> member of the file's <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure to an appropriate value. This value should be updated as needed for as long as the file remains cached.</p>

<p>In particular, file systems should set the <strong>IsFastIoPossible</strong> member of the <a href="fsrtl_common_fcb_header" title="typedef struct _FSRTL_COMMON_FCB_HEADER {&#10;  CSHORT        NodeTypeCode;&#10;  CSHORT        NodeByteSize;&#10;  UCHAR         Flags;&#10;  UCHAR         IsFastIoPossible;&#10;  UCHAR         Flags2;&#10;  UCHAR         Reserved : 4;&#10;  UCHAR         Version : 4;&#10;  PERESOURCE    Resource;&#10;  PERESOURCE    PagingIoResource;&#10;  LARGE_INTEGER AllocationSize;&#10;  LARGE_INTEGER FileSize;&#10;  LARGE_INTEGER ValidDataLength;&#10;} FSRTL_COMMON_FCB_HEADER;">FSRTL_COMMON_FCB_HEADER</a> structure to <strong>FastIoIsQuestionable</strong> as soon as any exclusive byte-range lock on the cached file exists.</p></li>
</ol>

<p>If <strong>Wait</strong> is TRUE, <strong>FsRtlCopyRead</strong> is guaranteed to complete the copy request and return TRUE. If the required pages of the cached file are already resident in memory, the data will be copied immediately and no blocking will occur. If any needed pages are not resident, the caller will be put into a wait state until all required pages have been made resident and the data can be copied.</p>

<p>If <strong>Wait</strong> is FALSE, <strong>FsRtlCopyRead</strong> will refuse to block, and will return FALSE, if it cannot acquire the file's main resource or if the required pages of the cached file are not already resident in memory.</p>

<p>The file system's <strong>FastIoCheckIfPossible</strong> routine is responsible for ensuring that the byte range defined by <strong>FileOffset</strong> and <strong>Length</strong> does not include any exclusively locked byte range for which the caller does not pass the appropriate <strong>LockKey</strong> value. If the file system uses the <strong>FsRtl<em>Xxx</em>Lock*Yyy</strong>* support routines to manage byte-range locks, this can be accomplished by calling <strong><a href="fsrtlfastchecklockforread" title="BOOLEAN FsRtlFastCheckLockForRead(&#10;  [in] PFILE_LOCK     FileLock,&#10;  [in] PLARGE_INTEGER StartingByte,&#10;  [in] PLARGE_INTEGER Length,&#10;  [in] ULONG          Key,&#10;  [in] PFILE_OBJECT   FileObject,&#10;  [in] PVOID          ProcessId&#10;);">FsRtlFastCheckLockForRead</a></strong> from the <strong>FastIoCheckIfPossible</strong> routine before calling <strong>FsRtlCopyRead</strong>.</p>

<p>To cache a file, use the <strong><a href="ccinitializecachemap" title="VOID CcInitializeCacheMap(&#10;  [in] PFILE_OBJECT             FileObject,&#10;  [in] PCC_FILE_SIZES           FileSizes,&#10;  [in] BOOLEAN                  PinAccess,&#10;  [in] PCACHE_MANAGER_CALLBACKS Callbacks,&#10;  [in] PVOID                    LazyWriteContext&#10;);">CcInitializeCacheMap</a></strong> routine.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="ccinitializecachemap" title="VOID CcInitializeCacheMap(&#10;  [in] PFILE_OBJECT             FileObject,&#10;  [in] PCC_FILE_SIZES           FileSizes,&#10;  [in] BOOLEAN                  PinAccess,&#10;  [in] PCACHE_MANAGER_CALLBACKS Callbacks,&#10;  [in] PVOID                    LazyWriteContext&#10;);">CcInitializeCacheMap</a></strong></p>

<p><strong><a href="fsrtlcopywrite" title="BOOLEAN FsRtlCopyWrite(&#10;  [in]  PFILE_OBJECT     FileObject,&#10;  [in]  PLARGE_INTEGER   FileOffset,&#10;  [in]  ULONG            Length,&#10;  [in]  BOOLEAN          Wait,&#10;  [in]  ULONG            LockKey,&#10;  [in]  PVOID            Buffer,&#10;  [out] PIO_STATUS_BLOCK IoStatus,&#10;  [in]  PDEVICE_OBJECT   DeviceObject&#10;);">FsRtlCopyWrite</a></strong></p>

<p><strong><a href="fsrtlfastchecklockforread" title="BOOLEAN FsRtlFastCheckLockForRead(&#10;  [in] PFILE_LOCK     FileLock,&#10;  [in] PLARGE_INTEGER StartingByte,&#10;  [in] PLARGE_INTEGER Length,&#10;  [in] ULONG          Key,&#10;  [in] PFILE_OBJECT   FileObject,&#10;  [in] PVOID          ProcessId&#10;);">FsRtlFastCheckLockForRead</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlcopyread">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-_fsrtl_advanced_fcb_header-fsrtlcopyread.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
