<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="DXGKARGCB_NOTIFY_INTERRUPT_DATA - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>DXGKARGCB_NOTIFY_INTERRUPT_DATA - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            DXGKARGCB_NOTIFY_INTERRUPT_DATA - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dkmddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _DXGKARGCB_NOTIFY_INTERRUPT_DATA {
  <a href="dxgk_interrupt_type" title="typedef enum _DXGK_INTERRUPT_TYPE {&#10;  DXGK_INTERRUPT_DMA_COMPLETED = 1,&#10;  DXGK_INTERRUPT_DMA_PREEMPTED = 2,&#10;  DXGK_INTERRUPT_CRTC_VSYNC = 3,&#10;  DXGK_INTERRUPT_DMA_FAULTED = 4,&#10;  DXGK_INTERRUPT_DISPLAYONLY_VSYNC = 5,&#10;  DXGK_INTERRUPT_DISPLAYONLY_PRESENT_PROGRESS = 6,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY = 7,&#10;  DXGK_INTERRUPT_MICACAST_CHUNK_PROCESSING_COMPLETE = 8,&#10;  DXGK_INTERRUPT_DMA_PAGE_FAULTED = 9,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY2 = 10,&#10;  DXGK_INTERRUPT_MONITORED_FENCE_SIGNALED = 11,&#10;  DXGK_INTERRUPT_HWQUEUE_PAGE_FAULTED = 12,&#10;  DXGK_INTERRUPT_HWCONTEXTLIST_SWITCH_COMPLETED = 13,&#10;  DXGK_INTERRUPT_PERIODIC_MONITORED_FENCE_SIGNALED = 14,&#10;  DXGK_INTERRUPT_SCHEDULING_LOG_INTERRUPT = 15,&#10;  DXGK_INTERRUPT_GPU_ENGINE_TIMEOUT = 16,&#10;  DXGK_INTERRUPT_SUSPEND_CONTEXT_COMPLETED = 17,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY3 = 18,&#10;  DXGK_INTERRUPT_NATIVE_FENCE_SIGNALED = 19,&#10;...">DXGK_INTERRUPT_TYPE</a>                InterruptType;
  union {
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> SubmissionFenceId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> EngineOrdinal;
    } DmaCompleted;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> PreemptionFenceId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> LastCompletedFenceId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> EngineOrdinal;
    } DmaPreempted;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>     FaultedFenceId;
      <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Status;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>     NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>     EngineOrdinal;
    } DmaFaulted;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId;
      <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>               PhysicalAddress;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                           PhysicalAdapterMask;
    } CrtcVsync;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId;
    } DisplayOnlyVsync;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID     VidPnTargetId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                               PhysicalAdapterMask;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                               MultiPlaneOverlayVsyncInfoCount;
      <a href="dxgk_multiplane_overlay_vsync_info" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO {&#10;       DWORD                              LayerIndex;&#10;       BOOL                               Enabled;&#10;  [in] PHYSICAL_ADDRESS                   PhysicalAddress;&#10;       DXGK_MULTIPLANE_OVERLAY_ATTRIBUTES PlaneAttributes;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO</a> *pMultiPlaneOverlayVsyncInfo;
    } CrtcVsyncWithMultiPlaneOverlay;
    <a href="dxgkargcb_present_displayonly_progress" title="typedef struct _DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS {&#10;  D3DDDI_VIDEO_PRESENT_SOURCE_ID        VidPnSourceId;&#10;  DXGK_PRESENT_DISPLAY_ONLY_PROGRESS_ID ProgressId;&#10;} DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS;">DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS</a> DisplayOnlyPresentProgress;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId;
      <a href="dxgk_miracast_chunk_info" title="typedef struct {&#10;  DXGK_MIRACAST_CHUNK_TYPE ChunkType;&#10;  DXGK_MIRACAST_CHUNK_ID   ChunkId;&#10;  UINT                     ProcessingTime;&#10;  UINT                     EncodeRate;&#10;} DXGK_MIRACAST_CHUNK_INFO;">DXGK_MIRACAST_CHUNK_INFO</a>       ChunkInfo;
      PVOID                          pPrivateDriverData;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                           PrivateDataDriverSize;
      <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>                       Status;
    } MiracastEncodeChunkCompleted;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       FaultedFenceId;
      <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a>                     FaultedPrimitiveAPISequenceNumber;
      <a href="dxgk_render_pipeline_stage" title="typedef enum _DXGK_RENDER_PIPELINE_STAGE {&#10;  DXGK_RENDER_PIPELINE_STAGE_UNKNOWN,&#10;  DXGK_RENDER_PIPELINE_STAGE_INPUT_ASSEMBLER,&#10;  DXGK_RENDER_PIPELINE_STAGE_VERTEX_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_GEOMETRY_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_STREAM_OUTPUT,&#10;  DXGK_RENDER_PIPELINE_STAGE_RASTERIZER,&#10;  DXGK_RENDER_PIPELINE_STAGE_PIXEL_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_OUTPUT_MERGER&#10;} DXGK_RENDER_PIPELINE_STAGE;">DXGK_RENDER_PIPELINE_STAGE</a> FaultedPipelineStage;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       FaultedBindTableEntry;
      <a href="dxgk_page_fault_flags" title="typedef enum _DXGK_PAGE_FAULT_FLAGS {&#10;  DXGK_PAGE_FAULT_WRITE,&#10;  DXGK_PAGE_FAULT_FENCE_INVALID,&#10;  DXGK_PAGE_FAULT_ADAPTER_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_ENGINE_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_FATAL_HARDWARE_ERROR,&#10;  DXGK_PAGE_FAULT_IOMMU,&#10;  DXGK_PAGE_FAULT_HW_CONTEXT_VALID,&#10;  DXGK_PAGE_FAULT_PROCESS_HANDLE_VALID&#10;} DXGK_PAGE_FAULT_FLAGS;">DXGK_PAGE_FAULT_FLAGS</a>      PageFaultFlags;
      D3DGPU_VIRTUAL_ADDRESS     FaultedVirtualAddress;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       EngineOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       PageTableLevel;
      <a href="dxgk_fault_error_code" title="typedef struct _DXGK_FAULT_ERROR_CODE {&#10;  union {&#10;    struct {&#10;      UINT                    IsDeviceSpecificCode : 1;&#10;      DXGK_GENERAL_ERROR_CODE GeneralErrorCode : 31;&#10;    };&#10;    struct {&#10;      UINT IsDeviceSpecificCodeReservedBit : 1;&#10;      UINT DeviceSpecificCode : 31;&#10;    };&#10;  };&#10;} DXGK_FAULT_ERROR_CODE;">DXGK_FAULT_ERROR_CODE</a>      FaultErrorCode;
      HANDLE                     FaultedProcessHandle;
    } DmaPageFaulted;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID      VidPnTargetId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                                PhysicalAdapterMask;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                                MultiPlaneOverlayVsyncInfoCount;
      <a href="dxgk_multiplane_overlay_vsync_info2" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2 {&#10;  DWORD                         LayerIndex;&#10;  ULONGLONG                     PresentId;&#10;  DXGKCB_NOTIFY_MPO_VSYNC_FLAGS Flags;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2</a> *pMultiPlaneOverlayVsyncInfo;
      <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                           GpuFrequency;
      <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                           GpuClockCounter;
    } CrtcVsyncWithMultiPlaneOverlay2;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> EngineOrdinal;
    } MonitoredFenceSignaled;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   EngineOrdinal;
      <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a> ContextSwitchFence;
    } HwContextListSwitchCompleted;
    struct {
      <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a>                     FaultedFenceId;
      D3DGPU_VIRTUAL_ADDRESS     FaultedVirtualAddress;
      <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a>                     FaultedPrimitiveAPISequenceNumber;
      union {
        HANDLE FaultedHwQueue;
        HANDLE FaultedHwContext;
        HANDLE FaultedProcessHandle;
      };
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       EngineOrdinal;
      <a href="dxgk_render_pipeline_stage" title="typedef enum _DXGK_RENDER_PIPELINE_STAGE {&#10;  DXGK_RENDER_PIPELINE_STAGE_UNKNOWN,&#10;  DXGK_RENDER_PIPELINE_STAGE_INPUT_ASSEMBLER,&#10;  DXGK_RENDER_PIPELINE_STAGE_VERTEX_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_GEOMETRY_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_STREAM_OUTPUT,&#10;  DXGK_RENDER_PIPELINE_STAGE_RASTERIZER,&#10;  DXGK_RENDER_PIPELINE_STAGE_PIXEL_SHADER,&#10;  DXGK_RENDER_PIPELINE_STAGE_OUTPUT_MERGER&#10;} DXGK_RENDER_PIPELINE_STAGE;">DXGK_RENDER_PIPELINE_STAGE</a> FaultedPipelineStage;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       FaultedBindTableEntry;
      <a href="dxgk_page_fault_flags" title="typedef enum _DXGK_PAGE_FAULT_FLAGS {&#10;  DXGK_PAGE_FAULT_WRITE,&#10;  DXGK_PAGE_FAULT_FENCE_INVALID,&#10;  DXGK_PAGE_FAULT_ADAPTER_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_ENGINE_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_FATAL_HARDWARE_ERROR,&#10;  DXGK_PAGE_FAULT_IOMMU,&#10;  DXGK_PAGE_FAULT_HW_CONTEXT_VALID,&#10;  DXGK_PAGE_FAULT_PROCESS_HANDLE_VALID&#10;} DXGK_PAGE_FAULT_FLAGS;">DXGK_PAGE_FAULT_FLAGS</a>      PageFaultFlags;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                       PageTableLevel;
      <a href="dxgk_fault_error_code" title="typedef struct _DXGK_FAULT_ERROR_CODE {&#10;  union {&#10;    struct {&#10;      UINT                    IsDeviceSpecificCode : 1;&#10;      DXGK_GENERAL_ERROR_CODE GeneralErrorCode : 31;&#10;    };&#10;    struct {&#10;      UINT IsDeviceSpecificCodeReservedBit : 1;&#10;      UINT DeviceSpecificCode : 31;&#10;    };&#10;  };&#10;} DXGK_FAULT_ERROR_CODE;">DXGK_FAULT_ERROR_CODE</a>      FaultErrorCode;
    } HwQueuePageFaulted;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID VidPnTargetId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                           NotificationID;
    } PeriodicMonitoredFenceSignaled;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> EngineOrdinal;
    } SchedulingLogInterrupt;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> EngineOrdinal;
    } GpuEngineTimeout;
    struct {
      HANDLE hContext;
      <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a> ContextSuspendFence;
    } SuspendContextCompleted;
    struct {
      D3DDDI_VIDEO_PRESENT_TARGET_ID      VidPnTargetId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                                PhysicalAdapterMask;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                                MultiPlaneOverlayVsyncInfoCount;
      <a href="dxgk_multiplane_overlay_vsync_info3" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3 {&#10;  DWORD LayerIndex;&#10;  ULONG FirstFreeFlipQueueLogEntryIndex;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3</a> *pMultiPlaneOverlayVsyncInfo;
      <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                           GpuFrequency;
      <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                           GpuClockCounter;
    } CrtcVsyncWithMultiPlaneOverlay3;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   EngineOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   SignaledNativeFenceCount;
      HANDLE *pSignaledNativeFenceArray;
      HANDLE hHWQueue;
    } NativeFenceSignaled;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>              NodeOrdinal;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>              EngineOrdinal;
      <a href="dxgk_engine_state" title="typedef enum _DXGK_ENGINE_STATE {&#10;  DXGK_ENGINE_STATE_ACTIVE,&#10;  DXGK_ENGINE_STATE_TRANSITION_TO_F1,&#10;  DXGK_ENGINE_STATE_HUNG&#10;} DXGK_ENGINE_STATE;">DXGK_ENGINE_STATE</a> NewState;
    } EngineStateChange;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> Reserved[16];
    } Reserved;
  };
  <a href="dxgkcb_notify_interrupt_data_flags" title="typedef struct _DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS {&#10;  union {&#10;    struct {&#10;      UINT ValidPhysicalAdapterMask : 1;&#10;      UINT HsyncFlipCompletion : 1;&#10;      UINT EvaluateLegacyMonitoredFences : 1;&#10;#if ...&#10;      UINT Reserved : 29;&#10;#else&#10;      UINT Reserved : 31;&#10;#endif&#10;    };&#10;    UINT Value;&#10;  };&#10;} DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS;">DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS</a> Flags;
} DXGKARGCB_NOTIFY_INTERRUPT_DATA;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkargcb_notify_interrupt_data">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/dxgkargcb_notify_interrupt_data.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-d3dkmddi-_dxgkargcb_notify_interrupt_data)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>DXGKARGCB_NOTIFY_INTERRUPT_DATA structure</h1>
<h2>Description</h2>
<p>The <strong>DXGKARGCB_NOTIFY_INTERRUPT_DATA</strong> structure contains interrupt notification information for the <strong><a href="dxgkcb_notify_interrupt" title="DXGKCB_NOTIFY_INTERRUPT DxgkcbNotifyInterrupt;&#10;&#10;VOID DxgkcbNotifyInterrupt(&#10;  [in] IN_CONST_HANDLE hAdapter,&#10;  [in] IN_CONST_PDXGKARGCB_NOTIFY_INTERRUPT_DATA unnamedParam2&#10;)&#10;{...}">DXGKCB_NOTIFY_INTERRUPT</a></strong> callback function.</p>
<h2>Members</h2>
<h3><code>InterruptType</code></h3>
<p>A <strong><a href="dxgk_interrupt_type" title="typedef enum _DXGK_INTERRUPT_TYPE {&#10;  DXGK_INTERRUPT_DMA_COMPLETED = 1,&#10;  DXGK_INTERRUPT_DMA_PREEMPTED = 2,&#10;  DXGK_INTERRUPT_CRTC_VSYNC = 3,&#10;  DXGK_INTERRUPT_DMA_FAULTED = 4,&#10;  DXGK_INTERRUPT_DISPLAYONLY_VSYNC = 5,&#10;  DXGK_INTERRUPT_DISPLAYONLY_PRESENT_PROGRESS = 6,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY = 7,&#10;  DXGK_INTERRUPT_MICACAST_CHUNK_PROCESSING_COMPLETE = 8,&#10;  DXGK_INTERRUPT_DMA_PAGE_FAULTED = 9,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY2 = 10,&#10;  DXGK_INTERRUPT_MONITORED_FENCE_SIGNALED = 11,&#10;  DXGK_INTERRUPT_HWQUEUE_PAGE_FAULTED = 12,&#10;  DXGK_INTERRUPT_HWCONTEXTLIST_SWITCH_COMPLETED = 13,&#10;  DXGK_INTERRUPT_PERIODIC_MONITORED_FENCE_SIGNALED = 14,&#10;  DXGK_INTERRUPT_SCHEDULING_LOG_INTERRUPT = 15,&#10;  DXGK_INTERRUPT_GPU_ENGINE_TIMEOUT = 16,&#10;  DXGK_INTERRUPT_SUSPEND_CONTEXT_COMPLETED = 17,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY3 = 18,&#10;  DXGK_INTERRUPT_NATIVE_FENCE_SIGNALED = 19,&#10;...">DXGK_INTERRUPT_TYPE</a></strong>-typed value that indicates the type of interrupt the display miniport driver is notifying the GPU scheduler about.</p>
<h3><code>DmaCompleted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DMA_COMPLETED</strong>.</p>
<h3><code>DmaCompleted.SubmissionFenceId</code></h3>
<p>The DMA buffer fence identifier of the completed command. This identifier was assigned during a call to the driver's <strong><a href="dxgkddi_submitcommand" title="DXGKDDI_SUBMITCOMMAND DxgkddiSubmitcommand;&#10;&#10;NTSTATUS DxgkddiSubmitcommand(&#10;  [in] IN_CONST_HANDLE hAdapter,&#10;  [in] IN_CONST_PDXGKARG_SUBMITCOMMAND pSubmitCommand&#10;)&#10;{...}">DXGKDDI_SUBMITCOMMAND</a></strong> function for the latest completed DMA buffer.</p>
<h3><code>DmaCompleted.NodeOrdinal</code></h3>
<p>The zero-based index of the node that generates the notification.</p>
<h3><code>DmaCompleted.EngineOrdinal</code></h3>
<p>The zero-based index of the engine, within the node that <strong>NodeOrdinal</strong> specifies, that generates the notification. For graphics adapters that are not part of a link, you should always set <strong>EngineOrdinal</strong> to 0. For graphics adapters that are part of a link, set <strong>EngineOrdinal</strong> to the adapter index of the adapter in the link that the interrupting engine belongs to.</p>
<h3><code>DmaPreempted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DMA_PREEMPTED</strong>.</p>
<h3><code>DmaPreempted.PreemptionFenceId</code></h3>
<p>The submission identifier of the preempting request.</p>
<h3><code>DmaPreempted.LastCompletedFenceId</code></h3>
<p>The submission identifier of the last completed command before preemption.</p>
<h3><code>DmaPreempted.NodeOrdinal</code></h3>
<p>The zero-based index of the node that generates the notification.</p>
<h3><code>DmaPreempted.EngineOrdinal</code></h3>
<p>The zero-based index of the engine, within the node that <strong>NodeOrdinal</strong> specifies, that generates the notification. For graphics adapters that are not part of a link, you should always set <strong>EngineOrdinal</strong> set to 0. For graphics adapters that are part of a link, set <strong>EngineOrdinal</strong> to the adapter index of the adapter in the link that the interrupting engine belongs to. The GPU scheduler determines that hardware preempted all commands between the preemption request and the submission that <strong>LastCompletedFenceId</strong> specifies.</p>
<h3><code>DmaFaulted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DMA_FAULTED</strong>.</p>
<h3><code>DmaFaulted.FaultedFenceId</code></h3>
<p>The identifier of the faulty command.</p>
<h3><code>DmaFaulted.Status</code></h3>
<p>The status of the faulty command.</p>
<h3><code>DmaFaulted.NodeOrdinal</code></h3>
<p>The zero-based index of the node that generates the notification.</p>
<h3><code>DmaFaulted.EngineOrdinal</code></h3>
<p>The zero-based index of the engine, within the node that <strong>NodeOrdinal</strong> specifies, that generates the notification. For graphics adapters that are not part of a link, you should always set <strong>EngineOrdinal</strong> to 0. For graphics adapters that are part of a link, set <strong>EngineOrdinal</strong> to the adapter index of the adapter in the link that the interrupting engine belongs to.</p>
<h3><code>CrtcVsync</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_CRTC_VSYNC</strong>.</p>
<h3><code>CrtcVsync.VidPnTargetId</code></h3>
<p>The zero-based identification number of the video present target in a path of a video present network (VidPN) topology. This number represents the video present target where the vertical sync occurs.</p>
<h3><code>CrtcVsync.PhysicalAddress</code></h3>
<p>The physical address of the displaying buffer. When monitor visibility is off, the operating system still expects a non-<strong>NULL</strong> physical address. This address should be set to the physical address that the pixel pipeline would read from if visibility were on.</p>
<h3><code>CrtcVsync.PhysicalAdapterMask</code></h3>
<p>The physical adapter mask where the vertical sync occurs. If this member contains a valid value, the driver must also set the <strong>ValidPhysicalAdapterMask</strong> bit-field flag in the <strong>Flags</strong> member.</p>
<h3><code>DisplayOnlyVsync</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DISPLAYONLY_VSYNC</strong>. Supported starting with Windows 8.</p>
<h3><code>DisplayOnlyVsync.VidPnTargetId</code></h3>
<p>For a display-only driver, the zero-based identification number of the video present target in a path of a video present network (VidPN) topology. This number represents the video present target where the vertical sync occurs. Supported starting with Windows 8.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY</strong>. Provides VSync notifications for display miniport drivers that support multiplane overlays. Supported starting with Windows 8.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay.VidPnTargetId</code></h3>
<p>The zero-based identification number of the video present target in a path of a video present network (VidPN) topology. This number represents the video present target where the vertical sync occurs. Supported starting with Windows 8.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay.PhysicalAdapterMask</code></h3>
<p>The physical adapter mask where the vertical sync occurs. If this member contains a valid value, the driver must also set the <strong>ValidPhysicalAdapterMask</strong> bit-field flag in the <strong>Flags</strong> member. Supported starting with Windows 8.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay.MultiPlaneOverlayVsyncInfoCount</code></h3>
<p>The number of overlay planes that are available to display. Supported starting with Windows 8.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay.pMultiPlaneOverlayVsyncInfo</code></h3>
<p>A pointer to a <strong><a href="dxgk_multiplane_overlay_vsync_info" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO {&#10;       DWORD                              LayerIndex;&#10;       BOOL                               Enabled;&#10;  [in] PHYSICAL_ADDRESS                   PhysicalAddress;&#10;       DXGK_MULTIPLANE_OVERLAY_ATTRIBUTES PlaneAttributes;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO</a></strong> structure that specifies an overlay plane to display during a VSync interval. Supported starting with Windows 8.</p>
<h3><code>DisplayOnlyPresentProgress</code></h3>
<p>A <strong><a href="dxgkargcb_present_displayonly_progress" title="typedef struct _DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS {&#10;  D3DDDI_VIDEO_PRESENT_SOURCE_ID        VidPnSourceId;&#10;  DXGK_PRESENT_DISPLAY_ONLY_PROGRESS_ID ProgressId;&#10;} DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS;">DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS</a></strong> structure that provides the progress of a kernel mode display-only driver's (KMDOD) present operation. Used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DISPLAYONLY_PRESENT_PROGRESS</strong>. Supported starting with Windows 8.</p>
<h3><code>MiracastEncodeChunkCompleted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_MICACAST_CHUNK_PROCESSING_COMPLETE</strong>. Supported by WDDM 1.3 and later display miniport drivers running on Windows 8.1 and later.</p>
<h3><code>MiracastEncodeChunkCompleted.VidPnTargetId</code></h3>
<p>The zero-based identification number of the video present target in a path of a video present network (VidPN) topology. This number represents the video present target where the encoding is being performed. Supported starting with Windows 8.1.</p>
<h3><code>MiracastEncodeChunkCompleted.ChunkInfo</code></h3>
<p>A <strong><a href="dxgk_miracast_chunk_info" title="typedef struct {&#10;  DXGK_MIRACAST_CHUNK_TYPE ChunkType;&#10;  DXGK_MIRACAST_CHUNK_ID   ChunkId;&#10;  UINT                     ProcessingTime;&#10;  UINT                     EncodeRate;&#10;} DXGK_MIRACAST_CHUNK_INFO;">DXGK_MIRACAST_CHUNK_INFO</a></strong> encode chunk information structure that the display miniport driver wants to report. Supported starting with Windows 8.1.</p>
<h3><code>MiracastEncodeChunkCompleted.pPrivateDriverData</code></h3>
<p>A pointer to a block of private data that describes this encode chunk. Supported starting with Windows 8.1.</p>
<h3><code>MiracastEncodeChunkCompleted.PrivateDataDriverSize</code></h3>
<p>The size, in bytes, of the block of private data in <strong>pPrivateDriverData</strong>.
This value must not be larger than the <strong>MaxChunkPrivateDriverDataSize</strong> value that the driver reported in the <strong><a href="dxgk_miracast_caps" title="typedef struct _DXGK_MIRACAST_CAPS {&#10;  ULONG MaxChunkPrivateDriverDataSize;&#10;  union {&#10;    struct {&#10;      UINT HdcpSupport : 1;&#10;      UINT Reserved : 31;&#10;    };&#10;    UINT Value;&#10;  } Flags;&#10;} DXGK_MIRACAST_CAPS, *PDXGK_MIRACAST_CAPS;">DXGK_MIRACAST_CAPS</a></strong> structure. Supported starting with Windows 8.1.</p>
<h3><code>MiracastEncodeChunkCompleted.Status</code></h3>
<p>A value of type <strong><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></strong> that indicates whether the encode chunk was successfully added to the queue of chunks. If successful, <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong> is returned. If any other value is returned, the chunk could not be added to the queue, and all outstanding chunks will be lost. Supported starting with Windows 8.1.</p>
<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></td>
  <td>The chunk was successfully added to the queue.</td>
</tr>
<tr>
  <td>STATUS_INVALID_PARAMETER</td>
  <td>Parameters were validated and determined to be incorrect.</td>
</tr>
<tr>
  <td>STATUS_NO_MEMORY</td>
  <td>The interrupt-service-routine (ISR) ran out of free encode chunks.</td>
</tr>
</tbody>
</table>
<h3><code>DmaPageFaulted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_DMA_PAGE_FAULTED</strong>. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedFenceId</code></h3>
<p>Submission fence ID of faulted command.</p>
<p>If the faulted fence cannot be determined reliably, <strong>PageFaultFlags</strong> should have <strong>DXGK_PAGE_FAULT_FENCE_INVALID</strong> bit set, and <strong>FaultedFenceId</strong> should be set to 0. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedPrimitiveAPISequenceNumber</code></h3>
<p>When per draw fence write is enabled, this identifies the draw operation that caused the page fault, or <strong>DXGK_PRIMITIVE_API_SEQUENCE_NUMBER_UNKNOWN</strong> if such information is not available. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedPipelineStage</code></h3>
<p>Render pipeline stage during which the fault was generated, or <strong>DXGK_RENDER_PIPELINE_STAGE_UNKNOWN</strong> if such information is not available. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedBindTableEntry</code></h3>
<p>A bind table index of a resource being accessed at the time of the fault, or <strong>DXGK_BIND_TABLE_ENTRY_UNKNOWN</strong> if such information is not available. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.PageFaultFlags</code></h3>
<p>Flags described in <strong><a href="dxgk_page_fault_flags" title="typedef enum _DXGK_PAGE_FAULT_FLAGS {&#10;  DXGK_PAGE_FAULT_WRITE,&#10;  DXGK_PAGE_FAULT_FENCE_INVALID,&#10;  DXGK_PAGE_FAULT_ADAPTER_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_ENGINE_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_FATAL_HARDWARE_ERROR,&#10;  DXGK_PAGE_FAULT_IOMMU,&#10;  DXGK_PAGE_FAULT_HW_CONTEXT_VALID,&#10;  DXGK_PAGE_FAULT_PROCESS_HANDLE_VALID&#10;} DXGK_PAGE_FAULT_FLAGS;">DXGK_PAGE_FAULT_FLAGS</a></strong> enumeration specifying the nature of the fault. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedVirtualAddress</code></h3>
<p>GPU virtual address of fault, or <strong>D3DGPU_NULL</strong> if the fault has another cause. In the latter case, <strong>FaultErrorCode</strong> field should be used to describe the GPU error. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.NodeOrdinal</code></h3>
<p>Node ordinal of the engine generating the notification. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.EngineOrdinal</code></h3>
<p>Engine ordinal of the engine generating the notification. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.PageTableLevel</code></h3>
<p>Describes page table level that the faulting operation was attempted on. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultErrorCode</code></h3>
<p>A <strong><a href="dxgk_fault_error_code" title="typedef struct _DXGK_FAULT_ERROR_CODE {&#10;  union {&#10;    struct {&#10;      UINT                    IsDeviceSpecificCode : 1;&#10;      DXGK_GENERAL_ERROR_CODE GeneralErrorCode : 31;&#10;    };&#10;    struct {&#10;      UINT IsDeviceSpecificCodeReservedBit : 1;&#10;      UINT DeviceSpecificCode : 31;&#10;    };&#10;  };&#10;} DXGK_FAULT_ERROR_CODE;">DXGK_FAULT_ERROR_CODE</a></strong> structure describing the error. Supported starting with Windows 10.</p>
<h3><code>DmaPageFaulted.FaultedProcessHandle</code></h3>
<p>DirectX graphics kernel process handle of the process that generated page fault, or <strong>NULL</strong> if the faulted process cannot be determined. Supported starting with Windows 10.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY2</strong>. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.VidPnTargetId</code></h3>
<p>Vsync with multiplane overlay Vidpn target id. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.PhysicalAdapterMask</code></h3>
<p>The physical adapter mask where the vertical sync occurs. If this member contains a valid value, the driver must also set the <strong>ValidPhysicalAdapterMask</strong> bit-field flag in the <strong>Flags</strong> member. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.MultiPlaneOverlayVsyncInfoCount</code></h3>
<p>The number of overlay planes that are available to display. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.pMultiPlaneOverlayVsyncInfo</code></h3>
<p>A pointer to a <strong><a href="dxgk_multiplane_overlay_vsync_info2" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2 {&#10;  DWORD                         LayerIndex;&#10;  ULONGLONG                     PresentId;&#10;  DXGKCB_NOTIFY_MPO_VSYNC_FLAGS Flags;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2</a></strong> structure that specifies information for each overlay plane updated by the VSync. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.GpuFrequency</code></h3>
<p>The frequency of the GPU clock counter. Supported starting with Windows 10, version 1607.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay2.GpuClockCounter</code></h3>
<p>The GPU clock counter at the time of the VSYNC interrupt. Combined with GpuFrequency, this indicates the time of the VSYNC interrupt. Supported starting with Windows 10, version 1607.</p>
<h3><code>MonitoredFenceSignaled</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_MONITORED_FENCE_SIGNALED</strong>. Supported starting with Windows 10, version 1703.</p>
<h3><code>MonitoredFenceSignaled.NodeOrdinal</code></h3>
<p>Node ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>MonitoredFenceSignaled.EngineOrdinal</code></h3>
<p>Engine ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwContextListSwitchCompleted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_HWCONTEXTLIST_SWITCH_COMPLETED</strong>. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwContextListSwitchCompleted.NodeOrdinal</code></h3>
<p>Node ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwContextListSwitchCompleted.EngineOrdinal</code></h3>
<p>Engine ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwContextListSwitchCompleted.ContextSwitchFence</code></h3>
<p>Context switch fence used to perform this switch operation. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_HWQUEUE_PAGE_FAULTED</strong>. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedFenceId</code></h3>
<p>HW queue progress fence ID of the faulted command. If the faulted fence could not be determined reliably PageFaultFlags should have DXGK_PAGE_FAULT_FENCE_INVALID flag set. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedVirtualAddress</code></h3>
<p>Virtual address of fault, or 0 if the fault has another cause. In the latter case, FaultErrorCode field should be used to describe the GPU error. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedPrimitiveAPISequenceNumber</code></h3>
<p>When per draw fence write is enabled, identifies the draw that caused the page fault, or DXGK_PRIMITIVE_API_SEQUENCE_NUMBER_UNKNOWN if such information is not available. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedHwQueue</code></h3>
<p>When DXGK_PAGE_FAULT_FENCE_INVALID is not set, specifies the handle of the HW queue that generated the fault. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedHwContext</code></h3>
<p>When DXGK_PAGE_FAULT_FENCE_INVALID and DXGK_PAGE_FAULT_HW_CONTEXT_VALID are set, specifies the handle of the HW context that generated the fault. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedProcessHandle</code></h3>
<p>Wen DXGK_PAGE_FAULT_FENCE_INVALID and DXGK_PAGE_FAULT_PROCESS_HANDLE_VALID are set, specifies the handle of the process that generated the fault. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.NodeOrdinal</code></h3>
<p>Node ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.EngineOrdinal</code></h3>
<p>Engine ordinal of engine generating the notification. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedPipelineStage</code></h3>
<p>Render pipeline stage during which the fault was generated, or DXGK_RENDER_PIPELINE_STAGE_UNKNOWN if such information is not available. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultedBindTableEntry</code></h3>
<p>A bind table index of a resource being accessed at the time of the fault, or DXGK_BIND_TABLE_ENTRY_UNKNOWN if such information is not available. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.PageFaultFlags</code></h3>
<p>Flags specifying the nature of the page fault and recovery policy. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.PageTableLevel</code></h3>
<p>Described page table level which the faulting operation was attempted on. Supported starting with Windows 10, version 1703.</p>
<h3><code>HwQueuePageFaulted.FaultErrorCode</code></h3>
<p>Structure that contains error code describing the fault. Supported starting with Windows 10, version 1703.</p>
<h3><code>PeriodicMonitoredFenceSignaled</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_PERIODIC_MONITORED_FENCE_SIGNALED</strong>. Supported starting with Windows 10, version 1703.</p>
<h3><code>PeriodicMonitoredFenceSignaled.VidPnTargetId</code></h3>
<p>The display signaling the monitored fence. Supported starting with Windows 10, version 1703.</p>
<h3><code>PeriodicMonitoredFenceSignaled.NotificationID</code></h3>
<p>The notification id as multiple can be attached to one VidPnSource. Supported starting with Windows 10, version 1703.</p>
<h3><code>SchedulingLogInterrupt</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_SCHEDULING_LOG_INTERRUPT</strong>. Supported starting with Windows 10, version 1803.</p>
<h3><code>SchedulingLogInterrupt.NodeOrdinal</code></h3>
<p>Node ordinal of engine that raised the scheduling log interrupt. Supported starting with Windows 10, version 1803.</p>
<h3><code>SchedulingLogInterrupt.EngineOrdinal</code></h3>
<p>Engine ordinal of engine that raised the scheduling log interrupt. Supported starting with Windows 10, version 1803.</p>
<h3><code>GpuEngineTimeout</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_GPU_ENGINE_TIMEOUT</strong>. Supported starting with Windows 10, version 1803.</p>
<h3><code>GpuEngineTimeout.NodeOrdinal</code></h3>
<p>Node ordinal of engine that timed out and needs the reset. Supported starting with Windows 10, version 1803.</p>
<h3><code>GpuEngineTimeout.EngineOrdinal</code></h3>
<p>Engine ordinal of engine that timed out and needs the reset. Supported starting with Windows 10, version 1803.</p>
<h3><code>SuspendContextCompleted</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_SUSPEND_CONTEXT_COMPLETED</strong>. Supported starting with Windows 10, version 1803.</p>
<h3><code>SuspendContextCompleted.hContext</code></h3>
<p>Hardware context that the suspend acknowledgment is for. Supported starting with Windows 10, version 1803.</p>
<h3><code>SuspendContextCompleted.ContextSuspendFence</code></h3>
<p>Context suspend fence. Supported starting with Windows 10, version 1803.</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3</code></h3>
<p>Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY3</strong>. Available starting with Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.VidPnTargetId</code></h3>
<p>Vsync with multiplane overlay Vidpn target id. Available starting with Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.PhysicalAdapterMask</code></h3>
<p>The physical adapter mask where the vertical sync occurs. If this member contains a valid value, the driver must also set the <strong>ValidPhysicalAdapterMask</strong> bit-field flag in the <strong>Flags</strong> member. Available starting in Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.MultiPlaneOverlayVsyncInfoCount</code></h3>
<p>The number of <strong><a href="dxgk_multiplane_overlay_vsync_info3" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3 {&#10;  DWORD LayerIndex;&#10;  ULONG FirstFreeFlipQueueLogEntryIndex;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3</a></strong> structures that <strong>CrtcVsyncWithMultiPlaneOverlay3.pMultiPlaneOverlayVsyncInfo</strong> points to. These structures describe the overlay planes that are available to display. Available starting in Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.pMultiPlaneOverlayVsyncInfo</code></h3>
<p>A pointer to an array of <strong><a href="dxgk_multiplane_overlay_vsync_info3" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3 {&#10;  DWORD LayerIndex;&#10;  ULONG FirstFreeFlipQueueLogEntryIndex;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO3</a></strong> structures that specify information for each overlay plane updated by the VSync. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/hardware-flip-queue">Hardware flip queue</a> for more information. Available starting in Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.GpuFrequency</code></h3>
<p>The frequency of the GPU clock counter. Available starting in Windows Server 2022 (WDDM 2.9).</p>
<h3><code>CrtcVsyncWithMultiPlaneOverlay3.GpuClockCounter</code></h3>
<p>The GPU clock counter at the time of the VSYNC interrupt. Combined with GpuFrequency, this indicates the time of the VSYNC interrupt. Available starting in Windows Server 2022 (WDDM 2.9).</p>
<h3><code>NativeFenceSignaled</code></h3>
<p>[in] Structure used when <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ne-d3dkmddi-_dxgk_interrupt_type"><strong>InterruptType</strong></a> is <strong>DXGK_INTERRUPT_NATIVE_FENCE_SIGNALED</strong>. For more information about native fences, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/native-gpu-fence-objects">Native GPU fence objects</a>. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>NativeFenceSignaled.NodeOrdinal</code></h3>
<p>Node ordinal of the engine generating the notification. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>NativeFenceSignaled.EngineOrdinal</code></h3>
<p>Engine ordinal of the engine generating the notification. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>NativeFenceSignaled.SignaledNativeFenceCount</code></h3>
<p>The size of the signaled native fence array that <strong>pSignaledNativeFenceArray</strong> points to. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>NativeFenceSignaled.pSignaledNativeFenceArray</code></h3>
<p>Array containing OS kernel-mode handles of all native fences that were signaled and require waiters to be unblocked. If this array is empty, the OS will rescan all pending native fence waiters instead of the subset specified by the signaled native fence array. <em>Dxgkrnl</em> reads this value only if <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_vidschcaps"><strong>DXGK_VIDSCHCAPS::OptimizedNativeFenceInterrupt</strong></a> is FALSE. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>NativeFenceSignaled.hHWQueue</code></h3>
<p>KMD handle of the HWQueue running on the engine that raised the interrupt. If this handle is NULL then <em>Dxgkrnl</em> will re-scan the log buffer of all HWQueues on this engine. <em>Dxgkrnl</em> reads this value only if <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_vidschcaps"><strong>DXGK_VIDSCHCAPS::OptimizedNativeFenceInterrupt</strong></a> is TRUE. Supported starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>EngineStateChange</code></h3>
<p>[in] Structure used when <strong>InterruptType</strong> is <strong>DXGK_INTERRUPT_GPU_ENGINE_STATE_CHANGE</strong>. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/user-mode-work-submission">User-mode work submission</a>. Available starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>EngineStateChange.NodeOrdinal</code></h3>
<p>Node ordinal of the engine whose state changed. Available starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>EngineStateChange.EngineOrdinal</code></h3>
<p>Engine ordinal of the engine whose state changed. Available starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>EngineStateChange.NewState</code></h3>
<p>A <strong><a href="dxgk_engine_state" title="typedef enum _DXGK_ENGINE_STATE {&#10;  DXGK_ENGINE_STATE_ACTIVE,&#10;  DXGK_ENGINE_STATE_TRANSITION_TO_F1,&#10;  DXGK_ENGINE_STATE_HUNG&#10;} DXGK_ENGINE_STATE;">DXGK_ENGINE_STATE</a></strong> value that specifies the new state of the engine. Available starting with Windows 11, version 24H2 (WDDM 3.2).</p>
<h3><code>Reserved</code></h3>
<p>Reserved for future use.</p>
<h3><code>Reserved.Reserved</code></h3>
<p>An array of 32-bit values that are reserved for future use.</p>
<h3><code>Flags</code></h3>
<p>A <strong><a href="dxgkcb_notify_interrupt_data_flags" title="typedef struct _DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS {&#10;  union {&#10;    struct {&#10;      UINT ValidPhysicalAdapterMask : 1;&#10;      UINT HsyncFlipCompletion : 1;&#10;      UINT EvaluateLegacyMonitoredFences : 1;&#10;#if ...&#10;      UINT Reserved : 29;&#10;#else&#10;      UINT Reserved : 31;&#10;#endif&#10;    };&#10;    UINT Value;&#10;  };&#10;} DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS;">DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS</a></strong> structure that indicates whether the display miniport driver provides a physical adapter mask in a call to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkcb_notify_interrupt"><strong>DxgkCbNotifyInterrupt</strong></a> function.</p>
<h2>Remarks</h2>
<p>A miniport driver fills in <strong>DXGKARGCB_NOTIFY_INTERRUPT_DATA</strong>, and then uses the <strong><a href="dxgkcb_synchronize_execution" title="DXGKCB_SYNCHRONIZE_EXECUTION DxgkcbSynchronizeExecution;&#10;&#10;NTSTATUS DxgkcbSynchronizeExecution(&#10;  [in]  HANDLE DeviceHandle,&#10;  [in]  PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,&#10;  [in]  PVOID Context,&#10;  [in]  ULONG MessageNumber,&#10;  [out] PBOOLEAN ReturnValue&#10;)&#10;{...}">DXGKCB_SYNCHRONIZE_EXECUTION</a></strong> callback to sync with the interrupt. The <strong>SynchronizeRoutine</strong> parameter of the <strong><a href="dxgkcb_synchronize_execution" title="DXGKCB_SYNCHRONIZE_EXECUTION DxgkcbSynchronizeExecution;&#10;&#10;NTSTATUS DxgkcbSynchronizeExecution(&#10;  [in]  HANDLE DeviceHandle,&#10;  [in]  PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,&#10;  [in]  PVOID Context,&#10;  [in]  ULONG MessageNumber,&#10;  [out] PBOOLEAN ReturnValue&#10;)&#10;{...}">DXGKCB_SYNCHRONIZE_EXECUTION</a></strong> callback points to a miniport-implemented function that gets called by the OS when appropriate, and then the driver fills out the parameter info before calling back into the OS with the <strong><a href="dxgkcb_notify_interrupt" title="DXGKCB_NOTIFY_INTERRUPT DxgkcbNotifyInterrupt;&#10;&#10;VOID DxgkcbNotifyInterrupt(&#10;  [in] IN_CONST_HANDLE hAdapter,&#10;  [in] IN_CONST_PDXGKARGCB_NOTIFY_INTERRUPT_DATA unnamedParam2&#10;)&#10;{...}">DXGKCB_NOTIFY_INTERRUPT</a></strong> callback. The OS then handles the interrupt, with the scheduler using information in the <a href="dxgk_multiplane_overlay_vsync_info2" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2 {&#10;  DWORD                         LayerIndex;&#10;  ULONGLONG                     PresentId;&#10;  DXGKCB_NOTIFY_MPO_VSYNC_FLAGS Flags;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO2</a> struct.</p>
<p>Depending on the value in the <strong>InterruptType</strong> member, the display miniport driver should set the appropriate union member in this structure. For example, for the end of a direct memory access (DMA) buffer fence, which corresponds to a value of DXGK_INTERRUPT_DMA_COMPLETED in <strong>InterruptType</strong>, the driver must set a value in the <strong>SubmissionFenceId</strong> member of the <strong>DmaCompleted</strong> member. This value should be the DMA buffer fence identifier, which the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_submitcommand"><strong>DxgkDdiSubmitCommand</strong></a> function assigned to the just completed DMA buffer.</p>
<h2>See also</h2>
<p><strong><a href="dxgk_interrupt_type" title="typedef enum _DXGK_INTERRUPT_TYPE {&#10;  DXGK_INTERRUPT_DMA_COMPLETED = 1,&#10;  DXGK_INTERRUPT_DMA_PREEMPTED = 2,&#10;  DXGK_INTERRUPT_CRTC_VSYNC = 3,&#10;  DXGK_INTERRUPT_DMA_FAULTED = 4,&#10;  DXGK_INTERRUPT_DISPLAYONLY_VSYNC = 5,&#10;  DXGK_INTERRUPT_DISPLAYONLY_PRESENT_PROGRESS = 6,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY = 7,&#10;  DXGK_INTERRUPT_MICACAST_CHUNK_PROCESSING_COMPLETE = 8,&#10;  DXGK_INTERRUPT_DMA_PAGE_FAULTED = 9,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY2 = 10,&#10;  DXGK_INTERRUPT_MONITORED_FENCE_SIGNALED = 11,&#10;  DXGK_INTERRUPT_HWQUEUE_PAGE_FAULTED = 12,&#10;  DXGK_INTERRUPT_HWCONTEXTLIST_SWITCH_COMPLETED = 13,&#10;  DXGK_INTERRUPT_PERIODIC_MONITORED_FENCE_SIGNALED = 14,&#10;  DXGK_INTERRUPT_SCHEDULING_LOG_INTERRUPT = 15,&#10;  DXGK_INTERRUPT_GPU_ENGINE_TIMEOUT = 16,&#10;  DXGK_INTERRUPT_SUSPEND_CONTEXT_COMPLETED = 17,&#10;  DXGK_INTERRUPT_CRTC_VSYNC_WITH_MULTIPLANE_OVERLAY3 = 18,&#10;  DXGK_INTERRUPT_NATIVE_FENCE_SIGNALED = 19,&#10;...">DXGK_INTERRUPT_TYPE</a></strong></p>
<p><strong><a href="dxgk_miracast_caps" title="typedef struct _DXGK_MIRACAST_CAPS {&#10;  ULONG MaxChunkPrivateDriverDataSize;&#10;  union {&#10;    struct {&#10;      UINT HdcpSupport : 1;&#10;      UINT Reserved : 31;&#10;    };&#10;    UINT Value;&#10;  } Flags;&#10;} DXGK_MIRACAST_CAPS, *PDXGK_MIRACAST_CAPS;">DXGK_MIRACAST_CAPS</a></strong></p>
<p><strong><a href="dxgk_miracast_chunk_info" title="typedef struct {&#10;  DXGK_MIRACAST_CHUNK_TYPE ChunkType;&#10;  DXGK_MIRACAST_CHUNK_ID   ChunkId;&#10;  UINT                     ProcessingTime;&#10;  UINT                     EncodeRate;&#10;} DXGK_MIRACAST_CHUNK_INFO;">DXGK_MIRACAST_CHUNK_INFO</a></strong></p>
<p><strong><a href="dxgk_multiplane_overlay_vsync_info" title="typedef struct _DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO {&#10;       DWORD                              LayerIndex;&#10;       BOOL                               Enabled;&#10;  [in] PHYSICAL_ADDRESS                   PhysicalAddress;&#10;       DXGK_MULTIPLANE_OVERLAY_ATTRIBUTES PlaneAttributes;&#10;} DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO;">DXGK_MULTIPLANE_OVERLAY_VSYNC_INFO</a></strong></p>
<p><strong><a href="dxgkcb_notify_interrupt" title="DXGKCB_NOTIFY_INTERRUPT DxgkcbNotifyInterrupt;&#10;&#10;VOID DxgkcbNotifyInterrupt(&#10;  [in] IN_CONST_HANDLE hAdapter,&#10;  [in] IN_CONST_PDXGKARGCB_NOTIFY_INTERRUPT_DATA unnamedParam2&#10;)&#10;{...}">DXGKCB_NOTIFY_INTERRUPT</a></strong></p>
<p><strong><a href="dxgkcb_notify_interrupt_data_flags" title="typedef struct _DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS {&#10;  union {&#10;    struct {&#10;      UINT ValidPhysicalAdapterMask : 1;&#10;      UINT HsyncFlipCompletion : 1;&#10;      UINT EvaluateLegacyMonitoredFences : 1;&#10;#if ...&#10;      UINT Reserved : 29;&#10;#else&#10;      UINT Reserved : 31;&#10;#endif&#10;    };&#10;    UINT Value;&#10;  };&#10;} DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS;">DXGKCB_NOTIFY_INTERRUPT_DATA_FLAGS</a></strong></p>
<p><strong><a href="dxgk_page_fault_flags" title="typedef enum _DXGK_PAGE_FAULT_FLAGS {&#10;  DXGK_PAGE_FAULT_WRITE,&#10;  DXGK_PAGE_FAULT_FENCE_INVALID,&#10;  DXGK_PAGE_FAULT_ADAPTER_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_ENGINE_RESET_REQUIRED,&#10;  DXGK_PAGE_FAULT_FATAL_HARDWARE_ERROR,&#10;  DXGK_PAGE_FAULT_IOMMU,&#10;  DXGK_PAGE_FAULT_HW_CONTEXT_VALID,&#10;  DXGK_PAGE_FAULT_PROCESS_HANDLE_VALID&#10;} DXGK_PAGE_FAULT_FLAGS;">DXGK_PAGE_FAULT_FLAGS</a></strong></p>
<p><strong><a href="dxgkargcb_present_displayonly_progress" title="typedef struct _DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS {&#10;  D3DDDI_VIDEO_PRESENT_SOURCE_ID        VidPnSourceId;&#10;  DXGK_PRESENT_DISPLAY_ONLY_PROGRESS_ID ProgressId;&#10;} DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS;">DXGKARGCB_PRESENT_DISPLAYONLY_PROGRESS</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_submitcommand"><strong>DxgkDdiSubmitCommand</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkargcb_notify_interrupt_data">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dkmddi/ns-d3dkmddi-_dxgkargcb_notify_interrupt_data.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
