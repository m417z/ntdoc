<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// acxstreams.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">EVT_ACX_STREAM_ALLOCATE_RTPACKETS EvtAcxStreamAllocateRtpackets;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> EvtAcxStreamAllocateRtpackets(
  ACXSTREAM Stream,
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketCount,
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketSize,
  <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a> *Packets
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/evt_acx_stream_allocate_rtpackets.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-acxstreams-evt_acx_stream_allocate_rtpackets)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>EvtAcxStreamAllocateRtPackets</strong> event tells the driver to allocate RtPackets for streaming.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="stream"><code>Stream</code></h3>

<p>An ACXSTREAM Object represents an audio stream created by a circuit. The stream is composed of a list of elements created based on the parent circuit's elements. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/audio/acx-summary-of-objects">ACX - Summary of ACX Objects</a>.</p>

<h3 id="packetcount"><code>PacketCount</code></h3>

<p>Specifies the number of packets to be allocated. Valid values are 1 or 2. Event-driven streams will use two packets while timer-driven streams will use one packet.</p>

<h3 id="packetsize"><code>PacketSize</code></h3>

<p>The packet size, measured in bytes.</p>

<h3 id="packets"><code>Packets</code></h3>

<p>A pointer that receives a pointer to an array of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/ns-acxstreams-acx_rtpacket">ACX_RTPACKET structures</a> that describes the location and size of the packets.</p>

<p>The initial ACX version supports only WdfMemoryDescriptorTypeMdl buffers for the <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> RtPacketBuffer member. The RtPacketBuffer must be page-aligned and have a page-aligned byte count.</p>

<h2 id="return-value">Return value</h2>

<p>Returns <code><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></code> if the call was successful. Otherwise, it returns an appropriate error code. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-ntstatus-values">Using NTSTATUS Values</a>.</p>

<h2 id="remarks">Remarks</h2>

<p>The initial ACX version will call with PacketCount = 1 or PacketCount = 2 when the StreamModel is AcxStreamModelRtPacket. With PacketCount = 2, the driver can allocate a single buffer that is shared between the two packets or the driver can allocate two separate buffers.</p>

<p>If the driver allocates a single buffer to be shared across two packets, the second <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure should have a <a href="wdf_memory_descriptor_type" title="typedef enum _WDF_MEMORY_DESCRIPTOR_TYPE {&#10;  WdfMemoryDescriptorTypeInvalid = 0,&#10;  WdfMemoryDescriptorTypeBuffer,&#10;  WdfMemoryDescriptorTypeMdl,&#10;  WdfMemoryDescriptorTypeHandle&#10;} WDF_MEMORY_DESCRIPTOR_TYPE;">WDF_MEMORY_DESCRIPTOR_TYPE</a> = WdfMemoryDescriptorTypeInvalid. The RtPacketOffset for the second <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure should be a valid offset into the RtPacketBuffer of the first <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure and should align with the first <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure's RtPacketOffset + RtPacketSize.</p>

<p>EvtAcxStreamAllocateRtPackets is called before <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_prepare_hardware">EvtAcxStreamPrepareHardware</a> to allow the RT packet allocation to occur before EvtAcxStreamPrepareHardware.</p>

<p>The buffer allocation typically only involves allocating system memory in such a way that it can be used with the DMA hardware. Typically, the buffer allocation will not have any effect on the streaming hardware. The prepare hardware phase is used as the driver is getting the stream ready to run, by completing tasks such as reserving bandwidth, programming DMA, and completing the preparation for the request to run the stream. Typically, the prepare hardware code will make use of the allocated buffers for preparing the DMA and related activities to be ready to start the stream.</p>

<h3 id="example">Example</h3>

<p>Example usage is shown below.</p>

<div class="codehilite">
<pre><span></span><code><span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Init RT streaming callbacks.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="n"><a href="acx_rt_stream_callbacks_init" title="VOID ACX_RT_STREAM_CALLBACKS_INIT(&#10;  PACX_RT_STREAM_CALLBACKS Callbacks&#10;);">ACX_RT_STREAM_CALLBACKS_INIT</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtCallbacks</span><span class="p">);</span>
<span class="w">    </span><span class="n">rtCallbacks</span><span class="p">.</span><span class="n">EvtAcxStreamAllocateRtPackets</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">Codec_EvtStreamAllocateRtPackets</span><span class="p">;</span>

<span class="p">...</span>

<span class="cp">#pragma code_seg(&quot;PAGE&quot;)</span>
<span class="n"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></span>
<span class="n">Codec_EvtStreamAllocateRtPackets</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w"> </span><span class="n">ACXSTREAM</span><span class="w"> </span><span class="n">Stream</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">PacketCount</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">PacketSize</span><span class="p">,</span>
<span class="w">    </span><span class="n">_Out_</span><span class="w"> </span><span class="n"><a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a></span><span class="w"> </span><span class="o">*</span><span class="n">Packets</span>
<span class="w">    </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></span><span class="p">;</span>
<span class="w">    </span><span class="n">PCODEC_STREAM_CONTEXT</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a></span><span class="w"> </span><span class="n">packets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">PVOID</span><span class="w"> </span><span class="n">packetBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">packetAllocSizeInPages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">packetAllocSizeInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w"> </span><span class="n">firstPacketOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt"><a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a></span><span class="w"> </span><span class="n">packetsSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">PAGED_CODE</span><span class="p">();</span>

<span class="w">    </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetCodecStreamContext</span><span class="p">(</span><span class="n">Stream</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PacketCount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATUS_INVALID_PARAMETER</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="rtlsizetmult" title="#define RtlSizeTMult RtlULongLongMult">RtlSizeTMult</a></span><span class="p">(</span><span class="n">PacketCount</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n"><a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a></span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">packetsSize</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">packets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a></span><span class="p">)</span><span class="n"><a href="exallocatepool2" title="DECLSPEC_RESTRICT PVOID ExAllocatePool2(&#10;  POOL_FLAGS Flags,&#10;  SIZE_T     NumberOfBytes,&#10;  ULONG      Tag&#10;);">ExAllocatePool2</a></span><span class="p">(</span><span class="n">POOL_FLAG_NON_PAGED</span><span class="p">,</span><span class="w"> </span><span class="n">packetsSize</span><span class="p">,</span><span class="w"> </span><span class="n">DRIVER_TAG</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">packets</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATUS_NO_MEMORY</span><span class="p">;</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// We need to allocate page-aligned buffers, to ensure no kernel memory leaks</span>
<span class="w">    </span><span class="c1">// to user space. Round up the packet size to page aligned, then calculate</span>
<span class="w">    </span><span class="c1">// the first packet&#39;s buffer offset so packet 0 ends on a page boundary and</span>
<span class="w">    </span><span class="c1">// packet 1 begins on a page boundary.</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="rtlulongadd" title="_Must_inspect_result_&#10;__inline&#10;NTSTATUS&#10;RtlULongAdd(&#10;    _In_ ULONG ulAugend,&#10;    _In_ ULONG ulAddend,&#10;    _Out_ _Deref_out_range_(==, ulAugend + ulAddend) ULONG* pulResult)&#10;{&#10;    NTSTATUS status;&#10;&#10;    if ((ulAugend + ulAddend) &gt;= ulAugend)&#10;    {&#10;        *pulResult = (ulAugend + ulAddend);&#10;        status = STATUS_SUCCESS;&#10;    }&#10;    else&#10;    {&#10;        *pulResult = ULONG_ERROR;&#10;        status = STATUS_INTEGER_OVERFLOW;&#10;    }&#10;...">RtlULongAdd</a></span><span class="p">(</span><span class="n">PacketSize</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a></span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">packetAllocSizeInPages</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n"><a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a></span><span class="p">(</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">packetAllocSizeInPages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packetAllocSizeInPages</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n"><a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a></span><span class="p">;</span>
<span class="w">    </span><span class="n">packetAllocSizeInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a></span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">packetAllocSizeInPages</span><span class="p">;</span>
<span class="w">    </span><span class="n">firstPacketOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packetAllocSizeInBytes</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">PacketSize</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">PacketCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a></span><span class="w"> </span><span class="n">pMdl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">        </span><span class="n"><a href="acx_rtpacket_init" title="VOID ACX_RTPACKET_INIT(&#10;  PACX_RTPACKET RtPacket&#10;);">ACX_RTPACKET_INIT</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">packets</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">        </span><span class="n">packetBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="exallocatepool2" title="DECLSPEC_RESTRICT PVOID ExAllocatePool2(&#10;  POOL_FLAGS Flags,&#10;  SIZE_T     NumberOfBytes,&#10;  ULONG      Tag&#10;);">ExAllocatePool2</a></span><span class="p">(</span><span class="n">POOL_FLAG_NON_PAGED</span><span class="p">,</span><span class="w"> </span><span class="n">packetAllocSizeInBytes</span><span class="p">,</span><span class="w"> </span><span class="n">DRIVER_TAG</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">packetBuffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATUS_NO_MEMORY</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">pMdl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="ioallocatemdl" title="PMDL IoAllocateMdl(&#10;  [in, optional]      __drv_aliasesMem PVOID VirtualAddress,&#10;  [in]                ULONG                  Length,&#10;  [in]                BOOLEAN                SecondaryBuffer,&#10;  [in]                BOOLEAN                ChargeQuota,&#10;  [in, out, optional] PIRP                   Irp&#10;);">IoAllocateMdl</a></span><span class="p">(</span><span class="n">packetBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">packetAllocSizeInBytes</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">TRUE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pMdl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STATUS_NO_MEMORY</span><span class="p">;</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">exit</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n"><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></span><span class="p">(</span><span class="n">pMdl</span><span class="p">);</span>

<span class="w">        </span><span class="n"><a href="wdf_memory_descriptor_init_mdl" title="VOID WDF_MEMORY_DESCRIPTOR_INIT_MDL(&#10;  [out] PWDF_MEMORY_DESCRIPTOR Descriptor,&#10;  [in]  PMDL                   Mdl,&#10;  [in]  ULONG                  BufferLength&#10;);">WDF_MEMORY_DESCRIPTOR_INIT_MDL</a></span><span class="p">(</span>
<span class="w">            </span><span class="o">&amp;</span><span class="p">((</span><span class="n">packets</span><span class="p">)[</span><span class="n">i</span><span class="p">].</span><span class="n">RtPacketBuffer</span><span class="p">),</span>
<span class="w">            </span><span class="n">pMdl</span><span class="p">,</span>
<span class="w">            </span><span class="n">packetAllocSizeInBytes</span><span class="p">);</span>

<span class="w">        </span><span class="n">packets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">RtPacketSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PacketSize</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">packets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">RtPacketOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstPacketOffset</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">packets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">RtPacketOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">m_Packets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packetBuffer</span><span class="p">;</span>

<span class="w">        </span><span class="n">packetBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">*</span><span class="n">Packets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">packets</span><span class="p">;</span>
<span class="w">    </span><span class="n">packets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">PacketsCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PacketCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">PacketSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PacketSize</span><span class="p">;</span>
<span class="w">    </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">FirstPacketOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstPacketOffset</span><span class="p">;</span>

<span class="nl">exit</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">packetBuffer</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n"><a href="exfreepoolwithtag" title="VOID ExFreePoolWithTag(&#10;  [in] PVOID P,&#10;  [in] ULONG Tag&#10;);">ExFreePoolWithTag</a></span><span class="p">(</span><span class="n">packetBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">DRIVER_TAG</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">packets</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">FreeRtPackets</span><span class="p">(</span><span class="n">packets</span><span class="p">,</span><span class="w"> </span><span class="n">PacketCount</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="acx-requirements">ACX requirements</h3>

<p><strong>Minimum ACX version:</strong> 1.0</p>

<p>For more information about ACX versions, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/audio/acx-version-overview">ACX version overview</a>.</p>

<h2 id="see-also">See also</h2>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/">acxstreams.h header</a></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
