<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            EVT_ACX_STREAM_ALLOCATE_RTPACKETS - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// acxstreams.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">EVT_ACX_STREAM_ALLOCATE_RTPACKETS EvtAcxStreamAllocateRtpackets;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> EvtAcxStreamAllocateRtpackets(
  ACXSTREAM Stream,
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketCount,
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketSize,
  <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a> *Packets
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/evt_acx_stream_allocate_rtpackets.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-acxstreams-evt_acx_stream_allocate_rtpackets)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<p>The <strong>EvtAcxStreamAllocateRtPackets</strong> event tells the driver to allocate RtPackets for streaming.</p>
<h2>Parameters</h2>
<h3><code>Stream</code></h3>
<p>An ACXSTREAM Object represents an audio stream created by a circuit. The stream is composed of a list of elements created based on the parent circuit's elements. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/audio/acx-summary-of-objects">ACX - Summary of ACX Objects</a>.</p>
<h3><code>PacketCount</code></h3>
<p>Specifies the number of packets to be allocated. Valid values are 1 or 2. Event-driven streams will use two packets while timer-driven streams will use one packet.</p>
<h3><code>PacketSize</code></h3>
<p>The packet size, measured in bytes.</p>
<h3><code>Packets</code></h3>
<p>A pointer that receives a pointer to an array of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/ns-acxstreams-acx_rtpacket">ACX_RTPACKET structures</a> that describes the location and size of the packets.</p>
<p>The initial ACX version supports only WdfMemoryDescriptorTypeMdl buffers for the <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> RtPacketBuffer member. The RtPacketBuffer must be page-aligned and have a page-aligned byte count.</p>
<h2>Return value</h2>
<p>Returns <code><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></code> if the call was successful. Otherwise, it returns an appropriate error code. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-ntstatus-values">Using NTSTATUS Values</a>.</p>
<h2>Remarks</h2>
<p>The initial ACX version will call with PacketCount = 1 or PacketCount = 2 when the StreamModel is AcxStreamModelRtPacket. With PacketCount = 2, the driver can allocate a single buffer that is shared between the two packets or the driver can allocate two separate buffers.</p>
<p>If the driver allocates a single buffer to be shared across two packets, the second <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure should have a <a href="wdf_memory_descriptor_type" title="typedef enum _WDF_MEMORY_DESCRIPTOR_TYPE {&#10;  WdfMemoryDescriptorTypeInvalid = 0,&#10;  WdfMemoryDescriptorTypeBuffer,&#10;  WdfMemoryDescriptorTypeMdl,&#10;  WdfMemoryDescriptorTypeHandle&#10;} WDF_MEMORY_DESCRIPTOR_TYPE;">WDF_MEMORY_DESCRIPTOR_TYPE</a> = WdfMemoryDescriptorTypeInvalid. The RtPacketOffset for the second <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure should be a valid offset into the RtPacketBuffer of the first <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure and should align with the first <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a> structure's RtPacketOffset + RtPacketSize.</p>
<p>EvtAcxStreamAllocateRtPackets is called before <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_prepare_hardware">EvtAcxStreamPrepareHardware</a> to allow the RT packet allocation to occur before EvtAcxStreamPrepareHardware.</p>
<p>The buffer allocation typically only involves allocating system memory in such a way that it can be used with the DMA hardware. Typically, the buffer allocation will not have any effect on the streaming hardware. The prepare hardware phase is used as the driver is getting the stream ready to run, by completing tasks such as reserving bandwidth, programming DMA, and completing the preparation for the request to run the stream. Typically, the prepare hardware code will make use of the allocated buffers for preparing the DMA and related activities to be ready to start the stream.</p>
<h3>Example</h3>
<p>Example usage is shown below.</p>
<pre><code class="language-cpp">    //
    // Init RT streaming callbacks.
    //
    <a href="acx_rt_stream_callbacks_init" title="VOID ACX_RT_STREAM_CALLBACKS_INIT(&#10;  PACX_RT_STREAM_CALLBACKS Callbacks&#10;);">ACX_RT_STREAM_CALLBACKS_INIT</a>(&amp;rtCallbacks);
    rtCallbacks.EvtAcxStreamAllocateRtPackets       = Codec_EvtStreamAllocateRtPackets;

...

#pragma code_seg(&quot;PAGE&quot;)
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
Codec_EvtStreamAllocateRtPackets(
    _In_ ACXSTREAM Stream,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketCount,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PacketSize,
    _Out_ <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a> *Packets
    )
{
    <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> status = <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>;
    PCODEC_STREAM_CONTEXT ctx;
    <a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a> packets = NULL;
    PVOID packetBuffer = NULL;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> i;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> packetAllocSizeInPages = 0;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> packetAllocSizeInBytes = 0;
    <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> firstPacketOffset = 0;
    <a href="size_t" title="typedef unsigned __int64 size_t;">size_t</a> packetsSize = 0;

    PAGED_CODE();

    ctx = GetCodecStreamContext(Stream);

    if (PacketCount &gt; 2)
    {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    status = <a href="rtlsizetmult" title="#define RtlSizeTMult RtlULongLongMult">RtlSizeTMult</a>(PacketCount, sizeof(<a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">ACX_RTPACKET</a>), &amp;packetsSize);
    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
        goto exit;
    }

    packets = (<a href="acx_rtpacket" title="typedef struct _ACX_RTPACKET {&#10;  ULONG                 Size;&#10;  WDF_MEMORY_DESCRIPTOR RtPacketBuffer;&#10;  ULONG                 RtPacketOffset;&#10;  ULONG                 RtPacketSize;&#10;} ACX_RTPACKET, *PACX_RTPACKET;">PACX_RTPACKET</a>)<a href="exallocatepool2" title="DECLSPEC_RESTRICT PVOID ExAllocatePool2(&#10;  POOL_FLAGS Flags,&#10;  SIZE_T     NumberOfBytes,&#10;  ULONG      Tag&#10;);">ExAllocatePool2</a>(POOL_FLAG_NON_PAGED, packetsSize, DRIVER_TAG);
    if (!packets) {
        status = STATUS_NO_MEMORY;
        goto exit;
    }

    // We need to allocate page-aligned buffers, to ensure no kernel memory leaks
    // to user space. Round up the packet size to page aligned, then calculate
    // the first packet's buffer offset so packet 0 ends on a page boundary and
    // packet 1 begins on a page boundary.
    status = <a href="rtlulongadd" title="_Must_inspect_result_&#10;__inline&#10;NTSTATUS&#10;RtlULongAdd(&#10;    _In_ ULONG ulAugend,&#10;    _In_ ULONG ulAddend,&#10;    _Out_ _Deref_out_range_(==, ulAugend + ulAddend) ULONG* pulResult)&#10;{&#10;    NTSTATUS status;&#10;&#10;    if ((ulAugend + ulAddend) &gt;= ulAugend)&#10;    {&#10;        *pulResult = (ulAugend + ulAddend);&#10;        status = STATUS_SUCCESS;&#10;    }&#10;    else&#10;    {&#10;        *pulResult = ULONG_ERROR;&#10;        status = STATUS_INTEGER_OVERFLOW;&#10;    }&#10;...">RtlULongAdd</a>(PacketSize, <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a> - 1, &amp;packetAllocSizeInPages);
    if (!<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(status)) {
        goto exit;
    }
    packetAllocSizeInPages = packetAllocSizeInPages / <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a>;
    packetAllocSizeInBytes = <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a> * packetAllocSizeInPages;
    firstPacketOffset = packetAllocSizeInBytes - PacketSize;

    for (i = 0; i &lt; PacketCount; ++i)
    {
        <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a> pMdl = NULL;

        <a href="acx_rtpacket_init" title="VOID ACX_RTPACKET_INIT(&#10;  PACX_RTPACKET RtPacket&#10;);">ACX_RTPACKET_INIT</a>(&amp;packets[i]);

        packetBuffer = <a href="exallocatepool2" title="DECLSPEC_RESTRICT PVOID ExAllocatePool2(&#10;  POOL_FLAGS Flags,&#10;  SIZE_T     NumberOfBytes,&#10;  ULONG      Tag&#10;);">ExAllocatePool2</a>(POOL_FLAG_NON_PAGED, packetAllocSizeInBytes, DRIVER_TAG);
        if (packetBuffer == NULL) {
            status = STATUS_NO_MEMORY;
            goto exit;
        }

        pMdl = <a href="ioallocatemdl" title="PMDL IoAllocateMdl(&#10;  [in, optional]      __drv_aliasesMem PVOID VirtualAddress,&#10;  [in]                ULONG                  Length,&#10;  [in]                BOOLEAN                SecondaryBuffer,&#10;  [in]                BOOLEAN                ChargeQuota,&#10;  [in, out, optional] PIRP                   Irp&#10;);">IoAllocateMdl</a>(packetBuffer, packetAllocSizeInBytes, FALSE, TRUE, NULL);
        if (pMdl == NULL) {
            status = STATUS_NO_MEMORY;
            goto exit;
        }

        <a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a>(pMdl);

        <a href="wdf_memory_descriptor_init_mdl" title="VOID WDF_MEMORY_DESCRIPTOR_INIT_MDL(&#10;  [out] PWDF_MEMORY_DESCRIPTOR Descriptor,&#10;  [in]  PMDL                   Mdl,&#10;  [in]  ULONG                  BufferLength&#10;);">WDF_MEMORY_DESCRIPTOR_INIT_MDL</a>(
            &amp;((packets)[i].RtPacketBuffer),
            pMdl,
            packetAllocSizeInBytes);

        packets[i].RtPacketSize = PacketSize;
        if (i == 0)
        {
            packets[i].RtPacketOffset = firstPacketOffset;
        }
        else
        {
            packets[i].RtPacketOffset = 0;
        }
        m_Packets[i] = packetBuffer;

        packetBuffer = NULL;
    }

    *Packets = packets;
    packets = NULL;
    ctx-&gt;PacketsCount = PacketCount;
    ctx-&gt;PacketSize = PacketSize;
    ctx-&gt;FirstPacketOffset = firstPacketOffset;

exit:
    if (packetBuffer)
    {
        <a href="exfreepoolwithtag" title="VOID ExFreePoolWithTag(&#10;  [in] PVOID P,&#10;  [in] ULONG Tag&#10;);">ExFreePoolWithTag</a>(packetBuffer, DRIVER_TAG);
    }
    if (packets)
    {
        FreeRtPackets(packets, PacketCount);
    }
    return status;
}
</code></pre>
<h3>ACX requirements</h3>
<p><strong>Minimum ACX version:</strong> 1.0</p>
<p>For more information about ACX versions, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/audio/acx-version-overview">ACX version overview</a>.</p>
<h2>See also</h2>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/">acxstreams.h header</a></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/acxstreams/nc-acxstreams-evt_acx_stream_allocate_rtpackets.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
