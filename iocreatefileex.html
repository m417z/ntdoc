<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IoCreateFileEx - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IoCreateFileEx - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IoCreateFileEx - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntddk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> IoCreateFileEx(
  [out]          PHANDLE                   FileHandle,
  [in]           ACCESS_MASK               DesiredAccess,
  [in]           <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a>        ObjectAttributes,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a>          IoStatusBlock,
  [in, optional] PLARGE_INTEGER            AllocationSize,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     FileAttributes,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     ShareAccess,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     Disposition,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     CreateOptions,
  [in, optional] PVOID                     EaBuffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     EaLength,
  [in]           <a href="create_file_type" title="typedef enum _CREATE_FILE_TYPE&#10;{&#10;    CreateFileTypeNone,&#10;    CreateFileTypeNamedPipe,&#10;    CreateFileTypeMailslot&#10;} CREATE_FILE_TYPE;">CREATE_FILE_TYPE</a>          CreateFileType,
  [in, optional] PVOID                     InternalParameters,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                     Options,
  [in, optional] <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">PIO_DRIVER_CREATE_CONTEXT</a> DriverContext
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-iocreatefileex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/iocreatefileex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntddk-iocreatefileex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>IoCreateFileEx</strong> routine either causes a new file or directory to be created, or opens an existing file, device, directory, or volume and gives the caller a handle for the file object. File system filter drivers (legacy filter drivers) call this routine.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="filehandle-out"><code>FileHandle</code> [out]</h3>

<p>A pointer to a variable that receives the file handle if the call is successful. The driver must close the handle with <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></strong> as soon as the handle is no longer being used.</p>

<h3 id="desiredaccess-in"><code>DesiredAccess</code> [in]</h3>

<p>A bitmask of flags (see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a>) that specifies the type of access that the caller requires to the file or directory. This set of system-defined <em>DesiredAccess</em> flags determines the following specific access rights for file objects.</p>

<table>
<thead>
<tr>
  <th><em>DesiredAccess</em> flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>DELETE</td>
  <td>The file can be deleted.</td>
</tr>
<tr>
  <td>FILE_READ_DATA</td>
  <td>Data can be read from the file.</td>
</tr>
<tr>
  <td>FILE_READ_ATTRIBUTES</td>
  <td><em>FileAttributes</em> flags, described below, can be read.</td>
</tr>
<tr>
  <td>FILE_READ_EA</td>
  <td>Extended attributes (EAs) associated with the file can be read.</td>
</tr>
<tr>
  <td>READ_CONTROL</td>
  <td>The access control list (<strong><a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a></strong>) and ownership information associated with the file can be read.</td>
</tr>
<tr>
  <td>FILE_WRITE_DATA</td>
  <td>Data can be written to the file.</td>
</tr>
<tr>
  <td>FILE_WRITE_ATTRIBUTES</td>
  <td><em>FileAttributes</em> flags can be written.</td>
</tr>
<tr>
  <td>FILE_WRITE_EA</td>
  <td>EAs associated with the file can be written.</td>
</tr>
<tr>
  <td>FILE_APPEND_DATA</td>
  <td>Data can be appended to the file.</td>
</tr>
<tr>
  <td>WRITE_DAC</td>
  <td>The discretionary access control list (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_acl"><strong>DACL</strong></a>) associated with the file can be written.</td>
</tr>
<tr>
  <td>WRITE_OWNER</td>
  <td>Ownership information associated with the file can be written.</td>
</tr>
<tr>
  <td>SYNCHRONIZE</td>
  <td>The caller can synchronize the completion of an I/O operation by waiting for the returned <em>FileHandle</em> to be set to the Signaled state. This flag must be set if the <em>CreateOptions</em> <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> flag is set.</td>
</tr>
<tr>
  <td>FILE_EXECUTE</td>
  <td>Data can be read into memory from the file using system paging I/O.</td>
</tr>
</tbody>
</table>

<p>Alternatively, for any file object that does not represent a directory, you can specify one or more of the following generic ACCESS_MASK flags. The STANDARD_RIGHTS_XXX flags are predefined system values that are used to enforce security on system objects. You can also combine these generic flags with additional flags from the preceding table.</p>

<table>
<thead>
<tr>
  <th>Desired access to file values</th>
  <th>Maps to <em>DesiredAccess</em> flags</th>
</tr>
</thead>
<tbody>
<tr>
  <td>GENERIC_READ</td>
  <td>STANDARD_RIGHTS_READ, FILE_READ_DATA, FILE_READ_ATTRIBUTES, FILE_READ_EA, SYNCHRONIZE.</td>
</tr>
<tr>
  <td>GENERIC_WRITE</td>
  <td>STANDARD_RIGHTS_WRITE, FILE_WRITE_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, FILE_APPEND_DATA, SYNCHRONIZE.</td>
</tr>
<tr>
  <td>GENERIC_EXECUTE</td>
  <td>STANDARD_RIGHTS_EXECUTE, SYNCHRONIZE, FILE_READ_ATTRIBUTES, FILE_EXECUTE.</td>
</tr>
</tbody>
</table>

<p>For directories (the <a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> <em>CreateOptions</em> flag is set), you can specify one or more of the following ACCESS_MASK flags, which you can also combine with any compatible flags that were described earlier.</p>

<table>
<thead>
<tr>
  <th>Desired access to directory values</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FILE_LIST_DIRECTORY</td>
  <td>Files in the directory can be listed.</td>
</tr>
<tr>
  <td>FILE_TRAVERSE</td>
  <td>The directory can be traversed; that is, it can be part of the pathname of a file.</td>
</tr>
</tbody>
</table>

<p>The FILE_READ_DATA, FILE_WRITE_DATA, FILE_EXECUTE, and FILE_APPEND_DATA <em>DesiredAccess</em> flags are incompatible with creating or opening a directory file.</p>

<h3 id="objectattributes-in"><code>ObjectAttributes</code> [in]</h3>

<p>Pointer to an <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> structure already initialized by the <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> routine. If the caller is running in the system process context, this parameter can be <strong>NULL<em>*. Otherwise, the caller must set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute in the call to *</em><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong>. Members of this structure for a file object include the following.</p>

<table>
<thead>
<tr>
  <th>Member</th>
  <th>Value</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length</strong></td>
  <td>The number of bytes of the supplied <em>ObjectAttributes</em> data. This value must be at least <code>sizeof(<a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a>)</code>.</td>
</tr>
<tr>
  <td><strong><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">PUNICODE_STRING</a> ObjectName</strong></td>
  <td>Pointer to a buffered Unicode string that contains the name of the file to be created or opened. This value must be a fully qualified file specification, unless it is the name of a file relative to the directory specified by <strong>RootDirectory</strong>. For example, "<em>\Device\Floppy1\myfile.dat</em>" or "<em>\??\B:\myfile.dat</em>" could be the fully qualified file specification, as long as the floppy disk drive driver and overlying file system are already loaded. (Note: "\??" replaces "\DosDevices" as the name of the Win32 object namespace. "\DosDevices" still works, but "\??" is translated faster by the object manager.)</td>
</tr>
<tr>
  <td><strong>HANDLE RootDirectory</strong></td>
  <td>Optional handle to a directory that was obtained by a previous call to <strong>IoCreateFileEx</strong>. If this value is <strong>NULL</strong>, the <strong>ObjectName</strong> member must be a fully qualified file specification that includes the full path to the target file. If this value is non-<strong>NULL</strong>, the <strong>ObjectName</strong> member specifies a file name relative to this directory.</td>
</tr>
<tr>
  <td><strong>PSECURITY_DESCRIPTOR SecurityDescriptor</strong></td>
  <td>Optional security descriptor to be applied to a file. ACLs specified by such a security descriptor are only applied to the file when it is created. If the value is <strong>NULL</strong> when a file is created, the <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a> placed on the file is file-system-dependent; most file systems propagate some part of such an <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a> from the parent directory file combined with the caller's default <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a>.</td>
</tr>
<tr>
  <td><strong><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Attributes</strong></td>
  <td>A set of flags that controls the file object attributes. If the caller is running in the system process context, this parameter can be zero. Otherwise, the caller must set the <strong><a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a></strong> flag. The caller can also optionally set the <strong><a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a></strong> flag, which indicates that name-lookup code should ignore the case of <strong>ObjectName</strong> instead of performing an exact-match search.</td>
</tr>
</tbody>
</table>

<h3 id="iostatusblock-out"><code>IoStatusBlock</code> [out]</h3>

<p>Pointer to a variable of type <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> that receives the final completion status and information about the requested operation. On return from <strong>IoCreateFileEx</strong>, the <strong>Information</strong> member of the variable contains one of the following values:</p>

<ul>
<li><p><a href="file_created" title="#define FILE_CREATED 0x00000002">FILE_CREATED</a></p></li>
<li><p><a href="file_opened" title="#define FILE_OPENED 0x00000001">FILE_OPENED</a></p></li>
<li><p><a href="file_overwritten" title="#define FILE_OVERWRITTEN 0x00000003">FILE_OVERWRITTEN</a></p></li>
<li><p><a href="file_superseded" title="#define FILE_SUPERSEDED 0x00000000">FILE_SUPERSEDED</a></p></li>
<li><p><a href="file_exists" title="#define FILE_EXISTS 0x00000004">FILE_EXISTS</a></p></li>
<li><p><a href="file_does_not_exist" title="#define FILE_DOES_NOT_EXIST 0x00000005">FILE_DOES_NOT_EXIST</a></p></li>
</ul>

<h3 id="allocationsize-in-optional"><code>AllocationSize</code> [in, optional]</h3>

<p>Optionally specifies the initial allocation size, in bytes, for the file. A nonzero value has no effect unless the file is being created, overwritten, or superseded.</p>

<h3 id="fileattributes-in"><code>FileAttributes</code> [in]</h3>

<p>Explicitly specified attributes are applied only when the file is created, superseded, or, in some cases, overwritten. By default, this value is FILE_ATTRIBUTE_NORMAL, which can be overridden by any other flag or by a combination (through a bitwise OR operation) of compatible flags. Possible <em>FileAttributes</em> flags include the following.</p>

<table>
<thead>
<tr>
  <th><em>FileAttributes</em> flags</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FILE_ATTRIBUTE_NORMAL</td>
  <td>A file that has standard attributes should be created.</td>
</tr>
<tr>
  <td>FILE_ATTRIBUTE_READONLY</td>
  <td>A read-only file should be created.</td>
</tr>
<tr>
  <td>FILE_ATTRIBUTE_HIDDEN</td>
  <td>A hidden file should be created.</td>
</tr>
<tr>
  <td>FILE_ATTRIBUTE_SYSTEM</td>
  <td>A system file should be created.</td>
</tr>
<tr>
  <td>FILE_ATTRIBUTE_ARCHIVE</td>
  <td>The file should be marked so that it will be archived.</td>
</tr>
<tr>
  <td>FILE_ATTRIBUTE_TEMPORARY</td>
  <td>A temporary file should be created.</td>
</tr>
</tbody>
</table>

<h3 id="shareaccess-in"><code>ShareAccess</code> [in]</h3>

<p>Specifies the type of share access to the file that the caller would like, as zero, or one, or a combination of the following flags. To request exclusive access, set this parameter to zero. If the IO_IGNORE_SHARE_ACCESS_CHECK flag is specified in the <em>Options</em> parameter, the I/O manager ignores the <em>ShareAccess</em> parameter. However, the file system might still perform access checks. Thus, it is important to specify the sharing mode you would like for this parameter, even when you use the IO_IGNORE_SHARE_ACCESS_CHECK flag. To help you avoid sharing violation errors, specify all the following share access flags.</p>

<table>
<thead>
<tr>
  <th><em>ShareAccess</em> flags</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a></td>
  <td>The file can be opened for read access by other threads' file create calls.</td>
</tr>
<tr>
  <td><a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a></td>
  <td>The file can be opened for write access by other threads' file create calls.</td>
</tr>
<tr>
  <td><a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a></td>
  <td>The file can be opened for delete access by other threads' file create calls.</td>
</tr>
</tbody>
</table>

<p>Device drivers and intermediate drivers usually set <em>ShareAccess</em> to zero, which gives the caller exclusive access to the open file.</p>

<h3 id="disposition-in"><code>Disposition</code> [in]</h3>

<p>Value that determines how the file should be handled when the file already exists. <em>Disposition</em> can be one of the following.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a></td>
  <td>If the file already exists, replace it with the given file. If it does not exist, create the given file.</td>
</tr>
<tr>
  <td><a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a></td>
  <td>If the file already exists, fail the request and do not create or open the given file. If it does not exist, create the given file.</td>
</tr>
<tr>
  <td><a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a></td>
  <td>If the file already exists, open it instead of creating a new file. If it does not exist, fail the request and do not create a new file.</td>
</tr>
<tr>
  <td><a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a></td>
  <td>If the file already exists, open it. If it does not exist, create the given file.</td>
</tr>
<tr>
  <td><a href="file_overwrite" title="#define FILE_OVERWRITE 0x00000004">FILE_OVERWRITE</a></td>
  <td>If the file already exists, open it and overwrite it. If it does not exist, fail the request.</td>
</tr>
<tr>
  <td><a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a></td>
  <td>If the file already exists, open it and overwrite it. If it does not exist, create the given file.</td>
</tr>
</tbody>
</table>

<h3 id="createoptions-in"><code>CreateOptions</code> [in]</h3>

<p>Specifies the options to be applied when creating or opening the file, as a compatible combination of the following flags.</p>

<table>
<thead>
<tr>
  <th><em>CreateOptions</em> flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> (0x00000001)</td>
  <td>The file being created or opened is a directory file. With this flag, the <em>Disposition</em> parameter must be set to one of <a href="file_create" title="#define FILE_CREATE 0x00000002">FILE_CREATE</a>, <a href="file_open" title="#define FILE_OPEN 0x00000001">FILE_OPEN</a>, or <a href="file_open_if" title="#define FILE_OPEN_IF 0x00000003">FILE_OPEN_IF</a>. <em>CreateOptions</em> flags that are compatible with this flag are as follows: <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>, <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, <a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a>, <a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a>, and <a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a>.</td>
</tr>
<tr>
  <td><a href="file_write_through" title="#define FILE_WRITE_THROUGH 0x00000002">FILE_WRITE_THROUGH</a> (0x00000002)</td>
  <td>System services, file systems, and drivers that write data to the file must actually transfer the data into the file before any requested write operation is considered complete.</td>
</tr>
<tr>
  <td><a href="file_sequential_only" title="#define FILE_SEQUENTIAL_ONLY 0x00000004">FILE_SEQUENTIAL_ONLY</a> (0x00000004)</td>
  <td>All accesses to the file will be sequential.</td>
</tr>
<tr>
  <td><a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> (0x00000008)</td>
  <td>The file cannot be cached or buffered in a driver's internal buffers. This flag is incompatible with the <em>DesiredAccess</em>FILE_APPEND_DATA flag.</td>
</tr>
<tr>
  <td><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> (0x00000010)</td>
  <td>All operations on the file are performed synchronously. Any wait on behalf of the caller is subject to premature termination from alerts. This flag also causes the I/O system to maintain the file position context. If this flag is set, the DesiredAccess SYNCHRONIZE flag also must be set so that the I/O Manager uses the file object as a synchronization object.</td>
</tr>
<tr>
  <td><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> (0x00000020)</td>
  <td>All operations on the file are performed synchronously. Waits in the system to synchronize I/O queuing and completion are not subject to alerts. This flag also causes the I/O system to maintain the file position context. If this flag is set, the DesiredAccess SYNCHRONIZE flag also must be set so that the I/O Manager uses the file object as a synchronization object.</td>
</tr>
<tr>
  <td><a href="file_non_directory_file" title="#define FILE_NON_DIRECTORY_FILE 0x00000040">FILE_NON_DIRECTORY_FILE</a> (0x00000040)</td>
  <td>The file being opened must not be a directory file or this call fails. The file object being opened can represent a data file; a logical, virtual, or physical device; or a volume.</td>
</tr>
<tr>
  <td><a href="file_create_tree_connection" title="#define FILE_CREATE_TREE_CONNECTION 0x00000080">FILE_CREATE_TREE_CONNECTION</a> (0x00000080)</td>
  <td>Create a tree connection for this file in order to open it over the network.</td>
</tr>
<tr>
  <td><a href="file_complete_if_oplocked" title="#define FILE_COMPLETE_IF_OPLOCKED 0x00000100">FILE_COMPLETE_IF_OPLOCKED</a> (0x00000100)</td>
  <td>Complete this operation immediately with an alternate success code if the target file is oplocked, rather than blocking the caller's thread. If the file is oplocked, another caller already has access to the file over the network.</td>
</tr>
<tr>
  <td><a href="file_no_ea_knowledge" title="#define FILE_NO_EA_KNOWLEDGE 0x00000200">FILE_NO_EA_KNOWLEDGE</a> (0x00000200)</td>
  <td>If the extended attributes on an existing file being opened indicate that the caller must understand extended attributes to properly interpret the file, fail this request because the caller does not understand how to deal with extended attributes.</td>
</tr>
<tr>
  <td><a href="file_open_remote_instance" title="#define FILE_OPEN_REMOTE_INSTANCE 0x00000400">FILE_OPEN_REMOTE_INSTANCE</a> (0x00000400)</td>
  <td>Reserved for system use; do not use.</td>
</tr>
<tr>
  <td><a href="file_random_access" title="#define FILE_RANDOM_ACCESS 0x00000800">FILE_RANDOM_ACCESS</a> (0x00000800)</td>
  <td>Accesses to the file can be random, so no sequential read-ahead operations should be performed on the file by file systems or the operating system.</td>
</tr>
<tr>
  <td><a href="file_delete_on_close" title="#define FILE_DELETE_ON_CLOSE 0x00001000">FILE_DELETE_ON_CLOSE</a> (0x00001000)</td>
  <td>Delete the file when the last handle to it is passed to <a href="fltclose" title="NTSTATUS FLTAPI FltClose(&#10;  [in] HANDLE FileHandle&#10;);">FltClose</a>.</td>
</tr>
<tr>
  <td><a href="file_open_by_file_id" title="#define FILE_OPEN_BY_FILE_ID 0x00002000">FILE_OPEN_BY_FILE_ID</a> (0x00002000)</td>
  <td>The file is being opened by ID. The file name contains the name of a device and a 64-bit ID to be used to open the file.</td>
</tr>
<tr>
  <td><a href="file_open_for_backup_intent" title="#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000">FILE_OPEN_FOR_BACKUP_INTENT</a> (0x000004000)</td>
  <td>The file is being opened for backup intent; therefore, the system should check for certain access rights and grant the caller the appropriate accesses to the file before checking the input DesiredAccess against the file's security descriptor.</td>
</tr>
<tr>
  <td><a href="file_no_compression" title="#define FILE_NO_COMPRESSION 0x00008000">FILE_NO_COMPRESSION</a> (0x00008000)</td>
  <td>Suppress inheritance of FILE_ATTRIBUTE_COMPRESSED from the parent directory. This allows creation of a non-compressed file in a directory that is marked compressed.</td>
</tr>
<tr>
  <td><a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> (0x00010000)</td>
  <td>The file is being opened and an opportunistic lock (oplock) on the file is being requested as a single atomic operation. The file system checks for oplocks before it performs the create operation, and the create operation will fail with a return code of STATUS_CANNOT_BREAK_OPLOCK if the create operation would break an existing oplock. This flag is available in Windows 7, Windows Server 2008 R2 and later Windows operating systems.</td>
</tr>
<tr>
  <td><a href="file_disallow_exclusive" title="#define FILE_DISALLOW_EXCLUSIVE 0x00020000">FILE_DISALLOW_EXCLUSIVE</a> (0x00020000)</td>
  <td>When opening an existing file, if <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> is not specified and file system access checks would not grant the caller write access to the file, fail this open with STATUS_ACCESS_DENIED. This was default behavior prior to Windows 7.</td>
</tr>
<tr>
  <td><a href="file_session_aware" title="#define FILE_SESSION_AWARE 0x00040000">FILE_SESSION_AWARE</a> (0x00040000)</td>
  <td>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows. This flag is not supported before Windows Server 2012.</td>
</tr>
<tr>
  <td><a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> (0x00100000)</td>
  <td>This flag allows an application to request a filter opportunistic lock (oplock) to prevent other applications from getting share violations. If there are already open handles, the create request will fail with STATUS_OPLOCK_NOT_GRANTED. For more information, see the following Remarks section.</td>
</tr>
<tr>
  <td><a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> (0x00200000)</td>
  <td>Open a file with a reparse point and bypass normal reparse point processing for the file. For more information, see the following Remarks section.</td>
</tr>
<tr>
  <td><a href="file_open_no_recall" title="#define FILE_OPEN_NO_RECALL 0x00400000">FILE_OPEN_NO_RECALL</a> (0x00400000)</td>
  <td>Instructs any filters that perform offline storage or virtualization to not recall the contents of the file as a result of this open.</td>
</tr>
<tr>
  <td><a href="file_open_for_free_space_query" title="#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000">FILE_OPEN_FOR_FREE_SPACE_QUERY</a> (0x00800000)</td>
  <td>This flag instructs the file system to capture the user associated with the calling thread. Any subsequent calls to <a href="fltqueryvolumeinformation" title="NTSTATUS FLTAPI FltQueryVolumeInformation(&#10;  [in]  PFLT_INSTANCE        Instance,&#10;  [out] PIO_STATUS_BLOCK     Iosb,&#10;  [out] PVOID                FsInformation,&#10;  [in]  ULONG                Length,&#10;  [in]  FS_INFORMATION_CLASS FsInformationClass&#10;);">FltQueryVolumeInformation</a> or <a href="ntqueryvolumeinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryVolumeInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FsInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FSINFOCLASS FsInformationClass&#10;    );">ZwQueryVolumeInformationFile</a> using the returned handle will assume the captured user, rather than the calling user at the time, for purposes of computing the free space available to the caller. This applies to the following FsInformationClass values: FileFsSizeInformation, FileFsFullSizeInformation, and FileFsFullSizeInformationEx.</td>
</tr>
</tbody>
</table>

<h3 id="eabuffer-in-optional"><code>EaBuffer</code> [in, optional]</h3>

<p>A pointer to a caller-supplied variable of type <strong><a href="file_full_ea_information" title="typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></strong> that contains extended attribute (EA) information to be applied to the file. For device and intermediate drivers, this parameter must be <strong>NULL</strong>.</p>

<h3 id="ealength-in"><code>EaLength</code> [in]</h3>

<p>Length, in bytes, of <em>EaBuffer</em>. For device drivers and intermediate drivers, this parameter must be zero.</p>

<h3 id="createfiletype-in"><code>CreateFileType</code> [in]</h3>

<p>Drivers must set this parameter to CreateFileTypeNone.</p>

<h3 id="internalparameters-in-optional"><code>InternalParameters</code> [in, optional]</h3>

<p>Drivers must set this parameter to <strong>NULL</strong>.</p>

<h3 id="options-in"><code>Options</code> [in]</h3>

<p>Specifies options to be used during the generation of the create request. Zero or more of the following bit flag values can be used.</p>

<table>
<thead>
<tr>
  <th><em>Options</em> flag</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>IO_FORCE_ACCESS_CHECK</td>
  <td>The I/O manager must check the create request against the file's security descriptor. For more information, see Remarks.</td>
</tr>
<tr>
  <td>IO_IGNORE_SHARE_ACCESS_CHECK</td>
  <td>The I/O manager should not perform share-access checks on the file object after it is created. However, the file system might still perform these checks.</td>
</tr>
<tr>
  <td>IO_STOP_ON_SYMLINK</td>
  <td>If a junction, symbolic link, or global reparse point is encountered while opening or creating the file, I/O manager will return STATUS_STOPPED_ON_SYMLINK. Additionally, a <a href="reparse_data_buffer" title="typedef struct _REPARSE_DATA_BUFFER&#10;{&#10;    ULONG ReparseTag;&#10;    USHORT ReparseDataLength;&#10;    USHORT Reserved;&#10;&#10;    _Field_size_bytes_(ReparseDataLength)&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            USHORT SubstituteNameOffset;&#10;            USHORT SubstituteNameLength;&#10;            USHORT PrintNameOffset;&#10;            USHORT PrintNameLength;&#10;            ULONG Flags;&#10;            WCHAR PathBuffer[1];&#10;        } SymbolicLinkReparseBuffer;&#10;        struct&#10;        {&#10;...">REPARSE_DATA_BUFFER</a> structure will be returned in <strong>IoStatusBlock->Information</strong>. The caller is responsible for freeing the <strong><a href="reparse_data_buffer" title="typedef struct _REPARSE_DATA_BUFFER&#10;{&#10;    ULONG ReparseTag;&#10;    USHORT ReparseDataLength;&#10;    USHORT Reserved;&#10;&#10;    _Field_size_bytes_(ReparseDataLength)&#10;    union&#10;    {&#10;        struct&#10;        {&#10;            USHORT SubstituteNameOffset;&#10;            USHORT SubstituteNameLength;&#10;            USHORT PrintNameOffset;&#10;            USHORT PrintNameLength;&#10;            ULONG Flags;&#10;            WCHAR PathBuffer[1];&#10;        } SymbolicLinkReparseBuffer;&#10;        struct&#10;        {&#10;...">REPARSE_DATA_BUFFER</a></strong> structure.</td>
</tr>
<tr>
  <td>IO_OPEN_TARGET_DIRECTORY</td>
  <td>Open the file's parent directory.</td>
</tr>
</tbody>
</table>

<h3 id="drivercontext-in-optional"><code>DriverContext</code> [in, optional]</h3>

<p>An optional pointer to an <strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong> structure that was previously initialized by the <strong><a href="ioinitializedrivercreatecontext" title="VOID IoInitializeDriverCreateContext(&#10;  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">IoInitializeDriverCreateContext</a></strong> routine. The <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure can be used to pass additional parameters to the *<em>IoCreateFileEx</em>* and <strong><a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a></strong> routines. See the following Remarks section for more information.</p>

<h2 id="return-value">Return value</h2>

<p><strong>IoCreateFileEx</strong> either returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value such as one of the following.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STATUS_INVALID_DEVICE_OBJECT_PARAMETER</td>
  <td><a href=""><strong>IoCreateFileEx</strong></a> returns this status value if the <em>DriverContext</em> parameter is not <strong>NULL</strong> and if the specified device object is not attached to the file system driver stack for the volume specified in the file or directory name. This device object is specified by the <strong>DeviceObjectHint</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure. For more information, see <strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong>.</td>
</tr>
<tr>
  <td>STATUS_MOUNT_POINT_NOT_RESOLVED</td>
  <td><strong>IoCreateFileEx</strong> returns this status value if the <em>DriverContext</em> parameter is not <strong>NULL</strong> and if the file or directory name contains a mount point that resolves to a volume other than the one to which the specified device object is attached. This device object is specified by the <strong>DeviceObjectHint</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure. For more information, see <strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong>.</td>
</tr>
<tr>
  <td>STATUS_OBJECT_PATH_SYNTAX_BAD</td>
  <td><strong>IoCreateFileEx</strong> returns this status value if the <em>ObjectAttributes</em> parameter did not contain a <strong>RootDirectory</strong> member, but the <strong>ObjectName</strong> member in the <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> structure was an empty string or did not contain an OBJECT_NAME_PATH_SEPARATOR character. This indicates incorrect syntax for the object path.</td>
</tr>
<tr>
  <td>STATUS_STOPPED_ON_SYMLINK</td>
  <td><strong>IoCreateFileEx</strong> returns this status value if the <em>Options</em> parameter flag <strong>IO_STOP_ON_SYMLINK</strong> is set and a symbolic link is encountered while opening or creating the file.</td>
</tr>
</tbody>
</table>

<p>If the <strong>IoCreateFileEx</strong> routine returns an error status, the caller can find additional information about the cause of the failure by checking the <em>IoStatusBlock</em> parameter.</p>

<p><strong>IoCreateFileEx</strong> might return STATUS_FILE_LOCK_CONFLICT as the return value or in the **Status** member of the <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that is pointed to by the <strong>IoStatusBlock</strong> parameter. This would occur only if the NTFS log file is full, and an error occurs while <strong>IoCreateFileEx</strong> tries to handle this situation.</p>

<h2 id="remarks">Remarks</h2>

<p>The <strong>IoCreateFileEx</strong> routine is similar to both the <strong><a href="iocreatefile" title="NTSTATUS IoCreateFile(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options&#10;);">IoCreateFile</a></strong> routine and the <strong><a href="iocreatefilespecifydeviceobjecthint" title="NTSTATUS IoCreateFileSpecifyDeviceObjectHint(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options,&#10;  [in, optional] PVOID              DeviceObject&#10;);">IoCreateFileSpecifyDeviceObjectHint</a></strong> routine but offers additional functionality including access to extra create parameters (ECPs), device objects hints, and transaction information through the <strong>IoCreateFileEx</strong> routine's <em>DriverContext</em> parameter. For more information about these structure based parameters, see <strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong>.</p>

<p>File system filter drivers call <strong>IoCreateFileEx</strong> to send a create request only to a specified device object, the filters attached below it, and the file system. Filters attached above the specified device object in the driver stack do not receive the create request. However, if the <strong>DeviceObjectHint</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure (passed through the <em>DriverContext</em> parameter) is <strong>NULL</strong>, the request goes to the top of the stack and is received by all filters and the file system.</p>

<p>If the I/O request does not go to the top of the driver stack, that is if the <em>DriverContext</em> parameter is not <strong>NULL</strong> and a valid device object is specified by the <strong>DeviceObjectHint</strong> member of the <a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a> structure, the following restriction applies:</p>

<ul>
<li>If the file name path that is passed to the <strong>IoCreateFileEx</strong> routine contains a mount point, the mount point must resolve to the same volume where the file or directory resides.</li>
</ul>

<p>The handle obtained by <strong>IoCreateFileEx</strong> can be used by subsequent calls to manipulate data within the file or the state or attributes of the file object. Any handle that is obtained from <strong>IoCreateFileEx</strong> must eventually be released by calling <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></strong>.</p>

<p>There are two alternate ways to specify the name of the file to be created or opened with <strong>IoCreateFileEx</strong>:</p>

<ul>
<li><p>As a fully qualified pathname, supplied in the <strong>ObjectName</strong> member of the input <em>ObjectAttributes</em> parameter.</p></li>
<li><p>As a pathname relative to the handle in the <strong>RootDirectory</strong> member of the input <em>ObjectAttributes</em> parameter. (This handle can represent a directory file.)</p></li>
</ul>

<p>Driver routines that run in a process context other than that of the system process must set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute for the <em>ObjectAttributes</em> parameter of <strong>IoCreateFileEx</strong>. This restricts the use of the handle that is returned by <strong>IoCreateFileEx</strong> to processes running in kernel mode. Otherwise, the handle can be accessed by the process in whose context the driver is running. Drivers can call <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> to set the <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a> attribute.</p>

<p>Certain <em>DesiredAccess</em> flags and combinations of flags have the following effects:</p>

<ul>
<li><p>For a caller to synchronize an I/O completion by waiting for the returned <em>FileHandle</em> to be set to the Signaled state, the SYNCHRONIZE flag must be set. Otherwise, a caller that is a device or intermediate driver must synchronize an I/O completion by using an event object.</p></li>
<li><p>If only the FILE_APPEND_DATA and SYNCHRONIZE flags are set, the caller can write only to the end of the file, and any offset information about writes to the file is ignored. However, the file will automatically be extended as necessary for this kind of write operation.</p></li>
<li><p>Setting the FILE_WRITE_DATA flag for a file also allows writes beyond the end of the file to occur. The file is automatically extended for this kind of write, as well.</p></li>
<li><p>If only the FILE_EXECUTE and SYNCHRONIZE flags are set, the caller cannot directly read or write any data in the file using the returned *FileHandle*: that is, all operations on the file occur through the system pager in response to instruction and data accesses. Device and intermediate drivers should not set the FILE_EXECUTE flag in <em>DesiredAccess</em>.</p></li>
</ul>

<p>The <em>ShareAccess</em> parameter determines whether separate threads can access the same file, possibly simultaneously. Provided that both file openers have the privilege to access a file in the specified manner, the file can be successfully opened and shared. If the original caller of <strong>IoCreateFileEx</strong> does not specify <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a>, <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a>, or <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>, no other open operations can be performed on the file: that is, the original caller is given exclusive access to the file.</p>

<p>For a shared file to be successfully opened, the requested <em>DesiredAccess</em> value for the file must be compatible with both the <em>DesiredAccess</em> and <em>ShareAccess</em> specifications of all previous open requests that have not yet been released with <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></strong>. That is, the <em>DesiredAccess</em> value that is specified to <strong>IoCreateFileEx</strong> for a given file must not conflict with the accesses that other openers of the file have disallowed.</p>

<p>If IO_IGNORE_SHARE_ACCESS_CHECK is specified in the <em>Options</em> parameter, the I/O manager ignores the <em>ShareAccess</em> parameter. However, the file system might still perform access checks. Thus, it is important to specify the sharing mode you would like for the <em>ShareAccess</em> parameter, even when using the IO_IGNORE_SHARE_ACCESS_CHECK flag.</p>

<p>The <em>Disposition</em> value <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> requires that the caller have DELETE access to an existing file object. If so, a successful call to **IoCreateFileEx** with <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> on an existing file effectively deletes that file, and then recreates it. This implies that, if the file has already been opened by another thread, the thread opened the file by specifying a <em>ShareAccess</em> parameter with the <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a> flag set. Notice that this type of disposition is consistent with the POSIX style of overwriting files.</p>

<p>The <em>Disposition</em> values <a href="file_overwrite_if" title="#define FILE_OVERWRITE_IF 0x00000005">FILE_OVERWRITE_IF</a> and <a href="file_supersede" title="#define FILE_SUPERSEDE 0x00000000">FILE_SUPERSEDE</a> are similar. If <strong>IoCreateFileEx</strong> is called with an existing file and either of these <em>Disposition</em> values, the file will be replaced.</p>

<p>Overwriting a file is semantically equivalent to a supersede operation, except for the following:</p>

<ul>
<li><p>The caller must have write access to the file, instead of delete access. This implies that, if the file has already been opened by another thread, it opened the file with the <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> flag set in the input <em>ShareAccess</em>.</p></li>
<li><p>The specified file attributes are logically ORed with those already on the file. This implies that if the file has already been opened by another thread, a subsequent caller of <strong>IoCreateFileEx</strong> cannot disable existing <em>FileAttributes</em> flags but can enable additional flags for the same file. Notice that this style of overwriting files is consistent with MS-DOS, Windows 3.1, and with OS/2.</p></li>
</ul>

<p>The <em>CreateOptions</em> <a href="file_directory_file" title="#define FILE_DIRECTORY_FILE 0x00000001">FILE_DIRECTORY_FILE</a> value specifies that the file to be created or opened is a directory file. When a directory file is created, the file system creates an appropriate structure on the disk to represent an empty directory for that particular file system's on-disk structure. If this option was specified and the given file to be opened is not a directory file, or if the caller specified an inconsistent <em>CreateOptions</em> or <em>Disposition</em> value, the call to <strong>IoCreateFileEx</strong> will fail.</p>

<p>The <em>CreateOptions</em> <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> flag prevents the file system from performing any intermediate buffering on behalf of the caller. Specifying this value places certain restrictions on the caller's parameters to the <strong>Zw..File</strong> routines, including the following:</p>

<ul>
<li><p>Any optional <em>ByteOffset</em> passed to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong> must be an integral (integer multiple) of the sector size.</p></li>
<li><p>The <em>Length</em> passed to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> or <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong>, must be an integral of the sector size. Notice that specifying a read operation to a buffer whose length is exactly the sector size might result in a lesser number of significant bytes being transferred to that buffer if the end of the file was reached during the transfer.</p></li>
<li><p>Buffers must be aligned in accordance with the alignment requirement of the underlying device. This information can be obtained by calling <strong>IoCreateFileEx</strong> to get a handle for the file object that represents the physical device, and, then, calling <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong> with that handle. For a list of the system FILE_<em>XXX</em>_ALIGNMENT values, see <strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong>.</p></li>
<li><p>Calls to <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong> with the <em>FileInformationClass</em> parameter set to <strong>FilePositionInformation</strong> must specify an offset that is an integral of the sector size.</p></li>
</ul>

<p>The mutually exclusive <em>CreateOptions</em>, <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> and <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> flags, specify that all I/O operations on the file are to be synchronous as long as they occur through the file object referred to by the returned <em>FileHandle</em>. All I/O on such a file is serialized across all threads by using the returned handle. With either of these <em>CreateOptions</em> values, the <em>DesiredAccess</em> SYNCHRONIZE flag must be set so that the I/O Manager will use the file object as a synchronization object. With either of these <em>CreateOptions</em> values set, the I/O Manager maintains the "file position context" for the file object, an internal, current file position offset. This offset can be used in calls to <strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong> and <strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong>. Its position can also be queried by calling <strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong>, or set by calling <strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong>.</p>

<p>If the <em>CreateOptions</em> <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is *not* specified and **IoCreateFileEx** attempts to open a file with a reparse point, normal reparse point processing occurs for the file. If, on the other hand, the <a href="file_open_reparse_point" title="#define FILE_OPEN_REPARSE_POINT 0x00200000">FILE_OPEN_REPARSE_POINT</a> flag is specified, normal reparse processing does <em>not</em> occur and <strong>IoCreateFileEx</strong> attempts to directly open the reparse point file. In either case, if the open operation was successful, <strong>IoCreateFileEx</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>; otherwise, the routine returns an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code. **IoCreateFileEx** never returns STATUS_REPARSE.</p>

<p>The <em>CreateOptions</em> <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag eliminates the time between when you open the file and request an oplock that could potentially enable a third party to open the file and get a sharing violation. An application can use the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag on <strong>IoCreateFileEx</strong> and then request any oplock. This ensures that an oplock owner will be notified of any later open request that causes a sharing violation.</p>

<p>In Windows 7, if other handles exist on the file when an application uses the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag, the create operation will fail with STATUS_OPLOCK_NOT_GRANTED. This restriction no longer exists starting with Windows 8.</p>

<p>If this create operation would break an oplock that already exists on the file, then setting the <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag will cause the create operation to fail with STATUS_CANNOT_BREAK_OPLOCK. The existing oplock will not be broken by this create operation.</p>

<p>An application that uses this flag must request an oplock after this call succeeds, or all later attempts to open the file will be blocked without the benefit of typical oplock processing. Similarly, if this call succeeds but the later oplock request fails, an application that uses this flag must close its handle after it detects that the oplock request has failed.</p>

<p>The <a href="file_open_requiring_oplock" title="#define FILE_OPEN_REQUIRING_OPLOCK 0x00010000">FILE_OPEN_REQUIRING_OPLOCK</a> flag is available in Windows 7, Windows Server 2008 R2and later Windows operating systems. The Microsoft file systems that implement this flag are NTFS, FAT, and exFAT.</p>

<p>The <em>CreateOptions</em> flag, <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>, allows an application to request a level 1, batch, or filter oplock to prevent other applications from getting share violations. However, <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> is only practically useful for filter oplocks. To use it, you must follow these steps:</p>

<ol>
<li><p>Issue a create request with <em>CreateOptions</em> of <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>, DesiredAccess of exactly FILE_READ_ATTRIBUTES, and ShareAccess of exactly <a href="file_share_read" title="#define FILE_SHARE_READ 0x00000001">FILE_SHARE_READ</a> | <a href="file_share_write" title="#define FILE_SHARE_WRITE 0x00000002">FILE_SHARE_WRITE</a> | <a href="file_share_delete" title="#define FILE_SHARE_DELETE 0x00000004">FILE_SHARE_DELETE</a>.</p>

<ul>
<li><p>If there are already open handles, the create request fails with STATUS_OPLOCK_NOT_GRANTED, and the next requested oplock also fails.</p></li>
<li><p>If you open with more access or less sharing will also cause a failure of STATUS_OPLOCK_NOT_GRANTED.</p></li>
</ul></li>
<li><p>If the create request succeeds, request an oplock.</p></li>
<li><p>Open another handle to the file to do I/O.</p></li>
</ol>

<p>Step three makes this practical only for filter oplocks. The handle opened in step 3 can have a DesiredAccess that contains a maximum of FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_EXECUTE | SYNCHRONIZE | READ_CONTROL and still not break a filter oplock. However, any DesiredAccess greater than FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE will break a level 1 or batch oplock and make the <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a> flag useless for those oplock types.</p>

<p>For create requests originating in user mode, if the driver sets IO_FORCE_ACCESS_CHECK in the *Options* parameter of **IoCreateFileEx** then it should also set <a href="obj_force_access_check" title="#define OBJ_FORCE_ACCESS_CHECK 0x00000400L">OBJ_FORCE_ACCESS_CHECK</a> in the <em>ObjectAttributes</em> parameter. For info on this flag, see the <strong>Attributes</strong> member of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfwdm/ns-wudfwdm-_object_attributes">OBJECT_ATTRIBUTES</a>.</p>

<p>NTFS is the only Microsoft file system that implements <a href="file_reserve_opfilter" title="#define FILE_RESERVE_OPFILTER 0x00100000">FILE_RESERVE_OPFILTER</a>.</p>

<p><strong>IoCreateFileEx</strong> can be used to obtain a handle to a volume.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a></p>

<p><strong><a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a></strong></p>

<p><strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong></p>

<p><strong><a href="file_full_ea_information" title="typedef struct _FILE_FULL_EA_INFORMATION&#10;{&#10;    ULONG NextEntryOffset;&#10;    UCHAR Flags;&#10;    UCHAR EaNameLength;&#10;    USHORT EaValueLength;&#10;    _Field_size_bytes_(EaNameLength) CHAR EaName[1];&#10;    // ...&#10;    // UCHAR EaValue[1]&#10;} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;">FILE_FULL_EA_INFORMATION</a></strong></p>

<p><strong><a href="fltacknowledgeecp" title="VOID FLTAPI FltAcknowledgeEcp(&#10;  [in] PFLT_FILTER Filter,&#10;  [in] PVOID       EcpContext&#10;);">FltAcknowledgeEcp</a></strong></p>

<p><strong><a href="fltallocateextracreateparameter" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameter(&#10;  [in]           PFLT_FILTER                                    Filter,&#10;  [in]           LPCGUID                                        EcpType,&#10;  [in]           ULONG                                          SizeOfContext,&#10;  [in]           FSRTL_ALLOCATE_ECP_FLAGS                       Flags,&#10;  [in, optional] PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK CleanupCallback,&#10;  [in]           ULONG                                          PoolTag,&#10;  [out]          PVOID                                          *EcpContext&#10;);">FltAllocateExtraCreateParameter</a></strong></p>

<p><strong><a href="fltallocateextracreateparameterlist" title="NTSTATUS FLTAPI FltAllocateExtraCreateParameterList(&#10;  [in]  PFLT_FILTER                  Filter,&#10;  [in]  FSRTL_ALLOCATE_ECPLIST_FLAGS Flags,&#10;  [out] PECP_LIST                    *EcpList&#10;);">FltAllocateExtraCreateParameterList</a></strong></p>

<p><strong><a href="fltclose" title="NTSTATUS FLTAPI FltClose(&#10;  [in] HANDLE FileHandle&#10;);">FltClose</a></strong></p>

<p><strong><a href="fltcreatefileex2" title="NTSTATUS FLTAPI FltCreateFileEx2(&#10;  [in]            PFLT_FILTER               Filter,&#10;  [in, optional]  PFLT_INSTANCE             Instance,&#10;  [out]           PHANDLE                   FileHandle,&#10;  [out, optional] PFILE_OBJECT              *FileObject,&#10;  [in]            ACCESS_MASK               DesiredAccess,&#10;  [in]            POBJECT_ATTRIBUTES        ObjectAttributes,&#10;  [out]           PIO_STATUS_BLOCK          IoStatusBlock,&#10;  [in, optional]  PLARGE_INTEGER            AllocationSize,&#10;  [in]            ULONG                     FileAttributes,&#10;  [in]            ULONG                     ShareAccess,&#10;  [in]            ULONG                     CreateDisposition,&#10;  [in]            ULONG                     CreateOptions,&#10;  [in, optional]  PVOID                     EaBuffer,&#10;  [in]            ULONG                     EaLength,&#10;  [in]            ULONG                     Flags,&#10;  [in, optional]  PIO_DRIVER_CREATE_CONTEXT DriverContext&#10;);">FltCreateFileEx2</a></strong></p>

<p><strong><a href="io_driver_create_context" title="typedef struct _IO_DRIVER_CREATE_CONTEXT {&#10;  CSHORT               Size;&#10;  struct _ECP_LIST     *ExtraCreateParameter;&#10;  PVOID                DeviceObjectHint;&#10;  PTXN_PARAMETER_BLOCK TxnParameters;&#10;  PESILO               SiloContext;&#10;} IO_DRIVER_CREATE_CONTEXT, *PIO_DRIVER_CREATE_CONTEXT;">IO_DRIVER_CREATE_CONTEXT</a></strong></p>

<p><strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong></p>

<p><strong><a href="iocreatefile" title="NTSTATUS IoCreateFile(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options&#10;);">IoCreateFile</a></strong></p>

<p><strong><a href="iocreatefilespecifydeviceobjecthint" title="NTSTATUS IoCreateFileSpecifyDeviceObjectHint(&#10;  [out]          PHANDLE            FileHandle,&#10;  [in]           ACCESS_MASK        DesiredAccess,&#10;  [in]           POBJECT_ATTRIBUTES ObjectAttributes,&#10;  [out]          PIO_STATUS_BLOCK   IoStatusBlock,&#10;  [in, optional] PLARGE_INTEGER     AllocationSize,&#10;  [in]           ULONG              FileAttributes,&#10;  [in]           ULONG              ShareAccess,&#10;  [in]           ULONG              Disposition,&#10;  [in]           ULONG              CreateOptions,&#10;  [in, optional] PVOID              EaBuffer,&#10;  [in]           ULONG              EaLength,&#10;  [in]           CREATE_FILE_TYPE   CreateFileType,&#10;  [in, optional] PVOID              InternalParameters,&#10;  [in]           ULONG              Options,&#10;  [in, optional] PVOID              DeviceObject&#10;);">IoCreateFileSpecifyDeviceObjectHint</a></strong></p>

<p><strong><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a></strong></p>

<p><strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></strong></p>

<p><strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong></p>

<p><strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></strong></p>

<p><strong><a href="ntreadfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtReadFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwReadFile</a></strong></p>

<p><strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></strong></p>

<p><strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-iocreatefileex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddk/nf-ntddk-iocreatefileex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
