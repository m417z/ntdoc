<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtAllocateVirtualMemory - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtAllocateVirtualMemory - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtAllocateVirtualMemory - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTMMAPI_H
//
// Virtual memory
//
#if (PHNT_MODE != PHNT_MODE_KERNEL)

</span><span class="ntdoc-code-intro">/**
 * The NtAllocateVirtualMemory routine reserves, commits, or both, a region of pages within the user-mode virtual address space of a specified process.
 *
 * \param ProcessHandle A handle for the process for which the mapping should be done.
 * \param BaseAddress A pointer to a variable that will receive the base address of the allocated region of pages.
 * If the initial value is not zero, the region is allocated at the specified virtual address.
 * \param ZeroBits The number of high-order address bits that must be zero in the base address of the section view.
 * This value must be less than 21 and the initial value of BaseAddress must be zero.
 * \param RegionSize A pointer to a variable that will receive the actual size, in bytes, of the allocated region of pages.
 * \param AllocationType A bitmask containing flags that specify the type of allocation to be performed.
 * \param PageProtection A bitmask containing page protection flags that specify the protection desired for the committed region of pages.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwallocatevirtualmemory
 */
</span><span class="ntdoc-code-body">_Must_inspect_result_
_When_(return == 0, __drv_allocatesMem(mem))
NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a> ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AllocationType,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PageProtection
    );
</span><span class="ntdoc-code-footer">
#endif
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/d9393a49b3707fc786047a2ca5ae4afefd760b30/phnt/include/ntmmapi.h#L670">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a> ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> AllocationType,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> PageProtection
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/d9393a49b3707fc786047a2ca5ae4afefd760b30/phnt/include/ntzwapi.h#L343">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtAllocateVirtualMemory(
  [in]      HANDLE    ProcessHandle,
  [in, out] PVOID     *BaseAddress,
  [in]      <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a> ZeroBits,
  [in, out] PSIZE_T   RegionSize,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     AllocationType,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     Protect
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwAllocateVirtualMemory(
  [in]      HANDLE    ProcessHandle,
  [in, out] PVOID     *BaseAddress,
  [in]      <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a> ZeroBits,
  [in, out] PSIZE_T   RegionSize,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     AllocationType,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>     Protect
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwallocatevirtualmemory">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntallocatevirtualmemory.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntallocatevirtualmemory)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>NtAllocateVirtualMemory function</h1>
<h2>Description</h2>
<p>The <strong>NtAllocateVirtualMemory</strong> routine reserves, commits, or both, a region of pages within the user-mode virtual address space of a specified process.</p>
<h2>Parameters</h2>
<h3><code>ProcessHandle</code> [in]</h3>
<p>A handle for the process for which the mapping should be done. Use the <strong><a href="ntcurrentprocess" title="#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)">NtCurrentProcess</a></strong> macro, defined in <em>Ntddk.h</em>, to specify the current process.</p>
<h3><code>BaseAddress</code> [in, out]</h3>
<p>A pointer to a variable that will receive the base address of the allocated region of pages. If the initial value of <em>BaseAddress</em> is non-<strong>NULL</strong>, the region is allocated starting at the specified virtual address rounded down to the next host page size address boundary. If the initial value of <em>BaseAddress</em> is <strong>NULL</strong>, the operating system will determine where to allocate the region.</p>
<h3><code>ZeroBits</code> [in]</h3>
<p>The number of high-order address bits that must be zero in the base address of the section view. Used only when the operating system determines where to allocate the region, as when <em>BaseAddress</em>* is <strong>NULL</strong>. Note that when ZeroBits is larger than 32, it becomes a bitmask.</p>
<h3><code>RegionSize</code> [in, out]</h3>
<p>A pointer to a variable that will receive the actual size, in bytes, of the allocated region of pages. The initial value of <em>RegionSize</em> specifies the size, in bytes, of the region and is rounded up to the next host page size boundary. <em>RegionSize</em> cannot be zero on input.</p>
<h3><code>AllocationType</code> [in]</h3>
<p>A bitmask containing flags that specify the type of allocation to be performed for the specified region of pages. The following table describes the most common flags. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc"><strong>VirtualAlloc</strong></a> for a full list of possible flags and descriptions.</p>
<blockquote>
<p>[!NOTE]</p>
<p>One of <a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a>, <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a>, or <a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a> must be set.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a></td>
<td>The specified region of pages is to be committed.</td>
</tr>
<tr>
<td><a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a></td>
<td>The specified region of pages is to be reserved.</td>
</tr>
<tr>
<td><a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a></td>
<td>Reset the state of the specified region so that if the pages are in paging file, they are discarded and pages of zeros are brought in. If the pages are in memory and modified, they are marked as not modified so that they will not be written out to the paging file. The contents are <em>not</em> zeroed. The <strong>Protect</strong> parameter is not used, but it must be set to a valid value. If <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a> is set, no other flag may be set.</td>
</tr>
<tr>
<td>Other MEM_<em>XXX</em> flags</td>
<td>See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc"><strong>VirtualAlloc</strong></a>.</td>
</tr>
</tbody>
</table>
<h3><code>Protect</code> [in]</h3>
<p>A bitmask containing page protection flags that specify the protection desired for the committed region of pages. The following table describes these flags.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a></td>
<td>No access to the committed region of pages is allowed. An attempt to read, write, or execute the committed region results in an access violation exception, called a general protection (GP) fault.</td>
</tr>
<tr>
<td><a href="page_readonly" title="#define PAGE_READONLY 0x02 // Enables read-only access to the committed region of pages. An attempt to write or execute the committed region results in an access violation.">PAGE_READONLY</a></td>
<td>Read-only and execute access to the committed region of pages is allowed. An attempt to write the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_readwrite" title="#define PAGE_READWRITE 0x04 // Enables read-only or read/write access to the committed region of pages.">PAGE_READWRITE</a></td>
<td>Read, write, and execute access to the committed region of pages is allowed. If write access to the underlying section is allowed, then a single copy of the pages is shared. Otherwise the pages are shared read only/copy on write.</td>
</tr>
<tr>
<td><a href="page_execute" title="#define PAGE_EXECUTE 0x10 // Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.">PAGE_EXECUTE</a></td>
<td>Execute access to the committed region of pages is allowed. An attempt to read or write to the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_execute_read" title="#define PAGE_EXECUTE_READ 0x20 // Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.">PAGE_EXECUTE_READ</a></td>
<td>Execute and read access to the committed region of pages are allowed. An attempt to write to the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_guard" title="#define PAGE_GUARD 0x100 // Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception.">PAGE_GUARD</a></td>
<td>Pages in the region become guard pages. Any attempt to read from or write to a guard page causes the system to raise a STATUS_GUARD_PAGE exception. Guard pages thus act as a one-shot access alarm. This flag is a page protection modifier, valid only when used with one of the page protection flags other than <a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a>. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page exception occurs during a system service, the service typically returns a failure status indicator.</td>
</tr>
<tr>
<td><a href="page_nocache" title="#define PAGE_NOCACHE 0x200 // Sets all pages to be non-cachable. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_NOCACHE</a></td>
<td>The region of pages should be allocated as noncacheable. <a href="page_nocache" title="#define PAGE_NOCACHE 0x200 // Sets all pages to be non-cachable. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_NOCACHE</a> is not allowed for sections.</td>
</tr>
<tr>
<td><a href="page_writecombine" title="#define PAGE_WRITECOMBINE 0x400 // Sets all pages to be write-combined. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_WRITECOMBINE</a></td>
<td>Enables write combining, that is, coalescing writes from cache to main memory, where the hardware supports it. This flag is used primarily for frame buffer memory so that writes to the same cache line are combined where possible before being written to the device. This can greatly reduce writes across the bus to (for example) video memory. If the hardware does not support write combining, the flag is ignored. This flag is a page protection modifier, valid only when used with one of the page protection flags other than <a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a>.</td>
</tr>
</tbody>
</table>
<h2>Return value</h2>
<p><strong>NtAllocateVirtualMemory</strong> returns either <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an error status code. Possible error status codes include the following:</p>
<ul>
<li>
<strong>STATUS_ACCESS_DENIED</strong>
</li>
<li>
<strong>STATUS_ALREADY_COMMITTED</strong>
</li>
<li>
<strong>STATUS_COMMITMENT_LIMIT</strong>
</li>
<li>
<strong>STATUS_CONFLICTING_ADDRESSES</strong>
</li>
<li>
<strong>STATUS_INSUFFICIENT_RESOURCES</strong>
</li>
<li>
<strong>STATUS_INVALID_HANDLE</strong>
</li>
<li>
<strong>STATUS_INVALID_PAGE_PROTECTION</strong>
</li>
<li>
<strong>STATUS_NO_MEMORY</strong>
</li>
<li>
<strong>STATUS_OBJECT_TYPE_MISMATCH</strong>
</li>
<li>
<strong>STATUS_PROCESS_IS_TERMINATING</strong>
</li>
</ul>
<h2>Remarks</h2>
<p><strong>NtAllocateVirtualMemory</strong> can perform the following operations:</p>
<ul>
<li>
Commit a region of pages reserved by a previous call to <strong>NtAllocateVirtualMemory</strong>.
</li>
<li>
Reserve a region of free pages.
</li>
<li>
Reserve and commit a region of free pages.
</li>
</ul>
<p>Kernel-mode drivers can use <strong>NtAllocateVirtualMemory</strong> to reserve a range of application-accessible virtual addresses in the specified process and then make additional calls to <strong>NtAllocateVirtualMemory</strong> to commit individual pages from the reserved range. This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed.</p>
<p>Each page in the process's virtual address space is in one of the three states described in the following table.</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>FREE</td>
<td>The page is not committed or reserved and is not accessible to the process. <strong>NtAllocateVirtualMemory</strong> can reserve, or simultaneously reserve and commit, a free page.</td>
</tr>
<tr>
<td>RESERVED</td>
<td>The range of addresses cannot be used by other allocation functions, but the page is not accessible to the process and has no physical storage associated with it. <strong>NtAllocateVirtualMemory</strong> can commit a reserved page, but it cannot reserve it a second time. <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">NtFreeVirtualMemory</a></strong> can release a reserved page, making it a free page.</td>
</tr>
<tr>
<td>COMMITTED</td>
<td>Physical storage is allocated for the page, and access is controlled by a protection code. The system initializes and loads each committed page into physical memory only at the first attempt to read or write to that page. When the process terminates, the system releases the storage for committed pages. <strong>NtAllocateVirtualMemory</strong> can commit an already committed page. This means that you can commit a range of pages, regardless of whether they have already been committed, and the function will not fail. <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">NtFreeVirtualMemory</a></strong> can decommit a committed page, releasing the page's storage, or it can simultaneously decommit and release a committed page.</td>
</tr>
</tbody>
</table>
<p>Memory allocated by calling <strong>NtAllocateVirtualMemory</strong> must be freed by calling <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">NtFreeVirtualMemory</a></strong>.</p>
<p>For more information about memory management, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/managing-memory-for-drivers">Memory Management for Windows Drivers</a>.</p>
<blockquote>
<p><strong>Note</strong> If the call to the <strong>NtAllocateVirtualMemory</strong> function occurs in user mode, you should use the name "<strong>NtAllocateVirtualMemory</strong>" instead of "<strong>ZwAllocateVirtualMemory</strong>".</p>
</blockquote>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">NtFreeVirtualMemory</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntallocatevirtualmemory.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-zwallocatevirtualmemory)</h1>
</div>
<div class="ntdoc-description">
<h1>ZwAllocateVirtualMemory function</h1>
<h2>Description</h2>
<p>The <strong>ZwAllocateVirtualMemory</strong> routine reserves, commits, or both, a region of pages within the user-mode virtual address space of a specified process.</p>
<h2>Parameters</h2>
<h3><code>ProcessHandle</code> [in]</h3>
<p>A handle for the process for which the mapping should be done. Use the <strong><a href="ntcurrentprocess" title="#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)">NtCurrentProcess</a></strong> macro, defined in Ntddk.h, to specify the current process.</p>
<h3><code>BaseAddress</code> [in, out]</h3>
<p>A pointer to a variable that will receive the base address of the allocated region of pages. If the initial value of this parameter is non-<strong>NULL</strong>, the region is allocated starting at the specified virtual address rounded down to the next host page size address boundary. If the initial value of this parameter is <strong>NULL</strong>, the operating system will determine where to allocate the region.</p>
<h3><code>ZeroBits</code> [in]</h3>
<p>The number of high-order address bits that must be zero in the base address of the section view. This value must be less than 21 and is used only when the operating system determines where to allocate the region, as when <strong>BaseAddress</strong> is <strong>NULL</strong>.</p>
<h3><code>RegionSize</code> [in, out]</h3>
<p>A pointer to a variable that will receive the actual size, in bytes, of the allocated region of pages. The initial value of this parameter specifies the size, in bytes, of the region and is rounded up to the next host page size boundary. *<strong>RegionSize</strong> cannot be zero on input.</p>
<h3><code>AllocationType</code> [in]</h3>
<p>A bitmask containing flags that specify the type of allocation to be performed. The following table describes these flags.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a></td>
<td>The specified region of pages is to be committed. One of <a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a>, <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a>, or <a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a> must be set.</td>
</tr>
<tr>
<td><a href="mem_physical" title="#define MEM_PHYSICAL 0x00400000">MEM_PHYSICAL</a></td>
<td>Allocate physical memory. This flag is solely for use with Address Windowing Extensions (AWE) memory. If <a href="mem_physical" title="#define MEM_PHYSICAL 0x00400000">MEM_PHYSICAL</a> is set, <a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a> must also be set, no other flags may be set, and <strong>Protect</strong> must be set to <a href="page_readwrite" title="#define PAGE_READWRITE 0x04 // Enables read-only or read/write access to the committed region of pages.">PAGE_READWRITE</a>.</td>
</tr>
<tr>
<td><a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a></td>
<td>The specified region of pages is to be reserved. One of <a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a>, <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a>, or <a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a> must be set.</td>
</tr>
<tr>
<td><a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a></td>
<td>Reset the state of the specified region so that if the pages are in paging file, they are discarded and pages of zeros are brought in. If the pages are in memory and modified, they are marked as not modified so that they will not be written out to the paging file. The contents are <em>not</em> zeroed. The <strong>Protect</strong> parameter is not used, but it must be set to a valid value. One of <a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a>, <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a>, or <a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a> must be set; if <a href="mem_reset" title="#define MEM_RESET 0x00080000">MEM_RESET</a> is set, no other flag may be set.</td>
</tr>
<tr>
<td><a href="mem_top_down" title="#define MEM_TOP_DOWN 0x00100000">MEM_TOP_DOWN</a></td>
<td>The specified region should be created at the highest virtual address possible based on <strong>ZeroBits</strong>.</td>
</tr>
</tbody>
</table>
<h3><code>Protect</code> [in]</h3>
<p>A bitmask containing page protection flags that specify the protection desired for the committed region of pages. The following table describes these flags.</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a></td>
<td>No access to the committed region of pages is allowed. An attempt to read, write, or execute the committed region results in an access violation exception, called a general protection (GP) fault.</td>
</tr>
<tr>
<td><a href="page_readonly" title="#define PAGE_READONLY 0x02 // Enables read-only access to the committed region of pages. An attempt to write or execute the committed region results in an access violation.">PAGE_READONLY</a></td>
<td>Read-only and execute access to the committed region of pages is allowed. An attempt to write the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_readwrite" title="#define PAGE_READWRITE 0x04 // Enables read-only or read/write access to the committed region of pages.">PAGE_READWRITE</a></td>
<td>Read, write, and execute access to the committed region of pages is allowed. If write access to the underlying section is allowed, then a single copy of the pages is shared. Otherwise the pages are shared read only/copy on write.</td>
</tr>
<tr>
<td><a href="page_execute" title="#define PAGE_EXECUTE 0x10 // Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation.">PAGE_EXECUTE</a></td>
<td>Execute access to the committed region of pages is allowed. An attempt to read or write to the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_execute_read" title="#define PAGE_EXECUTE_READ 0x20 // Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation.">PAGE_EXECUTE_READ</a></td>
<td>Execute and read access to the committed region of pages are allowed. An attempt to write to the committed region results in an access violation.</td>
</tr>
<tr>
<td><a href="page_execute_readwrite" title="#define PAGE_EXECUTE_READWRITE 0x40 // Enables execute, read-only, or read/write access to the committed region of pages.">PAGE_EXECUTE_READWRITE</a></td>
<td>Execute, read, and write access to the committed region of pages are allowed.</td>
</tr>
<tr>
<td><a href="page_guard" title="#define PAGE_GUARD 0x100 // Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception.">PAGE_GUARD</a></td>
<td>Pages in the region become guard pages. Any attempt to read from or write to a guard page causes the system to raise a STATUS_GUARD_PAGE exception. Guard pages thus act as a one-shot access alarm. This flag is a page protection modifier, valid only when used with one of the page protection flags other than <a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a>. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page exception occurs during a system service, the service typically returns a failure status indicator.</td>
</tr>
<tr>
<td><a href="page_nocache" title="#define PAGE_NOCACHE 0x200 // Sets all pages to be non-cachable. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_NOCACHE</a></td>
<td>The region of pages should be allocated as noncacheable. <a href="page_nocache" title="#define PAGE_NOCACHE 0x200 // Sets all pages to be non-cachable. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_NOCACHE</a> is not allowed for sections.</td>
</tr>
<tr>
<td><a href="page_writecombine" title="#define PAGE_WRITECOMBINE 0x400 // Sets all pages to be write-combined. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_WRITECOMBINE</a></td>
<td>Enables write combining, that is, coalescing writes from cache to main memory, where the hardware supports it. This flag is used primarily for frame buffer memory so that writes to the same cache line are combined where possible before being written to the device. This can greatly reduce writes across the bus to (for example) video memory. If the hardware does not support write combining, the flag is ignored. This flag is a page protection modifier, valid only when used with one of the page protection flags other than <a href="page_noaccess" title="#define PAGE_NOACCESS 0x01 // Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.">PAGE_NOACCESS</a>.</td>
</tr>
</tbody>
</table>
<h2>Return value</h2>
<p><strong>ZwAllocateVirtualMemory</strong> returns either <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an error status code. Possible error status codes include the following:</p>
<h2>Remarks</h2>
<p><strong>ZwAllocateVirtualMemory</strong> can perform the following operations:</p>
<ul>
<li>
<p>Commit a region of pages reserved by a previous call to <strong>ZwAllocateVirtualMemory</strong>.</p>
</li>
<li>
<p>Reserve a region of free pages.</p>
</li>
<li>
<p>Reserve and commit a region of free pages.</p>
</li>
</ul>
<p>Kernel-mode drivers can use <strong>ZwAllocateVirtualMemory</strong> to reserve a range of application-accessible virtual addresses in the specified process and then make additional calls to <strong>ZwAllocateVirtualMemory</strong> to commit individual pages from the reserved range. This enables a process to reserve a range of its virtual address space without consuming physical storage until it is needed.</p>
<p>Each page in the process's virtual address space is in one of the three states described in the following table.</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>FREE</td>
<td>The page is not committed or reserved and is not accessible to the process. <strong>ZwAllocateVirtualMemory</strong> can reserve, or simultaneously reserve and commit, a free page.</td>
</tr>
<tr>
<td>RESERVED</td>
<td>The range of addresses cannot be used by other allocation functions, but the page is not accessible to the process and has no physical storage associated with it. <strong>ZwAllocateVirtualMemory</strong> can commit a reserved page, but it cannot reserve it a second time. <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">ZwFreeVirtualMemory</a></strong> can release a reserved page, making it a free page.</td>
</tr>
<tr>
<td>COMMITTED</td>
<td>Physical storage is allocated for the page, and access is controlled by a protection code. The system initializes and loads each committed page into physical memory only at the first attempt to read or write to that page. When the process terminates, the system releases the storage for committed pages. <strong>ZwAllocateVirtualMemory</strong> can commit an already committed page. This means that you can commit a range of pages, regardless of whether they have already been committed, and the function will not fail. <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">ZwFreeVirtualMemory</a></strong> can decommit a committed page, releasing the page's storage, or it can simultaneously decommit and release a committed page.</td>
</tr>
</tbody>
</table>
<p>Memory allocated by calling <strong>ZwAllocateVirtualMemory</strong> must be freed by calling <strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">ZwFreeVirtualMemory</a></strong>.</p>
<p>For more information about memory management, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/managing-memory-for-drivers">Memory Management for Windows Drivers</a>.</p>
<blockquote>
<p>[!NOTE]</p>
<p>If the call to the <strong>ZwAllocateVirtualMemory</strong> function occurs in user mode, you should use the name "<strong>NtAllocateVirtualMemory</strong>" instead of "<strong>ZwAllocateVirtualMemory</strong>".</p>
</blockquote>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a></p>
<p><strong><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">ZwFreeVirtualMemory</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwallocatevirtualmemory">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-zwallocatevirtualmemory.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwallocatevirtualmemory">here</a>.</p>
<hr />
<h3>ProcessHandle</h3>
<p>Handle to Process Object opened with <code><a href="process_vm_operation" title="#define PROCESS_VM_OPERATION 0x0008">PROCESS_VM_OPERATION</a></code> access.</p>
<h3>*BaseAddress</h3>
<p>If not zero, system tries to allocate virtual memory block on this virtual address. If BaseAddress is zero, system use first free virtual location.</p>
<h3>AllocationType</h3>
<p>Can be <code><a href="mem_reserve" title="#define MEM_RESERVE 0x00002000">MEM_RESERVE</a></code> or <code><a href="mem_commit" title="#define MEM_COMMIT 0x00001000">MEM_COMMIT</a></code>.</p>
<h3>Protect</h3>
<p>One or combination of <code>PAGE_***</code> attributes.</p>
<h1>Documented by</h1>
<ul>
<li>
ReactOS
</li>
<li>
Tomasz Nowak
</li>
</ul>
<h1>See also</h1>
<ul>
<li>
<code><a href="ntfreevirtualmemory" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFreeVirtualMemory(&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ __drv_freesMem(Mem) PVOID *BaseAddress,&#10;    _Inout_ PSIZE_T RegionSize,&#10;    _In_ ULONG FreeType&#10;    );">NtFreeVirtualMemory</a></code>
</li>
<li>
<code><a href="ntmapviewofsection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtMapViewOfSection(&#10;    _In_ HANDLE SectionHandle,&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,&#10;    _In_ ULONG_PTR ZeroBits,&#10;    _In_ SIZE_T CommitSize,&#10;    _Inout_opt_ PLARGE_INTEGER SectionOffset,&#10;    _Inout_ PSIZE_T ViewSize,&#10;    _In_ SECTION_INHERIT InheritDisposition,&#10;    _In_ ULONG AllocationType,&#10;    _In_ ULONG PageProtection&#10;    );">NtMapViewOfSection</a></code>
</li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntallocatevirtualmemory.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
