<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFN_WSK_SOCKET_CONNECT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFN_WSK_SOCKET_CONNECT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFN_WSK_SOCKET_CONNECT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wsk.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">PFN_WSK_SOCKET_CONNECT PfnWskSocketConnect;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> PfnWskSocketConnect(
  [in]           PWSK_CLIENT Client,
  [in]           <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a> SocketType,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Protocol,
  [in]           PSOCKADDR LocalAddress,
  [in]           PSOCKADDR RemoteAddress,
                 <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Flags,
  [in, optional] PVOID SocketContext,
  [in, optional] const <a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a> *Dispatch,
  [in, optional] PEPROCESS OwningProcess,
  [in, optional] PETHREAD OwningThread,
  [in, optional] PSECURITY_DESCRIPTOR SecurityDescriptor,
  [in, out]      PIRP Irp
)
{...}</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfn_wsk_socket_connect.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wsk-pfn_wsk_socket_connect)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>PFN_WSK_SOCKET_CONNECT callback function</h1>
<h2>Description</h2>
<p>The
<strong>WskSocketConnect</strong> function creates a new connection-oriented socket, binds it to a local transport
address, connects it to a given remote transport address, and returns a pointer to the associated socket
object.</p>
<h2>Parameters</h2>
<h3><code>Client</code> [in]</h3>
<p>A pointer to a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-client">WSK_CLIENT</a> structure that was returned through
the
<strong>WskProviderNpi</strong> parameter of the
<a href="wskcaptureprovidernpi" title="NTSTATUS WskCaptureProviderNPI(&#10;  [in]  PWSK_REGISTRATION WskRegistration,&#10;  [in]  ULONG             WaitTimeout,&#10;  [out] PWSK_PROVIDER_NPI WskProviderNpi&#10;);">WskCaptureProviderNPI</a> function.</p>
<h3><code>SocketType</code> [in]</h3>
<p>The type of the socket that is being created. The following socket types are supported:</p>
<h4>SOCK_STREAM</h4>
<p>Supports reliable connection-oriented byte stream communication.</p>
<h4>SOCK_DGRAM</h4>
<p>Supports unreliable connectionless datagram communication.</p>
<h4>SOCK_RAW</h4>
<p>Supports raw access to the transport protocol.</p>
<p>For more information about the socket types that are supported for each supported address family, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/ws2def-h">WSK Address Families</a>.</p>
<h3><code>Protocol</code> [in]</h3>
<p>The transport protocol for the socket that is being created. For more information about the
protocols that are supported for each supported address family, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/ws2def-h">WSK Address Families</a>.</p>
<h3><code>LocalAddress</code> [in]</h3>
<p>A pointer to a structure that specifies the local transport address to which to bind the socket.
The WSK application must specify a pointer to the specific SOCKADDR structure type that corresponds to
the address family for the socket that is being created.</p>
<h3><code>RemoteAddress</code> [in]</h3>
<p>A pointer to a structure that specifies the remote transport address to which to connect the
socket. The WSK application must specify a pointer to the specific SOCKADDR structure type that
corresponds to the address family for the socket that is being created.</p>
<h3><code>Flags</code></h3>
<p>This parameter is reserved for system use. WSK applications must set this parameter to
zero.</p>
<h3><code>SocketContext</code> [in, optional]</h3>
<p>A pointer to a caller-supplied context for the socket that is being created. The WSK subsystem
passes this pointer to the socket's event callback functions. The context information is opaque to the
WSK subsystem and must be stored in non-paged memory. If the WSK application will not be enabling any
event callback functions on the new socket, it should set this pointer to <strong>NULL</strong>.</p>
<h3><code>Dispatch</code> [in, optional]</h3>
<p>A pointer to a constant
<a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a> structure. This structure is a dispatch table that contains
pointers to the event callback functions for the new socket. If the WSK application will not be enabling
all of the event callback functions for the new socket, it should set the pointers in the dispatch table
to <strong>NULL</strong> for those event callback functions that it does not enable. If the WSK application will not be
enabling any event callback functions on the new socket, it should set this pointer to <strong>NULL</strong>.</p>
<h3><code>OwningProcess</code> [in, optional]</h3>
<p>A pointer to the process from which the WSK subsystem will retrieve the security context to use
when it binds the socket. The WSK subsystem uses the security context to determine whether the local
transport address can be shared if that address is already in use. To specify the current process, a WSK
application sets this pointer to <strong>NULL</strong>.</p>
<h3><code>OwningThread</code> [in, optional]</h3>
<p>A pointer to a specific thread from which the WSK subsystem will retrieve the security context to
use when it binds the socket. The WSK subsystem uses the security context to determine whether the local
transport address can be shared if that address is already in use. If a WSK application does not need to
specify a specific thread, it sets this pointer to <strong>NULL</strong>.</p>
<h3><code>SecurityDescriptor</code> [in, optional]</h3>
<p>A pointer to a <a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> structure that specifies the security descriptor to apply to
the socket that is being created. The security descriptor controls the sharing of the local transport
address to which the socket is bound. If a WSK application specifies a non-<strong>NULL</strong> pointer, it must specify
a pointer to a cached copy of a security descriptor that was obtained by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a> function with the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-cache-sd">WSK_CACHE_SD</a> control code. To specify a
default security descriptor that does not allow sharing of the local transport address, a WSK
application sets
<strong>SecurityDescriptor</strong> to <strong>NULL</strong>.</p>
<p>For more information about the <a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> structure, see the reference page for
<a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a> in the Microsoft Windows SDK documentation.</p>
<h3><code>Irp</code> [in, out]</h3>
<p>A pointer to a caller-allocated <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that the WSK subsystem uses to complete the creation of the
new socket asynchronously. For more information about using IRPs with WSK functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions">Using IRPs with Winsock
Kernel Functions</a>.</p>
<h2>Return value</h2>
<p><strong>WskSocketConnect</strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
<td>The new socket was successfully created. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with success status.</td>
</tr>
<tr>
<td><strong>STATUS_PENDING</strong></td>
<td>The WSK subsystem could not create the socket immediately. The WSK subsystem will complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> after it has created the new socket. The status of the socket creation will be returned in the <strong>IoStatus.Status</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</td>
</tr>
<tr>
<td><strong>Other status codes</strong></td>
<td>An error occurred. The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> will be completed with failure status.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>If the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed with success status, the
<strong>IoStatus.Information</strong> field of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> contains a pointer to a socket object structure (
<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a>) for the new socket.</p>
<p>A WSK application can obtain a list of available transport protocols by calling the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a> function with the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-transport-list-query">WSK_TRANSPORT_LIST_QUERY</a> control
code.
<strong>WskControlClient</strong> returns a list of
<a href="wsk_transport" title="typedef struct _WSK_TRANSPORT {&#10;  USHORT         Version;&#10;  USHORT         SocketType;&#10;  ULONG          Protocol;&#10;  ADDRESS_FAMILY AddressFamily;&#10;  GUID           ProviderId;&#10;} WSK_TRANSPORT, *PWSK_TRANSPORT;">WSK_TRANSPORT</a> structures that contains all of
the valid combinations of the
<strong>SocketType</strong> and
<strong>Protocol</strong> parameters.</p>
<p>The WSK subsystem determines the address family for the new socket from the address family that is
specified in the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-sockaddr">SOCKADDR</a> structure that is pointed to by the
<strong>LocalAddress</strong> parameter.</p>
<p>If the WSK application needs to set a socket option or issue an I/O control operation on the socket
before binding or connecting the socket, the WSK application must call the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">WskSocket</a>,
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_bind">WskBind</a>, and
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_connect">WskConnect</a> functions instead of calling the
<strong>WskSocketConnect</strong> function.</p>
<p>When a WSK application successfully creates a new socket, all of the event callback functions on the
new socket are disabled by default. For more information about enabling any of the new socket's event
callback functions, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/evntprov/nc-evntprov-penablecallback">Enabling and
Disabling Event Callback Functions</a>.</p>
<p>If a WSK application specifies a non-<strong>NULL</strong> pointer for the
<strong>SecurityDescriptor</strong> parameter, it must not release the cached security descriptor until after the
<a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> is completed.</p>
<p>The WSK subsystem allocates the memory for the socket object structure (<a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a>) for the new socket
on behalf of the WSK application. The WSK subsystem deallocates this memory when the socket is
closed.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-sockaddr">SOCKADDR</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/wsk-client">WSK_CLIENT</a></p>
<p><a href="wsk_client_connection_dispatch" title="typedef struct _WSK_CLIENT_CONNECTION_DISPATCH {&#10;  PFN_WSK_RECEIVE_EVENT      WskReceiveEvent;&#10;  PFN_WSK_DISCONNECT_EVENT   WskDisconnectEvent;&#10;  PFN_WSK_SEND_BACKLOG_EVENT WskSendBacklogEvent;&#10;} WSK_CLIENT_CONNECTION_DISPATCH, *PWSK_CLIENT_CONNECTION_DISPATCH;">WSK_CLIENT_CONNECTION_DISPATCH</a></p>
<p><a href="wsk_provider_dispatch" title="typedef struct _WSK_PROVIDER_DISPATCH {&#10;  USHORT                    Version;&#10;  USHORT                    Reserved;&#10;  PFN_WSK_SOCKET            WskSocket;&#10;  PFN_WSK_SOCKET_CONNECT    WskSocketConnect;&#10;  PFN_WSK_CONTROL_CLIENT    WskControlClient;&#10;  PFN_WSK_GET_ADDRESS_INFO  WskGetAddressInfo;&#10;  PFN_WSK_FREE_ADDRESS_INFO WskFreeAddressInfo;&#10;  PFN_WSK_GET_NAME_INFO     WskGetNameInfo;&#10;} WSK_PROVIDER_DISPATCH, *PWSK_PROVIDER_DISPATCH;">WSK_PROVIDER_DISPATCH</a></p>
<p><a href="wsk_provider_npi" title="typedef struct _WSK_PROVIDER_NPI {&#10;  PWSK_CLIENT                 Client;&#10;  const WSK_PROVIDER_DISPATCH *Dispatch;&#10;} WSK_PROVIDER_NPI, *PWSK_PROVIDER_NPI;">WSK_PROVIDER_NPI</a></p>
<p><a href="wsk_socket" title="typedef struct _WSK_SOCKET {&#10;  const VOID *Dispatch;&#10;} WSK_SOCKET, *PWSK_SOCKET;">WSK_SOCKET</a></p>
<p><a href="wskcaptureprovidernpi" title="NTSTATUS WskCaptureProviderNPI(&#10;  [in]  PWSK_REGISTRATION WskRegistration,&#10;  [in]  ULONG             WaitTimeout,&#10;  [out] PWSK_PROVIDER_NPI WskProviderNpi&#10;);">WskCaptureProviderNPI</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_close_socket">WskCloseSocket</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_control_client">WskControlClient</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket">WskSocket</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wsk/nc-wsk-pfn_wsk_socket_connect">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wsk/nc-wsk-pfn_wsk_socket_connect.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
