<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="_URB_ISOCH_TRANSFER - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>_URB_ISOCH_TRANSFER - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            _URB_ISOCH_TRANSFER - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// usb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">struct _URB_ISOCH_TRANSFER {
  struct <a href="_urb_header" title="struct _URB_HEADER {&#10;  USHORT      Length;&#10;  USHORT      Function;&#10;  USBD_STATUS Status;&#10;  PVOID       UsbdDeviceHandle;&#10;  ULONG       UsbdFlags;&#10;};">_URB_HEADER</a>         Hdr;
  USBD_PIPE_HANDLE           PipeHandle;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      TransferFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      TransferBufferLength;
  PVOID                      TransferBuffer;
  <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a>                       TransferBufferMDL;
  <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">struct _URB</a>                *UrbLink;
  struct _URB_HCD_AREA       hca;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      StartFrame;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      NumberOfPackets;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      ErrorCount;
  <a href="usbd_iso_packet_descriptor" title="typedef struct _USBD_ISO_PACKET_DESCRIPTOR {&#10;  ULONG       Offset;&#10;  ULONG       Length;&#10;  USBD_STATUS Status;&#10;} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;">USBD_ISO_PACKET_DESCRIPTOR</a> IsoPacket[1];
};</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usb/ns-usb-_urb_isoch_transfer">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/_urb_isoch_transfer.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-usb-_urb_isoch_transfer)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>_URB_ISOCH_TRANSFER structure</h1>

<h2>Description</h2>

<p>The <strong>_URB_ISOCH_TRANSFER</strong> structure is used by USB client drivers to send data to or retrieve data from an isochronous transfer pipe.</p>

<h2>Members</h2>

<h3><code>Hdr</code></h3>

<p>A pointer to a <a href="_urb_header" title="struct _URB_HEADER {&#10;  USHORT      Length;&#10;  USHORT      Function;&#10;  USBD_STATUS Status;&#10;  PVOID       UsbdDeviceHandle;&#10;  ULONG       UsbdFlags;&#10;};">_URB_HEADER</a> structure that specifies the <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> header information. <strong>Hdr.Function</strong> must be URB_FUNCTION_ISOCH_TRANSFER, and <strong>Hdr.Length</strong> must be the size of this variable-length data structure.</p>

<h3><code>PipeHandle</code></h3>

<p>Specifies an opaque handle to the isochronous pipe. The host controller driver returns this handle when the client driver selects the device configuration with a <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> of type URB_FUNCTION_SELECT_CONFIGURATION or when the client driver changes the settings for an interface with a <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> of type URB_FUNCTION_SELECT_INTERFACE.</p>

<h3><code>TransferFlags</code></h3>

<p>Specifies zero, one, or a combination of the following flags:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>USBD_TRANSFER_DIRECTION_IN</strong></td>
  <td>Is set to request data from a device. To transfer data to a device, this flag must be clear.</td>
</tr>
<tr>
  <td><strong>USBD_SHORT_TRANSFER_OK</strong></td>
  <td>Is set to direct the host controller not to return an error when it receives a packet from the device that is shorter than the maximum packet size for the endpoint. This flag has no effect on an isochronous pipe, because the bus driver does not return an error when it receives short packets on an isochronous pipe.</td>
</tr>
<tr>
  <td><strong>USBD_START_ISO_TRANSFER_ASAP</strong></td>
  <td>Causes the transfer to begin on the next frame, if no transfers have been submitted to the pipe since the pipe was opened or last reset. Otherwise, the transfer begins on the first frame that follows all currently queued requests for the pipe. The actual frame that the transfer begins on will be adjusted for bus latency by the host controller driver.</td>
</tr>
</tbody>
</table>

<h3><code>TransferBufferLength</code></h3>

<p>Specifies the length, in bytes, of the buffer specified in <strong>TransferBuffer</strong> or described in <strong>TransferBufferMDL</strong>. The host controller driver returns the number of bytes that are sent to or read from the pipe in this member.</p>

<h3><code>TransferBuffer</code></h3>

<p>A pointer to a resident buffer for the transfer is <strong>NULL</strong> if an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is supplied in <strong>TransferBufferMDL</strong>. The contents of this buffer depend on the value of <strong>TransferFlags</strong>. If USBD_TRANSFER_DIRECTION_IN is specified, this buffer will contain data that is read from the device on return from the host controller driver. Otherwise, this buffer contains driver-supplied data for transfer to the device.</p>

<h3><code>TransferBufferMDL</code></h3>

<p>A pointer to an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that describes a resident buffer is <strong>NULL</strong> if a buffer is supplied in <strong>TransferBuffer</strong>. The contents of the buffer depend on the value of <strong>TransferFlags</strong>. If USBD_TRANSFER_DIRECTION_IN is specified, the described buffer will contain data that is read from the device on return from the host controller driver. Otherwise, the buffer contains driver-supplied data for transfer to the device. This <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must be allocated from nonpaged pool.</p>

<h3><code>UrbLink</code></h3>

<p>Reserved. Do not use.</p>

<h3><code>hca</code></h3>

<p>Reserved. Do not use.</p>

<h3><code>StartFrame</code></h3>

<p>Specifies the frame number that the transfer should begin on. This variable must be within a system-defined range of the current frame. The range is specified by the constant USBD_ISO_START_FRAME_RANGE.</p>

<p>If START_ISO_TRANSFER_ASAP is set in <strong>TransferFlags</strong>, this member contains the frame number that the transfer began on, when the request is returned by the host controller driver. Otherwise, this member must contain the frame number that this transfer begins on.</p>

<h3><code>NumberOfPackets</code></h3>

<p>Specifies the number of packets that are described by the variable-length array member <strong>IsoPacket</strong>.</p>

<h3><code>ErrorCount</code></h3>

<p>Contains the number of packets that completed with an error condition on return from the host controller driver.</p>

<h3><code>IsoPacket</code></h3>

<p>Contains a variable-length array of <a href="usbd_iso_packet_descriptor" title="typedef struct _USBD_ISO_PACKET_DESCRIPTOR {&#10;  ULONG       Offset;&#10;  ULONG       Length;&#10;  USBD_STATUS Status;&#10;} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;">USBD_ISO_PACKET_DESCRIPTOR</a> structures that describe the isochronous transfer packets to be transferred on the USB bus. For more information about this member see the Remarks section.</p>

<h2>Remarks</h2>

<p>The USB bus driver always returns a value of USBD_STATUS_SUCCESS in <strong>Hdr.Status</strong>, unless every packet in the transfer generated an error or the request was not well-formed and could not be executed at all. The following table includes possible error codes returned in <strong>Hdr.Status</strong>.</p>

<table>
<thead>
<tr>
  <th>Error value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>USBD_STATUS_ISOCH_REQUEST_FAILED</td>
  <td>Indicates that every packet of an isochronous request was completed with errors.</td>
</tr>
<tr>
  <td>USBD_STATUS_BAD_START_FRAME</td>
  <td>Indicates that the requested start frame is not within USBD_ISO_START_FRAME_RANGE of the current USB frame.</td>
</tr>
<tr>
  <td>USBD_ISO_NOT_ACCESSED_LATE</td>
  <td>Indicates that every packet was submitted too late for the packet to be sent, based on the requested start frame.</td>
</tr>
<tr>
  <td>USBD_STATUS_INVALID_PARAMETER</td>
  <td>Indicates that one of the <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> parameters was incorrect.</td>
</tr>
</tbody>
</table>

<p>Before the host controller sends an isochronous request to a USB device, it requires information about the device's endpoint to which it must send or receive data. This information is stored in endpoint descriptors (<a href="usb_endpoint_descriptor" title="typedef struct _USB_ENDPOINT_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  UCHAR  bEndpointAddress;&#10;  UCHAR  bmAttributes;&#10;  USHORT wMaxPacketSize;&#10;  UCHAR  bInterval;&#10;} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;">USB_ENDPOINT_DESCRIPTOR</a>) that are retrieved from the selected configuration descriptor.
After the bus driver gets the endpoint descriptor, it creates an isochronous transfer pipe to set up the data transfer. The pipe's attributes are stored in the <a href="usbd_pipe_information" title="typedef struct _USBD_PIPE_INFORMATION {&#10;  USHORT           MaximumPacketSize;&#10;  UCHAR            EndpointAddress;&#10;  UCHAR            Interval;&#10;  USBD_PIPE_TYPE   PipeType;&#10;  USBD_PIPE_HANDLE PipeHandle;&#10;  ULONG            MaximumTransferSize;&#10;  ULONG            PipeFlags;&#10;} USBD_PIPE_INFORMATION, *PUSBD_PIPE_INFORMATION;">USBD_PIPE_INFORMATION</a> structure. For isochronous transfers, the members are set as follows:</p>

<ul>
<li>The <strong>PipeType</strong> member specifies the type of transfer and is set to UsbdPipeTypeIsochronous.</li>
<li>The <strong>MaximumPacketSize</strong> member specifies the amount of data, in bytes, that constitutes one packet. For isochronous transfers, the packet size is fixed and can be a value from 0-1024. The packet size either equals or is less than the <strong>wMaxPacketSize</strong> value of the endpoint descriptor.</li>
<li>The <strong>Interval</strong> member is derived from the <strong>bInterval</strong> value of the endpoint descriptor. This value is used to calculate the polling period that indicates the frequency at which data is sent on the bus. For full speed devices, the period is measured in units of 1 millisecond frames; for high speed devices, the period is measured in microframes.</li>
</ul>

<p>The host controller also determines the amount of data that can be transferred (within a frame or a microframe) depending on the type of device. This information is available in bits <strong>12.. 11</strong> of <strong>wMaxPacketSize</strong> in the endpoint descriptor.</p>

<p>For full-speed devices, only one packet can be transferred within a frame; bits <strong>12.. 11</strong> are reserved and set to zero.</p>

<p>For high speed devices, data can be transferred in a single packet or might span multiple packets, within a microframe.
If bits <strong>12.. 11</strong> are set to <em>n</em>, you can transfer <code>(n+1)*MaximumPacketSize</code> bytes per microframe. Bits <strong>12.. 11</strong> set to zero indicate that only one packet can be transferred in a microframe. If bits <strong>12.. 11</strong> are set to 1, the host controller can transfer two packets in a microframe.</p>

<p>The <strong>IsoPacket</strong> member of <strong>_URB_ISOCH_TRANSFER</strong> is an array of <a href="usbd_iso_packet_descriptor" title="typedef struct _USBD_ISO_PACKET_DESCRIPTOR {&#10;  ULONG       Offset;&#10;  ULONG       Length;&#10;  USBD_STATUS Status;&#10;} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;">USBD_ISO_PACKET_DESCRIPTOR</a> that describes the transfer buffer layout. Each element in the array correlates to data that is transferred in one microframe. If <strong>IsoPacket</strong> has <em>n</em> elements, the host controller transfers use <em>n</em> frames (for full speed devices) or microframes (for high speed devices) to transfer data. The <strong>IsoPacket[</strong>i<strong>].Offset</strong> member is used to track the amount of data to send or receive. This is done by setting a byte offset from the start of the entire transfer buffer for the request.</p>

<p>For example, there are five microframes available to transfer 1024 byte-sized packets.</p>

<p>If bits <strong>12.. 11</strong> are set to zero (indicating a single packet per microframe transfer), <strong>IsoPacket</strong> contains the following entries:</p>

<p>Microframe 1 <code>IsoPacket.Element[0].Offset = 0</code> (start address)</p>

<p>Microframe 2 <code>IsoPacket.Element[1].Offset = 1024</code></p>

<p>Microframe 3 <code>IsoPacket.Element[2].Offset = 2048</code></p>

<p>Microframe 4 <code>IsoPacket.Element[3].Offset = 3072</code></p>

<p>Microframe 5 <code>IsoPacket.Element[4].Offset = 4096</code></p>

<p>If bits <strong>12.. 11</strong> are set to 1 (indicating two packets per microframe), <strong>IsoPacket</strong> contains the following entries:</p>

<p>Microframe 1 <code>IsoPacket.Element[0].Offset = 0</code> (start address)</p>

<p>Microframe 2 <code>IsoPacket.Element[1].Offset = 2048</code></p>

<p>Microframe 3 <code>IsoPacket.Element[2].Offset = 4096</code></p>

<p>Microframe 4 <code>IsoPacket.Element[3].Offset = 6144</code></p>

<p>Microframe 5 <code>IsoPacket.Element[4].Offset = 8192</code></p>

<p><strong>Note</strong> For multiple packets, the offset value indicates sizes for all the packets within the microframe.</p>

<p>The <strong>IsoPacket[</strong>i<strong>].Length</strong> member is updated by the host controller to indicate the actual number of bytes that are received from the device for isochronous IN transfers. <strong>IsoPacket[</strong>i<strong>].Length</strong> is not used for isochronous OUT transfers.</p>

<p>Drivers can use the <a href="get_iso_urb_size" title="#define  GET_ISO_URB_SIZE(n) (sizeof(struct _URB_ISOCH_TRANSFER)+\&#10;        sizeof(USBD_ISO_PACKET_DESCRIPTOR)*n)">GET_ISO_URB_SIZE</a> macro to determine the size that is needed to hold the entire <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a>. If the length is too small to fill the space set aside for this packet, the bus driver leaves a gap from the end of the retrieved data to the offset for the next packet. The bus driver will not adjust the offsets to avoid wasting buffer space.</p>

<p>The <strong>TransferBuffer</strong> or <strong>TransferBufferMDL</strong> members must specify a virtually contiguous buffer.</p>

<p>Treat other members that are part of this structure but not described here as opaque. They are reserved for system use.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/usbcon/transfer-data-to-isochronous-endpoints">How to Transfer Data to USB Isochronous Endpoints</a></p>

<p><a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_usbref/#structures">USB Structures</a></p>

<p><a href="usbd_iso_packet_descriptor" title="typedef struct _USBD_ISO_PACKET_DESCRIPTOR {&#10;  ULONG       Offset;&#10;  ULONG       Length;&#10;  USBD_STATUS Status;&#10;} USBD_ISO_PACKET_DESCRIPTOR, *PUSBD_ISO_PACKET_DESCRIPTOR;">USBD_ISO_PACKET_DESCRIPTOR</a></p>

<p><a href="usbd_isochurballocate" title="NTSTATUS USBD_IsochUrbAllocate(&#10;  [in]  USBD_HANDLE USBDHandle,&#10;  [in]  ULONG       NumberOfIsochPackets,&#10;  [out] PURB        *Urb&#10;);">USBD_IsochUrbAllocate</a></p>

<p><a href="_urb_header" title="struct _URB_HEADER {&#10;  USHORT      Length;&#10;  USHORT      Function;&#10;  USBD_STATUS Status;&#10;  PVOID       UsbdDeviceHandle;&#10;  ULONG       UsbdFlags;&#10;};">_URB_HEADER</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usb/ns-usb-_urb_isoch_transfer">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/usb/ns-usb-_urb_isoch_transfer.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
