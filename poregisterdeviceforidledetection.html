<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PoRegisterDeviceForIdleDetection - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PoRegisterDeviceForIdleDetection - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PoRegisterDeviceForIdleDetection - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PULONG PoRegisterDeviceForIdleDetection(
  [in] <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>     DeviceObject,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              ConservationIdleTime,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              PerformanceIdleTime,
  [in] <a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a> State
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-poregisterdeviceforidledetection">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PULONG PoRegisterDeviceForIdleDetection(
  [in] <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a>     DeviceObject,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              ConservationIdleTime,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>              PerformanceIdleTime,
  [in] <a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a> State
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-poregisterdeviceforidledetection">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/poregisterdeviceforidledetection.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-poregisterdeviceforidledetection)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="poregisterdeviceforidledetection-function-ntifsh">PoRegisterDeviceForIdleDetection function (ntifs.h)</h1>

<h2 id="description">Description</h2>

<p>The <strong>PoRegisterDeviceForIdleDetection</strong> routine enables or cancels idle detection and sets idle time-out values for a device.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="deviceobject-in"><code>DeviceObject</code> [in]</h3>

<p>A pointer to the driver-created <strong><a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a></strong> for the device. This parameter can point to a physical device object (PDO) or a functional device object (FDO).</p>

<h3 id="conservationidletime-in"><code>ConservationIdleTime</code> [in]</h3>

<p>Sets the time-out value (in seconds) to apply when the system power policy optimizes for energy conservation. Specify zero to disable idle detection when conservation policy is in effect.</p>

<h3 id="performanceidletime-in"><code>PerformanceIdleTime</code> [in]</h3>

<p>Sets the time-out value (in seconds) to apply when the system power policy optimizes for performance. Specify zero to disable idle detection when performance policy is in effect.</p>

<h3 id="state-in"><code>State</code> [in]</h3>

<p>Specifies the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/device-power-states">device power state</a> to be requested in an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-power"><strong>IRP_MN_SET_POWER</strong></a> request when either <strong>ConservationIdleTime</strong> or <strong>PerformanceIdleTime</strong> has been met. Possible values are the <strong><a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a></strong> values.</p>

<h2 id="return-value">Return value</h2>

<p><strong>PoRegisterDeviceForIdleDetection</strong> returns a pointer to the idle counter to indicate that idle detection has been enabled. It returns NULL to indicate that idle detection has been disabled, that an idle counter could not be allocated, or that one or both of the time-out values were invalid.</p>

<h2 id="remarks">Remarks</h2>

<p><strong>PoRegisterDeviceForIdleDetection</strong> enables drivers to use the idle detection mechanism provided by the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/power-manager">power manager</a>. Drivers call <strong>PoRegisterDeviceForIdleDetection</strong> for any of the following reasons:</p>

<ul>
<li>To enable idle detection for the device and set initial idle time-out values.</li>
<li>To change the idle time-out values for a device.</li>
<li>To disable idle detection for a device.</li>
</ul>

<p>After enabling a device for idle detection, a driver calls <strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong> whenever the device is in use, passing the non-NULL idle pointer returned by <strong>PoRegisterDeviceForIdleDetection</strong>. Calling <strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong> restarts the idle countdown. Note that a driver must not pass a NULL pointer to <strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong>.</p>

<p>Whenever the device satisfies the current idle time-out value, the power manager sends an <strong><a href="irp_mn_set_power" title="#define IRP_MN_SET_POWER 0x02">IRP_MN_SET_POWER</a></strong> request to the top of the device stack, specifying device power state <strong>State</strong>. In response to the <strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong>, each driver performs any device-specific tasks required before the power state transition, then passes the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the next-lower driver. When the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> reaches the bus driver, that driver puts the device in the requested lower power state and completes the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<p><strong>PoRegisterDeviceForIdleDetection</strong> sets time-out values for both conservation and performance. The <strong>ConservationIdleTime</strong> value applies when the system power policy optimizes for conservation; the <strong>PerformanceIdleTime</strong> value applies when the system power policy optimizes for performance. Typically, the applicable policy depends upon the power source: when running with AC power, the system optimizes for performance, and when running off a battery, the system optimizes for conservation.</p>

<p>Certain devices can specify time-out values of -1 to use the standard power policy time-outs for their device class. The standard time-out values provide for better system integration for supported standard device classes. At present, WDM supports this feature for devices of type FILE_DEVICE_DISK and FILE_DEVICE_MASS_STORAGE. <strong>PoRegisterDeviceForIdleDetection</strong> returns NULL if -1 is specified for a device of an unsupported type. For information about device types, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/specifying-device-types">Specifying Device Types</a>.</p>

<p>Only one idle detection can be set per device. Subsequent calls to <strong>PoRegisterDeviceForIdleDetection</strong> change the idle detection values.</p>

<p>If both <strong>ConservationIdleTime</strong> and <strong>PerformanceIdleTime</strong> are zero, this routine cancels all idle detection for the device and returns NULL.</p>

<p><strong>PoRegisterDeviceForIdleDetection</strong> can free a driver from the need to perform its own idle detection. However, drivers can also implement their own idle detection.</p>

<h2 id="see-also">See also</h2>

<p><strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></strong></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-power"><strong>IRP_MN_SET_POWER</strong></a></p>

<p><strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-poregisterdeviceforidledetection">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-poregisterdeviceforidledetection.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-poregisterdeviceforidledetection)</h1>
</div>
<div class="ntdoc-description">
<h1>PoRegisterDeviceForIdleDetection function (wdm.h)</h1>

<h2>Description</h2>

<p>The <strong>PoRegisterDeviceForIdleDetection</strong> routine enables or cancels idle detection and sets idle time-out values for a device.</p>

<h2>Parameters</h2>

<h3><code>DeviceObject</code> [in]</h3>

<p>A pointer to the driver-created <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a> for the device. On Windows 2000 and later systems, this parameter can point to a physical device object (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">PDO</a>) or a functional device object (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/">FDO</a>). On Windows 98/Me, this parameter must point to the PDO of the underlying device.</p>

<h3><code>ConservationIdleTime</code> [in]</h3>

<p>Sets the time-out value (in seconds) to apply when the system power policy optimizes for energy conservation. Specify zero to disable idle detection when conservation policy is in effect.</p>

<h3><code>PerformanceIdleTime</code> [in]</h3>

<p>Sets the time-out value (in seconds) to apply when the system power policy optimizes for performance. Specify zero to disable idle detection when performance policy is in effect.</p>

<h3><code>State</code> [in]</h3>

<p>Specifies the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/device-power-states">device power state</a> to be requested in an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-power">IRP_MN_SET_POWER</a> request when either <em>ConservationIdleTime</em> or <em>PerformanceIdleTime</em> has been met. Possible values are the <a href="device_power_state" title="typedef enum _DEVICE_POWER_STATE {&#10;  PowerDeviceUnspecified,&#10;  PowerDeviceD0,&#10;  PowerDeviceD1,&#10;  PowerDeviceD2,&#10;  PowerDeviceD3,&#10;  PowerDeviceMaximum&#10;} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;">DEVICE_POWER_STATE</a> values.</p>

<h2>Return value</h2>

<p><strong>PoRegisterDeviceForIdleDetection</strong> returns a pointer to the idle counter to indicate that idle detection has been enabled. It returns <strong>NULL</strong> to indicate that idle detection has been disabled, that an idle counter could not be allocated, or that one or both of the time-out values were invalid.</p>

<h2>Remarks</h2>

<p><strong>PoRegisterDeviceForIdleDetection</strong> enables drivers to use the idle detection mechanism provided by the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/power-manager">power manager</a>. Drivers call <strong>PoRegisterDeviceForIdleDetection</strong> for any of the following reasons:</p>

<ul>
<li>To enable idle detection for the device and set initial idle time-out values</li>
<li>To change the idle time-out values for a device</li>
<li>To disable idle detection for a device</li>
</ul>

<p>After enabling a device for idle detection, a driver calls <a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a> whenever the device is in use, passing the non-<strong>NULL</strong> idle pointer returned by <strong>PoRegisterDeviceForIdleDetection</strong>. Calling <strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong> restarts the idle countdown. Note that a driver must not pass a <strong>NULL</strong> pointer to <strong><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></strong>.</p>

<p>Whenever the device satisfies the current idle time-out value, the power manager sends an <strong><a href="irp_mn_set_power" title="#define IRP_MN_SET_POWER 0x02">IRP_MN_SET_POWER</a></strong> request to the top of the device stack, specifying device power state <em>State</em>. In response to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>, each driver performs any device-specific tasks required before the power state transition, then passes the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to the next-lower driver. When the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> reaches the bus driver, that driver puts the device in the requested lower power state and completes the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<p><strong>PoRegisterDeviceForIdleDetection</strong> sets time-out values for both conservation and performance. The <em>ConservationIdleTime</em> value applies when the system power policy optimizes for conservation; the <em>PerformanceIdleTime</em> value applies when the system power policy optimizes for performance. Typically, the applicable policy depends upon the power source: when running with AC power, the system optimizes for performance, and when running off a battery, the system optimizes for conservation.</p>

<p>Certain devices can specify time-out values of -1 to use the standard power policy time-outs for their device class. The standard time-out values provide for better system integration for supported standard device classes. At present, WDM supports this feature for devices of type FILE_DEVICE_DISK and FILE_DEVICE_MASS_STORAGE. <strong>PoRegisterDeviceForIdleDetection</strong> returns <strong>NULL</strong> if -1 is specified for a device of an unsupported type. (For information about device types, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/specifying-device-types">Specifying Device Types</a>.)</p>

<p>Only one idle detection can be set per device. Subsequent calls to <strong>PoRegisterDeviceForIdleDetection</strong> change the idle detection values.</p>

<p>If both <em>ConservationIdleTime</em> and <em>PerformanceIdleTime</em> are zero, this routine cancels all idle detection for the device and returns <strong>NULL</strong>.</p>

<p><strong>PoRegisterDeviceForIdleDetection</strong> can free a driver from the need to perform its own idle detection. However, drivers can also implement their own idle detection.</p>

<h2>See also</h2>

<p><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-set-power">IRP_MN_SET_POWER</a></p>

<p><a href="posetdevicebusy" title="void PoSetDeviceBusy(&#10;  [in, out] IdlePointer&#10;);">PoSetDeviceBusy</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-poregisterdeviceforidledetection">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-poregisterdeviceforidledetection.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
