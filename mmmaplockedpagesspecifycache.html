<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="MmMapLockedPagesSpecifyCache - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>MmMapLockedPagesSpecifyCache - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            MmMapLockedPagesSpecifyCache - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PVOID MmMapLockedPagesSpecifyCache(
  [in]           <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a>                                                                          MemoryDescriptorList,
  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,
  [in]           __drv_strictTypeMatch(__drv_typeCond)<a href="memory_caching_type" title="typedef enum _MEMORY_CACHING_TYPE {&#10;  MmNonCached,&#10;  MmCached,&#10;  MmWriteCombined,&#10;  MmHardwareCoherentCached,&#10;  MmNonCachedUnordered,&#10;  MmUSWCCached,&#10;  MmMaximumCacheType,&#10;  MmNotMapped&#10;} MEMORY_CACHING_TYPE;">MEMORY_CACHING_TYPE</a>                      CacheType,
  [in, optional] PVOID                                                                         RequestedAddress,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                                                         BugCheckOnFailure,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                                                                         Priority
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmmaplockedpagesspecifycache">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/mmmaplockedpagesspecifycache.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-mmmaplockedpagesspecifycache)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>MmMapLockedPagesSpecifyCache</strong> routine maps the physical pages that are described by an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to a virtual address, and enables the caller to specify the cache attribute that is used to create the mapping.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="memorydescriptorlist-in"><code>MemoryDescriptorList</code> [in]</h3>

<p>A pointer to the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that is to be mapped. This <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> must describe physical pages that are locked down. A locked-down <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> can be built by the <a href="mmprobeandlockpages" title="VOID MmProbeAndLockPages(&#10;  [in, out] PMDL            MemoryDescriptorList,&#10;  [in]      KPROCESSOR_MODE AccessMode,&#10;  [in]      LOCK_OPERATION  Operation&#10;);">MmProbeAndLockPages</a> or <a href="mmallocatepagesformdlex" title="PMDL MmAllocatePagesForMdlEx(&#10;  [in] PHYSICAL_ADDRESS    LowAddress,&#10;  [in] PHYSICAL_ADDRESS    HighAddress,&#10;  [in] PHYSICAL_ADDRESS    SkipBytes,&#10;  [in] SIZE_T              TotalBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType,&#10;  [in] ULONG               Flags&#10;);">MmAllocatePagesForMdlEx</a> routine. For mappings to user space, MDLs that are built by the <a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a> routine can be used.</p>

<h3 id="accessmode-in"><code>AccessMode</code> [in]</h3>

<p>Specifies the access mode in which to map the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>: <strong>KernelMode</strong> or <strong>UserMode</strong>. Almost all drivers should use <strong>KernelMode</strong>.</p>

<h3 id="cachetype-in"><code>CacheType</code> [in]</h3>

<p>Specifies a <a href="memory_caching_type" title="typedef enum _MEMORY_CACHING_TYPE {&#10;  MmNonCached,&#10;  MmCached,&#10;  MmWriteCombined,&#10;  MmHardwareCoherentCached,&#10;  MmNonCachedUnordered,&#10;  MmUSWCCached,&#10;  MmMaximumCacheType,&#10;  MmNotMapped&#10;} MEMORY_CACHING_TYPE;">MEMORY_CACHING_TYPE</a> value, which indicates the cache attribute to use to map the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>. For more information, see the following Remarks section.</p>

<h3 id="requestedaddress-in-optional"><code>RequestedAddress</code> [in, optional]</h3>

<p>If <em>AccessMode</em> = <strong>UserMode</strong>, this parameter specifies the starting user virtual address to map the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> to, or set to <strong>NULL</strong> to allow the system to choose the starting address. The system might round down the requested address to fit address boundary requirements, so callers must check the return value.</p>

<h3 id="bugcheckonfailure-in"><code>BugCheckOnFailure</code> [in]</h3>

<p>Specifies the behavior of the routine for <em>AccessMode</em> = <strong>KernelMode</strong> if the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> cannot be mapped because of low system resources. If <strong>TRUE</strong>, the system issues a bug check. If <strong>FALSE</strong>, the routine returns <strong>NULL</strong>. Drivers must set this parameter to <strong>FALSE</strong>.</p>

<h3 id="priority-in"><code>Priority</code> [in]</h3>

<p>An <strong>MM_PAGE_PRIORITY</strong> value that indicates the importance of success when page table entries (PTEs) are scarce. Starting with Windows 8, the specified priority value can be bitwise-ORed with the <strong>MdlMappingNoWrite</strong> or <strong>MdlMappingNoExecute</strong> flags to specify memory in which writes or instruction execution are disabled. For more information about the possible values for <em>Priority</em>, see <a href="mmgetsystemaddressformdlsafe" title="PVOID MmGetSystemAddressForMdlSafe(&#10;  [in] PMDL  Mdl,&#10;  [in] ULONG Priority&#10;);">MmGetSystemAddressForMdlSafe</a>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>MmMapLockedPagesSpecifyCache</strong> returns the starting address of the mapped pages. If the pages cannot be mapped and <em>BugCheckOnFailure</em> is <strong>FALSE</strong>, the routine returns <strong>NULL</strong>.</p>

<h2 id="remarks">Remarks</h2>

<p>Use <a href="mmunmaplockedpages" title="VOID MmUnmapLockedPages(&#10;  [in] PVOID BaseAddress,&#10;  [in] PMDL  MemoryDescriptorList&#10;);">MmUnmapLockedPages</a> to unmap the physical pages that were mapped by <strong>MmMapLockedPagesSpecifyCache</strong>.</p>

<p>If <em>AccessMode</em> is <strong>KernelMode</strong>, and if <strong>MmMapLockedPagesSpecifyCache</strong> cannot map the specified pages, the routine returns <strong>NULL</strong> (if <em>BugCheckOnFailure</em> = <strong>FALSE</strong>), or the operating system issues a bug check (if <em>BugCheckOnFailure</em> = <strong>TRUE</strong>).</p>

<p>If <em>AccessMode</em> is <strong>UserMode</strong>, be aware of the following details:</p>

<ul>
<li><p>If the specified pages cannot be mapped, the routine raises an exception. Callers that specify <strong>UserMode</strong> must wrap the call to <strong>MmMapLockedPagesSpecifyCache</strong> in a <strong>try/except</strong> block. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/handling-exceptions">Handling Exceptions</a>.</p></li>
<li><p>The routine returns a user address that is valid in the context of the process in which the driver is running. For example, if a 64-bit driver is running in the context of a 32-bit application, the buffer is mapped to an address in the 32-bit address range of the application.</p></li>
<li><p>A non-executable mapping is always created when <em>AccessMode</em> is <strong>UserMode</strong>. Therefore, using the <strong>MdlMappingNoExecute</strong> flag with the <em>Priority</em> parameter is unnecessary in this scenario. However, the <strong>MdlMappingNoWrite</strong> flag can still be used with the <em>Priority</em> parameter in this scenario to request a read-only mapping.</p></li>
<li><p>The non-executable protection of the mapping and any write protection of the mapping specified by using the <strong>MdlMappingNoWrite</strong> flag with the <em>Priority</em> parameter cannot be changed by code that is running in user mode. For example, if a driver maps some pages into a user process and specifies the <strong>MdlMappingNoWrite</strong> flag, the system guarantees that the process cannot modify the pages.</p></li>
</ul>

<p>The routine uses the <em>CacheType</em> parameter only if the pages that are described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> do not already have a cache type associated with them. However, in nearly all cases, the pages already have an associated cache type, and this cache type is used by the new mapping. An exception to this rule is for pages that are allocated by <a href="mmallocatepagesformdl" title="PMDL MmAllocatePagesForMdl(&#10;  [in] PHYSICAL_ADDRESS LowAddress,&#10;  [in] PHYSICAL_ADDRESS HighAddress,&#10;  [in] PHYSICAL_ADDRESS SkipBytes,&#10;  [in] SIZE_T           TotalBytes&#10;);">MmAllocatePagesForMdl</a>, which do not have a specific cache type associated with them. For such pages, the <em>CacheType</em> parameter determines the cache type of the mapping.</p>

<p>A driver must not try to create more than one system-address-space mapping for an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>. Additionally, because an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that is built by the <a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a> routine is already mapped to the system address space, a driver must not try to map this <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> into the system address space again by using the <strong>MmMapLockedPagesSpecifyCache</strong> routine (although creating user-address-space mappings is allowed). If it is not known whether a locked-down <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> already has a system-address-space mapping, a driver can use the <a href="mmgetsystemaddressformdlsafe" title="PVOID MmGetSystemAddressForMdlSafe(&#10;  [in] PMDL  Mdl,&#10;  [in] ULONG Priority&#10;);">MmGetSystemAddressForMdlSafe</a> macro instead of <strong>MmMapLockedPagesSpecifyCache</strong>. If the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is already mapped into the system address space, <strong><a href="mmgetsystemaddressformdlsafe" title="PVOID MmGetSystemAddressForMdlSafe(&#10;  [in] PMDL  Mdl,&#10;  [in] ULONG Priority&#10;);">MmGetSystemAddressForMdlSafe</a></strong> will return the existing system-address-space mapping instead of creating a new mapping.</p>

<blockquote>
  <p>[!WARNING]
  A driver that maps kernel memory into user address space must avoid exposing potentially sensitive kernel data to untrusted processes. Uninitialized buffers, such as buffers that are allocated from pool, must be explicitly filled with zeros before they are mapped. In addition, the size of a user-mode buffer that is allocated from pool must be a multiple of the virtual memory page size to prevent any part of the pages in the buffer from being used for other allocations. Finally, buffers must not be freed back to the pool while they are still mapped to user address space.</p>
</blockquote>

<p>If <em>AccessMode</em> is <strong>UserMode</strong>, the caller must be running at IRQL &lt;= APC_LEVEL. If <em>AccessMode</em> is <strong>KernelMode</strong>, the caller must be running at IRQL &lt;= DISPATCH_LEVEL.</p>

<h2 id="see-also">See also</h2>

<p><a href="mmallocatepagesformdl" title="PMDL MmAllocatePagesForMdl(&#10;  [in] PHYSICAL_ADDRESS LowAddress,&#10;  [in] PHYSICAL_ADDRESS HighAddress,&#10;  [in] PHYSICAL_ADDRESS SkipBytes,&#10;  [in] SIZE_T           TotalBytes&#10;);">MmAllocatePagesForMdl</a></p>

<p><a href="mmallocatepagesformdlex" title="PMDL MmAllocatePagesForMdlEx(&#10;  [in] PHYSICAL_ADDRESS    LowAddress,&#10;  [in] PHYSICAL_ADDRESS    HighAddress,&#10;  [in] PHYSICAL_ADDRESS    SkipBytes,&#10;  [in] SIZE_T              TotalBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType,&#10;  [in] ULONG               Flags&#10;);">MmAllocatePagesForMdlEx</a></p>

<p><a href="mmbuildmdlfornonpagedpool" title="VOID MmBuildMdlForNonPagedPool(&#10;  [in, out] PMDL MemoryDescriptorList&#10;);">MmBuildMdlForNonPagedPool</a></p>

<p><a href="mmgetsystemaddressformdlsafe" title="PVOID MmGetSystemAddressForMdlSafe(&#10;  [in] PMDL  Mdl,&#10;  [in] ULONG Priority&#10;);">MmGetSystemAddressForMdlSafe</a></p>

<p><a href="mmprobeandlockpages" title="VOID MmProbeAndLockPages(&#10;  [in, out] PMDL            MemoryDescriptorList,&#10;  [in]      KPROCESSOR_MODE AccessMode,&#10;  [in]      LOCK_OPERATION  Operation&#10;);">MmProbeAndLockPages</a></p>

<p><a href="mmunmaplockedpages" title="VOID MmUnmapLockedPages(&#10;  [in] PVOID BaseAddress,&#10;  [in] PMDL  MemoryDescriptorList&#10;);">MmUnmapLockedPages</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmmaplockedpagesspecifycache">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-mmmaplockedpagesspecifycache.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
