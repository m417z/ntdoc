<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="USBD_PIPE_INFORMATION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>USBD_PIPE_INFORMATION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            USBD_PIPE_INFORMATION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// usb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _USBD_PIPE_INFORMATION {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>           MaximumPacketSize;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            EndpointAddress;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>            Interval;
  <a href="usbd_pipe_type" title="typedef enum _USBD_PIPE_TYPE {&#10;  UsbdPipeTypeControl,&#10;  UsbdPipeTypeIsochronous,&#10;  UsbdPipeTypeBulk,&#10;  UsbdPipeTypeInterrupt&#10;} USBD_PIPE_TYPE;">USBD_PIPE_TYPE</a>   PipeType;
  USBD_PIPE_HANDLE PipeHandle;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            MaximumTransferSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            PipeFlags;
} USBD_PIPE_INFORMATION, *PUSBD_PIPE_INFORMATION;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usb/ns-usb-_usbd_pipe_information">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/usbd_pipe_information.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-usb-_usbd_pipe_information)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>_USBD_PIPE_INFORMATION structure</h1>
<h2>Description</h2>
<p>The <strong>USBD_PIPE_INFORMATION</strong> structure is used by USB client drivers to hold information about a pipe from a specific interface.</p>
<h2>Members</h2>
<h3><code>MaximumPacketSize</code></h3>
<p>Specifies the maximum packet size, in bytes, that this pipe handles. This value must be less than or equal to the value of <strong>wMaxPacketSize</strong> in the endpoint descriptor. The USB stack ignores this value if the USBD_PF_CHANGE_MAX_PACKET flag is not set in the <strong>PipeFlags</strong> member.</p>
<p>For high-speed isochronous endpoints, the received <strong>MaximumPacketSize</strong> value includes the number of bytes that can be transferred in additional transactions, if the endpoint supports them. For more information, see Remarks.</p>
<h3><code>EndpointAddress</code></h3>
<p>Specifies the bus address for this pipe.</p>
<h3><code>Interval</code></h3>
<p>Contains the polling interval, indicated by the <strong>bInterval</strong> field in the corresponding endpoint descriptor (<a href="usb_endpoint_descriptor" title="typedef struct _USB_ENDPOINT_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  UCHAR  bEndpointAddress;&#10;  UCHAR  bmAttributes;&#10;  USHORT wMaxPacketSize;&#10;  UCHAR  bInterval;&#10;} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;">USB_ENDPOINT_DESCRIPTOR</a>). This value is only valid for interrupt and isochronous pipes. For other types of pipe, this value should be ignored. It reflects the device's configuration in firmware. Drivers cannot change it.</p>
<p>The polling interval, together with the speed of the device and the type of host controller, determine the frequency with which the driver should initiate a transfer. The value in <strong>Interval</strong> does not represent a fixed amount of time. It is a relative value, and the actual polling frequency will also depend on whether the device and the USB host controller operate at low, full or high speed.</p>
<p>If either the host controller or the device operates at low speed, the period of time between transfers (also known as the "polling period") is measured in units of 1 millisecond frames, and the period is related to the value in <strong>Interval</strong> as indicated the following table:</p>
<table>
<thead>
<tr>
  <th>Interval</th>
  <th>Polling Period (1-millisecond frames)</th>
  <th>Interrupt</th>
  <th>Isochronous</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0 to 15</td>
  <td>8</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>16 to 35</td>
  <td>16</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>36 to 255</td>
  <td>32</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
</tbody>
</table>
<p>For devices and host controllers that can operate at full speed, the period is measured in units of 1 millisecond frames. For full-speed isochronous transfers, the <strong>Interval</strong> value and the polling period is always 1. That value indicates that data can be transferred in every frame. For full-speed interrupt transfers, the polling period is derived from the <strong>Interval</strong> value. The following table indicates the supported values for interrupt and isochronous endpoints.</p>
<table>
<thead>
<tr>
  <th>Interval</th>
  <th>Polling Period (1-millisecond frames)</th>
  <th>Interrupt</th>
  <th>Isochronous</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>1</td>
  <td>Supported.</td>
  <td>Supported.</td>
</tr>
<tr>
  <td>2 to 3</td>
  <td>2</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>4 to 7</td>
  <td>4</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>8 to 15</td>
  <td>8</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>16 to 31</td>
  <td>16</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>32 to 255</td>
  <td>32</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
</tbody>
</table>
<p>For devices and host controllers that can operate at high speed, the period is measured in units of microframes. The polling period is derived from the <strong>Interval</strong> value by using the formula <code>Polling period = 2 ** (Interval - 1)</code>. The calculated values are indicated in the following table:</p>
<table>
<thead>
<tr>
  <th>Interval</th>
  <th>Polling Period (microframes)</th>
  <th>Interrupt</th>
  <th>Isochronous</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>1</td>
  <td>Supported.</td>
  <td>Supported.</td>
</tr>
<tr>
  <td>2</td>
  <td>2</td>
  <td>Supported.</td>
  <td>Supported.</td>
</tr>
<tr>
  <td>3</td>
  <td>4</td>
  <td>Supported.</td>
  <td>Supported.</td>
</tr>
<tr>
  <td>4</td>
  <td>8</td>
  <td>Supported.</td>
  <td>Supported.</td>
</tr>
<tr>
  <td>5</td>
  <td>16</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
<tr>
  <td>6 to 255</td>
  <td>32</td>
  <td>Supported.</td>
  <td>Not supported.</td>
</tr>
</tbody>
</table>
<p>The supported polling periods for high-speed isochronous transfers are 1, 2, 4, and 8. If a client driver submits a URB_FUNCTION_ISOCH_TRANSFER request for a high speed isochronous endpoint with polling period greater than 8, the request fails with status USBD_STATUS_INVALID_PARAMETER. For information about isochronous transfers, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Transfer Data to USB Isochronous Endpoints</a>.</p>
<p>The mappings in the preceding tables between periods and polling intervals are valid in Microsoft Windows 2000 and later versions of the Windows operating system.</p>
<h3><code>PipeType</code></h3>
<p>Specifies what type of transfers this pipe uses. These values are defined in the <a href="usbd_pipe_type" title="typedef enum _USBD_PIPE_TYPE {&#10;  UsbdPipeTypeControl,&#10;  UsbdPipeTypeIsochronous,&#10;  UsbdPipeTypeBulk,&#10;  UsbdPipeTypeInterrupt&#10;} USBD_PIPE_TYPE;">USBD_PIPE_TYPE</a> enumeration.</p>
<h3><code>PipeHandle</code></h3>
<p>Specifies an opaque handle to the bulk or interrupt pipe. The host controller driver returns this handle when the client driver selects the device configuration with a <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> of type URB_FUNCTION_SELECT_CONFIGURATION or when the client driver changes the settings for an interface with a <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> of type URB_FUNCTION_SELECT_INTERFACE.</p>
<h3><code>MaximumTransferSize</code></h3>
<p>Specifies the maximum size, in bytes, for a transfer request on this pipe. In Windows Server 2003, Windows XP and later operating systems, this member is not used and does not contain valid data.</p>
<p>For information about the maximum transfer sizes of each type of USB endpoint in different versions of Windows, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">USB Transfer and Packet Sizes</a>.</p>
<p><strong>Note</strong> For WinUSB, do not use <strong>MaximumTransferSize</strong> to determine the maximum size of a USB transfer. Instead, use the MAXIMUM_TRANSFER_SIZE value retrieved by <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winusb/nf-winusb-winusb_getpipepolicy">WinUsb_GetPipePolicy</a>.</p>
<h3><code>PipeFlags</code></h3>
<p>Contains a bitwise-OR of pipe flags that the driver can use to specify certain configurable characteristics of the pipe. The driver specifies these pipe characteristics when it selects the configuration of a USB device with a <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a> request whose function type is URB_FUNCTION_SELECT_CONFIGURATION.</p>
<p>The following table explains the meaning of each pipe flag:</p>
<table>
<thead>
<tr>
  <th>Flag name</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>USBD_PF_CHANGE_MAX_PACKET</td>
  <td>Indicates that the driver is overriding the endpoint maximum packet size with the value specified in <strong>MaximumPacketSize</strong>. This value must be less than or equal to the default maximum specified in the pipe's endpoint descriptor.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>This structure contains information for an endpoint, retrieved from the device's interface descriptor. For an explanation of how to obtain the information in <strong>USBD_PIPE_INFORMATION</strong> from the interface descriptor, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/">How to Select a Configuration for a USB Device</a>.</p>
<p>The <strong>MaximumPacketSize</strong> value is derived from the first <strong>11</strong> bits of the <strong>wMaxPacketSize</strong> field of the endpoint descriptor, which indicates the maximum number of bytes that the host controller can send to or receive from the endpoint in a single transaction.</p>
<p>Typically, for high-speed transfers, the host controller sends or receives one transaction per microframe. However, high speed, high bandwidth isochronous or interrupt endpoints support higher data rates through additional transactions. This allows the host controller to transfer up to 3072 bytes in a single microframe. The number of additional transactions supported by that type of endpoint is indicated by bits <strong>12..11</strong> of <strong>wMaxPacketSize</strong> (least significant bit is 0). That number can be 0, 1, or 2. If <strong>12..11</strong> indicate 0, additional transactions per microframe are not supported by the endpoint. If the number is 1, then the host controller can send an additional transaction (total of two transactions per microframe); 2 indicates two additional transactions (total of three transactions per microframe).</p>
<p>The value received in <strong>MaximumPacketSize</strong> for an isochronous endpoint (high-speed and high-bandwidth) indicates the total number of bytes that the host controller can send to or receive from the endpoint in one microframe. The value includes the number of bytes in additional transactions, if the endpoint supports them. For example, consider the following isochronous endpoint characteristics:</p>
<ul>
<li><strong>wMaxPacketSize</strong> is 1,024</li>
<li>Bits <strong>12..11</strong> indicate 2</li>
<li><strong>Interval</strong> is 1.</li>
</ul>
<p>In the preceding example, the value received in <strong>MaximumPacketSize</strong> is 3,072 bytes (Total transactions * <strong>wMaxPacketSize</strong>). Because <strong>Interval</strong> is 1, the polling period is 1. Thus, the host controller can transfer 3,072 bytes in each microframe of a frame. In a single I/O request (described in one <a href="urb" title="typedef struct _URB {&#10;  union {&#10;#if ...&#10;    _URB_HEADER                                     UrbHeader;&#10;#else&#10;    struct _URB_HEADER                              UrbHeader;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_INTERFACE                           UrbSelectInterface;&#10;#else&#10;    struct _URB_SELECT_INTERFACE                    UrbSelectInterface;&#10;#endif&#10;#if ...&#10;    _URB_SELECT_CONFIGURATION                       UrbSelectConfiguration;&#10;#else&#10;    struct _URB_SELECT_CONFIGURATION                UrbSelectConfiguration;&#10;#endif&#10;#if ...&#10;    _URB_PIPE_REQUEST                               UrbPipeRequest;&#10;#else&#10;...">URB</a>), the host controller can transfer no more than 24,576 bytes.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_usbref/#structures">USB Structures</a></p>
<p><a href="usb_endpoint_descriptor" title="typedef struct _USB_ENDPOINT_DESCRIPTOR {&#10;  UCHAR  bLength;&#10;  UCHAR  bDescriptorType;&#10;  UCHAR  bEndpointAddress;&#10;  UCHAR  bmAttributes;&#10;  USHORT wMaxPacketSize;&#10;  UCHAR  bInterval;&#10;} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;">USB_ENDPOINT_DESCRIPTOR</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/usb/ns-usb-_usbd_pipe_information">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/usb/ns-usb-_usbd_pipe_information.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
