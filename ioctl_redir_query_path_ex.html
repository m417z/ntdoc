<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IOCTL_REDIR_QUERY_PATH_EX - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IOCTL_REDIR_QUERY_PATH_EX - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IOCTL_REDIR_QUERY_PATH_EX - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0014, 0x064, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_REDIR_QUERY_PATH_EX 0x00140193</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ni-ntifs-ioctl_redir_query_path_ex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ioctl_redir_query_path_ex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ni-ntifs-ioctl_redir_query_path_ex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>IOCTL_REDIR_QUERY_PATH_EX IOCTL</h1>
<h2>Description</h2>
<p>Starting in Windows Vista, the multiple UNC provider (MUP) sends an <strong>IOCTL_REDIR_QUERY_PATH_EX</strong> control code to network redirectors to determine which provider can handle a specific UNC path in a name-based operation, typically an <a href="irp_mj_create" title="#define IRP_MJ_CREATE 0x00">IRP_MJ_CREATE</a> request. This request is referred to as &quot;prefix resolution.&quot;</p>
<p>MUP is a kernel-mode component responsible for channeling all remote file system accesses using a UNC name to a network redirector (the UNC provider) that is capable of handling the remote file system requests. MUP is involved when a UNC path is used as illustrated by the following example that could be executed from a command line:</p>
<pre><code>notepad \\server\public\readme.txt
</code></pre>
<p>MUP is not involved during an operation that creates a mapped drive letter (the &quot;NET USE&quot; command, for example). This operation is handled by the multiple provider router (MPR) and a user-mode WNet provider DLL for the network redirector. However, a user-mode WNet provider DLL might communicate directly with a kernel-mode network redirector driver during this operation.</p>
<p>For network redirectors that conform to the Windows Vista redirector model, MUP is involved even when a mapped network drive is used. File operations performed on the mapped drive go through MUP to the network redirector. Note that in this case, MUP simply passes the operation to the network redirector that is involved.</p>
<p>The <strong>IOCTL_REDIR_QUERY_PATH_EX</strong> control code is sent to network redirectors that have registered with MUP as Universal Naming Convention (UNC) providers by calling <strong><a href="fsrtlregisteruncproviderex" title="NTSTATUS FsRtlRegisterUncProviderEx(&#10;  [out] PHANDLE                  MupHandle,&#10;  [in]  PCUNICODE_STRING         RedirDevName,&#10;  [in]  PDEVICE_OBJECT           DeviceObject,&#10;  [in]  FSRTL_UNC_PROVIDER_FLAGS Flags&#10;);">FsRtlRegisterUncProviderEx</a></strong>. There can be multiple UNC providers registered with MUP.</p>
<p>The prefix resolution operation serves two purposes:</p>
<ul>
<li>
<p>The name-based operation that resulted in the prefix resolution is routed to the provider that claims the prefix. If successful, MUP ensures that subsequent handle-based operations (<a href="irp_mj_read" title="#define IRP_MJ_READ 0x03">IRP_MJ_READ</a> and <a href="irp_mj_write" title="#define IRP_MJ_WRITE 0x04">IRP_MJ_WRITE</a>, for example) go through MUP to the same provider. Note that this behavior is different for network redirectors that are not in conformance with the Windows Vista redirector model, which will be sent <a href="ioctl_redir_query_path" title="// CTL_CODE(0x0014, 0x063, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define IOCTL_REDIR_QUERY_PATH 0x0014018F">IOCTL_REDIR_QUERY_PATH</a> for prefix resolution. For network redirectors that don't conform with the Windows Vista redirector model, MUP is completely bypassed for subsequent handle-based operations.</p>
</li>
<li>
<p>The provider and the prefix that it claimed are entered in a prefix cache maintained by MUP. For subsequent name-based operations, MUP uses this prefix cache to determine whether a provider has already claimed a prefix before MUP attempts to perform a prefix resolution. Each entry in this prefix cache is subject to a timeout (referred to as TTL) once it is added to the cache. An entry is thrown away after this timeout expires, at which point MUP will perform prefix resolution again for this prefix on a subsequent name-based operation.</p>
</li>
</ul>
<h2>Parameters</h2>
<h3>Major code</h3>
<p>IOCTL_REDIR_QUERY_PATH_EX</p>
<h3>Input buffer</h3>
<p><strong>IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer</strong> is set to a <strong><a href="query_path_request_ex" title="typedef struct _QUERY_PATH_REQUEST_EX {&#10;  PIO_SECURITY_CONTEXT pSecurityContext;&#10;  ULONG                EaLength;&#10;  PVOID                pEaBuffer;&#10;  UNICODE_STRING       PathName;&#10;  UNICODE_STRING       DomainServiceName;&#10;  PECP_LIST            EcpList;&#10;  PESILO               Silo;&#10;#if ...&#10;  ULONG_PTR            Reserved;&#10;#else&#10;  ULONG_PTR            Reserved[2];&#10;#endif&#10;} QUERY_PATH_REQUEST_EX, *PQUERY_PATH_REQUEST_EX;">QUERY_PATH_REQUEST_EX</a></strong> data structure that contains the request.</p>
<h3>Input buffer length</h3>
<p>Size of the <strong><a href="query_path_request_ex" title="typedef struct _QUERY_PATH_REQUEST_EX {&#10;  PIO_SECURITY_CONTEXT pSecurityContext;&#10;  ULONG                EaLength;&#10;  PVOID                pEaBuffer;&#10;  UNICODE_STRING       PathName;&#10;  UNICODE_STRING       DomainServiceName;&#10;  PECP_LIST            EcpList;&#10;  PESILO               Silo;&#10;#if ...&#10;  ULONG_PTR            Reserved;&#10;#else&#10;  ULONG_PTR            Reserved[2];&#10;#endif&#10;} QUERY_PATH_REQUEST_EX, *PQUERY_PATH_REQUEST_EX;">QUERY_PATH_REQUEST_EX</a></strong> structure that the input buffer points to, in bytes.</p>
<h3>Output buffer</h3>
<p><strong><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>-&gt;UserBuffer</strong> is set to a <strong><a href="query_path_response" title="typedef struct _QUERY_PATH_RESPONSE {&#10;  ULONG LengthAccepted;&#10;} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;">QUERY_PATH_RESPONSE</a></strong> data structure that contains the response.</p>
<h3>Output buffer length</h3>
<p>Size of the <strong><a href="query_path_response" title="typedef struct _QUERY_PATH_RESPONSE {&#10;  ULONG LengthAccepted;&#10;} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;">QUERY_PATH_RESPONSE</a></strong> structure that the output buffer points to, in bytes.</p>
<h3>Input/output buffer</h3>
<p>n/a</p>
<h3>Input/output buffer length</h3>
<p>n/a</p>
<h3>Status block</h3>
<p>The <strong>Status</strong> member is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> on success if the \\server\share prefix name is recognized, or to an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value, such as one of the following:</p>
<table>
<thead>
<tr>
<th>Status code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_BAD_NETWORK_NAME</td>
<td>The specified share name cannot be found on the remote server. The machine name (\\server, for example) is valid, but the specified share name cannot be found on the remote server.</td>
</tr>
<tr>
<td>STATUS_BAD_NETWORK_PATH</td>
<td>The network path cannot be located. The machine name (\\server, for example) is not valid or the network redirector cannot resolve the machine name (using whatever name resolution mechanisms are available).</td>
</tr>
<tr>
<td>STATUS_INSUFFICIENT_RESOURCES</td>
<td>There were insufficient resources available to allocate memory for buffers.</td>
</tr>
<tr>
<td>STATUS_INVALID_DEVICE_REQUEST</td>
<td>An IOCTL_REDIR_QUERY_PATH_EX request should only come from MUP and the <strong>RequestorMode</strong> member of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> structure should always be <strong>KernelMode</strong>. This error code is returned if the requester mode of the calling thread was not <strong>KernelMode</strong>.</td>
</tr>
<tr>
<td>STATUS_INVALID_PARAMETER</td>
<td>The <strong>PathNameLength</strong> member in the <strong><a href="query_path_request" title="typedef struct _QUERY_PATH_REQUEST {&#10;  ULONG                PathNameLength;&#10;  PIO_SECURITY_CONTEXT SecurityContext;&#10;  WCHAR                FilePathName[1];&#10;} QUERY_PATH_REQUEST, *PQUERY_PATH_REQUEST;">QUERY_PATH_REQUEST</a></strong> structure exceeds the maximum allowable length, UNICODE_STRING_MAX_BYTES, for a Unicode string.</td>
</tr>
<tr>
<td>STATUS_LOGON_FAILURE or STATUS_ACCESS_DENIED</td>
<td>If the prefix resolution operation failed due to invalid or incorrect credentials, the provider should return the exact error code returned by the remote server; these error codes must not be translated to STATUS_BAD_NETWORK_NAME or STATUS_BAD_NETWORK_PATH. Error codes like STATUS_LOGON_FAILURE and STATUS_ACCESS_DENIED serve as a feedback mechanism to the user and indicate the requirement to use appropriate credentials. These error codes are also used in certain cases to prompt the user automatically for credentials. Without these error codes, the user might assume that the machine is not accessible.</td>
</tr>
</tbody>
</table>
<p>If the network redirector is unable to resolve a prefix, it must return an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code that closely matches the intended semantics from the above list of recommended <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes. A network redirector must not return the actual encountered error (STATUS_CONNECTION_REFUSED, for example) directly to MUP if the <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code is not from the above list.</p>
<h2>Remarks</h2>
<p>Network redirectors should only honor kernel-mode senders of this IOCTL, by verifying that <strong>Irp-&gt;RequestorMode</strong> is <strong>KernelMode</strong>.</p>
<p>Note that IOCTL_REDIR_QUERY_PATH_EX is a METHOD_NEITHER IOCTL. This means that the input and output buffers might not be at the same address. A common mistake by UNC providers is to assume that the input buffer and the output buffer are the same and use the input buffer pointer to provide the response.</p>
<p>When a UNC provider receives an IOCTL_REDIR_QUERY_PATH_EX request, it has to determine whether it can handle the UNC path that is specified in the <strong>PathName</strong> member of the <strong><a href="query_path_request_ex" title="typedef struct _QUERY_PATH_REQUEST_EX {&#10;  PIO_SECURITY_CONTEXT pSecurityContext;&#10;  ULONG                EaLength;&#10;  PVOID                pEaBuffer;&#10;  UNICODE_STRING       PathName;&#10;  UNICODE_STRING       DomainServiceName;&#10;  PECP_LIST            EcpList;&#10;  PESILO               Silo;&#10;#if ...&#10;  ULONG_PTR            Reserved;&#10;#else&#10;  ULONG_PTR            Reserved[2];&#10;#endif&#10;} QUERY_PATH_REQUEST_EX, *PQUERY_PATH_REQUEST_EX;">QUERY_PATH_REQUEST_EX</a></strong> structure. If so, the UNC provider has to update the <strong>LengthAccepted</strong> member of the <strong><a href="query_path_response" title="typedef struct _QUERY_PATH_RESPONSE {&#10;  ULONG LengthAccepted;&#10;} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;">QUERY_PATH_RESPONSE</a></strong> structure with the length, in bytes, of the prefix it has claimed and complete the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> with <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>. If the provider cannot handle the UNC path specified, it must fail the IOCTL_REDIR_QUERY_PATH_EX request with an appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code and must not update the <strong>LengthAccepted</strong> member of the <strong><a href="query_path_response" title="typedef struct _QUERY_PATH_RESPONSE {&#10;  ULONG LengthAccepted;&#10;} QUERY_PATH_RESPONSE, *PQUERY_PATH_RESPONSE;">QUERY_PATH_RESPONSE</a></strong> structure. Providers must not modify any other members or the <strong>PathName</strong> member under any condition.</p>
<p>The length of the prefix claimed by the provider depends on an individual UNC provider. Most providers usually claim the \\<em>servername</em>\<em>sharename</em> part of a path of the form \\<em>servername</em>\<em>sharename</em>\<em>path</em>. For example, if a provider claimed \\<em>server</em>\<em>public</em> given a path \\<em>server</em>\<em>public</em>\<em>dir1</em>\<em>dir2</em>, all name-based operations for the prefix \\<em>server</em>\<em>public</em> (\\<em>server</em>\<em>public</em>\<em>file1</em>, for example) will be routed to that provider automatically without any prefix resolution because the prefix is already in the prefix cache. However, a path with the prefix \\<em>server</em>\<em>marketing</em>\<em>presentation</em> will go through prefix resolution.</p>
<p>If a network redirector claims a server name (\\<em>server</em>, for example), all requests for shares on this server will go to this network redirector. This behavior is only acceptable if there is no possibility of another share on the same server being accessed by a different network redirector. For example, a network redirector that claims \\<em>server</em> of a UNC path will prevent access by other network redirectors to other shares on this server (WebDAV access to \\<em>server</em>\<em>web</em>, for example).</p>
<p>For more information, see the following sections in the Design Guide:</p>
<ul>
<li>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/support-for-unc-naming-and-mup">Support for UNC Naming and MUP</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/windows-hardware/drivers/ifs/mup-changes-in-microsoft-windows-vista">MUP Changes in Microsoft Windows Vista</a></p>
</li>
</ul>
<h2>See also</h2>
<p><strong><a href="fsrtlderegisteruncprovider" title="VOID FsRtlDeregisterUncProvider(&#10;  [in] HANDLE Handle&#10;);">FsRtlDeregisterUncProvider</a></strong></p>
<p><strong><a href="fsrtlregisteruncprovider" title="NTSTATUS FsRtlRegisterUncProvider(&#10;  [out] PHANDLE          MupHandle,&#10;        PCUNICODE_STRING RedirectorDeviceName,&#10;  [in]  BOOLEAN          MailslotsSupported&#10;);">FsRtlRegisterUncProvider</a></strong></p>
<p><strong><a href="fsrtlregisteruncproviderex" title="NTSTATUS FsRtlRegisterUncProviderEx(&#10;  [out] PHANDLE                  MupHandle,&#10;  [in]  PCUNICODE_STRING         RedirDevName,&#10;  [in]  PDEVICE_OBJECT           DeviceObject,&#10;  [in]  FSRTL_UNC_PROVIDER_FLAGS Flags&#10;);">FsRtlRegisterUncProviderEx</a></strong></p>
<p><strong><a href="ioctl_redir_query_path" title="// CTL_CODE(0x0014, 0x063, METHOD_NEITHER, FILE_ANY_ACCESS)&#10;#define IOCTL_REDIR_QUERY_PATH 0x0014018F">IOCTL_REDIR_QUERY_PATH</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/ni-ntifs-ioctl_redir_query_path_ex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/ni-ntifs-ioctl_redir_query_path_ex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
