<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="DXGKARG_BUILDPAGINGBUFFER - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>DXGKARG_BUILDPAGINGBUFFER - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            DXGKARG_BUILDPAGINGBUFFER - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dkmddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _DXGKARG_BUILDPAGINGBUFFER {
  VOID                             *pDmaBuffer;
  <a href="uint" title="typedef unsigned int UINT;">UINT</a>                             DmaSize;
  VOID                             *pDmaBufferPrivateData;
  <a href="uint" title="typedef unsigned int UINT;">UINT</a>                             DmaBufferPrivateDataSize;
  <a href="dxgk_buildpagingbuffer_operation" title="typedef enum _DXGK_BUILDPAGINGBUFFER_OPERATION {&#10;  DXGK_OPERATION_TRANSFER = 0,&#10;  DXGK_OPERATION_FILL = 1,&#10;  DXGK_OPERATION_DISCARD_CONTENT = 2,&#10;  DXGK_OPERATION_READ_PHYSICAL = 3,&#10;  DXGK_OPERATION_WRITE_PHYSICAL = 4,&#10;  DXGK_OPERATION_MAP_APERTURE_SEGMENT = 5,&#10;  DXGK_OPERATION_UNMAP_APERTURE_SEGMENT = 6,&#10;  DXGK_OPERATION_SPECIAL_LOCK_TRANSFER = 7,&#10;  DXGK_OPERATION_VIRTUAL_TRANSFER = 8,&#10;  DXGK_OPERATION_VIRTUAL_FILL = 9,&#10;  DXGK_OPERATION_INIT_CONTEXT_RESOURCE = 10,&#10;  DXGK_OPERATION_UPDATE_PAGE_TABLE = 11,&#10;  DXGK_OPERATION_FLUSH_TLB = 12,&#10;  DXGK_OPERATION_UPDATE_CONTEXT_ALLOCATION = 13,&#10;  DXGK_OPERATION_COPY_PAGE_TABLE_ENTRIES = 14,&#10;  DXGK_OPERATION_NOTIFY_RESIDENCY = 15,&#10;  DXGK_OPERATION_SIGNAL_MONITORED_FENCE = 16,&#10;  DXGK_OPERATION_MAP_APERTURE_SEGMENT2 = 17,&#10;  DXGK_OPERATION_NOTIFY_FENCE_RESIDENCY = 18,&#10;...">DXGK_BUILDPAGINGBUFFER_OPERATION</a> Operation;
  <a href="uint" title="typedef unsigned int UINT;">UINT</a>                             MultipassOffset;
  union {
    struct {
      HANDLE             hAllocation;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>               TransferOffset;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>             TransferSize;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a> SegmentId;
        union {
          LARGE_INTEGER SegmentAddress;
          <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>           *pMdl;
        };
      } Source;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a> SegmentId;
        union {
          LARGE_INTEGER SegmentAddress;
          <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>           *pMdl;
        };
      } Destination;
      <a href="dxgk_transferflags" title="typedef struct _DXGK_TRANSFERFLAGS {&#10;  union {&#10;    struct {&#10;      UINT Swizzle : 1;&#10;      UINT Unswizzle : 1;&#10;      UINT AllocationIsIdle : 1;&#10;      UINT TransferStart : 1;&#10;      UINT TransferEnd : 1;&#10;      UINT Reserved : 27;&#10;    };&#10;    [in] UINT Value;&#10;  };&#10;} DXGK_TRANSFERFLAGS;">DXGK_TRANSFERFLAGS</a> Flags;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>               MdlOffset;
    } Transfer;
    struct {
      HANDLE hAllocation;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a> FillSize;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>   FillPattern;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a>          SegmentId;
        LARGE_INTEGER SegmentAddress;
      } Destination;
    } Fill;
    struct {
      HANDLE                   hAllocation;
      <a href="dxgk_discardcontentflags" title="typedef struct _DXGK_DISCARDCONTENTFLAGS {&#10;  union {&#10;    struct {&#10;      UINT AllocationIsIdle : 1;&#10;      UINT Reserved : 31;&#10;    };&#10;    [in] UINT Value;&#10;  };&#10;} DXGK_DISCARDCONTENTFLAGS;">DXGK_DISCARDCONTENTFLAGS</a> Flags;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                     SegmentId;
      <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>         SegmentAddress;
    } DiscardContent;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>             SegmentId;
      <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> PhysicalAddress;
    } <a href="readphysical" title="VOID ReadPhysical(&#10;  ULONG64 address,&#10;  PVOID   buf,&#10;  ULONG   size,&#10;  PULONG  sizer&#10;);">ReadPhysical</a>;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>             SegmentId;
      <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> PhysicalAddress;
    } <a href="writephysical" title="VOID WritePhysical(&#10;  [in]            ULONG64 address,&#10;  [in]            PVOID   buf,&#10;  [in]            ULONG   size,&#10;  [out, optional] PULONG  sizew&#10;);">WritePhysical</a>;
    struct {
      HANDLE                hDevice;
      HANDLE                hAllocation;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                  SegmentId;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>                OffsetInPages;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>                NumberOfPages;
      <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a>                  pMdl;
      <a href="dxgk_mapapertureflags" title="typedef struct _DXGK_MAPAPERTUREFLAGS {&#10;  union {&#10;    struct {&#10;      UINT CacheCoherent : 1;&#10;      UINT Reserved : 31;&#10;    };&#10;    [in] UINT Value;&#10;  };&#10;} DXGK_MAPAPERTUREFLAGS;">DXGK_MAPAPERTUREFLAGS</a> Flags;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                 MdlOffset;
    } MapApertureSegment;
    struct {
      HANDLE           hDevice;
      HANDLE           hAllocation;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>             SegmentId;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>           OffsetInPages;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>           NumberOfPages;
      <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> DummyPage;
    } UnmapApertureSegment;
    struct {
      HANDLE             hAllocation;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>               TransferOffset;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>             TransferSize;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a> SegmentId;
        union {
          LARGE_INTEGER SegmentAddress;
          <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>           *pMdl;
        };
      } Source;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a> SegmentId;
        union {
          LARGE_INTEGER SegmentAddress;
          <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>           *pMdl;
        };
      } Destination;
      <a href="dxgk_transferflags" title="typedef struct _DXGK_TRANSFERFLAGS {&#10;  union {&#10;    struct {&#10;      UINT Swizzle : 1;&#10;      UINT Unswizzle : 1;&#10;      UINT AllocationIsIdle : 1;&#10;      UINT TransferStart : 1;&#10;      UINT TransferEnd : 1;&#10;      UINT Reserved : 27;&#10;    };&#10;    [in] UINT Value;&#10;  };&#10;} DXGK_TRANSFERFLAGS;">DXGK_TRANSFERFLAGS</a> Flags;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>               SwizzlingRangeId;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>               SwizzlingRangeData;
    } SpecialLockTransfer;
    struct {
      HANDLE hAllocation;
      struct {
        <a href="uint" title="typedef unsigned int UINT;">UINT</a>                   SegmentId;
        union {
          LARGE_INTEGER SegmentAddress;
          <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>           *pMdl;
        };
        PVOID                  VirtualAddress;
        D3DGPU_VIRTUAL_ADDRESS GpuVirtualAddress;
      } Destination;
    } InitContextResource;
    <a href="dxgk_buildpagingbuffer_transfervirtual" title="typedef struct _DXGK_BUILDPAGINGBUFFER_TRANSFERVIRTUAL {&#10;  HANDLE                         hAllocation;&#10;  UINT64                         AllocationOffsetInBytes;&#10;  UINT64                         TransferSizeInBytes;&#10;  D3DGPU_VIRTUAL_ADDRESS         SourceVirtualAddress;&#10;  D3DGPU_VIRTUAL_ADDRESS         DestinationVirtualAddress;&#10;  D3DGPU_VIRTUAL_ADDRESS         SourcePageTable;&#10;  DXGK_MEMORY_TRANSFER_DIRECTION TransferDirection;&#10;  DXGK_TRANSFERVIRTUALFLAGS      Flags;&#10;  D3DGPU_VIRTUAL_ADDRESS         DestinationPageTable;&#10;} DXGK_BUILDPAGINGBUFFER_TRANSFERVIRTUAL;">DXGK_BUILDPAGINGBUFFER_TRANSFERVIRTUAL</a>         TransferVirtual;
    <a href="dxgk_buildpagingbuffer_fillvirtual" title="typedef struct _DXGK_BUILDPAGINGBUFFER_FILLVIRTUAL {&#10;  HANDLE                 hAllocation;&#10;  UINT64                 AllocationOffsetInBytes;&#10;  UINT64                 FillSizeInBytes;&#10;  UINT                   FillPattern;&#10;  D3DGPU_VIRTUAL_ADDRESS DestinationVirtualAddress;&#10;} DXGK_BUILDPAGINGBUFFER_FILLVIRTUAL;">DXGK_BUILDPAGINGBUFFER_FILLVIRTUAL</a>             FillVirtual;
    <a href="dxgk_buildpagingbuffer_updatepagetable" title="typedef struct _DXGK_BUILDPAGINGBUFFER_UPDATEPAGETABLE {&#10;  UINT                        PageTableLevel;&#10;  HANDLE                      hAllocation;&#10;  DXGK_PAGETABLEUPDATEADDRESS PageTableAddress;&#10;  DXGK_PTE                    *pPageTableEntries;&#10;  UINT                        StartIndex;&#10;  UINT                        NumPageTableEntries;&#10;  UINT                        Reserved0;&#10;  DXGK_UPDATEPAGETABLEFLAGS   Flags;&#10;  UINT64                      DriverProtection;&#10;  UINT64                      AllocationOffsetInBytes;&#10;  HANDLE                      hProcess;&#10;  DXGK_PAGETABLEUPDATEMODE    UpdateMode;&#10;  DXGK_PTE                    *pPageTableEntries64KB;&#10;  D3DGPU_VIRTUAL_ADDRESS      FirstPteVirtualAddress;&#10;} DXGK_BUILDPAGINGBUFFER_UPDATEPAGETABLE;">DXGK_BUILDPAGINGBUFFER_UPDATEPAGETABLE</a>         UpdatePageTable;
    <a href="dxgk_buildpagingbuffer_flushtlb" title="typedef struct _DXGK_BUILDPAGINGBUFFER_FLUSHTLB {&#10;  D3DGPU_PHYSICAL_ADDRESS RootPageTableAddress;&#10;  HANDLE                  hProcess;&#10;  D3DGPU_VIRTUAL_ADDRESS  StartVirtualAddress;&#10;  D3DGPU_VIRTUAL_ADDRESS  EndVirtualAddress;&#10;} DXGK_BUILDPAGINGBUFFER_FLUSHTLB;">DXGK_BUILDPAGINGBUFFER_FLUSHTLB</a>                FlushTlb;
    <a href="dxgk_buildpagingbuffer_copypagetableentries" title="typedef struct _DXGK_BUILDPAGINGBUFFER_COPYPAGETABLEENTRIES {&#10;  UINT                              NumRanges;&#10;  DXGK_BUILDPAGINGBUFFER_COPY_RANGE *pRanges;&#10;} DXGK_BUILDPAGINGBUFFER_COPYPAGETABLEENTRIES;">DXGK_BUILDPAGINGBUFFER_COPYPAGETABLEENTRIES</a>    CopyPageTableEntries;
    <a href="dxgk_buildpagingbuffer_updatecontextallocation" title="typedef struct _DXGK_BUILDPAGINGBUFFER_UPDATECONTEXTALLOCATION {&#10;  D3DGPU_VIRTUAL_ADDRESS ContextAllocation;&#10;  UINT64                 ContextAllocationSize;&#10;  PVOID                  pDriverPrivateData;&#10;  UINT                   DriverPrivateDataSize;&#10;} DXGK_BUILDPAGINGBUFFER_UPDATECONTEXTALLOCATION;">DXGK_BUILDPAGINGBUFFER_UPDATECONTEXTALLOCATION</a> UpdateContextAllocation;
    <a href="dxgk_buildpagingbuffer_notifyresidency" title="typedef struct _DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY {&#10;  HANDLE                  hAllocation;&#10;  D3DGPU_PHYSICAL_ADDRESS PhysicalAddress;&#10;  union {&#10;    UINT Resident : 1;&#10;    UINT Reserved : 31;&#10;  };&#10;} DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY;">DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY</a>         NotifyResidency;
    DXGK_BUILDPAGINGBUFFER_SIGNALMONITOREDFENCE    SignalMonitoredFence;
    struct {
      HANDLE                hDevice;
      HANDLE                hAllocation;
      <a href="uint" title="typedef unsigned int UINT;">UINT</a>                  SegmentId;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>                OffsetInPages;
      <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>                NumberOfPages;
      <a href="dxgk_adl" title="typedef struct _DXGK_ADL {&#10;  UINT32         PageCount;&#10;  DXGK_ADL_FLAGS Flags;&#10;  union {&#10;    DXGK_PAGE_NUMBER       BasePageNumber;&#10;    const DXGK_PAGE_NUMBER *Pages;&#10;  };&#10;} DXGK_ADL;">DXGK_ADL</a>              Adl;
      <a href="dxgk_mapapertureflags" title="typedef struct _DXGK_MAPAPERTUREFLAGS {&#10;  union {&#10;    struct {&#10;      UINT CacheCoherent : 1;&#10;      UINT Reserved : 31;&#10;    };&#10;    [in] UINT Value;&#10;  };&#10;} DXGK_MAPAPERTUREFLAGS;">DXGK_MAPAPERTUREFLAGS</a> Flags;
      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                 AdlOffset;
      PVOID                 CpuVisibleAddress;
    } MapApertureSegment2;
    DXGK_BUILDPAGINGBUFFER_NOTIFY_FENCE_RESIDENCY  NotifyFenceResidency;
    DXGK_BUILDPAGINGBUFFER_MAPMMU                  MmapMmu;
    DXGK_BUILDPAGINGBUFFER_UNMAPMMU                UnmapMmu;
    DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY2        NotifyResidency2;
    <a href="dxgk_buildpagingbuffer_notifyalloc" title="typedef struct _DXGK_BUILDPAGINGBUFFER_NOTIFYALLOC {&#10;  HANDLE                hAllocation;&#10;  HANDLE                hKmdProcessHandle;&#10;  DXGK_NOTIFYALLOCFLAGS Flags;&#10;  UINT64                OffsetInBytes;&#10;  UINT64                SizeInBytes;&#10;  UINT64                GpuVirtualAddressAtOffset;&#10;} DXGK_BUILDPAGINGBUFFER_NOTIFYALLOC;">DXGK_BUILDPAGINGBUFFER_NOTIFYALLOC</a>             NotifyAllocation;
    struct {
      <a href="uint" title="typedef unsigned int UINT;">UINT</a> Reserved[64];
    } Reserved;
  };
  HANDLE                           hSystemContext;
  D3DGPU_VIRTUAL_ADDRESS           DmaBufferGpuVirtualAddress;
  <a href="uint" title="typedef unsigned int UINT;">UINT</a>                             DmaBufferWriteOffset;
} DXGKARG_BUILDPAGINGBUFFER;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_buildpagingbuffer">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/dxgkarg_buildpagingbuffer.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-d3dkmddi-_dxgkarg_buildpagingbuffer)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="dxgkarg_buildpagingbuffer-structure">DXGKARG_BUILDPAGINGBUFFER structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>DXGKARG_BUILDPAGINGBUFFER</strong> structure describes parameters for the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer"><strong>DxgkDdiBuildPagingBuffer</strong></a> callback that builds a paging buffer for use in a memory-transfer operation.</p>

<h2 id="members">Members</h2>

<h3 id="pdmabuffer"><code>pDmaBuffer</code></h3>

<p>[in/out] A virtual address to the first available byte in the paging buffer. When the driver is first called with a new paging buffer, this virtual address is aligned on 4 KB. The driver tightly packs operations in the paging buffer until the paging buffer is full and then uses a new paging buffer. Therefore, if the graphics processing unit (GPU) requires a specific alignment for a paging-buffer submission, the driver should enforce this alignment by padding the operations that it writes to the paging buffer. Before the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer"><strong>DxgkDdiBuildPagingBuffer</strong></a> function returns, the driver should update <strong>pDmaBuffer</strong> to point past the last byte that is written to the paging buffer.</p>

<h3 id="dmasize"><code>DmaSize</code></h3>

<p>[in/out] The size, in bytes, of the paging buffer that <strong>pDmaBuffer</strong> specifies.</p>

<h3 id="pdmabufferprivatedata"><code>pDmaBufferPrivateData</code></h3>

<p>[in/out] A pointer to a driver-resident private data structure that is associated with the direct memory access (DMA) buffer (that is, paging buffer) that <strong>pDmaBuffer</strong> specifies.</p>

<h3 id="dmabufferprivatedatasize"><code>DmaBufferPrivateDataSize</code></h3>

<p>[in/out] The number of bytes that remain in the private data structure that <strong>pDmaBufferPrivateData</strong> points to for the current operation.</p>

<h3 id="operation"><code>Operation</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ne-d3dkmddi-_dxgk_buildpagingbuffer_operation"><strong>DXGK_BUILDPAGINGBUFFER_OPERATION</strong></a>-typed value that indicates the type of memory operation to perform.</p>

<h3 id="multipassoffset"><code>MultipassOffset</code></h3>

<p>[in/out] A <a href="uint" title="typedef unsigned int UINT;">UINT</a> value that specifies the progress of the paging operation if multiple paging buffers are required. The driver sets this value to indicate a split into multiple paging buffers for more than one transfer operation. For example, the driver can store the page number that was last transferred for a paged-based transfer.</p>

<h3 id="transfer"><code>Transfer</code></h3>

<p>[in] A structure that describes the transfer operation.</p>

<h3 id="transferhallocation"><code>Transfer.hAllocation</code></h3>

<p>[in] A handle to the allocation that the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createallocation"><strong>DxgkDdiCreateAllocation</strong></a> function previously returned in the <strong>hAllocation</strong> member of a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_allocationinfo"><strong>DXGK_ALLOCATIONINFO</strong></a> structure, which is part of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_createallocation"><strong>DXGKARG_CREATEALLOCATION</strong></a> structure's <strong>pAllocationInfo</strong> member. The allocation handle points to a buffer that contains private driver data for the transfer.</p>

<h3 id="transfertransferoffset"><code>Transfer.TransferOffset</code></h3>

<p>[in] The offset, in bytes, of the first page within the allocation that is transferred. This offset is applied only to a location that a segment location describes. This offset does not apply to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> description of a memory range. If the driver requires more than one paging buffer to complete the transfer (that is, the driver returns STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER from its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer"><strong>DxgkDdiBuildPagingBuffer</strong></a> function), <strong>TransferOffset</strong> is the same for each call to <strong>DxgkDdiBuildPagingBuffer</strong> for this transfer.</p>

<h3 id="transfertransfersize"><code>Transfer.TransferSize</code></h3>

<p>[in] The size, in bytes, of the memory information to transfer.</p>

<h3 id="transfersource"><code>Transfer.Source</code></h3>

<p>[in] A structure that describes the source allocation. This structure contains a <strong>SegmentId</strong> member and a union that contains either an offset into a segment of the source allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the source (<strong>pMdl</strong>).</p>

<h3 id="transfersourcesegmentid"><code>Transfer.Source.SegmentId</code></h3>

<p>[in] The identifier of a segment within the source allocation, or zero if the source allocation is described by the <strong>pMdl</strong> member of the union that <strong>Source</strong> contains.</p>

<h3 id="transfersourcesegmentaddress"><code>Transfer.Source.SegmentAddress</code></h3>

<p>[in] The source segment address, if the <strong>SegmentId</strong> member of <strong>Source</strong> is nonzero. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="transfersourcepmdl"><code>Transfer.Source.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the system memory pages for the source, if the <strong>SegmentId</strong> member of <strong>Source</strong> is zero.</p>

<h3 id="transferdestination"><code>Transfer.Destination</code></h3>

<p>[in] A structure that describes the destination allocation. This structure contains a <strong>SegmentId</strong> member and a union that contains either an offset into a segment of the destination allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the destination (<strong>pMdl</strong>).</p>

<h3 id="transferdestinationsegmentid"><code>Transfer.Destination.SegmentId</code></h3>

<p>[in] The identifier of a segment within the destination allocation, or zero if the destination allocation is described by the <strong>pMdl</strong> member of the union that <strong>Destination</strong> contains.</p>

<h3 id="transferdestinationsegmentaddress"><code>Transfer.Destination.SegmentAddress</code></h3>

<p>[in] The destination segment address, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is nonzero. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="transferdestinationpmdl"><code>Transfer.Destination.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the system memory pages for the destination, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is zero.</p>

<h3 id="transferflags"><code>Transfer.Flags</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_transferflags"><strong>DXGK_TRANSFERFLAGS</strong></a> structure that identifies, in bit-field flags, the type of special-lock-transfer operation to perform.</p>

<h3 id="transfermdloffset"><code>Transfer.MdlOffset</code></h3>

<p>[in] The offset, in system memory pages, within the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that the <strong>pMdl</strong> member points to, to the first system memory page for the current operation. The driver can obtain the physical address of the first system memory page by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer#mmgetmdlpfnarray"><strong>MmGetMdlPfnArray</strong></a> function as follows.</p>

<div class="codehilite">
<pre><span></span><code><span class="n"><a href="mmgetmdlpfnarray" title="PPFN_NUMBER MmGetMdlPfnArray(&#10;  _In_ PMDL Mdl&#10;);">MmGetMdlPfnArray</a></span><span class="p">(</span><span class="n">pMdl</span><span class="p">)[</span><span class="n">MdlOffset</span><span class="p">];</span>
</code></pre>
</div>

<h3 id="fill"><code>Fill</code></h3>

<p>[in] A structure that describes the fill operation.</p>

<h3 id="fillhallocation"><code>Fill.hAllocation</code></h3>

<p>[in] A handle to the allocation that contains content to fill.</p>

<h3 id="fillfillsize"><code>Fill.FillSize</code></h3>

<p>[in] The size, in bytes, of the memory information to fill.</p>

<h3 id="fillfillpattern"><code>Fill.FillPattern</code></h3>

<p>[in] The pattern to fill the destination with. The video memory manager uses this information to initialize video memory to a specific pattern when an allocation without content is first paged in. In this case, no source exists for the fill request—only a destination exists.</p>

<h3 id="filldestination"><code>Fill.Destination</code></h3>

<p>[in] A structure that describes the destination allocation for the fill operation.</p>

<h3 id="filldestinationsegmentid"><code>Fill.Destination.SegmentId</code></h3>

<p>[in] The identifier of a segment within the destination allocation.</p>

<h3 id="filldestinationsegmentaddress"><code>Fill.Destination.SegmentAddress</code></h3>

<p>[in] The destination segment address. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="discardcontent"><code>DiscardContent</code></h3>

<p>[in] A structure that describes the discard-content operation.</p>

<h3 id="discardcontenthallocation"><code>DiscardContent.hAllocation</code></h3>

<p>[in] A handle to the allocation that contains content to discard.</p>

<h3 id="discardcontentflags"><code>DiscardContent.Flags</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_discardcontentflags"><strong>DXGK_DISCARDCONTENTFLAGS</strong></a> structure that identifies, in bit-field flags, the type of discard-content operation to perform.</p>

<h3 id="discardcontentsegmentid"><code>DiscardContent.SegmentId</code></h3>

<p>[in] The identifier of a segment within the allocation to discard content from.</p>

<h3 id="discardcontentsegmentaddress"><code>DiscardContent.SegmentAddress</code></h3>

<p>[in] A <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> data type (which is defined as LARGE_INTEGER) that indicates the segment address. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>. This location is where content is discarded from.</p>

<h3 id="readphysical"><code><a href="readphysical" title="VOID ReadPhysical(&#10;  ULONG64 address,&#10;  PVOID   buf,&#10;  ULONG   size,&#10;  PULONG  sizer&#10;);">ReadPhysical</a></code></h3>

<p>[in] A structure that describes the read-physical operation.</p>

<h3 id="readphysicalsegmentid"><code><a href="readphysical" title="VOID ReadPhysical(&#10;  ULONG64 address,&#10;  PVOID   buf,&#10;  ULONG   size,&#10;  PULONG  sizer&#10;);">ReadPhysical</a>.SegmentId</code></h3>

<p>[in] The identifier of a segment that data is read from.</p>

<h3 id="readphysicalphysicaladdress"><code><a href="readphysical" title="VOID ReadPhysical(&#10;  ULONG64 address,&#10;  PVOID   buf,&#10;  ULONG   size,&#10;  PULONG  sizer&#10;);">ReadPhysical</a>.PhysicalAddress</code></h3>

<p>[in] A <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> data type (which is defined as LARGE_INTEGER) that indicates the physical address, within the segment that <strong>SegmentId</strong> specifies, where the data is read.</p>

<h3 id="writephysical"><code><a href="writephysical" title="VOID WritePhysical(&#10;  [in]            ULONG64 address,&#10;  [in]            PVOID   buf,&#10;  [in]            ULONG   size,&#10;  [out, optional] PULONG  sizew&#10;);">WritePhysical</a></code></h3>

<p>[in] A structure that describes the write-physical operation.</p>

<h3 id="writephysicalsegmentid"><code><a href="writephysical" title="VOID WritePhysical(&#10;  [in]            ULONG64 address,&#10;  [in]            PVOID   buf,&#10;  [in]            ULONG   size,&#10;  [out, optional] PULONG  sizew&#10;);">WritePhysical</a>.SegmentId</code></h3>

<p>[in] The identifier of a segment to which data is written.</p>

<h3 id="writephysicalphysicaladdress"><code><a href="writephysical" title="VOID WritePhysical(&#10;  [in]            ULONG64 address,&#10;  [in]            PVOID   buf,&#10;  [in]            ULONG   size,&#10;  [out, optional] PULONG  sizew&#10;);">WritePhysical</a>.PhysicalAddress</code></h3>

<p>[in] A <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> data type (which is defined as LARGE_INTEGER) that indicates the physical address, within the segment that <strong>SegmentId</strong> specifies, where the data is written.</p>

<h3 id="mapaperturesegment"><code>MapApertureSegment</code></h3>

<p>[in] A structure that describes the map-aperture-segment operation using an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<h3 id="mapaperturesegmenthdevice"><code>MapApertureSegment.hDevice</code></h3>

<p>[in] A handle to the device that owns the allocation that <strong>hAllocation</strong> specifies that is mapped into the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p>For a shared allocation, <strong>hDevice</strong> is set to the device that the video memory manager determined to be the owner of the allocation.</p>

<p><strong>hDevice</strong> is <strong>NULL</strong> for the primary allocation.</p>

<h3 id="mapaperturesegmenthallocation"><code>MapApertureSegment.hAllocation</code></h3>

<p>[in] A handle to the allocation that is mapped into the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p><strong>hAllocation</strong> is <strong>NULL</strong> when a DMA buffer is mapped into the aperture segment because DMA buffers are not explicitly created by the driver.</p>

<h3 id="mapaperturesegmentsegmentid"><code>MapApertureSegment.SegmentId</code></h3>

<p>[in] The identifier of an aperture segment to configure.</p>

<h3 id="mapaperturesegmentoffsetinpages"><code>MapApertureSegment.OffsetInPages</code></h3>

<p>[in] The offset, in pages, from the beginning of the segment to the first pages to map.</p>

<h3 id="mapaperturesegmentnumberofpages"><code>MapApertureSegment.NumberOfPages</code></h3>

<p>[in] The number of pages to map.</p>

<h3 id="mapaperturesegmentpmdl"><code>MapApertureSegment.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the physical system memory pages to map into the aperture segment.</p>

<h3 id="mapaperturesegmentflags"><code>MapApertureSegment.Flags</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_mapapertureflags"><strong>DXGK_MAPAPERTUREFLAGS</strong></a> structure that identifies, in bit-field flags, the type of map-aperture-segment operation to perform.</p>

<h3 id="mapaperturesegmentmdloffset"><code>MapApertureSegment.MdlOffset</code></h3>

<p>[in] The offset, in system memory pages, within the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that the <strong>pMdl</strong> member points to, to the first system memory page for the current operation. The driver can obtain the physical address of the first system memory page by calling the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer#mmgetmdlpfnarray"><strong>MmGetMdlPfnArray</strong></a> function as follows.</p>

<div class="codehilite">
<pre><span></span><code><span class="n"><a href="mmgetmdlpfnarray" title="PPFN_NUMBER MmGetMdlPfnArray(&#10;  _In_ PMDL Mdl&#10;);">MmGetMdlPfnArray</a></span><span class="p">(</span><span class="n">pMdl</span><span class="p">)[</span><span class="n">MdlOffset</span><span class="p">];</span>
</code></pre>
</div>

<h3 id="unmapaperturesegment"><code>UnmapApertureSegment</code></h3>

<p>[in] A structure that describes the unmap-aperture-segment operation.</p>

<h3 id="unmapaperturesegmenthdevice"><code>UnmapApertureSegment.hDevice</code></h3>

<p>[in] A handle to the device that owns the allocation that <strong>hAllocation</strong> specifies that is unmapped from the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p>For a shared allocation, <strong>hDevice</strong> is set to the device that the video memory manager determined to be the owner of the allocation.</p>

<p><strong>hDevice</strong> is <strong>NULL</strong> for the primary allocation.</p>

<h3 id="unmapaperturesegmenthallocation"><code>UnmapApertureSegment.hAllocation</code></h3>

<p>[in] A handle to the allocation that is unmapped from the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p><strong>hAllocation</strong> is <strong>NULL</strong> when a DMA buffer is unmapped from the aperture segment because DMA buffers are not explicitly created by the driver.</p>

<h3 id="unmapaperturesegmentsegmentid"><code>UnmapApertureSegment.SegmentId</code></h3>

<p>[in] The identifier of an aperture segment to configure.</p>

<h3 id="unmapaperturesegmentoffsetinpages"><code>UnmapApertureSegment.OffsetInPages</code></h3>

<p>[in] The offset, in pages, from the beginning of the segment to the first pages to unmap.</p>

<h3 id="unmapaperturesegmentnumberofpages"><code>UnmapApertureSegment.NumberOfPages</code></h3>

<p>[in] The number of pages to unmap.</p>

<h3 id="unmapaperturesegmentdummypage"><code>UnmapApertureSegment.DummyPage</code></h3>

<p>[in] A <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> data type (which is defined as LARGE_INTEGER) that indicates the physical address of the placeholder page where the driver should map the range that is unmapped.</p>

<h3 id="speciallocktransfer"><code>SpecialLockTransfer</code></h3>

<p>[in] A structure that describes the special-lock-transfer operation.</p>

<h3 id="speciallocktransferhallocation"><code>SpecialLockTransfer.hAllocation</code></h3>

<p>[in] A handle to the allocation that the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createallocation"><strong>DxgkDdiCreateAllocation</strong></a> function previously returned in the <strong>hAllocation</strong> member of a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_allocationinfo"><strong>DXGK_ALLOCATIONINFO</strong></a> structure, which is part of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_createallocation"><strong>DXGKARG_CREATEALLOCATION</strong></a> structure's <strong>pAllocationInfo</strong> member. The allocation handle points to a buffer that contains private driver data for the special-lock transfer.</p>

<h3 id="speciallocktransfertransferoffset"><code>SpecialLockTransfer.TransferOffset</code></h3>

<p>[in] The offset, in bytes, of the first page within the allocation that is transferred. This offset is applied only to a location that a segment location describes. This offset does not apply to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> description of a memory range. If the driver requires more than one paging buffer to complete the transfer (that is, the driver returns STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER from its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer"><strong>DxgkDdiBuildPagingBuffer</strong></a> function), <strong>TransferOffset</strong> is the same for each call to <strong>DxgkDdiBuildPagingBuffer</strong> for this transfer.</p>

<h3 id="speciallocktransfertransfersize"><code>SpecialLockTransfer.TransferSize</code></h3>

<p>[in] The size, in bytes, of the memory information to transfer.</p>

<h3 id="speciallocktransfersource"><code>SpecialLockTransfer.Source</code></h3>

<p>[in] A structure that describes the source allocation. This structure contains a <strong>SegmentId</strong> member and a union that contains either an offset into a segment of the source allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the source (<strong>pMdl</strong>).</p>

<h3 id="speciallocktransfersourcesegmentid"><code>SpecialLockTransfer.Source.SegmentId</code></h3>

<p>[in] The identifier of a segment within the source allocation, or zero if the source allocation is described by the <strong>pMdl</strong> member of the union that <strong>Source</strong> contains.</p>

<h4 id="speciallocktransfersourceunnamed-union">SpecialLockTransfer.Source.(unnamed union)</h4>

<p>[in] A union that contains either an offset into a segment of the source allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the source (<strong>pMdl</strong>).</p>

<h3 id="speciallocktransfersourcesegmentaddress"><code>SpecialLockTransfer.Source.SegmentAddress</code></h3>

<p>[in] The source segment address, if the <strong>SegmentId</strong> member of <strong>Source</strong> is nonzero. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="speciallocktransfersourcepmdl"><code>SpecialLockTransfer.Source.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the system memory pages for the source, if the <strong>SegmentId</strong> member of <strong>Source</strong> is zero.</p>

<h3 id="speciallocktransferdestination"><code>SpecialLockTransfer.Destination</code></h3>

<p>[in] A structure that describes the destination allocation. This structure contains a <strong>SegmentId</strong> member and a union that contains either an offset into a segment of the destination allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the destination (<strong>pMdl</strong>).</p>

<h3 id="speciallocktransferdestinationsegmentid"><code>SpecialLockTransfer.Destination.SegmentId</code></h3>

<p>[in] The identifier of a segment within the destination allocation, or zero if the destination allocation is described by the <strong>pMdl</strong> member of the union that <strong>Destination</strong> contains.</p>

<h4 id="speciallocktransferdestinationunnamed-union">SpecialLockTransfer.Destination.(unnamed union)</h4>

<p>[in] A union that contains either an offset into a segment of the destination allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the destination (<strong>pMdl</strong>).</p>

<h3 id="speciallocktransferdestinationsegmentaddress"><code>SpecialLockTransfer.Destination.SegmentAddress</code></h3>

<p>[in] The destination segment address, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is nonzero. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="speciallocktransferdestinationpmdl"><code>SpecialLockTransfer.Destination.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the system memory pages for the destination, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is zero.</p>

<h3 id="speciallocktransferflags"><code>SpecialLockTransfer.Flags</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_transferflags"><strong>DXGK_TRANSFERFLAGS</strong></a> structure that identifies, in bit-field flags, the type of special-lock-transfer operation to perform.</p>

<h3 id="speciallocktransferswizzlingrangeid"><code>SpecialLockTransfer.SwizzlingRangeId</code></h3>

<p>[in] A <a href="uint" title="typedef unsigned int UINT;">UINT</a> value that identifies the swizzling range.</p>

<h3 id="speciallocktransferswizzlingrangedata"><code>SpecialLockTransfer.SwizzlingRangeData</code></h3>

<p>[in] A <a href="uint" title="typedef unsigned int UINT;">UINT</a> value that specifies swizzling range data.</p>

<h3 id="initcontextresource"><code>InitContextResource</code></h3>

<p>[in] A structure that describes the context initialization operation. Supported beginning with Windows 8.</p>

<h3 id="initcontextresourcehallocation"><code>InitContextResource.hAllocation</code></h3>

<p>[in] A handle to the context allocation that was created when the driver called <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkcb_createcontextallocation"><strong>DxgkCbCreateContextAllocation</strong></a>. The handle to this allocation is returned in the <strong>hAllocation</strong> member of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkargcb_createcontextallocation"><strong>DXGKARGCB_CREATECONTEXTALLOCATION</strong></a> structure. The driver passes a pointer to this structure in the <strong>ContextAllocation</strong> parameter when it calls <strong>DxgkCbCreateContextAllocation</strong>.</p>

<h3 id="initcontextresourcedestination"><code>InitContextResource.Destination</code></h3>

<p>[in] A structure that describes the destination context allocation. This structure contains a <strong>SegmentId</strong> member and a union that contains either an offset into a segment of the destination context allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the destination (<strong>pMdl</strong>).</p>

<h3 id="initcontextresourcedestinationsegmentid"><code>InitContextResource.Destination.SegmentId</code></h3>

<p>[in] The identifier of a segment within the destination context allocation, or zero if the destination context allocation is described by the <strong>pMdl</strong> member of the union that <strong>Destination</strong> contains.</p>

<h4 id="initcontextresourcedestinationunnamed-union">InitContextResource.Destination.(unnamed union)</h4>

<p>[in] A union that contains either an offset into a segment of the destination context allocation (<strong>SegmentAddress</strong>) or a pointer to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> for the destination (<strong>pMdl</strong>).</p>

<h3 id="initcontextresourcedestinationsegmentaddress"><code>InitContextResource.Destination.SegmentAddress</code></h3>

<p>[in] The destination segment address, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is nonzero. The DirectX graphics kernel subsystem computes the segment address as the sum of the segment offset and the base address of the segment: <code>SegmentAddress = SegmentOffset + Segment.BaseAddr</code>.</p>

<h3 id="initcontextresourcedestinationpmdl"><code>InitContextResource.Destination.pMdl</code></h3>

<p>[in] A pointer to a buffer that contains the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a> structure that describes the system memory pages for the destination, if the <strong>SegmentId</strong> member of <strong>Destination</strong> is zero.</p>

<h3 id="initcontextresourcedestinationvirtualaddress"><code>InitContextResource.Destination.VirtualAddress</code></h3>

<p>[in] The virtual address of the destination context allocation. This address is valid during the lifetime of the context allocation.</p>

<p>Follow procedures in the Virtual addresses for destination context allocations" section of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkcb_createcontextallocation"><strong>DxgkCbCreateContextAllocation</strong></a> topic to ensure that the virtual address is valid.</p>

<h3 id="initcontextresourcedestinationgpuvirtualaddress"><code>InitContextResource.Destination.GpuVirtualAddress</code></h3>

<p>GPU virtual address of the context resource to initialize.</p>

<h3 id="transfervirtual"><code>TransferVirtual</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_transfervirtual"><strong>DXGK_BUILDPAGINGBUFFER_TRANSFERVIRTUAL</strong></a> structure that describes the operation used to transfer allocation content between locations in memory.</p>

<h3 id="fillvirtual"><code>FillVirtual</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_fillvirtual"><strong>DXGK_BUILDPAGINGBUFFER_FILLVIRTUAL</strong></a> structure that describes the operation used to fill an allocation with a pattern.</p>

<h3 id="updatepagetable"><code>UpdatePageTable</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_updatepagetable"><strong>DXGK_BUILDPAGINGBUFFER_UPDATEPAGETABLE</strong></a> structure that describes the operation used to update a page table.</p>

<h3 id="flushtlb"><code>FlushTlb</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_flushtlb"><strong>DXGK_BUILDPAGINGBUFFER_FLUSHTLB</strong></a> structure that describes the operation used to flush the translation look-aside buffers.</p>

<h3 id="copypagetableentries"><code>CopyPageTableEntries</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_copypagetableentries"><strong>DXGK_BUILDPAGINGBUFFER_COPYPAGETABLEENTRIES</strong></a> structure that describes the operation used copy page table entries from one location to another.</p>

<h3 id="updatecontextallocation"><code>UpdateContextAllocation</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_updatecontextallocation"><strong>DXGK_BUILDPAGINGBUFFER_UPDATECONTEXTALLOCATION</strong></a> structure that describes the operation used to update the content of a context or device allocation.</p>

<h3 id="notifyresidency"><code>NotifyResidency</code></h3>

<p>A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_notifyresidency"><strong>DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY</strong></a> structure that describes a residency allocation change operation.</p>

<h3 id="signalmonitoredfence"><code>SignalMonitoredFence</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_signalmonitoredfence"><strong>DXGK_BUILDPAGINGBUFFER_SIGNALMONITOREDFENCE</strong></a> structure that describes a GPU instruction to signal the paging monitored fence object to the DMA buffer. Available starting with Windows 10, version 1703 (WDDM 2.2).</p>

<h3 id="mapaperturesegment2"><code>MapApertureSegment2</code></h3>

<p>A structure that describes the map-aperture-segment operation using an ADL. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/iommu-dma-remapping">IOMMU DMA remapping</a> for more information.</p>

<h3 id="mapaperturesegment2hdevice"><code>MapApertureSegment2.hDevice</code></h3>

<p>[in] A handle to the device that owns the allocation that <strong>hAllocation</strong> specifies that is mapped into the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p>For a shared allocation, <strong>hDevice</strong> is set to the device that the video memory manager determined to be the owner of the allocation.</p>

<p><strong>hDevice</strong> is <strong>NULL</strong> for the primary allocation.</p>

<h3 id="mapaperturesegment2hallocation"><code>MapApertureSegment2.hAllocation</code></h3>

<p>[in] The driver handle to the allocation that is mapped into the aperture segment that <strong>SegmentId</strong> specifies.</p>

<p><strong>hAllocation</strong> is <strong>NULL</strong> when a DMA buffer is mapped into the aperture segment because DMA buffers are not explicitly created by the driver.</p>

<h3 id="mapaperturesegment2segmentid"><code>MapApertureSegment2.SegmentId</code></h3>

<p>[in] The identifier of an aperture segment to configure.</p>

<h3 id="mapaperturesegment2offsetinpages"><code>MapApertureSegment2.OffsetInPages</code></h3>

<p>[in] The offset, in pages, from the beginning of the segment to the first pages to map.</p>

<h3 id="mapaperturesegment2numberofpages"><code>MapApertureSegment2.NumberOfPages</code></h3>

<p>[in] The size of the range being mapped within the allocation, in pages.</p>

<h3 id="mapaperturesegment2adl"><code>MapApertureSegment2.Adl</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-dxgk_adl"><strong>DXGK_ADL</strong></a> structure with the address descriptor list (ADL) that describes the logical address mappings (pages) for the allocation memory. This ADL can be either contiguous or a page array; the driver must be able to handle both cases.</p>

<h3 id="mapaperturesegment2flags"><code>MapApertureSegment2.Flags</code></h3>

<p>[in] A <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_mapapertureflags"><strong>DXGK_MAPAPERTUREFLAGS</strong></a> structure that identifies, in bit-field flags, the type of map-aperture-segment operation to perform.</p>

<h3 id="mapaperturesegment2adloffset"><code>MapApertureSegment2.AdlOffset</code></h3>

<p>[in] The offset within the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-dxgk_adl">ADL</a> to the start of the range of logical addresses being mapped for the current operation, specified in system memory pages. If the ADL is a contiguous ADL, then the ADL's <strong>BasePageNumber</strong> member is the start address of a contiguous range of memory. Otherwise use the ADL's <strong>Pages</strong> member for non-contiguous memory.</p>

<h3 id="mapaperturesegment2cpuvisibleaddress"><code>MapApertureSegment2.CpuVisibleAddress</code></h3>

<p>If a driver's allocation was created with the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_allocationinfoflags_wddm2_0"><strong>MapApertureCpuVisible</strong></a> flag set, <strong>CpuVisibleAddress</strong> is a non-null pointer to a system-mapped, kernel-mode virtual address for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ne-d3dkmddi-_dxgk_buildpagingbuffer_operation"><strong>DXGK_OPERATION_MAP_APERTURE_SEGMENT2</strong></a> operations. This address is valid as long as the allocation is mapped into the aperture segment and will be freed immediately after the corresponding <strong>DXGK_OPERATION_UNMAP_APERTURE_SEGMENT</strong> call for the same allocation.</p>

<p>If <strong>MapApertureCpuVisible</strong> is not specified, <strong>CpuVisibleAddress</strong> is NULL for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ne-d3dkmddi-_dxgk_buildpagingbuffer_operation"><strong>DXGK_OPERATION_MAP_APERTURE_SEGMENT2</strong></a> operations.</p>

<h3 id="reserved"><code>Reserved</code></h3>

<p>This member is reserved and should not be used.</p>

<h3 id="reservedreserved"><code>Reserved.Reserved</code></h3>

<p>This member is reserved and should not be used.</p>

<h3 id="hsystemcontext"><code>hSystemContext</code></h3>

<p>[in] A handle to the system context for the paging operation.</p>

<h3 id="dmabuffergpuvirtualaddress"><code>DmaBufferGpuVirtualAddress</code></h3>

<p>A <strong>D3DGPU_VIRTUAL_ADDRESS</strong> data type that indicates the virtual address where the DMA buffer was paged in. If the physical address is zero, the DMA buffer is not correctly paged in.</p>

<h3 id="dmabufferwriteoffset"><code>DmaBufferWriteOffset</code></h3>

<p>The current operation offset in bytes from the start of the DMA buffer.</p>

<h2 id="remarks">Remarks</h2>

<p><a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> is defined in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-mdls">Windows Driver Model (WDM)</a> documentation.</p>

<p>WDDM synchronization class:</p>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/threading-and-synchronization-first-level">First Level GPU Scheduler Class</a> for <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer">BuildPagingBuffer</a> submission type.</li>
</ul>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkargcb_createcontextallocation"><strong>DXGKARGCB_CREATECONTEXTALLOCATION</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_createallocation"><strong>DXGKARG_CREATEALLOCATION</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_allocationinfo"><strong>DXGK_ALLOCATIONINFO</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_copypagetableentries"><strong>DXGK_BUILDPAGINGBUFFER_COPYPAGETABLEENTRIES</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_fillvirtual"><strong>DXGK_BUILDPAGINGBUFFER_FILLVIRTUAL</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_flushtlb"><strong>DXGK_BUILDPAGINGBUFFER_FLUSHTLB</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_notifyresidency"><strong>DXGK_BUILDPAGINGBUFFER_NOTIFYRESIDENCY</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_transfervirtual"><strong>DXGK_BUILDPAGINGBUFFER_TRANSFERVIRTUAL</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_updatecontextallocation"><strong>DXGK_BUILDPAGINGBUFFER_UPDATECONTEXTALLOCATION</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_buildpagingbuffer_updatepagetable"><strong>DXGK_BUILDPAGINGBUFFER_UPDATEPAGETABLE</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_discardcontentflags"><strong>DXGK_DISCARDCONTENTFLAGS</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_mapapertureflags"><strong>DXGK_MAPAPERTUREFLAGS</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgk_transferflags"><strong>DXGK_TRANSFERFLAGS</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkcb_createcontextallocation"><strong>DxgkCbCreateContextAllocation</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_buildpagingbuffer"><strong>DxgkDdiBuildPagingBuffer</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createallocation"><strong>DxgkDdiCreateAllocation</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl"><strong>MDL</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer#mmgetmdlpfnarray"><strong>MmGetMdlPfnArray</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_lockcb"><strong>pfnLockCb</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/ns-d3dkmddi-_dxgkarg_buildpagingbuffer">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dkmddi/ns-d3dkmddi-_dxgkarg_buildpagingbuffer.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
