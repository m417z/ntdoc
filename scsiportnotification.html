<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="ScsiPortNotification - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>ScsiPortNotification - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            ScsiPortNotification - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">SCSIPORT_API VOID ScsiPortNotification(
  SCSI_NOTIFICATION_TYPE NotificationType,
  PVOID                  HwDeviceExtension,
  ...                    
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/nf-srb-scsiportnotification">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/scsiportnotification.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-srb-scsiportnotification)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="scsiportnotification-function">ScsiPortNotification function</h1>

<h2 id="description">Description</h2>

<p>The <strong>ScsiPortNotification</strong> routine informs the operating system-specific port driver of certain events, such as when a miniport driver completes a request or is ready to start another SRB, as well as when the host bus adapter (HBA) indicates certain SCSI error conditions that occurred during an operation.</p>

<blockquote>
  <p>[!NOTE]</p>
  
  <p>The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
</blockquote>

<h2 id="parameters">Parameters</h2>

<h3 id="notificationtype"><code>NotificationType</code></h3>

<p>Specifies the type of notification. See Remarks.</p>

<h3 id="hwdeviceextension"><code>HwDeviceExtension</code></h3>

<p>Pointer to the hardware device extension. This is a per-HBA storage area that the port driver allocates and initializes on behalf of the miniport driver. Miniport drivers usually store HBA-specific information in this extension, such as the state of the HBA and the HBA's mapped access ranges. This area is available to the miniport driver in the <strong>DeviceExtension->HwDeviceExtension</strong> member of the HBA's device object immediately after the miniport driver calls <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. The port driver frees this memory when it removes the device.</p>

<h3 id="-1"><code>...</code></h3>

<p>Variadic arguments for this routine. The number and type of arguments depend on <strong>NotificationType</strong>. See Remarks.</p>

<h2 id="return-value">Return value</h2>

<p>None</p>

<h2 id="remarks">Remarks</h2>

<p>The <strong>ScsiPortNotification</strong> routine has a different set of optional parameters associated with each <strong>NotificationType</strong>. The list of possible values for <strong>NotificationType</strong> follows, along with descriptions for each value.</p>

<ul>
<li><p><strong>NotificationType = RequestComplete</strong></p>

<p>Indicates that the given <strong>Srb</strong> has finished. If this value is set, <strong>ScsiPortNotification</strong> requires one additional parameter: the address of the SRB. After this notification, the operating system-specific port driver owns the request. The miniport driver must not access the <strong>Srb</strong>, and it must not pass the <strong>Srb</strong> to another routine (such as <strong><a href="scsiportlogerror" title="SCSIPORT_API VOID ScsiPortLogError(&#10;  PVOID               HwDeviceExtension,&#10;  PSCSI_REQUEST_BLOCK Srb,&#10;  UCHAR               PathId,&#10;  UCHAR               TargetId,&#10;  UCHAR               Lun,&#10;  ULONG               ErrorCode,&#10;  ULONG               UniqueId&#10;);">ScsiPortLogError</a></strong>).</p>

<p>Syntax:</p>

<div class="codehilite">
<pre><span></span><code><span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="nf">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">   </span><span class="c1">// RequestComplete</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">PSCSI_REQUEST_BLOCK</a></span><span class="w">    </span><span class="n">Srb</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">   </span><span class="c1">// NextLuRequest</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w">                        </span><span class="n">PathId</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w">                        </span><span class="n">TargetId</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w">                        </span><span class="n">Lun</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">           </span><span class="c1">// CallEnableInterrupts</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a></span><span class="w">          </span><span class="n">HwScsiXxxInterruptsCallback</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">          </span><span class="c1">// CallDisableInterrupts</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a></span><span class="w">          </span><span class="n">HwScsiXxxInterruptsCallback</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">    </span><span class="c1">// RequestTimerCall</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="phw_timer" title="PHW_TIMER PhwTimer;&#10;&#10;VOID PhwTimer(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_TIMER</a></span><span class="w">              </span><span class="n">HwScsiTimer</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="ulong" title="typedef unsigned long ULONG;">ULONG</a></span><span class="w">                  </span><span class="n">MiniportTimerValue</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">    </span><span class="c1">// BusChangeDetected</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">PathId</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">    </span><span class="c1">// WMIEvent</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">WMIEvent</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">PathId</span><span class="p">,</span><span class="w">              </span><span class="c1">// != 0xFF</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">TargetId</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">Lun</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">    </span><span class="c1">// WMIEvent</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">WMIEvent</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">PathId</span><span class="w">               </span><span class="c1">// 0xFF</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">    </span><span class="c1">// WMIReregister</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">PathId</span><span class="p">,</span><span class="w">             </span><span class="c1">// != 0xFF</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">TargetId</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">Lun</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="o"><!--</span><span class="w"> </span><span class="o">--></span>
<span class="err"> </span><span class="w"> </span><span class="n">C</span>
<span class="w">  </span><span class="n">VOID</span><span class="w"> </span><span class="n">ScsiPortNotification</span><span class="p">(</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">SCSI_NOTIFICATION_TYPE</span><span class="w"> </span><span class="n">NotificationType</span><span class="p">,</span><span class="w">   </span><span class="c1">// WMIReregister</span>
<span class="w">    </span><span class="n">_In_</span><span class="w">     </span><span class="n">PVOID</span><span class="w">                  </span><span class="n">HwDeviceExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">_In_opt_</span><span class="w"> </span><span class="n"><a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a></span><span class="w">                  </span><span class="n">PathId</span><span class="w">              </span><span class="c1">// 0xFF</span>
<span class="w">  </span><span class="p">);</span>
<span class="w"> </span>
</code></pre>
</div></li>
</ul>

<p>Every miniport driver must call <strong>ScsiPortNotification</strong> twice for each call to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557323(v=vs.85)"><strong>HwScsiStartIo</strong></a> routine with an SRB that the miniport driver completes successfully. First, the miniport driver calls <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>NextRequest</strong> or with <strong>NextLuRequest</strong> if the miniport driver supports tagged queuing or multiple requests per LU. Then, the miniport driver calls <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>RequestComplete</strong> and the request that it has just satisfied.</p>

<p>A miniport driver's <strong>HwScsiInterrupt</strong> routine is most likely to call <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>ResetDetected</strong>.</p>

<p>If an HBA requires the miniport driver to use more than a millisecond processing interrupt-driven I/O operations, its <strong>HwScsiInterrupt</strong> routine should disable interrupts on the HBA and call <strong>ScsiPortNotification</strong> with <strong>CallEnableInterrupts</strong> and a driver-supplied <strong>HwScsiEnableInterruptsCallback</strong> routine. This routine, in turn, calls <strong>ScsiPortNotification</strong> with <strong>CallDisableInterrupts</strong> and the corresponding driver-supplied <strong>HwScsiDisableInterruptsCallback</strong>.</p>

<p>A miniport driver that is registered as a WMI data provider can call <strong>ScsiPortNotification</strong> with <strong>WMIEvent</strong> to post an event for which it has previously received an enable request. The port driver queues the event in the interrupt data area of the miniport driver's device extension for later processing at a lower IRQL. Because only a limited number of events can be queued at one time, the miniport driver should use <strong>WMIEvent</strong> to signal exceptional rather than routine conditions, and it should give the port driver time to get back to DISPATCH_LEVEL between postings, to prevent events from being lost.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557288(v=vs.85)"><strong>HwScsiDisableInterruptsCallback</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557295(v=vs.85)"><strong>HwScsiEnableInterruptsCallback</strong></a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557327(v=vs.85)"><strong>HwScsiTimer</strong></a></p>

<p><strong><a href="iowmiregistrationcontrol" title="NTSTATUS IoWMIRegistrationControl(&#10;  [in] PDEVICE_OBJECT DeviceObject,&#10;  [in] ULONG          Action&#10;);">IoWMIRegistrationControl</a></strong></p>

<p><strong><a href="scsiportcompleterequest" title="SCSIPORT_API VOID ScsiPortCompleteRequest(&#10;  [in] PVOID HwDeviceExtension,&#10;  [in] UCHAR PathId,&#10;  [in] UCHAR TargetId,&#10;  [in] UCHAR Lun,&#10;  [in] UCHAR SrbStatus&#10;);">ScsiPortCompleteRequest</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/nf-srb-scsiportnotification">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/nf-srb-scsiportnotification.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
