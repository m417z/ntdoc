<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="ScsiPortNotification - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>ScsiPortNotification - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            ScsiPortNotification - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">SCSIPORT_API VOID ScsiPortNotification(
  SCSI_NOTIFICATION_TYPE NotificationType,
  PVOID                  HwDeviceExtension,
  ...                    
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/nf-srb-scsiportnotification">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/scsiportnotification.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-srb-scsiportnotification)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>ScsiPortNotification function</h1>
<h2>Description</h2>
<p>The <strong>ScsiPortNotification</strong> routine informs the operating system-specific port driver of certain events, such as when a miniport driver completes a request or is ready to start another SRB, as well as when the host bus adapter (HBA) indicates certain SCSI error conditions that occurred during an operation.</p>
<blockquote>
<p>[!NOTE]</p>
<p>The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
</blockquote>
<h2>Parameters</h2>
<h3><code>NotificationType</code></h3>
<p>Specifies the type of notification. See Remarks.</p>
<h3><code>HwDeviceExtension</code></h3>
<p>Pointer to the hardware device extension. This is a per-HBA storage area that the port driver allocates and initializes on behalf of the miniport driver. Miniport drivers usually store HBA-specific information in this extension, such as the state of the HBA and the HBA's mapped access ranges. This area is available to the miniport driver in the <strong>DeviceExtension-&gt;HwDeviceExtension</strong> member of the HBA's device object immediately after the miniport driver calls <strong><a href="scsiportinitialize" title="SCSIPORT_API ULONG ScsiPortInitialize(&#10;  [in] PVOID                   Argument1,&#10;  [in] PVOID                   Argument2,&#10;  [in] _HW_INITIALIZATION_DATA *HwInitializationData,&#10;  [in] PVOID                   HwContext&#10;);">ScsiPortInitialize</a></strong>. The port driver frees this memory when it removes the device.</p>
<h3><code>...</code></h3>
<p>Variadic arguments for this routine. The number and type of arguments depend on <strong>NotificationType</strong>. See Remarks.</p>
<h2>Return value</h2>
<p>None</p>
<h2>Remarks</h2>
<p>The <strong>ScsiPortNotification</strong> routine has a different set of optional parameters associated with each <strong>NotificationType</strong>. The list of possible values for <strong>NotificationType</strong> follows, along with descriptions for each value.</p>
<ul>
<li><strong>NotificationType = RequestComplete</strong></li>
</ul>
<p>Indicates that the given <strong>Srb</strong> has finished. If this value is set, <strong>ScsiPortNotification</strong> requires one additional parameter: the address of the SRB. After this notification, the operating system-specific port driver owns the request. The miniport driver must not access the <strong>Srb</strong>, and it must not pass the <strong>Srb</strong> to another routine (such as <strong><a href="scsiportlogerror" title="SCSIPORT_API VOID ScsiPortLogError(&#10;  PVOID               HwDeviceExtension,&#10;  PSCSI_REQUEST_BLOCK Srb,&#10;  UCHAR               PathId,&#10;  UCHAR               TargetId,&#10;  UCHAR               Lun,&#10;  ULONG               ErrorCode,&#10;  ULONG               UniqueId&#10;);">ScsiPortLogError</a></strong>).</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,   // RequestComplete
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">PSCSI_REQUEST_BLOCK</a>    Srb
  );
</code></pre>
<ul>
<li><strong>NotificationType = NextRequest</strong></li>
</ul>
<p>Indicates the miniport driver is ready for another request to a target that is not currently busy. This notification should be sent by the miniport driver as soon as the driver is ready for another request. Usually, this notification is sent from the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557323(v=vs.85)"><strong>HwScsiStartIo</strong></a> routine but, sometimes, from the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557312(v=vs.85)"><strong>HwScsiInterrupt</strong></a> (or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557295(v=vs.85)"><strong>HwScsiEnableInterruptsCallback</strong></a>) routine.</p>
<ul>
<li><strong>NotificationType = NextLuRequest</strong></li>
</ul>
<p>Indicates that the HBA is ready for another request for the specified logical unit. If this value is set, <strong>ScsiPortNotification</strong> requires three additional parameters: (1) the path ID, (2) the target ID, and (3) the logical unit number. This value should be used only if the HBA can queue multiple requests and support auto-request sense or tagged queuing.</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,   // NextLuRequest
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_                        PathId,
    _In_opt_                        TargetId,
    _In_opt_                        Lun
  );
</code></pre>
<ul>
<li><strong>NotificationType = ResetDetected</strong></li>
</ul>
<p>Indicates that the HBA has detected a reset on the SCSI bus. After this notification, the miniport driver is still responsible for completing any active requests. The SCSI port driver will manage all required bus-reset delays.</p>
<ul>
<li><strong>NotificationType = CallEnableInterrupts</strong></li>
</ul>
<p>Indicates that the miniport driver requires the operating system-specific port driver to call the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557295(v=vs.85)"><strong>HwScsiEnableInterruptsCallback</strong></a> routine. If this value is set, <strong>ScsiPortNotification</strong> requires an additional parameter: the entry point for the <strong>HwScsiEnableInterruptsCallback</strong>. The miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557312(v=vs.85)"><strong>HwScsiInterrupt</strong></a> routine makes this call <em>after</em> disabling interrupts on the HBA, to defer some interrupt-driven I/O processing if the HBA requires polling or stalling in the ISR. While the callback runs, system interrupts remain enabled but the miniport driver's <strong>HwScsiInterrupt</strong> routine will not be called. The <strong>HwScsiEnableInterruptsCallback</strong> is responsible for completing the deferred I/O processing and for calling <strong>ScsiPortNotification</strong> again with <strong>CallDisableInterrupts</strong> and the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557288(v=vs.85)"><strong>HwScsiDisableInterruptsCallback</strong></a> entry point.</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,           // CallEnableInterrupts
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>          HwScsiXxxInterruptsCallback
  );
</code></pre>
<ul>
<li><strong>NotificationType = CallDisableInterrupts</strong></li>
</ul>
<p>Indicates that the miniport driver requires the operating system-specific port driver to call the miniport driver's <strong>HwScsiDisableInterruptsCallback</strong> routine. If this value is set, <strong>ScsiPortNotification</strong> requires an additional parameter: the entry point for the <strong>HwScsiDisableInterruptsCallback</strong>. While this callback runs, it cannot be preempted by an interrupt except from a device with a higher priority interrupt than the HBA. In this callback, the miniport driver reenables interrupts on the HBA.</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,          // CallDisableInterrupts
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="phw_interrupt" title="PHW_INTERRUPT PhwInterrupt;&#10;&#10;BOOLEAN PhwInterrupt(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_INTERRUPT</a>          HwScsiXxxInterruptsCallback
  );
</code></pre>
<ul>
<li><strong>NotificationType = RequestTimerCall</strong></li>
</ul>
<p>Indicates that the miniport driver requires the operating system-specific port driver to call the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557327(v=vs.85)"><strong>HwScsiTimer</strong></a> routine in the requested number of microseconds. If this value is set, <strong>ScsiPortNotification</strong> requires two additional parameters: (1) the entry point for the miniport driver's <strong>HwScsiTimer</strong> routine, and (2) a <strong>MiniportTimerValue</strong> interval, in microseconds. Note that the resolution of the system timer is approximately 10 milliseconds.</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,    // RequestTimerCall
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="phw_timer" title="PHW_TIMER PhwTimer;&#10;&#10;VOID PhwTimer(&#10;  [in] PVOID DeviceExtension&#10;)&#10;{...}">PHW_TIMER</a>              HwScsiTimer,
    _In_opt_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                  MiniportTimerValue
  );
</code></pre>
<ul>
<li><strong>NotificationType = BusChangeDetected</strong></li>
</ul>
<p>Indicates that a target device might have been added or removed from a dynamic bus. If this value is set, <strong>ScsiPortNotification</strong> requires an additional parameter: the path ID of the bus on which the change was detected. After this notification, the port driver reenumerates the bus by issuing INQUIRY commands. Bus enumeration is time-consuming and ties up the bus, so a miniport driver should not send this notification unnecessarily.</p>
<p>Syntax:</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,    // BusChangeDetected
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  PathId
  );
</code></pre>
<ul>
<li><strong>NotificationType = WMIEvent</strong></li>
</ul>
<p>Indicates that the miniport driver has detected an event for which one or more WMI data consumers is registered. If this value is set, <strong>ScsiPortNotification</strong> requires at least three additional arguments: (1) a pointer to a WMI event structure, (2) the size of the event structure, and (3) the path ID of the target device if the event originated from a device, or 0xFF if the event originated from the adapter. If (3) is a path ID, <strong>ScsiPortNotification</strong> requires two additional arguments: (4) the target ID, and (5) the logical unit number (LUN) of the target device.</p>
<p>Syntax for PathId != 0xFF</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,    // WMIEvent
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ PVOID                  WMIEvent,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  PathId,              // != 0xFF
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  TargetId,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  Lun
  );
</code></pre>
<p>Syntax for PathId = 0xFF</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,    // WMIEvent
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ PVOID                  WMIEvent,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  PathId               // 0xFF
  );
</code></pre>
<ul>
<li><strong>NotificationType = WMIReregister</strong></li>
</ul>
<p>Indicates that the miniport driver has changed the data items or the number of instances of a given data block previously registered by calling <strong><a href="iowmiregistrationcontrol" title="NTSTATUS IoWMIRegistrationControl(&#10;  [in] PDEVICE_OBJECT DeviceObject,&#10;  [in] ULONG          Action&#10;);">IoWMIRegistrationControl</a></strong>. If <strong>WMIReregister</strong> is set, <strong>ScsiPortNotification</strong> requires at least two additional arguments: (1) the path ID of the target device to reregister that device, or 0xFF to reregister the adapter. If (1) is a path ID, <strong>ScsiPortNotification</strong> requires two additional arguments: (2) the target ID, and (3) the logical unit number (LUN) of the target device.</p>
<p>Syntax for PathId != 0xFF</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,    // WMIReregister
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  PathId,             // != 0xFF
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  TargetId,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  Lun
  );
</code></pre>
<p>Syntax for PathId = 0xFF</p>
<pre><code class="language-C">  VOID ScsiPortNotification(
    _In_     SCSI_NOTIFICATION_TYPE NotificationType,   // WMIReregister
    _In_     PVOID                  HwDeviceExtension,
    _In_opt_ <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                  PathId              // 0xFF
  );
</code></pre>
<p>Every miniport driver must call <strong>ScsiPortNotification</strong> twice for each call to the miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557323(v=vs.85)"><strong>HwScsiStartIo</strong></a> routine with an SRB that the miniport driver completes successfully. First, the miniport driver calls <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>NextRequest</strong> or with <strong>NextLuRequest</strong> if the miniport driver supports tagged queuing or multiple requests per LU. Then, the miniport driver calls <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>RequestComplete</strong> and the request that it has just satisfied.</p>
<p>A miniport driver's <strong>HwScsiInterrupt</strong> routine is most likely to call <strong>ScsiPortNotification</strong> with the <strong>NotificationType</strong> of <strong>ResetDetected</strong>.</p>
<p>If an HBA requires the miniport driver to use more than a millisecond processing interrupt-driven I/O operations, its <strong>HwScsiInterrupt</strong> routine should disable interrupts on the HBA and call <strong>ScsiPortNotification</strong> with <strong>CallEnableInterrupts</strong> and a driver-supplied <strong>HwScsiEnableInterruptsCallback</strong> routine. This routine, in turn, calls <strong>ScsiPortNotification</strong> with <strong>CallDisableInterrupts</strong> and the corresponding driver-supplied <strong>HwScsiDisableInterruptsCallback</strong>.</p>
<p>A miniport driver that is registered as a WMI data provider can call <strong>ScsiPortNotification</strong> with <strong>WMIEvent</strong> to post an event for which it has previously received an enable request. The port driver queues the event in the interrupt data area of the miniport driver's device extension for later processing at a lower IRQL. Because only a limited number of events can be queued at one time, the miniport driver should use <strong>WMIEvent</strong> to signal exceptional rather than routine conditions, and it should give the port driver time to get back to DISPATCH_LEVEL between postings, to prevent events from being lost.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557288(v=vs.85)"><strong>HwScsiDisableInterruptsCallback</strong></a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557295(v=vs.85)"><strong>HwScsiEnableInterruptsCallback</strong></a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557327(v=vs.85)"><strong>HwScsiTimer</strong></a></p>
<p><strong><a href="iowmiregistrationcontrol" title="NTSTATUS IoWMIRegistrationControl(&#10;  [in] PDEVICE_OBJECT DeviceObject,&#10;  [in] ULONG          Action&#10;);">IoWMIRegistrationControl</a></strong></p>
<p><strong><a href="scsiportcompleterequest" title="SCSIPORT_API VOID ScsiPortCompleteRequest(&#10;  [in] PVOID HwDeviceExtension,&#10;  [in] UCHAR PathId,&#10;  [in] UCHAR TargetId,&#10;  [in] UCHAR Lun,&#10;  [in] UCHAR SrbStatus&#10;);">ScsiPortCompleteRequest</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/nf-srb-scsiportnotification">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/nf-srb-scsiportnotification.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
