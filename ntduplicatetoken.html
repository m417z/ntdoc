<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtDuplicateToken - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtDuplicateToken - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtDuplicateToken - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTSEAPI_H

</span><span class="ntdoc-code-intro">/**
 * The NtDuplicateToken function creates a handle to a new access token that duplicates an existing token.
 *
 * @param ExistingTokenHandle A handle to an existing access token that was opened with the TOKEN_DUPLICATE access right.
 * @param DesiredAccess ACCESS_MASK structure specifying the requested types of access to the access token.
 * @param ObjectAttributes Pointer to an <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> structure that describes the requested properties for the new token.
 * @param EffectiveOnly A Boolean value that indicates whether the entire existing token should be duplicated into the new token or just the effective (currently enabled) part of the token.
 * @param Type Specifies the type of token to create either a primary token or an impersonation token.
 * @param NewTokenHandle Pointer to a caller-allocated variable that receives a handle to the newly duplicated token.
 * @return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * @sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken
 */
</span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ <a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a> Type,
    _Out_ PHANDLE NewTokenHandle
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/443d121781061210978931c1766974f1372e359a/phnt/include/ntseapi.h#L538">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ <a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a> Type,
    _Out_ PHANDLE NewTokenHandle
    );
</span><span class="ntdoc-code-footer">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/443d121781061210978931c1766974f1372e359a/phnt/include/ntzwapi.h#L1723">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtDuplicateToken(
  [in]  HANDLE             ExistingTokenHandle,
  [in]  ACCESS_MASK        DesiredAccess,
  [in]  <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
  [in]  BOOLEAN            EffectiveOnly,
  [in]  <a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a>         TokenType,
  [out] PHANDLE            NewTokenHandle
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwDuplicateToken(
  [in]  HANDLE             ExistingTokenHandle,
  [in]  ACCESS_MASK        DesiredAccess,
  [in]  <a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">POBJECT_ATTRIBUTES</a> ObjectAttributes,
  [in]  BOOLEAN            EffectiveOnly,
  [in]  <a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a>         TokenType,
  [out] PHANDLE            NewTokenHandle
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwduplicatetoken">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<p>Creates a copy of a token. This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwduplicatetoken">here</a>.</p>

<h1 id="parameters">Parameters</h1>

<ul>
<li><code>ExistingTokenHandle</code> - a handle to an existing token. The handle must grant <code>TOKEN_DUPLICATE</code> access.</li>
<li><code>DesiredAccess</code> - the access mask to provide on the returned handle. This value is usually <code>TOKEN_ALL_ACCESS</code>.</li>
<li><code>ObjectAttributes</code> - an optional pointer to an <code><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></code> structure that specifies attributes of the handle/object. The <code>SecurityQualityOfService-&gt;ImpersonationLevel</code> field is especially meaningful for this function because it controls the impersonation level of the new token.</li>
<li><code>EffectiveOnly</code> - a boolean indicating whether the system should copy all groups and privileges (set to <code>FALSE</code>) or only currently enabled ones (set to <code>TRUE</code>).</li>
<li><code>Type</code> - the type of the new token, either primary or impersonation.</li>
<li><code>NewTokenHandle</code> - a pointer to a variable that receives a handle to the new token.</li>
</ul>

<h1 id="access-masks">Access masks</h1>

<table>
<thead>
<tr>
  <th>Access mask</th>
  <th>Use</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>TOKEN_ASSIGN_PRIMARY</code></td>
  <td>Allows creating processes with this token and assigning the token as primary via <code><a href="ntsetinformationprocess" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationProcess(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ PROCESSINFOCLASS ProcessInformationClass,&#10;    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,&#10;    _In_ ULONG ProcessInformationLength&#10;    );">NtSetInformationProcess</a></code> with <code>ProcessAccessToken</code>.</td>
</tr>
<tr>
  <td><code>TOKEN_DUPLICATE</code></td>
  <td>Allows duplicating the token via <code>NtDuplicateToken</code>.</td>
</tr>
<tr>
  <td><code>TOKEN_IMPERSONATE</code></td>
  <td>Allows impersonating the token via <code><a href="ntsetinformationthread" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationThread(&#10;    _In_ HANDLE ThreadHandle,&#10;    _In_ THREADINFOCLASS ThreadInformationClass,&#10;    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,&#10;    _In_ ULONG ThreadInformationLength&#10;    );">NtSetInformationThread</a></code> with <code>ThreadImpersonationToken</code>.</td>
</tr>
<tr>
  <td><code>TOKEN_QUERY</code></td>
  <td>Allows querying most information classes via <code><a href="ntqueryinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtQueryInformationToken</a></code>.</td>
</tr>
<tr>
  <td><code>TOKEN_QUERY_SOURCE</code></td>
  <td>Allows querying <code><a href="tokensource" title="#define TokenSource 7 // q: TOKEN_SOURCE">TokenSource</a></code> via <code><a href="ntqueryinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtQueryInformationToken</a></code>.</td>
</tr>
<tr>
  <td><code>TOKEN_ADJUST_PRIVILEGES</code></td>
  <td>Allows adjusting token privileges via <code><a href="ntadjustprivilegestoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtAdjustPrivilegesToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ BOOLEAN DisableAllPrivileges,&#10;    _In_opt_ PTOKEN_PRIVILEGES NewState,&#10;    _In_ ULONG BufferLength,&#10;    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtAdjustPrivilegesToken</a></code></td>
</tr>
<tr>
  <td><code>TOKEN_ADJUST_GROUPS</code></td>
  <td>Allows adjusting token privileges via <code><a href="ntadjustgroupstoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtAdjustGroupsToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ BOOLEAN ResetToDefault,&#10;    _In_opt_ PTOKEN_GROUPS NewState,&#10;    _In_opt_ ULONG BufferLength,&#10;    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,&#10;    _Out_opt_ PULONG ReturnLength&#10;    );">NtAdjustGroupsToken</a></code></td>
</tr>
<tr>
  <td><code>TOKEN_ADJUST_DEFAULT</code></td>
  <td>Allows setting most information classes via <code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code>.</td>
</tr>
<tr>
  <td><code>TOKEN_ADJUST_SESSIONID</code></td>
  <td>Allows setting <code><a href="tokensessionid" title="#define TokenSessionId 12 // q; s: ULONG (requires SeTcbPrivilege)">TokenSessionId</a></code> via <code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code>.</td>
</tr>
<tr>
  <td><code>TOKEN_ALL_ACCESS_P</code></td>
  <td>All of the above except for the <code>TOKEN_ADJUST_SESSIONID</code> right, plus standard rights.</td>
</tr>
<tr>
  <td><code>TOKEN_ALL_ACCESS</code></td>
  <td>All of the above plus standard rights.</td>
</tr>
</tbody>
</table>

<h1 id="notable-return-values">Notable return values</h1>

<ul>
<li><code>STATUS_BAD_IMPERSONATION_LEVEL</code> - the caller attempted to raise impersonation level of a token or convert an anonymous- or identification-level token into a primary token.</li>
</ul>

<h1 id="remarks">Remarks</h1>

<p>Here is a table describing which type/level conversions are allowed:</p>

<table>
<thead>
<tr>
  <th style="text-align:right;">Source ↓ \ Destination →</th>
  <th style="text-align:center;">Anonymous</th>
  <th style="text-align:center;">Identification</th>
  <th style="text-align:center;">Impersonation</th>
  <th style="text-align:center;">Delegation</th>
  <th style="text-align:center;">Primary</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:right;">Anonymous</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">No</td>
</tr>
<tr>
  <td style="text-align:right;">Identification</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">No</td>
</tr>
<tr>
  <td style="text-align:right;">Impersonation</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">No</td>
  <td style="text-align:center;">Yes</td>
</tr>
<tr>
  <td style="text-align:right;">Delegation</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
</tr>
<tr>
  <td style="text-align:right;">Primary</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
  <td style="text-align:center;">Yes</td>
</tr>
</tbody>
</table>

<p>Note that this function does not support token pseudo-handles such as <code><a href="ntcurrentprocesstoken" title="#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) // NtOpenProcessToken(NtCurrentProcess())">NtCurrentProcessToken</a></code>. If you want to duplicate the current process/thread token, you need to open it first.</p>

<p>To avoid retaining unused resources, call <code><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></code> to close the returned handle when it is no longer required.</p>

<h1 id="related-win32-api">Related Win32 API</h1>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetoken"><code>DuplicateToken</code></a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex"><code>DuplicateTokenEx</code></a></li>
</ul>

<h1 id="see-also">See also</h1>

<ul>
<li><code><a href="ntopenprocesstoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenProcessToken(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenProcessToken</a></code></li>
<li><code><a href="ntopenthreadtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenThreadToken(&#10;    _In_ HANDLE ThreadHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ BOOLEAN OpenAsSelf,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenThreadToken</a></code></li>
<li><code><a href="ntfiltertoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtFilterToken(&#10;    _In_ HANDLE ExistingTokenHandle,&#10;    _In_ ULONG Flags,&#10;    _In_opt_ PTOKEN_GROUPS SidsToDisable,&#10;    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,&#10;    _In_opt_ PTOKEN_GROUPS RestrictedSids,&#10;    _Out_ PHANDLE NewTokenHandle&#10;    );">NtFilterToken</a></code></li>
<li><code><a href="ntcreatelowboxtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateLowBoxToken(&#10;    _Out_ PHANDLE TokenHandle,&#10;    _In_ HANDLE ExistingTokenHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,&#10;    _In_ PSID PackageSid,&#10;    _In_ ULONG CapabilityCount,&#10;    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,&#10;    _In_ ULONG HandleCount,&#10;    _In_reads_opt_(HandleCount) HANDLE *Handles&#10;    );">NtCreateLowBoxToken</a></code></li>
<li><code><a href="ntqueryinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtQueryInformationToken</a></code></li>
<li><code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code></li>
<li><code><a href="ntcomparetokens" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCompareTokens(&#10;    _In_ HANDLE FirstTokenHandle,&#10;    _In_ HANDLE SecondTokenHandle,&#10;    _Out_ PBOOLEAN Equal&#10;    );">NtCompareTokens</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntduplicatetoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntduplicatetoken)</h1>
</div>
<div class="ntdoc-description">
<h1>NtDuplicateToken function</h1>

<h2>Description</h2>

<p>The <strong>NtDuplicateToken</strong> function creates a handle to a new <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/secgloss/a-gly"><strong>access token</strong></a> that duplicates an existing token. This function can create either a primary token or an impersonation token.</p>

<h2>Parameters</h2>

<h3><code>ExistingTokenHandle</code> [in]</h3>

<p>A handle to an existing access token that was opened with the TOKEN_DUPLICATE access right. This parameter is required and can't be NULL.</p>

<h3><code>DesiredAccess</code> [in]</h3>

<p>Bitmask that specifies the requested access rights for the new token. <strong>NtDuplicateToken</strong> compares the requested access rights with the existing token's discretionary access control list (DACL) to determine which rights are granted or denied to the new token. To request the same access rights as the existing token, specify zero. To request all access rights that are valid for the caller, specify MAXIMUM_ALLOWED. This parameter is optional and can either be zero, MAXIMUM_ALLOWED, or a bitwise OR combination of one or more of the following values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>DELETE</td>
  <td>Required to delete the object.</td>
</tr>
<tr>
  <td>READ_CONTROL</td>
  <td>Required to read the DACL and ownership information for the object. For access to the system access control list (SACL), see ACCESS_SYSTEM_SECURITY later in this table.</td>
</tr>
<tr>
  <td>WRITE_DAC</td>
  <td>Required to change the DACL information for the object.</td>
</tr>
<tr>
  <td>WRITE_OWNER</td>
  <td>Required to change the ownership information in the object's security descriptor (<strong><a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a></strong>).</td>
</tr>
<tr>
  <td>ACCESS_SYSTEM_SECURITY</td>
  <td>Required to get or set the SACL in an object's <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a>. The operating system grants this right to the new token only if the SE_SECURITY_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_READ</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_WRITE</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_EXECUTE</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_REQUIRED</td>
  <td>Combines DELETE, READ_CONTROL, WRITE_DAC, and WRITE_OWNER access.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_ALL</td>
  <td>Combines DELETE, READ_CONTROL, WRITE_DAC, WRITE_OWNER, and SYNCHRONIZE access. However, the SYNCHRONIZE value is not applicable to token objects. Thus, STANDARD_RIGHTS_ALL has a functionally equivalent to STANDARD_RIGHTS_REQUIRED.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_DEFAULT</td>
  <td>Required to change the default owner, primary group, or DACL of an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_GROUPS</td>
  <td>Required to adjust the attributes of the groups in an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_PRIVILEGES</td>
  <td>Required to enable or disable the privileges in an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_SESSIONID</td>
  <td>Required to adjust the session ID (<a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a>) of an access token. The operating system grants this right to the new token only if the SE_TCB_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>TOKEN_ASSIGN_PRIMARY</td>
  <td>Required to attach a primary token to a process. The operating system grants this right to the new token only if the SE_ASSIGNPRIMARYTOKEN_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>TOKEN_DUPLICATE</td>
  <td>Required to duplicate an access token. Note that the given <strong>ExistingTokenHandle</strong> token must contain this right in order to successfully use this routine.</td>
</tr>
<tr>
  <td>TOKEN_EXECUTE</td>
  <td>Combines STANDARD_RIGHTS_EXECUTE and TOKEN_IMPERSONATE.</td>
</tr>
<tr>
  <td>TOKEN_IMPERSONATE</td>
  <td>Required to attach an impersonation access token to a process.</td>
</tr>
<tr>
  <td>TOKEN_QUERY</td>
  <td>Required to query an access token.</td>
</tr>
<tr>
  <td>TOKEN_QUERY_SOURCE</td>
  <td>Required to query the source of an access token.</td>
</tr>
<tr>
  <td>TOKEN_READ</td>
  <td>Combines STANDARD_RIGHTS_READ and TOKEN_QUERY.</td>
</tr>
<tr>
  <td>TOKEN_WRITE</td>
  <td>Combines STANDARD_RIGHTS_WRITE, TOKEN_ADJUST_PRIVILEGES, TOKEN_ADJUST_GROUPS, and TOKEN_ADJUST_DEFAULT.</td>
</tr>
<tr>
  <td>TOKEN_ALL_ACCESS</td>
  <td>Combines all possible token access permissions for a token.</td>
</tr>
</tbody>
</table>

<p>For additional information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/secauthz/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a>. Note that access tokens do not support the SYNCHRONIZE right.</p>

<h3><code>ObjectAttributes</code> [in]</h3>

<p>Pointer to an <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> structure that describes the requested properties for the new token. The <strong>ObjectAttributes</strong> parameter is optional and can be NULL. If the <strong>ObjectAttributes</strong> parameter is NULL or if the <strong>SecurityDescriptor</strong> member of the structure pointed to by the <strong>ObjectAttributes</strong> parameter is NULL, the new token receives a default security descriptor and the new token handle cannot be inherited. In that case, this default security descriptor is created from the user group, primary group, and DACL information that is stored in the caller's token.</p>

<p>When the <strong>TokenType</strong> parameter is set to <strong>TokenImpersonation</strong>:</p>

<ul>
<li>The <strong>ObjectAttributes</strong> parameter may be used to specify the impersonation level of the new token. This can be accomplished by setting <strong>ObjectAttributes</strong>->SecurityQualityOfService.ImpersonationLevel to an appropriate <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> enumeration value. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-security_quality_of_service"><strong>SECURITY_QUALITY_OF_SERVICE</strong></a>.</li>
<li>If the existing token is an impersonation token and the <strong>ObjectAttributes</strong> parameter provides no impersonation information, the new token's impersonation level is set to the existing token's impersonation level.</li>
<li>If the existing token is a primary token and no impersonation level information is provided, the new impersonation token will have a <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> impersonation level.</li>
</ul>

<h3><code>EffectiveOnly</code> [in]</h3>

<p>A Boolean value that indicates whether the entire existing token should be duplicated into the new token or just the effective (currently enabled) part of the token. If set to <strong>TRUE</strong>, only the currently enabled parts of the source token will be duplicated. If set to <strong>FALSE</strong>, the entire existing token will be duplicated. This provides a means for a caller of a protected subsystem to limit which optional groups and privileges are made available to the protected subsystem. For example, if <strong>EffectiveOnly</strong> is <strong>TRUE</strong>, the caller could duplicate a token but remove the Administrators group and the SeTcbPrivilege right. The resulting token could then be passed to a child process (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera"><strong>CreateProcessAsUser</strong></a>), which would restrict what the child process can do. This parameter is required.</p>

<h3><code>TokenType</code> [in]</h3>

<p>Specifies one of the following values from the <strong><a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong> enumeration.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>TokenPrimary</strong></td>
  <td>The new token is a primary token. If the existing token is an impersonation token, the existing impersonation token must have an impersonation level (as provided by the <strong>ObjectAttributes</strong> parameter) of <strong>SecurityImpersonation</strong> or <strong>SecurityDelegation</strong>. Otherwise, <strong>NtDuplicateToken</strong> returns STATUS_BAD_IMPERSONATION_LEVEL is returned.</td>
</tr>
<tr>
  <td><strong>TokenImpersonation</strong></td>
  <td>The new token is an impersonation token. If the existing token is an impersonation token, the requested impersonation level (as provided by the <strong>ObjectAttributes</strong> parameter) of the new token must not be greater than the impersonation level of the existing token. Otherwise, <strong>NtDuplicateToken</strong> returns STATUS_BAD_IMPERSONATION_LEVEL.</td>
</tr>
</tbody>
</table>

<p>The <strong>TokenType</strong> parameter is required and cannot be NULL.</p>

<h3><code>NewTokenHandle</code> [out]</h3>

<p>A pointer to a caller-allocated variable, of type HANDLE, that receives a handle to the new token. This parameter is required and cannot be NULL.</p>

<h2>Return value</h2>

<p><strong>NtDuplicateToken</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the call is successful. Possible error return codes include the following:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STATUS_ACCESS_VIOLATION</td>
  <td>A memory access violation occurred. For example, if the previous mode was user-mode and invalid user-mode memory was provided, <strong>NtDuplicateToken</strong> returns STATUS_ACCESS_VIOLATION.</td>
</tr>
<tr>
  <td>STATUS_INSUFFICIENT_RESOURCES</td>
  <td>Sufficient memory could not be allocated to duplicate the new token.</td>
</tr>
<tr>
  <td>STATUS_INVALID_PARAMETER</td>
  <td>An invalid parameter was detected.</td>
</tr>
<tr>
  <td>STATUS_BAD_IMPERSONATION_LEVEL</td>
  <td>The requested impersonation level for the new token is greater than the impersonation level of the existing token.</td>
</tr>
<tr>
  <td>STATUS_ACCESS_DENIED</td>
  <td><strong>NtDuplicateToken</strong> couldn't access <strong>ExistingTokenHandle</strong>. This would occur if the existing token does not have the TOKEN_DUPLICATE access right.</td>
</tr>
<tr>
  <td>STATUS_INVALID_HANDLE</td>
  <td><strong>ExistingTokenHandle</strong> refers to an invalid handle.</td>
</tr>
</tbody>
</table>

<h2>Remarks</h2>

<p>If no impersonation level information was provided by the <strong>ObjectAttributes</strong> parameter, the existing token's impersonation level will be used for the new token.</p>

<p>With regard to the structure pointed to by the optional <strong>ObjectAttributes</strong> parameter, the <strong>SecurityQualityOfService</strong> member of <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> points to a structure of type <strong>SECURITY_QUALITY_OF_SERVICE</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-security_quality_of_service"><strong>SECURITY_QUALITY_OF_SERVICE</strong></a> for information on the members of this structure.</p>

<p>The <strong>SecurityQualityOfService</strong> member must be set <em>after</em> calling the <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> macro because <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> currently sets <strong>SecurityQualityOfService</strong> to NULL.</p>

<p>For information on the user-mode analog of <strong>NtDuplicateToken</strong>, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex"><strong>DuplicateTokenEx</strong></a> in the Windows SDK documentation.</p>

<p>When you have finished using the new token, call the <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">NtClose</a></strong> function to close the token handle.</p>

<p>If the call to the <strong>NtDuplicateToken</strong> function occurs in user mode, you should use the name "<strong>NtDuplicateToken</strong>" instead of "<strong>NtDuplicateToken</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a></p>

<p><strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong></p>

<p><strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong></p>

<p><strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntduplicatetoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-zwduplicatetoken)</h1>
</div>
<div class="ntdoc-description">
<h1>ZwDuplicateToken function</h1>

<h2>Description</h2>

<p>The <strong>ZwDuplicateToken</strong> function creates a handle to a new <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/secgloss/a-gly">access token</a> that duplicates an existing token. This function can create either a primary token or an impersonation token.</p>

<h2>Parameters</h2>

<h3><code>ExistingTokenHandle</code> [in]</h3>

<p>A handle to an existing access token that was opened with the TOKEN_DUPLICATE access right. This parameter is required and cannot be NULL.</p>

<h3><code>DesiredAccess</code> [in]</h3>

<p>Bitmask that specifies the requested access rights for the new token. <strong>ZwDuplicateToken</strong> compares the requested access rights with the existing token's discretionary access control list (DACL) to determine which rights are granted or denied to the new token. To request the same access rights as the existing token, specify zero. To request all access rights that are valid for the caller, specify MAXIMUM_ALLOWED. This parameter is optional and can either be zero, MAXIMUM_ALLOWED, or a bitwise OR combination of one or more of the following values:</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>DELETE</td>
  <td>Required to delete the object.</td>
</tr>
<tr>
  <td>READ_CONTROL</td>
  <td>Required to read the DACL and ownership information for the object. For access to the system access control list (SACL), see ACCESS_SYSTEM_SECURITY later in this table.</td>
</tr>
<tr>
  <td>WRITE_DAC</td>
  <td>Required to change the DACL information for the object.</td>
</tr>
<tr>
  <td>WRITE_OWNER</td>
  <td>Required to change the ownership information in the object's security descriptor (<strong><a href="pisecurity_descriptor" title="typedef struct _SECURITY_DESCRIPTOR {&#10;  UCHAR                       Revision;&#10;  UCHAR                       Sbz1;&#10;  SECURITY_DESCRIPTOR_CONTROL Control;&#10;  PSID                        Owner;&#10;  PSID                        Group;&#10;  PACL                        Sacl;&#10;  PACL                        Dacl;&#10;} SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;">SECURITY_DESCRIPTOR</a></strong>).</td>
</tr>
<tr>
  <td>ACCESS_SYSTEM_SECURITY</td>
  <td>Required to get or set the SACL in an object's <a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a>. The operating system grants this right to the new token only if the SE_SECURITY_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_READ</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_WRITE</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_EXECUTE</td>
  <td>Currently defined to equal READ_CONTROL.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_REQUIRED</td>
  <td>Combines DELETE, READ_CONTROL, WRITE_DAC, and WRITE_OWNER access.</td>
</tr>
<tr>
  <td>STANDARD_RIGHTS_ALL</td>
  <td>Combines DELETE, READ_CONTROL, WRITE_DAC, WRITE_OWNER, and SYNCHRONIZE access. However, the SYNCHRONIZE value is not applicable to token objects. Thus, STANDARD_RIGHTS_ALL has a functionally equivalent to STANDARD_RIGHTS_REQUIRED.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_DEFAULT</td>
  <td>Required to change the default owner, primary group, or DACL of an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_GROUPS</td>
  <td>Required to adjust the attributes of the groups in an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_PRIVILEGES</td>
  <td>Required to enable or disable the privileges in an access token.</td>
</tr>
<tr>
  <td>TOKEN_ADJUST_SESSIONID</td>
  <td>Required to adjust the session ID (<a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a>) of an access token. The operating system grants this right to the new token only if the SE_TCB_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>TOKEN_ASSIGN_PRIMARY</td>
  <td>Required to attach a primary token to a process. The operating system grants this right to the new token only if the SE_ASSIGNPRIMARYTOKEN_NAME privilege is enabled in the access token of the calling thread.</td>
</tr>
<tr>
  <td>TOKEN_DUPLICATE</td>
  <td>Required to duplicate an access token. Note that the given <strong>ExistingTokenHandle</strong> token must contain this right in order to successfully use this routine.</td>
</tr>
<tr>
  <td>TOKEN_EXECUTE</td>
  <td>Combines STANDARD_RIGHTS_EXECUTE and TOKEN_IMPERSONATE.</td>
</tr>
<tr>
  <td>TOKEN_IMPERSONATE</td>
  <td>Required to attach an impersonation access token to a process.</td>
</tr>
<tr>
  <td>TOKEN_QUERY</td>
  <td>Required to query an access token.</td>
</tr>
<tr>
  <td>TOKEN_QUERY_SOURCE</td>
  <td>Required to query the source of an access token.</td>
</tr>
<tr>
  <td>TOKEN_READ</td>
  <td>Combines STANDARD_RIGHTS_READ and TOKEN_QUERY.</td>
</tr>
<tr>
  <td>TOKEN_WRITE</td>
  <td>Combines STANDARD_RIGHTS_WRITE, TOKEN_ADJUST_PRIVILEGES, TOKEN_ADJUST_GROUPS, and TOKEN_ADJUST_DEFAULT.</td>
</tr>
<tr>
  <td>TOKEN_ALL_ACCESS</td>
  <td>Combines all possible token access permissions for a token.</td>
</tr>
</tbody>
</table>

<p>For additional information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/secauthz/access-rights-for-access-token-objects">Access Rights for Access-Token Objects</a> in the Windows SDK. Note that access tokens do not support the SYNCHRONIZE right.</p>

<h3><code>ObjectAttributes</code> [in]</h3>

<p>Pointer to an <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> structure that describes the requested properties for the new token. The <strong>ObjectAttributes</strong> parameter is optional and can be NULL. If the <strong>ObjectAttributes</strong> parameter is NULL or if the <strong>SecurityDescriptor</strong> member of the structure pointed to by the <strong>ObjectAttributes</strong> parameter is NULL, the new token receives a default security descriptor and the new token handle cannot be inherited. In that case, this default security descriptor is created from the user group, primary group, and DACL information that is stored in the caller's token.</p>

<p>When the <strong>TokenType</strong> parameter is set to <strong>TokenImpersonation</strong>:</p>

<ul>
<li><p>The <strong>ObjectAttributes</strong> parameter may be used to specify the impersonation level of the new token. This can be accomplished by setting <strong>ObjectAttributes</strong>->SecurityQualityOfService.ImpersonationLevel to an appropriate <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> enumeration value. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-security_quality_of_service"><strong>SECURITY_QUALITY_OF_SERVICE</strong></a>.</p></li>
<li><p>If the existing token is an impersonation token and the <strong>ObjectAttributes</strong> parameter provides no impersonation information, the new token's impersonation level is set to the existing token's impersonation level.</p></li>
<li><p>If the existing token is a primary token and no impersonation level information is provided, the new impersonation token will have a <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> impersonation level.</p></li>
</ul>

<h3><code>EffectiveOnly</code> [in]</h3>

<p>A Boolean value that indicates whether the entire existing token should be duplicated into the new token or just the effective (currently enabled) part of the token. If set to TRUE, only the currently enabled parts of the source token will be duplicated. If set to FALSE, the entire existing token will be duplicated. This provides a means for a caller of a protected subsystem to limit which optional groups and privileges are made available to the protected subsystem. For example, if <strong>EffectiveOnly</strong> is TRUE, the caller could duplicate a token but remove the Administrators group and the SeTcbPrivilege right. The resulting token could then be passed to a child process (<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera"><strong>CreateProcessAsUser</strong></a>), which would restrict what the child process can do. This parameter is required.</p>

<h3><code>TokenType</code> [in]</h3>

<p>Specifies one of the following values from the <strong><a href="token_type" title="typedef enum _TOKEN_TYPE {&#10;  TokenPrimary,&#10;  TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong> enumeration.</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>TokenPrimary</strong></td>
  <td>The new token is a primary token. If the existing token is an impersonation token, the existing impersonation token must have an impersonation level (as provided by the <strong>ObjectAttributes</strong> parameter) of <strong>SecurityImpersonation</strong> or <strong>SecurityDelegation</strong>. Otherwise, <strong>ZwDuplicateToken</strong> returns STATUS_BAD_IMPERSONATION_LEVEL is returned.</td>
</tr>
<tr>
  <td><strong>TokenImpersonation</strong></td>
  <td>The new token is an impersonation token. If the existing token is an impersonation token, the requested impersonation level (as provided by the <strong>ObjectAttributes</strong> parameter) of the new token must not be greater than the impersonation level of the existing token. Otherwise, <strong>ZwDuplicateToken</strong> returns STATUS_BAD_IMPERSONATION_LEVEL.</td>
</tr>
</tbody>
</table>

<p>The <strong>TokenType</strong> parameter is required and cannot be NULL.</p>

<h3><code>NewTokenHandle</code> [out]</h3>

<p>A pointer to a caller-allocated variable, of type HANDLE, that receives a handle to the new token. This parameter is required and cannot be NULL.</p>

<h2>Return value</h2>

<p><strong>ZwDuplicateToken</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the call is successful. Possible error return codes include the following:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>STATUS_ACCESS_VIOLATION</td>
  <td>A memory access violation occurred. For example, if the previous mode was user-mode and invalid user-mode memory was provided, <strong>ZwDuplicateToken</strong> returns STATUS_ACCESS_VIOLATION.</td>
</tr>
<tr>
  <td>STATUS_INSUFFICIENT_RESOURCES</td>
  <td>Sufficient memory could not be allocated to duplicate the new token.</td>
</tr>
<tr>
  <td>STATUS_INVALID_PARAMETER</td>
  <td>An invalid parameter was detected.</td>
</tr>
<tr>
  <td>STATUS_BAD_IMPERSONATION_LEVEL</td>
  <td>The requested impersonation level for the new token is greater than the impersonation level of the existing token.</td>
</tr>
<tr>
  <td>STATUS_ACCESS_DENIED</td>
  <td><strong>ZwDuplicateToken</strong> returns STATUS_ACCESS_DENIED if it couldn't access <strong>ExistingTokenHandle</strong>. This would occur if the existing token does not have the TOKEN_DUPLICATE access right.</td>
</tr>
<tr>
  <td>STATUS_INVALID_HANDLE</td>
  <td><strong>ZwDuplicateToken</strong> returns STATUS_INVALID_HANDLE if <strong>ExistingTokenHandle</strong> refers to an invalid handle.</td>
</tr>
</tbody>
</table>

<h2>Remarks</h2>

<p>If no impersonation level information was provided by the <strong>ObjectAttributes</strong> parameter, the existing token's impersonation level will be used for the new token.</p>

<p>With regard to the structure pointed to by the optional <strong>ObjectAttributes</strong> parameter, the <strong>SecurityQualityOfService</strong> member of <strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong> points to a structure of type <strong>SECURITY_QUALITY_OF_SERVICE</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-security_quality_of_service"><strong>SECURITY_QUALITY_OF_SERVICE</strong></a> for information on the members of this structure.</p>

<p>The <strong>SecurityQualityOfService</strong> member must be set <em>after</em> calling the <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> macro because <strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong> currently sets <strong>SecurityQualityOfService</strong> to NULL.</p>

<p>For information on the user-mode analog of <strong>ZwDuplicateToken</strong>, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex"><strong>DuplicateTokenEx</strong></a>.</p>

<p>When you have finished using the new token, call the <strong><a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a></strong> function to close the token handle.</p>

<p>If the call to the <strong>ZwDuplicateToken</strong> function occurs in user mode, you should use the name "<strong>NtDuplicateToken</strong>" instead of "<strong>ZwDuplicateToken</strong>".</p>

<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a></p>

<p><strong><a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a></strong></p>

<p><strong><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></strong></p>

<p><strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwduplicatetoken">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-zwduplicatetoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntduplicatetoken">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwduplicatetoken">here</a>.</p>

<hr />

<p>Function <code>NtDuplicateToken</code> creates new Token Object basing on existing Token Object.</p>

<h3>ExistingToken</h3>

<p><code>HANDLE</code> to Token Object opened with <code>TOKEN_DUPLICATE</code> access.</p>

<h3>DesiredAccess</h3>

<p>Access mask for newly created token. Can be combination of:</p>

<ul>
<li><code>TOKEN_ASSIGN_PRIMARY</code></li>
<li><code>TOKEN_DUPLICATE</code></li>
<li><code>TOKEN_IMPERSONATE</code></li>
<li><code>TOKEN_QUERY</code></li>
<li><code>TOKEN_QUERY_SOURCE</code></li>
<li><code>TOKEN_ADJUST_PRIVILEGES</code></li>
<li><code>TOKEN_ADJUST_GROUPS</code></li>
<li><code>TOKEN_ADJUST_DEFAULT</code></li>
<li><code>TOKEN_ADJUST_SESSIONID</code></li>
</ul>

<h3>ObjectAttributes</h3>

<p>Optionally pointer to <code><a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PVOID SecurityDescriptor; // PSECURITY_DESCRIPTOR;&#10;    PVOID SecurityQualityOfService; // PSECURITY_QUALITY_OF_SERVICE&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a></code> structure, containing token's name.</p>

<h3>ImpersonationLevel</h3>

<p>Level of impersonation for new token.</p>

<h3>TokenType</h3>

<p>Type of new token.</p>

<h3>NewToken</h3>

<p>Result of call - pointer to <code>HANDLE</code> to new Token Object.</p>

<h1>Documented by</h1>

<ul>
<li>Tomasz Nowak</li>
<li>ReactOS</li>
</ul>

<h1>See also</h1>

<ul>
<li><code><a href="ntcreatetoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateToken(&#10;    _Out_ PHANDLE TokenHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,&#10;    _In_ TOKEN_TYPE Type,&#10;    _In_ PLUID AuthenticationId,&#10;    _In_ PLARGE_INTEGER ExpirationTime,&#10;    _In_ PTOKEN_USER User,&#10;    _In_ PTOKEN_GROUPS Groups,&#10;    _In_ PTOKEN_PRIVILEGES Privileges,&#10;    _In_opt_ PTOKEN_OWNER Owner,&#10;    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,&#10;    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,&#10;    _In_ PTOKEN_SOURCE Source&#10;    );">NtCreateToken</a></code></li>
<li><code><a href="ntopenprocesstoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenProcessToken(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenProcessToken</a></code></li>
<li><code><a href="ntopenthreadtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenThreadToken(&#10;    _In_ HANDLE ThreadHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ BOOLEAN OpenAsSelf,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenThreadToken</a></code></li>
<li><code><a href="ntqueryinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtQueryInformationToken</a></code></li>
<li><code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntduplicatetoken.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
