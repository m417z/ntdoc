<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtQueryInformationToken - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtQueryInformationToken - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtQueryInformationToken - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTSEAPI_H

</span><span class="ntdoc-code-intro language-cpp">/**
 * The NtQueryInformationToken routine retrieves a specified type of information about an access token. The calling process must have appropriate access rights to obtain the information.
 *
 * \param TokenHandle A handle to an existing access token from which information is to be retrieved. If TokenInformationClass is set to TokenSource, the handle must have TOKEN_QUERY_SOURCE access.
 * For all other TokenInformationClass values, the handle must have TOKEN_QUERY access.
 * \param TokenInformationClass A value from the <a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a> enumerated type identifying the type of information to be retrieved.
 * \param TokenInformation Pointer to a caller-allocated buffer that receives the requested information about the token.
 * \param TokenInformationLength Length, in bytes, of the caller-allocated TokenInformation buffer.
 * \param ReturnLength Pointer to a caller-allocated variable that receives the actual length, in bytes, of the information returned in the TokenInformation buffer.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationtoken
 */
</span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ <a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a> TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TokenInformationLength,
    _Out_ PULONG ReturnLength
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/9dc3ba43292cf685c02155f6faefe336524edae8/phnt/include/ntseapi.h#L708">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ <a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a> TokenInformationClass,
    _Out_writes_bytes_to_opt_(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> TokenInformationLength,
    _Out_ PULONG ReturnLength
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/9dc3ba43292cf685c02155f6faefe336524edae8/phnt/include/ntzwapi.h#L3206">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntifs.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtQueryInformationToken(
  [in]  HANDLE                  TokenHandle,
  [in]  <a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a> TokenInformationClass,
  [out] PVOID                   TokenInformation,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   TokenInformationLength,
  [out] PULONG                  ReturnLength
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationtoken">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntifs.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwQueryInformationToken(
  [in]  HANDLE                  TokenHandle,
  [in]  <a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a> TokenInformationClass,
  [out] PVOID                   TokenInformation,
  [in]  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                   TokenInformationLength,
  [out] PULONG                  ReturnLength
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwqueryinformationtoken">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<p>Queries various information about the specified token. This function is partially documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationtoken">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwqueryinformationtoken">here</a>.</p>
<h1>Parameters</h1>
<ul>
<li><code>TokenHandle</code> - a handle to the token or one of the supported pseudo-handles (see below). For most information classes, the handle must grant <code>TOKEN_QUERY</code> access.</li>
<li><code>TokenInformationClass</code> - the type of information to retrieve.</li>
<li><code>TokenInformation</code> - a pointer to a user-allocated buffer that receives the requested information.</li>
<li><code>TokenInformationLength</code> - the size of the provided buffer in bytes.</li>
<li><code>ReturnLength</code> - an optional pointer to a variable that receives the number of bytes written when the function succeeds or the number of bytes requires when the buffer is too small.</li>
</ul>
<h1>Information classes</h1>
<p>For the list of supported info classes and required token access, see <code><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></code>.</p>
<h1>Pseudo-handles</h1>
<p>This function supports the following pseudo-handle values <strong>on Windows 8 and above</strong>:</p>
<ul>
<li><code><a href="ntcurrentprocesstoken" title="#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) // NtOpenProcessToken(NtCurrentProcess())">NtCurrentProcessToken</a></code> - performs the query on the primary token of the calling process.</li>
<li><code><a href="ntcurrentthreadtoken" title="#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5) // NtOpenThreadToken(NtCurrentThread())">NtCurrentThreadToken</a></code> - performs the query on the impersonation token of the calling thread. The function fails if the thread is not impersonating.</li>
<li><code><a href="ntcurrentthreadeffectivetoken" title="#define NtCurrentThreadEffectiveToken() ((HANDLE)(LONG_PTR)-6) // NtOpenThreadToken(NtCurrentThread()) + NtOpenProcessToken(NtCurrentProcess())">NtCurrentThreadEffectiveToken</a></code> - performs the query on the impersonation token of the calling thread, if present. Otherwise, the function uses the primary token of the calling process.</li>
</ul>
<h1>Notable return values</h1>
<ul>
<li><code>STATUS_BUFFER_TOO_SMALL</code> and <code>STATUS_INFO_LENGTH_MISMATCH</code> indicate that the requested information does not fit into the provided buffer.</li>
<li><code>STATUS_CANT_OPEN_ANONYMOUS</code> indicates that the caller attempted to query information about the current thread token while impersonating an anonymous token.</li>
</ul>
<h1>Related Win32 API</h1>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation"><code>GetTokenInformation</code></a></li>
</ul>
<h1>See also</h1>
<ul>
<li><code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code></li>
<li><code><a href="ntquerysecurityattributestoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQuerySecurityAttributesToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_reads_opt_(NumberOfAttributes) PCUNICODE_STRING Attributes,&#10;    _In_ ULONG NumberOfAttributes,&#10;    _Out_writes_bytes_(Length) PVOID Buffer, // PTOKEN_SECURITY_ATTRIBUTES_INFORMATION&#10;    _In_ ULONG Length,&#10;    _Out_ PULONG ReturnLength&#10;    );">NtQuerySecurityAttributesToken</a></code></li>
<li><code><a href="ntopenprocesstoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenProcessToken(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenProcessToken</a></code></li>
<li><code><a href="ntopenthreadtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenThreadToken(&#10;    _In_ HANDLE ThreadHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ BOOLEAN OpenAsSelf,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenThreadToken</a></code></li>
<li><code><a href="ntduplicatetoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtDuplicateToken(&#10;    _In_ HANDLE ExistingTokenHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,&#10;    _In_ BOOLEAN EffectiveOnly,&#10;    _In_ TOKEN_TYPE Type,&#10;    _Out_ PHANDLE NewTokenHandle&#10;    );">NtDuplicateToken</a></code></li>
<li><code><a href="ntcomparetokens" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCompareTokens(&#10;    _In_ HANDLE FirstTokenHandle,&#10;    _In_ HANDLE SecondTokenHandle,&#10;    _Out_ PBOOLEAN Equal&#10;    );">NtCompareTokens</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntqueryinformationtoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntqueryinformationtoken)</h1>
</div>
<div class="ntdoc-description">
<h1>NtQueryInformationToken function</h1>
<h2>Description</h2>
<p>The <strong>NtQueryInformationToken</strong> routine retrieves a specified type of information about an access token. The calling process must have appropriate access rights to obtain the information.</p>
<h2>Parameters</h2>
<h3><code>TokenHandle</code> [in]</h3>
<p>Handle for an access token from which information is to be retrieved. If <strong>TokenInformationClass</strong> is set to <strong>TokenSource</strong>, the handle must have TOKEN_QUERY_SOURCE access. For all other <strong>TokenInformationClass</strong> values, the handle must have TOKEN_QUERY access. For more information about access rights for access-token objects, see the Security section of the Windows SDK documentation.</p>
<h3><code>TokenInformationClass</code> [in]</h3>
<p>A value from the <strong><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></strong> enumerated type identifying the type of information to be retrieved. The possible values for this parameter are listed in the <strong>TokenInformationClass</strong> Value column of the table shown in the description of the <strong>TokenInformation</strong> parameter.</p>
<h3><code>TokenInformation</code> [out]</h3>
<p>Pointer to a caller-allocated buffer that receives the requested information about the token. The structure put into this buffer depends upon the value of <strong>TokenInformationClass</strong>, as shown in the following table. All structures must be aligned on a 32-bit boundary.</p>
<table>
<thead>
<tr>
<th>TokenInformationClass value</th>
<th>Effect on TokenInformation buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TokenDefaultDacl</strong></td>
<td>The buffer receives a <strong><a href="token_default_dacl" title="typedef struct _TOKEN_DEFAULT_DACL&#10;{&#10;    PACL DefaultDacl;&#10;} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;">TOKEN_DEFAULT_DACL</a></strong> structure containing the default <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_acl"><strong>DACL</strong></a> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenGroups</strong></td>
<td>The buffer receives a <strong><a href="token_groups" title="typedef struct _TOKEN_GROUPS&#10;{&#10;    ULONG GroupCount;&#10;    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];&#10;} TOKEN_GROUPS, *PTOKEN_GROUPS;">TOKEN_GROUPS</a></strong> structure containing the group accounts associated with the token.</td>
</tr>
<tr>
<td><strong>TokenImpersonationLevel</strong></td>
<td>The buffer receives a <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> value indicating the impersonation level of the token. If the access token is not an impersonation token, the call to <strong>NtQueryInformationToken</strong> fails.</td>
</tr>
<tr>
<td><strong>TokenOwner</strong></td>
<td>The buffer receives a <strong><a href="token_owner" title="typedef struct _TOKEN_OWNER&#10;{&#10;    PSID Owner;&#10;} TOKEN_OWNER, *PTOKEN_OWNER;">TOKEN_OWNER</a></strong> structure containing the default owner <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenPrimaryGroup</strong></td>
<td>The buffer receives a <strong><a href="token_primary_group" title="typedef struct _TOKEN_PRIMARY_GROUP&#10;{&#10;    PSID PrimaryGroup;&#10;} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;">TOKEN_PRIMARY_GROUP</a></strong> structure containing the default primary group <a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenPrivileges</strong></td>
<td>The buffer receives a <strong><a href="token_privileges" title="typedef struct _TOKEN_PRIVILEGES&#10;{&#10;    ULONG PrivilegeCount;&#10;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];&#10;} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;">TOKEN_PRIVILEGES</a></strong> structure containing the token's privileges.</td>
</tr>
<tr>
<td><strong>TokenSessionId</strong></td>
<td>The buffer receives a 32-bit value specifying the Terminal Services session identifier associated with the token. If the token is associated with the Terminal Server console session, the session identifier is zero. A nonzero session identifier indicates a Terminal Services client session. In a non-Terminal Services environment, the session identifier is zero.</td>
</tr>
<tr>
<td><strong>TokenSource</strong></td>
<td>The buffer receives a <strong><a href="token_source" title="typedef struct _TOKEN_SOURCE&#10;{&#10;    CHAR SourceName[TOKEN_SOURCE_LENGTH];&#10;    LUID SourceIdentifier;&#10;} TOKEN_SOURCE, *PTOKEN_SOURCE;">TOKEN_SOURCE</a></strong> structure containing the source of the token. TOKEN_QUERY_SOURCE access is needed to retrieve this information.</td>
</tr>
<tr>
<td><strong>TokenStatistics</strong></td>
<td>The buffer receives a <strong><a href="token_statistics" title="typedef struct _TOKEN_STATISTICS {&#10;  LUID                         TokenId;&#10;  LUID                         AuthenticationId;&#10;  LARGE_INTEGER                ExpirationTime;&#10;  TOKEN_TYPE                   TokenType;&#10;  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;&#10;  ULONG                        DynamicCharged;&#10;  ULONG                        DynamicAvailable;&#10;  ULONG                        GroupCount;&#10;  ULONG                        PrivilegeCount;&#10;  LUID                         ModifiedId;&#10;} TOKEN_STATISTICS, *PTOKEN_STATISTICS;">TOKEN_STATISTICS</a></strong> structure containing various token statistics.</td>
</tr>
<tr>
<td><strong>TokenType</strong></td>
<td>The buffer receives a <strong><a href="token_type" title="typedef enum _TOKEN_TYPE&#10;{&#10;    TokenPrimary = 1,&#10;    TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong> value indicating whether the token is a primary or impersonation token.</td>
</tr>
<tr>
<td><strong>TokenUser</strong></td>
<td>The buffer receives a <strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong> structure containing the token's user account.</td>
</tr>
</tbody>
</table>
<h3><code>TokenInformationLength</code> [in]</h3>
<p>Length, in bytes, of the caller-allocated <strong>TokenInformation</strong> buffer.</p>
<h3><code>ReturnLength</code> [out]</h3>
<p>Pointer to a caller-allocated variable that receives the actual length, in bytes, of the information returned in the <strong>TokenInformation</strong> buffer. If either of the following conditions is true, no data is returned in the <strong>TokenInformation</strong> buffer:</p>
<ul>
<li>
<p>The size of the requested token information structure is greater than <strong>TokenInformationLength</strong>. In this case, <strong>ReturnLength</strong> receives the actual number of bytes needed to store the requested information.</p>
</li>
<li>
<p>The value of <strong>TokenInformationClass</strong> is <strong>TokenDefaultDacl</strong>, and there is no default DACL established for the token. In this case, <strong>ReturnLength</strong> receives zero.</p>
</li>
</ul>
<p><strong>ReturnLength</strong> cannot be <strong>NULL</strong>. See Remarks for further information.</p>
<h2>Return value</h2>
<p><strong>NtQueryInformationToken</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate error status. Possible error status codes include the following:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_ACCESS_DENIED</td>
<td><strong>TokenHandle</strong> did not have the required access.</td>
</tr>
<tr>
<td>STATUS_BUFFER_TOO_SMALL</td>
<td>The size of the requested token information structure is greater than <strong>TokenInformationLength</strong>. The number of bytes required is returned in <strong>ReturnLength</strong>.</td>
</tr>
<tr>
<td>STATUS_ACCESS_VIOLATION</td>
<td><strong>ReturnLength</strong> was NULL or was not writable in order to receive the actual length of the information pointed by <strong>TokenInformation</strong>.</td>
</tr>
<tr>
<td>STATUS_INVALID_HANDLE</td>
<td><strong>TokenHandle</strong> was not a valid handle.</td>
</tr>
<tr>
<td>STATUS_INVALID_INFO_CLASS</td>
<td><strong>TokenInformationClass</strong> was not a valid token information class.</td>
</tr>
<tr>
<td>STATUS_OBJECT_TYPE_MISMATCH</td>
<td><strong>TokenHandle</strong> was not a token handle.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>The <strong>NtQueryInformationToken</strong> routine can be used by a file system or file system filter driver to determine the <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong> of the caller that initiated the request during <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a> processing. If <strong>TokenUser</strong> is specified for the <strong>TokenInformationClass</strong> parameter passed to <strong>NtQueryInformationToken</strong>, a <strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong> structure is returned in the buffer pointed to by the <strong>TokenInformation</strong> parameter. This returned buffer contains an <strong><a href="sid_and_attributes" title="typedef struct _SID_AND_ATTRIBUTES {&#10;#if ...&#10;  PISID Sid;&#10;#else&#10;  PSID  Sid;&#10;#endif&#10;  ULONG Attributes;&#10;} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;">SID_AND_ATTRIBUTES</a></strong> structure with the user <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong>.</p>
<p>Due to the nature of token's properties (such as token user, token primary group, privileges, etc, where their contents can vary on each token), <strong>ReturnLength</strong> is not optional; that is, it cannot be NULL. This is because
<a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a> is a variable-length structure whereas a specific privilege can exist in a token but not in another (the privilege count can be different for each token). It's the caller's responsibility to first query the necessary
required length size in order to allocate memory to accommodate the requested token information before doing the actual query. That said, it is also the caller's responsibility to provide a valid <strong>ReturnLength</strong> variable that is writable and not NULL. On a NULL case scenario, the function raises an access violation exception.</p>
<p>For more information about security and access control, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/driversecurity/windows-security-model">Windows security model for driver developers</a> and the documentation on these topics in the Windows SDK.</p>
<blockquote>
<p>[!NOTE]
If the call to the <strong>NtQueryInformationToken</strong> function occurs in user mode, you should use the name &quot;<strong>NtQueryInformationToken</strong>&quot; instead of &quot;<strong>ZwQueryInformationToken</strong>&quot;.</p>
</blockquote>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><strong><a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a></p>
<p><strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong></p>
<p><strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong></p>
<p><strong><a href="sid_and_attributes" title="typedef struct _SID_AND_ATTRIBUTES {&#10;#if ...&#10;  PISID Sid;&#10;#else&#10;  PSID  Sid;&#10;#endif&#10;  ULONG Attributes;&#10;} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;">SID_AND_ATTRIBUTES</a></strong></p>
<p><strong><a href="sequeryinformationtoken" title="NTSTATUS SeQueryInformationToken(&#10;  [in]  PACCESS_TOKEN           Token,&#10;  [in]  TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;  [out] PVOID                   *TokenInformation&#10;);">SeQueryInformationToken</a></strong></p>
<p><strong><a href="token_default_dacl" title="typedef struct _TOKEN_DEFAULT_DACL&#10;{&#10;    PACL DefaultDacl;&#10;} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;">TOKEN_DEFAULT_DACL</a></strong></p>
<p><strong><a href="token_groups" title="typedef struct _TOKEN_GROUPS&#10;{&#10;    ULONG GroupCount;&#10;    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];&#10;} TOKEN_GROUPS, *PTOKEN_GROUPS;">TOKEN_GROUPS</a></strong></p>
<p><strong><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></strong></p>
<p><strong><a href="token_owner" title="typedef struct _TOKEN_OWNER&#10;{&#10;    PSID Owner;&#10;} TOKEN_OWNER, *PTOKEN_OWNER;">TOKEN_OWNER</a></strong></p>
<p><strong><a href="token_primary_group" title="typedef struct _TOKEN_PRIMARY_GROUP&#10;{&#10;    PSID PrimaryGroup;&#10;} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;">TOKEN_PRIMARY_GROUP</a></strong></p>
<p><strong><a href="token_privileges" title="typedef struct _TOKEN_PRIVILEGES&#10;{&#10;    ULONG PrivilegeCount;&#10;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];&#10;} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;">TOKEN_PRIVILEGES</a></strong></p>
<p><strong><a href="token_source" title="typedef struct _TOKEN_SOURCE&#10;{&#10;    CHAR SourceName[TOKEN_SOURCE_LENGTH];&#10;    LUID SourceIdentifier;&#10;} TOKEN_SOURCE, *PTOKEN_SOURCE;">TOKEN_SOURCE</a></strong></p>
<p><strong><a href="token_statistics" title="typedef struct _TOKEN_STATISTICS {&#10;  LUID                         TokenId;&#10;  LUID                         AuthenticationId;&#10;  LARGE_INTEGER                ExpirationTime;&#10;  TOKEN_TYPE                   TokenType;&#10;  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;&#10;  ULONG                        DynamicCharged;&#10;  ULONG                        DynamicAvailable;&#10;  ULONG                        GroupCount;&#10;  ULONG                        PrivilegeCount;&#10;  LUID                         ModifiedId;&#10;} TOKEN_STATISTICS, *PTOKEN_STATISTICS;">TOKEN_STATISTICS</a></strong></p>
<p><strong><a href="token_type" title="typedef enum _TOKEN_TYPE&#10;{&#10;    TokenPrimary = 1,&#10;    TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong></p>
<p><strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong></p>
<p><strong><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">ZwSetInformationToken</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationtoken">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntqueryinformationtoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-zwqueryinformationtoken)</h1>
</div>
<div class="ntdoc-description">
<h1>ZwQueryInformationToken function</h1>
<h2>Description</h2>
<p>The <strong>ZwQueryInformationToken</strong> routine retrieves a specified type of information about an access token. The calling process must have appropriate access rights to obtain the information.</p>
<h2>Parameters</h2>
<h3><code>TokenHandle</code> [in]</h3>
<p>Handle for an access token from which information is to be retrieved. If <strong>TokenInformationClass</strong> is set to <strong>TokenSource</strong>, the handle must have TOKEN_QUERY_SOURCE access. For all other <strong>TokenInformationClass</strong> values, the handle must have TOKEN_QUERY access. For more information about access rights for access-token objects, see the Security section of the Windows SDK documentation.</p>
<h3><code>TokenInformationClass</code> [in]</h3>
<p>A value from the <strong><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></strong> enumerated type identifying the type of information to be retrieved. The possible values for this parameter are listed in the <strong>TokenInformationClass</strong> Value column of the table shown in the description of the <strong>TokenInformation</strong> parameter.</p>
<h3><code>TokenInformation</code> [out]</h3>
<p>Pointer to a caller-allocated buffer that receives the requested information about the token. The structure put into this buffer depends upon the value of <strong>TokenInformationClass</strong>, as shown in the following table. All structures must be aligned on a 32-bit boundary.</p>
<table>
<thead>
<tr>
<th>TokenInformationClass value</th>
<th>Effect on TokenInformation buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TokenDefaultDacl</strong></td>
<td>The buffer receives a <strong><a href="token_default_dacl" title="typedef struct _TOKEN_DEFAULT_DACL&#10;{&#10;    PACL DefaultDacl;&#10;} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;">TOKEN_DEFAULT_DACL</a></strong> structure containing the default <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_acl"><strong>DACL</strong></a> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenGroups</strong></td>
<td>The buffer receives a <strong><a href="token_groups" title="typedef struct _TOKEN_GROUPS&#10;{&#10;    ULONG GroupCount;&#10;    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];&#10;} TOKEN_GROUPS, *PTOKEN_GROUPS;">TOKEN_GROUPS</a></strong> structure containing the group accounts associated with the token.</td>
</tr>
<tr>
<td><strong>TokenImpersonationLevel</strong></td>
<td>The buffer receives a <strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong> value indicating the impersonation level of the token. If the access token is not an impersonation token, the call to <strong>ZwQueryInformationToken</strong> fails.</td>
</tr>
<tr>
<td><strong>TokenOwner</strong></td>
<td>The buffer receives a <strong><a href="token_owner" title="typedef struct _TOKEN_OWNER&#10;{&#10;    PSID Owner;&#10;} TOKEN_OWNER, *PTOKEN_OWNER;">TOKEN_OWNER</a></strong> structure containing the default owner <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenPrimaryGroup</strong></td>
<td>The buffer receives a <strong><a href="token_primary_group" title="typedef struct _TOKEN_PRIMARY_GROUP&#10;{&#10;    PSID PrimaryGroup;&#10;} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;">TOKEN_PRIMARY_GROUP</a></strong> structure containing the default primary group <a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a> for newly created objects.</td>
</tr>
<tr>
<td><strong>TokenPrivileges</strong></td>
<td>The buffer receives a <strong><a href="token_privileges" title="typedef struct _TOKEN_PRIVILEGES&#10;{&#10;    ULONG PrivilegeCount;&#10;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];&#10;} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;">TOKEN_PRIVILEGES</a></strong> structure containing the token's privileges.</td>
</tr>
<tr>
<td><strong>TokenSessionId</strong></td>
<td>The buffer receives a 32-bit value specifying the Terminal Services session identifier associated with the token. If the token is associated with the Terminal Server console session, the session identifier is zero. A nonzero session identifier indicates a Terminal Services client session. In a non-Terminal Services environment, the session identifier is zero.</td>
</tr>
<tr>
<td><strong>TokenSource</strong></td>
<td>The buffer receives a <strong><a href="token_source" title="typedef struct _TOKEN_SOURCE&#10;{&#10;    CHAR SourceName[TOKEN_SOURCE_LENGTH];&#10;    LUID SourceIdentifier;&#10;} TOKEN_SOURCE, *PTOKEN_SOURCE;">TOKEN_SOURCE</a></strong> structure containing the source of the token. TOKEN_QUERY_SOURCE access is needed to retrieve this information.</td>
</tr>
<tr>
<td><strong>TokenStatistics</strong></td>
<td>The buffer receives a <strong><a href="token_statistics" title="typedef struct _TOKEN_STATISTICS {&#10;  LUID                         TokenId;&#10;  LUID                         AuthenticationId;&#10;  LARGE_INTEGER                ExpirationTime;&#10;  TOKEN_TYPE                   TokenType;&#10;  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;&#10;  ULONG                        DynamicCharged;&#10;  ULONG                        DynamicAvailable;&#10;  ULONG                        GroupCount;&#10;  ULONG                        PrivilegeCount;&#10;  LUID                         ModifiedId;&#10;} TOKEN_STATISTICS, *PTOKEN_STATISTICS;">TOKEN_STATISTICS</a></strong> structure containing various token statistics.</td>
</tr>
<tr>
<td><strong>TokenType</strong></td>
<td>The buffer receives a <strong><a href="token_type" title="typedef enum _TOKEN_TYPE&#10;{&#10;    TokenPrimary = 1,&#10;    TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong> value indicating whether the token is a primary or impersonation token.</td>
</tr>
<tr>
<td><strong>TokenUser</strong></td>
<td>The buffer receives a <strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong> structure containing the token's user account.</td>
</tr>
</tbody>
</table>
<h3><code>TokenInformationLength</code> [in]</h3>
<p>Length, in bytes, of the caller-allocated <strong>TokenInformation</strong> buffer.</p>
<h3><code>ReturnLength</code> [out]</h3>
<p>Pointer to a caller-allocated variable that receives the actual length, in bytes, of the information returned in the <strong>TokenInformation</strong> buffer. If either of the following conditions is true, no data is returned in the <strong>TokenInformation</strong> buffer:</p>
<ul>
<li>
<p>The size of the requested token information structure is greater than <strong>TokenInformationLength</strong>. In this case, <strong>ReturnLength</strong> receives the actual number of bytes needed to store the requested information.</p>
</li>
<li>
<p>The value of <strong>TokenInformationClass</strong> is <strong>TokenDefaultDacl</strong>, and there is no default DACL established for the token. In this case, <strong>ReturnLength</strong> receives zero.</p>
</li>
</ul>
<h2>Return value</h2>
<p><strong>ZwQueryInformationToken</strong> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an appropriate error status. Possible error status codes include the following:</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_ACCESS_DENIED</td>
<td><strong>TokenHandle</strong> did not have the required access.</td>
</tr>
<tr>
<td>STATUS_BUFFER_TOO_SMALL</td>
<td>The size of the requested token information structure is greater than <strong>TokenInformationLength</strong>. The number of bytes required is returned in <strong>ReturnLength</strong>.</td>
</tr>
<tr>
<td>STATUS_INVALID_HANDLE</td>
<td><strong>TokenHandle</strong> was not a valid handle.</td>
</tr>
<tr>
<td>STATUS_INVALID_INFO_CLASS</td>
<td><strong>TokenInformationClass</strong> was not a valid token information class.</td>
</tr>
<tr>
<td>STATUS_OBJECT_TYPE_MISMATCH</td>
<td><strong>TokenHandle</strong> was not a token handle.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>The <strong>ZwQueryInformationToken</strong> routine can be used by a file system or file system filter driver to determine the <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong> of the caller that initiated the request during <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a> processing. If <strong>TokenUser</strong> is specified for the <strong>TokenInformationClass</strong> parameter passed to <strong>ZwQueryInformationToken</strong>, a <strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong> structure is returned in the buffer pointed to by the <strong>TokenInformation</strong> parameter. This returned buffer contains an <strong><a href="sid_and_attributes" title="typedef struct _SID_AND_ATTRIBUTES {&#10;#if ...&#10;  PISID Sid;&#10;#else&#10;  PSID  Sid;&#10;#endif&#10;  ULONG Attributes;&#10;} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;">SID_AND_ATTRIBUTES</a></strong> structure with the user <strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong>.</p>
<p>For more information about security and access control, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/driversecurity/windows-security-model">Windows security model for driver developers</a> and the documentation on these topics in the Windows SDK.</p>
<blockquote>
<p>[!NOTE]
If the call to the <strong>ZwQueryInformationToken</strong> function occurs in user mode, you should use the name &quot;<strong>NtQueryInformationToken</strong>&quot; instead of &quot;<strong>ZwQueryInformationToken</strong>&quot;.</p>
</blockquote>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><strong><a href="acl" title="typedef struct _ACL {&#10;  UCHAR  AclRevision;&#10;  UCHAR  Sbz1;&#10;  USHORT AclSize;&#10;  USHORT AceCount;&#10;  USHORT Sbz2;&#10;} ACL;">ACL</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-create"><strong>IRP_MJ_CREATE</strong></a></p>
<p><strong><a href="security_impersonation_level" title="typedef enum _SECURITY_IMPERSONATION_LEVEL {&#10;  SecurityAnonymous,&#10;  SecurityIdentification,&#10;  SecurityImpersonation,&#10;  SecurityDelegation&#10;} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;">SECURITY_IMPERSONATION_LEVEL</a></strong></p>
<p><strong><a href="pisid" title="typedef struct _SID {&#10;  UCHAR                    Revision;&#10;  UCHAR                    SubAuthorityCount;&#10;  SID_IDENTIFIER_AUTHORITY IdentifierAuthority;&#10;#if ...&#10;  ULONG                    *SubAuthority[];&#10;#else&#10;  ULONG                    SubAuthority[ANYSIZE_ARRAY];&#10;#endif&#10;} SID, *PISID;">SID</a></strong></p>
<p><strong><a href="sid_and_attributes" title="typedef struct _SID_AND_ATTRIBUTES {&#10;#if ...&#10;  PISID Sid;&#10;#else&#10;  PSID  Sid;&#10;#endif&#10;  ULONG Attributes;&#10;} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;">SID_AND_ATTRIBUTES</a></strong></p>
<p><strong><a href="sequeryinformationtoken" title="NTSTATUS SeQueryInformationToken(&#10;  [in]  PACCESS_TOKEN           Token,&#10;  [in]  TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;  [out] PVOID                   *TokenInformation&#10;);">SeQueryInformationToken</a></strong></p>
<p><strong><a href="token_default_dacl" title="typedef struct _TOKEN_DEFAULT_DACL&#10;{&#10;    PACL DefaultDacl;&#10;} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;">TOKEN_DEFAULT_DACL</a></strong></p>
<p><strong><a href="token_groups" title="typedef struct _TOKEN_GROUPS&#10;{&#10;    ULONG GroupCount;&#10;    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];&#10;} TOKEN_GROUPS, *PTOKEN_GROUPS;">TOKEN_GROUPS</a></strong></p>
<p><strong><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></strong></p>
<p><strong><a href="token_owner" title="typedef struct _TOKEN_OWNER&#10;{&#10;    PSID Owner;&#10;} TOKEN_OWNER, *PTOKEN_OWNER;">TOKEN_OWNER</a></strong></p>
<p><strong><a href="token_primary_group" title="typedef struct _TOKEN_PRIMARY_GROUP&#10;{&#10;    PSID PrimaryGroup;&#10;} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;">TOKEN_PRIMARY_GROUP</a></strong></p>
<p><strong><a href="token_privileges" title="typedef struct _TOKEN_PRIVILEGES&#10;{&#10;    ULONG PrivilegeCount;&#10;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];&#10;} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;">TOKEN_PRIVILEGES</a></strong></p>
<p><strong><a href="token_source" title="typedef struct _TOKEN_SOURCE&#10;{&#10;    CHAR SourceName[TOKEN_SOURCE_LENGTH];&#10;    LUID SourceIdentifier;&#10;} TOKEN_SOURCE, *PTOKEN_SOURCE;">TOKEN_SOURCE</a></strong></p>
<p><strong><a href="token_statistics" title="typedef struct _TOKEN_STATISTICS {&#10;  LUID                         TokenId;&#10;  LUID                         AuthenticationId;&#10;  LARGE_INTEGER                ExpirationTime;&#10;  TOKEN_TYPE                   TokenType;&#10;  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;&#10;  ULONG                        DynamicCharged;&#10;  ULONG                        DynamicAvailable;&#10;  ULONG                        GroupCount;&#10;  ULONG                        PrivilegeCount;&#10;  LUID                         ModifiedId;&#10;} TOKEN_STATISTICS, *PTOKEN_STATISTICS;">TOKEN_STATISTICS</a></strong></p>
<p><strong><a href="token_type" title="typedef enum _TOKEN_TYPE&#10;{&#10;    TokenPrimary = 1,&#10;    TokenImpersonation&#10;} TOKEN_TYPE;">TOKEN_TYPE</a></strong></p>
<p><strong><a href="token_user" title="typedef struct _TOKEN_USER&#10;{&#10;    SID_AND_ATTRIBUTES User;&#10;} TOKEN_USER, *PTOKEN_USER;">TOKEN_USER</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a></p>
<p><strong><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">ZwSetInformationToken</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwqueryinformationtoken">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-zwqueryinformationtoken.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntqueryinformationtoken">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-zwqueryinformationtoken">here</a>.</p>
<hr />
<p>Function <code>NtQueryInformationToken</code> receives information specified by information class from Token Object. See also <em>Win32 API</em> <strong>GetTokenInformation</strong>.</p>
<h3>TokenHandle</h3>
<p><code>HANDLE</code> to Token Object opened with <code>TOKEN_QUERY</code> access.</p>
<h3>TokenInformationClass</h3>
<p>Information class described in <code><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></code> topic.</p>
<h3>TokenInformation</h3>
<p>User's allocated buffer for output data. Format of output buffer depends on <code>TokenInformationClass</code> parameter.</p>
<h3>TokenInformationLength</h3>
<p>Length of <code>TokenInformation</code> buffer, in bytes.</p>
<h3>ReturnLength</h3>
<p>If output buffer is to small, value under this parameter receives required length.</p>
<h1>Documented by</h1>
<ul>
<li>Tomasz Nowak</li>
</ul>
<h1>See also</h1>
<ul>
<li><code><a href="ntcreatetoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateToken(&#10;    _Out_ PHANDLE TokenHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,&#10;    _In_ TOKEN_TYPE Type,&#10;    _In_ PLUID AuthenticationId,&#10;    _In_ PLARGE_INTEGER ExpirationTime,&#10;    _In_ PTOKEN_USER User,&#10;    _In_ PTOKEN_GROUPS Groups,&#10;    _In_ PTOKEN_PRIVILEGES Privileges,&#10;    _In_opt_ PTOKEN_OWNER Owner,&#10;    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,&#10;    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,&#10;    _In_ PTOKEN_SOURCE Source&#10;    );">NtCreateToken</a></code></li>
<li><code><a href="ntopenprocesstoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenProcessToken(&#10;    _In_ HANDLE ProcessHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenProcessToken</a></code></li>
<li><code><a href="ntopenthreadtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenThreadToken(&#10;    _In_ HANDLE ThreadHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ BOOLEAN OpenAsSelf,&#10;    _Out_ PHANDLE TokenHandle&#10;    );">NtOpenThreadToken</a></code></li>
<li><code><a href="ntsetinformationtoken" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationToken(&#10;    _In_ HANDLE TokenHandle,&#10;    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,&#10;    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,&#10;    _In_ ULONG TokenInformationLength&#10;    );">NtSetInformationToken</a></code></li>
<li><code><a href="token_information_class" title="typedef enum _TOKEN_INFORMATION_CLASS&#10;{&#10;    TokenUser = 1,                        // q: TOKEN_USER, SE_TOKEN_USER&#10;    TokenGroups,                          // q: TOKEN_GROUPS&#10;    TokenPrivileges,                      // q: TOKEN_PRIVILEGES&#10;    TokenOwner,                           // qs: TOKEN_OWNER&#10;    TokenPrimaryGroup,                    // qs: TOKEN_PRIMARY_GROUP&#10;    TokenDefaultDacl,                     // qs: TOKEN_DEFAULT_DACL&#10;    TokenSource,                          // q: TOKEN_SOURCE&#10;    TokenType,                            // q: TOKEN_TYPE&#10;    TokenImpersonationLevel,              // q: SECURITY_IMPERSONATION_LEVEL&#10;    TokenStatistics,                      // q: TOKEN_STATISTICS // 10&#10;    TokenRestrictedSids,                  // q: TOKEN_GROUPS&#10;    TokenSessionId,                       // qs: ULONG (requires SeTcbPrivilege)&#10;    TokenGroupsAndPrivileges,             // q: TOKEN_GROUPS_AND_PRIVILEGES&#10;    TokenSessionReference,                // s: ULONG (requires SeTcbPrivilege)&#10;    TokenSandBoxInert,                    // q: ULONG&#10;    TokenAuditPolicy,                     // qs: TOKEN_AUDIT_POLICY (requires SeSecurityPrivilege/SeTcbPrivilege)&#10;    TokenOrigin,                          // qs: TOKEN_ORIGIN (requires SeTcbPrivilege)&#10;    TokenElevationType,                   // q: TOKEN_ELEVATION_TYPE&#10;...">TOKEN_INFORMATION_CLASS</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntqueryinformationtoken.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
