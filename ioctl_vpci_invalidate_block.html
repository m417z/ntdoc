<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IOCTL_VPCI_INVALIDATE_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IOCTL_VPCI_INVALIDATE_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IOCTL_VPCI_INVALIDATE_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// vpci.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x002a, 0x001, METHOD_NEITHER, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VPCI_INVALIDATE_BLOCK 0x002AC007</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/vpci/ni-vpci-ioctl_vpci_invalidate_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ioctl_vpci_invalidate_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ni-vpci-ioctl_vpci_invalidate_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="ioctl_vpci_invalidate_block-ioctl">IOCTL_VPCI_INVALIDATE_BLOCK IOCTL</h1>

<h2 id="major-code">Major Code:</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a></p>

<h2 id="description">Description</h2>

<p>The driver for a PCI Express (PCIe) virtual function (VF) issues the IOCTL_VPCI_INVALIDATE_BLOCK IOCTL request in order to be notified of changes to data in one or more VF configuration blocks. The driver is notified of these changes when the IOCTL is completed. Once notified, the driver should assume that any data previously read from the specified VF configuration blocks has become invalid. Therefore, the driver should update its cache by reading the configuration block data again.</p>

<p>The driver issues this IOCTL to the next-lower driver in the driver stack.</p>

<p><strong>Note</strong> This IOCTL request is issued by the driver of a PCIe VF on a device that supports the single root I/O virtualization (SR-IOV) interface.</p>

<p>When the driver issues the IOCTL_VPCI_INVALIDATE_BLOCK IOCTL, the driver must follow these steps:</p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/">Preparing an I/O Request Packet Structure</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/">Preparing an I/O Stack Location Structure</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/">Issuing the IOCTL Request</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/">IOCTL Request Completion Results</a></p>

<p>For more information about issuing IOCTLs between kernel-mode drivers, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/creating-ioctl-requests-in-drivers">Creating IOCTL Requests in Drivers</a>.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="major-code-2">Major code</h3>

<h3 id="input-buffer">Input buffer</h3>

<h3 id="input-buffer-length">Input buffer length</h3>

<h3 id="output-buffer">Output buffer</h3>

<h3 id="output-buffer-length">Output buffer length</h3>

<h3 id="inputoutput-buffer">Input/output buffer</h3>

<h3 id="inputoutput-buffer-length">Input/output buffer length</h3>

<h3 id="status-block">Status block</h3>

<p>Irp->IoStatus.Status is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the request is successful.</p>

<p>Otherwise, Status to the appropriate error condition as a <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code.</p>

<p>For more information, see [XREF-LINK:<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Values].</p>

<h2 id="remarks">Remarks</h2>

<h3 id="preparing-an-io-request-packet-structure">Preparing an I/O Request Packet Structure</h3>

<p>The driver must first allocate or reuse an I/O request packet (<a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>). You can use the <a href="iobuilddeviceiocontrolrequest" title="__drv_aliasesMem PIRP IoBuildDeviceIoControlRequest(&#10;  [in]            ULONG            IoControlCode,&#10;  [in]            PDEVICE_OBJECT   DeviceObject,&#10;  [in, optional]  PVOID            InputBuffer,&#10;  [in]            ULONG            InputBufferLength,&#10;  [out, optional] PVOID            OutputBuffer,&#10;  [in]            ULONG            OutputBufferLength,&#10;  [in]            BOOLEAN          InternalDeviceIoControl,&#10;  [in, optional]  PKEVENT          Event,&#10;  [out]           PIO_STATUS_BLOCK IoStatusBlock&#10;);">IoBuildDeviceIoControlRequest</a> routine to specifically allocate an IOCTL <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>. You can also use general-purpose <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> creation and initialization routines, such as <a href="ioallocateirp" title="PIRP IoAllocateIrp(&#10;  [in] CCHAR   StackSize,&#10;  [in] BOOLEAN ChargeQuota&#10;);">IoAllocateIrp</a>, <a href="ioreuseirp" title="VOID IoReuseIrp(&#10;  [in, out] PIRP     Irp,&#10;  [in]      NTSTATUS Iostatus&#10;);">IoReuseIrp</a>, or <a href="ioinitializeirp" title="VOID IoInitializeIrp(&#10;  [in, out] PIRP   Irp,&#10;  [in]      USHORT PacketSize,&#10;  [in]      CCHAR  StackSize&#10;);">IoInitializeIrp</a>. For more information about <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> allocation, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/creating-irps-for-lower-level-drivers">Creating IRPs for Lower-Level Drivers</a>.</p>

<p>The driver must then set the members of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> structure as described in the following table.</p>

<table>
<thead>
<tr>
  <th><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> member</th>
  <th>Value</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>UserBuffer</strong></td>
  <td><strong>NULL</strong></td>
</tr>
<tr>
  <td><strong>UserEvent</strong></td>
  <td>The address of the event object that was initialized in the call to the <a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a> routine.<br><br><strong>Note</strong> If asynchronous completion of the IOCTL request is not required, this member should be set to <strong>NULL</strong>. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/creating-ioctl-requests-in-drivers">Creating IOCTL Requests in Drivers</a>.</td>
</tr>
<tr>
  <td><strong>UserIosb</strong></td>
  <td>The address of a caller-allocated <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure. This structure is updated by the lower driver to indicate the final status of the I/O request.</td>
</tr>
</tbody>
</table>

<h3 id="preparing-an-io-stack-location-structure">Preparing an I/O Stack Location Structure</h3>

<p>The driver calls the <a href="iogetnextirpstacklocation" title="__drv_aliasesMem PIO_STACK_LOCATION IoGetNextIrpStackLocation(&#10;  [in] PIRP Irp&#10;);">IoGetNextIrpStackLocation</a> routine to access the lower driver's I/O stack location. This function returns a pointer to an <a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a> structure that contains the parameters for the I/O stack location.</p>

<p>The driver must then set the members in the <a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a> structure as described in the following table.</p>

<table>
<thead>
<tr>
  <th><a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a> member</th>
  <th>Value</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>MajorFunction</strong></td>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-internal-device-control">IRP_MJ_INTERNAL_DEVICE_CONTROL</a></td>
</tr>
<tr>
  <td><strong>Parameters</strong>.<strong>DeviceIoControl</strong>.<strong>IoControlCode</strong></td>
  <td>IOCTL_VPCI_INVALIDATE_BLOCK</td>
</tr>
<tr>
  <td><strong>Parameters</strong>.<strong>DeviceIoControl</strong>.<strong>Type3InputBuffer</strong></td>
  <td>A pointer to a <a href="vpci_invalidate_block_output" title="typedef struct _VPCI_INVALIDATE_BLOCK_OUTPUT {&#10;  UINT64 BlockMask;&#10;} VPCI_INVALIDATE_BLOCK_OUTPUT, *PVPCI_INVALIDATE_BLOCK_OUTPUT;">VPCI_INVALIDATE_BLOCK_OUTPUT</a> structure. The driver formats this structure with the parameters for the IOCTL_VPCI_INVALIDATE_BLOCK I/O request.</td>
</tr>
<tr>
  <td>I<strong>Parameters</strong>.<strong>DeviceIoControl</strong>.<strong>InputBufferLength</strong></td>
  <td>The size, in bytes, of the <a href="vpci_invalidate_block_output" title="typedef struct _VPCI_INVALIDATE_BLOCK_OUTPUT {&#10;  UINT64 BlockMask;&#10;} VPCI_INVALIDATE_BLOCK_OUTPUT, *PVPCI_INVALIDATE_BLOCK_OUTPUT;">VPCI_INVALIDATE_BLOCK_OUTPUT</a> structure.</td>
</tr>
<tr>
  <td><strong>Parameters</strong>.<strong>DeviceIoControl</strong>.<strong>OutputBufferLength</strong></td>
  <td>The size, in bytes, of the caller-allocated buffer that will contain the configuration data to be read.<br><br><strong>Note</strong> This value must be the same as the value of the <strong>BytesRequested</strong> member of the <a href="vpci_invalidate_block_output" title="typedef struct _VPCI_INVALIDATE_BLOCK_OUTPUT {&#10;  UINT64 BlockMask;&#10;} VPCI_INVALIDATE_BLOCK_OUTPUT, *PVPCI_INVALIDATE_BLOCK_OUTPUT;">VPCI_INVALIDATE_BLOCK_OUTPUT</a> structure.</td>
</tr>
</tbody>
</table>

<h3 id="issuing-the-ioctl-request">Issuing the IOCTL Request</h3>

<p>To issue this IOCTL request, the driver calls the <a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a> routine to pass the request on to the next-lower driver in the driver stack. The driver sets the parameters of <strong><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a></strong> as described in the following table.</p>

<table>
<thead>
<tr>
  <th><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a> parameter</th>
  <th>Value</th>
</tr>
</thead>
<tbody>
<tr>
  <td><em>DeviceObject</em></td>
  <td>The device object of the lower driver.</td>
</tr>
<tr>
  <td><em>Irp</em></td>
  <td>The address of the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> that was previously allocated and initialized. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/">Preparing an I/O Request Packet Structure</a>.</td>
</tr>
</tbody>
</table>

<h3 id="ioctl-request-completion-results">IOCTL Request Completion Results</h3>

<p>When the IOCTL_VPCI_INVALIDATE_BLOCK IOCTL request is completed, the members of the caller-allocated <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure are set to the values in the following table.</p>

<table>
<thead>
<tr>
  <th>Status value</th>
  <th>Value</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>Status</strong></td>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
</tr>
<tr>
  <td><strong>Information</strong></td>
  <td>Zero</td>
</tr>
</tbody>
</table>

<p>When the IOCTL_VPCI_INVALIDATE_BLOCK IOCTL is issued and completed, the VF driver is notified that the PF driver has changed (<em>invalidated</em>) data in one or more VF configuration blocks.</p>

<p><strong>Note</strong> The operating system reserves and manages the resources that are required for the successful completion of this IOCTL.</p>

<p>A VF configuration block is used for backchannel communication between the drivers of the PCIe PF and a VF on a device that supports the SR-IOV interface. VF configuration data can be exchanged between the following drivers:</p>

<ul>
<li>The VF driver, which runs in the guest operating system. This operating system runs within a Hyper-V child partition.</li>
<li><p>The PF driver, which runs in the management operating system.</p>

<p>This operating system runs within the Hyper-V parent partition.</p></li>
</ul>

<p>Starting with NDIS 6.30, the VF miniport driver should not issue an IOCTL_VPCI_INVALIDATE_BLOCK request. Instead, the following steps are performed in order to handle notifications of invalidated VF configuration block data.</p>

<ol>
<li>In the guest OS, NDIS issues an IOCTL_VPCI_INVALIDATE_BLOCK request.</li>
<li><p>In the management OS, the following steps occur:</p>

<ol>
<li>The PF miniport driver calls the <a href="ndisminvalidateconfigblock" title="VOID NdisMInvalidateConfigBlock(&#10;  [in] NDIS_HANDLE            NdisMiniportHandle,&#10;  [in] NDIS_SRIOV_FUNCTION_ID VFId,&#10;  [in] ULONGLONG              BlockMask&#10;);">NdisMInvalidateConfigBlock</a> function to notify NDIS that VF configuration data has changed and is no longer valid. The driver sets the <em>BlockMask</em> parameter to a <strong><a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a></strong> bitmask that specifies which VF configuration blocks have changed. Each bit in the bitmask corresponds to a VF configuration block. If a bit is set to one, the data in the corresponding VF configuration block has changed.</li>
<li><p>NDIS signals the virtualization stack, which runs in the management OS, about the change in VF configuration block data. The virtualization stack caches the <em>BlockMask</em> parameter data.</p>

<p><strong>Note</strong> Each time that the PF miniport driver calls <a href="ndisminvalidateconfigblock" title="VOID NdisMInvalidateConfigBlock(&#10;  [in] NDIS_HANDLE            NdisMiniportHandle,&#10;  [in] NDIS_SRIOV_FUNCTION_ID VFId,&#10;  [in] ULONGLONG              BlockMask&#10;);">NdisMInvalidateConfigBlock</a>, the virtualization stack <strong>OR</strong>s the <em>BlockMask</em> parameter data with the current value in its cache.</p></li>
<li>The virtualization stack notifies the virtual PCI (VPCI) driver, which runs in the guest OS, about the invalidation of VF configuration data. The virtualization stack sends the cached <em>BlockMask</em> parameter data to the VPCI driver.</li>
</ol></li>
<li><p>In the Guest OS, the following steps occur:</p>

<ol>
<li>The VPCI driver saves the cached <em>BlockMask</em> parameter data in the <strong>BlockMask</strong> member of the <a href="vpci_invalidate_block_output" title="typedef struct _VPCI_INVALIDATE_BLOCK_OUTPUT {&#10;  UINT64 BlockMask;&#10;} VPCI_INVALIDATE_BLOCK_OUTPUT, *PVPCI_INVALIDATE_BLOCK_OUTPUT;">VPCI_INVALIDATE_BLOCK_OUTPUT</a> structure that is associated with the IOCTL_VPCI_INVALIDATE_BLOCK request.</li>
<li><p>The VPCI driver successfully completes the IOCTL_VPCI_INVALIDATE_BLOCK request. When this happens, NDIS issues an object identifier (OID) request of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/oid-sriov-vf-invalidate-config-block">OID_SRIOV_VF_INVALIDATE_CONFIG_BLOCK</a> to the VF miniport driver. A pointer to an <a href="ndis_sriov_vf_invalidate_config_block_info" title="typedef struct _NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO {&#10;  NDIS_OBJECT_HEADER Header;&#10;  ULONG64            BlockMask;&#10;} NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO, *PNDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO;">NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO</a> structure is passed along in the OID request. This structure contains the cached <em>BlockMask</em> parameter data.</p>

<p>NDIS also issues another IOCTL_VPCI_INVALIDATE_BLOCK request to handle successive notifications of changes to VF configuration data.</p></li>
<li>When the VF driver handles the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/oid-sriov-vf-invalidate-config-block">OID_SRIOV_VF_INVALIDATE_CONFIG_BLOCK</a> request, it reads data from the specified VF configuration blocks.</li>
</ol></li>
</ol>

<p><strong>Note</strong> The usage of the VF configuration block and the format of its configuration data are defined by the independent hardware vendor (IHV) of the device. The configuration data is used only by the drivers of the PF and VF.</p>

<h2 id="see-also">See also</h2>

<p><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></p>

<p><a href="vpci_invalidate_block_output" title="typedef struct _VPCI_INVALIDATE_BLOCK_OUTPUT {&#10;  UINT64 BlockMask;&#10;} VPCI_INVALIDATE_BLOCK_OUTPUT, *PVPCI_INVALIDATE_BLOCK_OUTPUT;">VPCI_INVALIDATE_BLOCK_OUTPUT</a></p>

<p><a href="ndisminvalidateconfigblock" title="VOID NdisMInvalidateConfigBlock(&#10;  [in] NDIS_HANDLE            NdisMiniportHandle,&#10;  [in] NDIS_SRIOV_FUNCTION_ID VFId,&#10;  [in] ULONGLONG              BlockMask&#10;);">NdisMInvalidateConfigBlock</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-internal-device-control">IRP_MJ_INTERNAL_DEVICE_CONTROL</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/creating-ioctl-requests-in-drivers">Creating IOCTL Requests in Drivers</a></p>

<p><a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a></p>

<p><a href="io_stack_location" title="typedef struct _IO_STACK_LOCATION {&#10;  UCHAR                  MajorFunction;&#10;  UCHAR                  MinorFunction;&#10;  UCHAR                  Flags;&#10;  UCHAR                  Control;&#10;  union {&#10;    struct {&#10;      PIO_SECURITY_CONTEXT     SecurityContext;&#10;      ULONG                    Options;&#10;      USHORT POINTER_ALIGNMENT FileAttributes;&#10;      USHORT                   ShareAccess;&#10;      ULONG POINTER_ALIGNMENT  EaLength;&#10;    } Create;&#10;    struct {&#10;      PIO_SECURITY_CONTEXT          SecurityContext;&#10;      ULONG                         Options;&#10;      USHORT POINTER_ALIGNMENT      Reserved;&#10;      USHORT                        ShareAccess;&#10;      PNAMED_PIPE_CREATE_PARAMETERS Parameters;&#10;    } CreatePipe;&#10;...">IO_STACK_LOCATION</a></p>

<p><a href="iocalldriver" title="#define IoCallDriver(a,b)   \&#10;        IofCallDriver(a,b)&#10;);">IoCallDriver</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/oid-sriov-vf-invalidate-config-block">OID_SRIOV_VF_INVALIDATE_CONFIG_BLOCK</a></p>

<p><a href="ndis_sriov_vf_invalidate_config_block_info" title="typedef struct _NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO {&#10;  NDIS_OBJECT_HEADER Header;&#10;  ULONG64            BlockMask;&#10;} NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO, *PNDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO;">NDIS_SRIOV_VF_INVALIDATE_CONFIG_BLOCK_INFO</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/vpci/ni-vpci-ioctl_vpci_invalidate_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/vpci/ni-vpci-ioctl_vpci_invalidate_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
