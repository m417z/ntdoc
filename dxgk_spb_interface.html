<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="DXGK_SPB_INTERFACE - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>DXGK_SPB_INTERFACE - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            DXGK_SPB_INTERFACE - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// dispmprt.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _DXGK_SPB_INTERFACE {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                 Size;
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                 Version;
  PVOID                  Context;
  <a href="pinterface_reference" title="PINTERFACE_REFERENCE PinterfaceReference;&#10;&#10;VOID PinterfaceReference(&#10;  [in] PVOID Context&#10;)&#10;{...}">PINTERFACE_REFERENCE</a>   InterfaceReference;
  <a href="pinterface_dereference" title="PINTERFACE_DEREFERENCE PinterfaceDereference;&#10;&#10;VOID PinterfaceDereference(&#10;  [in] PVOID Context&#10;)&#10;{...}">PINTERFACE_DEREFERENCE</a> InterfaceDereference;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>(HANDLE DeviceHandle,LARGE_INTEGER SpbReourceId,<a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> *SpbResourceSubName,ACCESS_MASK DesiredAccess,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> ShareAccess,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> OpenOptions,VOID **SpbResource)              * )(OpenSpbResource;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>()(HANDLE DeviceHandle,VOID *SpbResource)              * CloseSpbResource;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>(ANDLE DeviceHandle,VOID *SpbResource,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,VOID *Buffer,LARGE_INTEGER *ByteOffset,HANDLE EventHandle,<a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> *IoStatusBlock)              * )(HReadSpbResource;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>(ANDLE DeviceHandle,VOID *SpbResource,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,VOID *Buffer,LARGE_INTEGER *ByteOffset,HANDLE EventHandle,<a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> *IoStatusBlock)              * )(HWriteSpbResource;
  <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>(ANDLE DeviceHandle,VOID *SpbResource,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> IoControlCode,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> InBufferSize,VOID *InputBuffer,<a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> OutBufferSize,VOID *OutputBuffer,HANDLE EventHandle,<a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> *IoStatusBlock)              * )(HSpbResourceIoControl;
} DXGK_SPB_INTERFACE, *PDXGK_SPB_INTERFACE;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/ns-dispmprt-_dxgk_spb_interface">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/dxgk_spb_interface.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-dispmprt-_dxgk_spb_interface)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="dxgk_spb_interface-structure">DXGK_SPB_INTERFACE structure</h1>

<h2 id="description">Description</h2>

<p>The <strong>DXGK_SPB_INTERFACE</strong> structure contains pointers to functions in the Simple Peripheral Bus (SPB) Interface that a Windows Display Driver Model (WDDM) 1.2 and later display miniport driver can call to inspect and alter SPB resources.</p>

<h2 id="members">Members</h2>

<h3 id="size"><code>Size</code></h3>

<p>The size, in bytes, of this structure.</p>

<h3 id="version"><code>Version</code></h3>

<p>The version number of the SPB interface. Version number constants are defined in <em>Dispmprt.h</em> (for example, DXGK_SPB_INTERFACE_VERSION_1).</p>

<h3 id="context"><code>Context</code></h3>

<p>A pointer to a context that is provided by the display miniport driver.</p>

<h3 id="interfacereference"><code>InterfaceReference</code></h3>

<p>A pointer to an interface reference function that is implemented by the display miniport driver.</p>

<h3 id="interfacedereference"><code>InterfaceDereference</code></h3>

<p>A pointer to an interface dereference function that is implemented by the display miniport driver.</p>

<h3 id="openspbresource"><code>OpenSpbResource</code></h3>

<p>Opens a Simple Peripheral Bus (SPB) resource. All input parameters are supplied by the display miniport driver.</p>

<table>
<thead>
<tr>
  <th>OpenSpbResource Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>DeviceHandle</strong></td>
  <td>Handle that represents a display adapter. The display miniport driver previously obtained this handle in the <strong>DeviceHandle</strong> member of the <strong><a href="dxgkrnl_interface" title="typedef struct _DXGKRNL_INTERFACE {&#10;  ULONG                                    Size;&#10;  ULONG                                    Version;&#10;  HANDLE                                   DeviceHandle;&#10;  DXGKCB_EVAL_ACPI_METHOD                  DxgkCbEvalAcpiMethod;&#10;  DXGKCB_GET_DEVICE_INFORMATION            DxgkCbGetDeviceInformation;&#10;  DXGKCB_INDICATE_CHILD_STATUS             DxgkCbIndicateChildStatus;&#10;  DXGKCB_MAP_MEMORY                        DxgkCbMapMemory;&#10;  DXGKCB_QUEUE_DPC                         DxgkCbQueueDpc;&#10;  DXGKCB_QUERY_SERVICES                    DxgkCbQueryServices;&#10;  DXGKCB_READ_DEVICE_SPACE                 DxgkCbReadDeviceSpace;&#10;  DXGKCB_SYNCHRONIZE_EXECUTION             DxgkCbSynchronizeExecution;&#10;  DXGKCB_UNMAP_MEMORY                      DxgkCbUnmapMemory;&#10;  DXGKCB_WRITE_DEVICE_SPACE                DxgkCbWriteDeviceSpace;&#10;  DXGKCB_IS_DEVICE_PRESENT                 DxgkCbIsDevicePresent;&#10;  DXGKCB_GETHANDLEDATA                     DxgkCbGetHandleData;&#10;  DXGKCB_GETHANDLEPARENT                   DxgkCbGetHandleParent;&#10;  DXGKCB_ENUMHANDLECHILDREN                DxgkCbEnumHandleChildren;&#10;  DXGKCB_NOTIFY_INTERRUPT                  DxgkCbNotifyInterrupt;&#10;  DXGKCB_NOTIFY_DPC                        DxgkCbNotifyDpc;&#10;...">DXGKRNL_INTERFACE</a></strong> structure that was passed to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkddi_start_device"><strong>DxgkDdiStartDevice</strong></a> function.</td>
</tr>
<tr>
  <td><strong>SpbReourceId</strong></td>
  <td>The resource ID of the SPB resource hub.</td>
</tr>
<tr>
  <td><strong>SpbResourceSubName</strong></td>
  <td>Optional pointer to the Unicode SPB resource subname.</td>
</tr>
<tr>
  <td><strong>DesiredAccess</strong></td>
  <td>An <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/access-mask"><strong>ACCESS_MASK</strong></a> value that determines the requested access to the SPB resource. For more information, see the <em>DesiredAccess</em> parameter of the <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong> function.</td>
</tr>
<tr>
  <td><strong>ShareAccess</strong></td>
  <td>Type of share access for the file. For more information, see the <em>ShareAccess</em> parameter of <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong>.</td>
</tr>
<tr>
  <td><strong>OpenOptions</strong></td>
  <td>The options to apply when opening the SPB resource. For more information, see the <em>CreateOptions</em> parameter of <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong>.</td>
</tr>
<tr>
  <td><strong>SpbResource</strong></td>
  <td>A pointer to a buffer that is used to return the handle to the SPB resource.</td>
</tr>
</tbody>
</table>

<h3 id="closespbresource"><code>CloseSpbResource</code></h3>

<p>Closes an SPB resource. All input parameters are supplied by the display miniport driver.</p>

<p>Closing an open object handle causes that handle to become invalid. The system also decrements the handle count for the object and checks whether the object can be deleted. The system does not actually delete the object until all of the object's handles are closed and no referenced pointers remain.</p>

<p>The driver must call <strong>CloseSpbResource</strong> to close every handle that it has opened with <strong>OpenSpbResource</strong> as soon as the handle is no longer required.</p>

<p>Callers of <strong>CloseSpbResource</strong> should not assume that this function automatically waits for all I/O to complete prior to returning.</p>

<table>
<thead>
<tr>
  <th>CloseSpbResource Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>DeviceHandle</strong></td>
  <td>A handle that represents a display adapter. The display miniport driver previously obtained this handle in the <strong>DeviceHandle</strong> member of the <strong><a href="dxgkrnl_interface" title="typedef struct _DXGKRNL_INTERFACE {&#10;  ULONG                                    Size;&#10;  ULONG                                    Version;&#10;  HANDLE                                   DeviceHandle;&#10;  DXGKCB_EVAL_ACPI_METHOD                  DxgkCbEvalAcpiMethod;&#10;  DXGKCB_GET_DEVICE_INFORMATION            DxgkCbGetDeviceInformation;&#10;  DXGKCB_INDICATE_CHILD_STATUS             DxgkCbIndicateChildStatus;&#10;  DXGKCB_MAP_MEMORY                        DxgkCbMapMemory;&#10;  DXGKCB_QUEUE_DPC                         DxgkCbQueueDpc;&#10;  DXGKCB_QUERY_SERVICES                    DxgkCbQueryServices;&#10;  DXGKCB_READ_DEVICE_SPACE                 DxgkCbReadDeviceSpace;&#10;  DXGKCB_SYNCHRONIZE_EXECUTION             DxgkCbSynchronizeExecution;&#10;  DXGKCB_UNMAP_MEMORY                      DxgkCbUnmapMemory;&#10;  DXGKCB_WRITE_DEVICE_SPACE                DxgkCbWriteDeviceSpace;&#10;  DXGKCB_IS_DEVICE_PRESENT                 DxgkCbIsDevicePresent;&#10;  DXGKCB_GETHANDLEDATA                     DxgkCbGetHandleData;&#10;  DXGKCB_GETHANDLEPARENT                   DxgkCbGetHandleParent;&#10;  DXGKCB_ENUMHANDLECHILDREN                DxgkCbEnumHandleChildren;&#10;  DXGKCB_NOTIFY_INTERRUPT                  DxgkCbNotifyInterrupt;&#10;  DXGKCB_NOTIFY_DPC                        DxgkCbNotifyDpc;&#10;...">DXGKRNL_INTERFACE</a></strong> structure that was passed to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkddi_start_device"><strong>DxgkDdiStartDevice</strong></a> function.</td>
</tr>
<tr>
  <td><strong>SpbResource</strong></td>
  <td>A pointer to an SPB resource that the display miniport driver opened using the <strong>OpenSpbResource</strong> function.</td>
</tr>
</tbody>
</table>

<h3 id="readspbresource"><code>ReadSpbResource</code></h3>

<p>Reads data from an open SPB resource. All input parameters are supplied by the display miniport driver.</p>

<p>If the call to <strong>OpenSpbResource</strong> set either of the <em>OpenOptions</em> flags <strong><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></strong> or <strong><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a></strong> (defined in <em>Wdm.h</em>), the I/O Manager maintains the current file position. If so, the caller of <strong>ReadSpbResource</strong> can specify that the current file position offset be used instead of an explicit <em>ByteOffset</em> value. This specification can be made by using one of the following methods:</p>

<ul>
<li>Specify a pointer to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1"><strong>LARGE_INTEGER</strong></a> value with the <strong>HighPart</strong> member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <strong><a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a></strong> (defined in Wdm.h).</li>
<li>Pass a <strong>NULL</strong> pointer for <em>ByteOffset</em>.</li>
</ul>

<p><strong>ReadSpbResource</strong> updates the current file position by adding the number of bytes read when it completes the read operation, if it is using the current file position maintained by the I/O Manager.</p>

<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <em>ByteOffset</em> value to <strong>ReadSpbResource</strong>. Doing this automatically changes the current file position to that <em>ByteOffset</em> value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service.</p>

<table>
<thead>
<tr>
  <th>OpenSpbResource Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>DeviceHandle</strong></td>
  <td>A handle that represents a display adapter. The display miniport driver previously obtained this handle in the <strong>DeviceHandle</strong> member of the <strong><a href="dxgkrnl_interface" title="typedef struct _DXGKRNL_INTERFACE {&#10;  ULONG                                    Size;&#10;  ULONG                                    Version;&#10;  HANDLE                                   DeviceHandle;&#10;  DXGKCB_EVAL_ACPI_METHOD                  DxgkCbEvalAcpiMethod;&#10;  DXGKCB_GET_DEVICE_INFORMATION            DxgkCbGetDeviceInformation;&#10;  DXGKCB_INDICATE_CHILD_STATUS             DxgkCbIndicateChildStatus;&#10;  DXGKCB_MAP_MEMORY                        DxgkCbMapMemory;&#10;  DXGKCB_QUEUE_DPC                         DxgkCbQueueDpc;&#10;  DXGKCB_QUERY_SERVICES                    DxgkCbQueryServices;&#10;  DXGKCB_READ_DEVICE_SPACE                 DxgkCbReadDeviceSpace;&#10;  DXGKCB_SYNCHRONIZE_EXECUTION             DxgkCbSynchronizeExecution;&#10;  DXGKCB_UNMAP_MEMORY                      DxgkCbUnmapMemory;&#10;  DXGKCB_WRITE_DEVICE_SPACE                DxgkCbWriteDeviceSpace;&#10;  DXGKCB_IS_DEVICE_PRESENT                 DxgkCbIsDevicePresent;&#10;  DXGKCB_GETHANDLEDATA                     DxgkCbGetHandleData;&#10;  DXGKCB_GETHANDLEPARENT                   DxgkCbGetHandleParent;&#10;  DXGKCB_ENUMHANDLECHILDREN                DxgkCbEnumHandleChildren;&#10;  DXGKCB_NOTIFY_INTERRUPT                  DxgkCbNotifyInterrupt;&#10;  DXGKCB_NOTIFY_DPC                        DxgkCbNotifyDpc;&#10;...">DXGKRNL_INTERFACE</a></strong> structure that was passed to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkddi_start_device"><strong>DxgkDdiStartDevice</strong></a> function.</td>
</tr>
<tr>
  <td><strong>SpbResource</strong></td>
  <td>A pointer to an SPB resource that the display miniport driver opened using the <strong>OpenSpbResource</strong> function.</td>
</tr>
<tr>
  <td><strong>Length</strong></td>
  <td>The size, in bytes, of the buffer pointed to by the <em>Buffer</em> parameter.</td>
</tr>
<tr>
  <td><strong>Buffer</strong></td>
  <td>A pointer to a buffer that receives the data read from the specified SPB resource.</td>
</tr>
<tr>
  <td><strong>ByteOffset</strong></td>
  <td>An optional pointer to a variable that specifies the starting byte offset in the SPB resource where the read operation will begin. If an attempt is made to read beyond the end of the file, <strong>ReadSpbResource</strong> returns an error.</td>
</tr>
<tr>
  <td><strong>EventHandle</strong></td>
  <td>An optional handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the read operation is completed and the given event is set to the <strong>Signaled</strong> state. This parameter can be <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>IoStatusBlock</strong></td>
  <td>A pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that receives the final completion status and information about the requested read operation. The <strong>Information</strong> member of the <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure receives the number of bytes actually read from the SPB resource.</td>
</tr>
</tbody>
</table>

<h3 id="writespbresource"><code>WriteSpbResource</code></h3>

<p>Writes data to an open SPB resource.</p>

<p>If the call to the <strong>OpenSpbResource</strong> function set only the <em>DesiredAccess</em> flag <strong>FILE_APPEND_DATA</strong>, the <em>ByteOffset</em> parameter is ignored. In this case, data in the buffer pointed to by the <em>Buffer</em> parameter, for <strong>Length</strong> bytes, is written starting at the current end of file.</p>

<p>If the call to <strong>OpenSpbResource</strong> set either of the <em>CreateOptions</em> flags, <strong><a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a></strong> or <strong><a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a></strong>, the I/O Manager maintains the current file position. If so, the caller of <strong>WriteSpbResource</strong> can specify that the current file position offset be used instead of an explicit <em>ByteOffset</em> value. This specification can be made by using one of the following methods:</p>

<ul>
<li>Specify a pointer to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1"><strong>LARGE_INTEGER</strong></a> value with the <strong>HighPart</strong> member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <strong><a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a></strong> (defined in <em>Wdm.h</em>).</li>
<li>Pass a <strong>NULL</strong> pointer for <em>ByteOffset</em>.</li>
</ul>

<p><strong>WriteSpbResource</strong> updates the current file position by adding the number of bytes written when it completes the write operation, if it is using the current file position maintained by the I/O Manager.</p>

<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <em>ByteOffset</em> value to <strong>WriteSpbResource</strong>. Doing this automatically changes the current file position to that <em>ByteOffset</em> value, performs the write operation, and then updates the position according to the number of bytes actually written. This technique gives the caller atomic seek-and-write service.</p>

<p>It is also possible to cause a write operation to start at the current end of file by specifying for <em>ByteOffset</em> a pointer to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1"><strong>LARGE_INTEGER</strong></a> value with <strong>HighPart</strong> set to -1 and <strong>LowPart</strong> set to <strong><a href="file_write_to_end_of_file" title="#define FILE_WRITE_TO_END_OF_FILE 0xffffffff">FILE_WRITE_TO_END_OF_FILE</a></strong>. This works regardless of whether the I/O Manager is maintaining the current file position.</p>

<table>
<thead>
<tr>
  <th>WriteSpbResource Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>DeviceHandle</strong></td>
  <td>A handle that represents a display adapter. The display miniport driver previously obtained this handle in the <strong>DeviceHandle</strong> member of the <strong><a href="dxgkrnl_interface" title="typedef struct _DXGKRNL_INTERFACE {&#10;  ULONG                                    Size;&#10;  ULONG                                    Version;&#10;  HANDLE                                   DeviceHandle;&#10;  DXGKCB_EVAL_ACPI_METHOD                  DxgkCbEvalAcpiMethod;&#10;  DXGKCB_GET_DEVICE_INFORMATION            DxgkCbGetDeviceInformation;&#10;  DXGKCB_INDICATE_CHILD_STATUS             DxgkCbIndicateChildStatus;&#10;  DXGKCB_MAP_MEMORY                        DxgkCbMapMemory;&#10;  DXGKCB_QUEUE_DPC                         DxgkCbQueueDpc;&#10;  DXGKCB_QUERY_SERVICES                    DxgkCbQueryServices;&#10;  DXGKCB_READ_DEVICE_SPACE                 DxgkCbReadDeviceSpace;&#10;  DXGKCB_SYNCHRONIZE_EXECUTION             DxgkCbSynchronizeExecution;&#10;  DXGKCB_UNMAP_MEMORY                      DxgkCbUnmapMemory;&#10;  DXGKCB_WRITE_DEVICE_SPACE                DxgkCbWriteDeviceSpace;&#10;  DXGKCB_IS_DEVICE_PRESENT                 DxgkCbIsDevicePresent;&#10;  DXGKCB_GETHANDLEDATA                     DxgkCbGetHandleData;&#10;  DXGKCB_GETHANDLEPARENT                   DxgkCbGetHandleParent;&#10;  DXGKCB_ENUMHANDLECHILDREN                DxgkCbEnumHandleChildren;&#10;  DXGKCB_NOTIFY_INTERRUPT                  DxgkCbNotifyInterrupt;&#10;  DXGKCB_NOTIFY_DPC                        DxgkCbNotifyDpc;&#10;...">DXGKRNL_INTERFACE</a></strong> structure that was passed to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkddi_start_device"><strong>DxgkDdiStartDevice</strong></a> function.</td>
</tr>
<tr>
  <td><strong>SpbResource</strong></td>
  <td>A pointer to an SPB resource that the display miniport driver opened using the <strong>OpenSpbResource</strong> function.</td>
</tr>
<tr>
  <td><strong>Length</strong></td>
  <td>The size, in bytes, of the buffer pointed to by the <em>Buffer</em> parameter.</td>
</tr>
<tr>
  <td><strong>Buffer</strong></td>
  <td>A pointer to a caller-allocated buffer that contains the data to be written to the specified SPB resource.</td>
</tr>
<tr>
  <td><strong>ByteOffset</strong></td>
  <td>An optional pointer to a variable that specifies the starting byte offset in the SPB resource where the write operation will begin. If the <em>Length</em> and <em>ByteOffset</em> parameters specify a write operation past the current end-of-file mark, <strong>WriteSpbResource</strong> automatically extends the file and updates the end-of-file mark; any bytes that are not explicitly written between such old and new end-of-file marks are defined to be zero.</td>
</tr>
<tr>
  <td><strong>EventHandle</strong></td>
  <td>An optional handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the write operation is completed and the given event is set to the <strong>Signaled</strong> state. This parameter can be <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>IoStatusBlock</strong></td>
  <td>A pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that receives the final completion status and information about the requested write operation. The <strong>Information</strong> member of the <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure receives the number of bytes actually written to the SPB resource.</td>
</tr>
</tbody>
</table>

<h3 id="spbresourceiocontrol"><code>SpbResourceIoControl</code></h3>

<p>Performs an I/O control operation on an open Simple Peripheral Bus (SPB) resource. All input parameters are supplied by the display miniport driver.</p>

<p>If the caller opened the file for asynchronous I/O (with neither <strong>FILE_SYNCHRONOUS_XXX</strong> create/open option set), the specified event, if any, will be set to the <strong>Signaled</strong> state when the device control operation completes. Otherwise, the file object specified by the <em>DeviceHandle</em> parameter will be set to the <strong>Signaled</strong> state.</p>

<table>
<thead>
<tr>
  <th>SpbResourceIoControl Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>DeviceHandle</strong></td>
  <td>A handle that represents a display adapter. The display miniport driver previously obtained this handle in the <strong>DeviceHandle</strong> member of the <strong><a href="dxgkrnl_interface" title="typedef struct _DXGKRNL_INTERFACE {&#10;  ULONG                                    Size;&#10;  ULONG                                    Version;&#10;  HANDLE                                   DeviceHandle;&#10;  DXGKCB_EVAL_ACPI_METHOD                  DxgkCbEvalAcpiMethod;&#10;  DXGKCB_GET_DEVICE_INFORMATION            DxgkCbGetDeviceInformation;&#10;  DXGKCB_INDICATE_CHILD_STATUS             DxgkCbIndicateChildStatus;&#10;  DXGKCB_MAP_MEMORY                        DxgkCbMapMemory;&#10;  DXGKCB_QUEUE_DPC                         DxgkCbQueueDpc;&#10;  DXGKCB_QUERY_SERVICES                    DxgkCbQueryServices;&#10;  DXGKCB_READ_DEVICE_SPACE                 DxgkCbReadDeviceSpace;&#10;  DXGKCB_SYNCHRONIZE_EXECUTION             DxgkCbSynchronizeExecution;&#10;  DXGKCB_UNMAP_MEMORY                      DxgkCbUnmapMemory;&#10;  DXGKCB_WRITE_DEVICE_SPACE                DxgkCbWriteDeviceSpace;&#10;  DXGKCB_IS_DEVICE_PRESENT                 DxgkCbIsDevicePresent;&#10;  DXGKCB_GETHANDLEDATA                     DxgkCbGetHandleData;&#10;  DXGKCB_GETHANDLEPARENT                   DxgkCbGetHandleParent;&#10;  DXGKCB_ENUMHANDLECHILDREN                DxgkCbEnumHandleChildren;&#10;  DXGKCB_NOTIFY_INTERRUPT                  DxgkCbNotifyInterrupt;&#10;  DXGKCB_NOTIFY_DPC                        DxgkCbNotifyDpc;&#10;...">DXGKRNL_INTERFACE</a></strong> structure that was passed to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkddi_start_device"><strong>DxgkDdiStartDevice</strong></a> function.</td>
</tr>
<tr>
  <td><strong>SpbResource</strong></td>
  <td>A pointer to an SPB resource that the display miniport driver opened using the <strong>OpenSpbResource</strong> function.</td>
</tr>
<tr>
  <td><strong>IoControlCode</strong></td>
  <td>A device I/O control code (IOCTL_XXX) that indicates which device I/O control operation is to be carried out on, usually by the underlying device driver. The value of this parameter determines the format and required length of the <em>InputBuffer</em> and <em>OutputBuffer</em> parameters, as well as which of the following parameter pairs are required.</td>
</tr>
<tr>
  <td><strong>InBufferSize</strong></td>
  <td>The size, in bytes, of the buffer pointed to by the <em>InputBuffer</em> parameter. This value is ignored if <em>InputBuffer</em> is <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>InputBuffer</strong></td>
  <td>A pointer to a caller-allocated input buffer that contains device-specific information to be given to the target device. If the <em>IoControlCode</em> parameter specifies an operation that does not require input data, this pointer can be <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>OutBufferSize</strong></td>
  <td>The size, in bytes, of the buffer pointed to by the <em>OutputBuffer</em> parameter. This value is ignored if <em>OutputBuffer</em> is <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>OutputBuffer</strong></td>
  <td>A pointer to a caller-allocated output buffer in which information is returned from the target device. If the <em>IoControlCode</em> parameter specifies an operation that does not produce output data, this pointer can be <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>EventHandle</strong></td>
  <td>An optional handle for a caller-created event. If this parameter is supplied, the caller will be put into a wait state until the requested operation is completed and the given event is set to the <strong>Signaled</strong> state. This parameter can be <strong>NULL</strong>.</td>
</tr>
<tr>
  <td><strong>IoStatusBlock</strong></td>
  <td>A pointer to a variable that receives the final completion status and information about the requested I/O control operation. For successful calls that return data, the number of bytes written to the buffer pointed to by the <em>OutputBuffer</em> parameter is returned in the <strong>Information</strong> member of the <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>To use this structure's functions, first supply the <strong>Size</strong> and <strong>Version</strong> members of the <strong>DXGK_SPB_INTERFACE</strong> structure. Then call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/nc-dispmprt-dxgkcb_query_services"><strong>DxgkCbQueryServices</strong></a> function with the <strong>ServicesType</strong> parameter set to a value of <strong>DxgkServicesFirmwareTable</strong>, and set the <strong>Interface</strong> parameter to the address (cast as <strong><a href="interface" title="typedef struct _INTERFACE {&#10;  USHORT                 Size;&#10;  USHORT                 Version;&#10;  PVOID                  Context;&#10;  PINTERFACE_REFERENCE   InterfaceReference;&#10;  PINTERFACE_DEREFERENCE InterfaceDereference;&#10;} INTERFACE, *PINTERFACE;">PINTERFACE</a></strong>) of the <strong>DXGK_SPB_INTERFACE</strong> structure.</p>

<p>For more information on SPB architecture, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/design/component-guidelines/simple-peripheral-bus--spb-">Simple Peripheral Buses</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/spb">SPB Peripheral Driver Design Guide**</a>.</p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/dispmprt/ns-dispmprt-_dxgk_spb_interface">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/dispmprt/ns-dispmprt-_dxgk_spb_interface.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
