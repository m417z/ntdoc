<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FLT_FILE_NAME_INFORMATION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FLT_FILE_NAME_INFORMATION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FLT_FILE_NAME_INFORMATION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fltkernel.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _FLT_FILE_NAME_INFORMATION {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                     Size;
  FLT_FILE_NAME_PARSED_FLAGS NamesParsed;
  FLT_FILE_NAME_OPTIONS      Format;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             Name;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             Volume;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             Share;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             Extension;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             Stream;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             FinalComponent;
  <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>             ParentDir;
} FLT_FILE_NAME_INFORMATION, *PFLT_FILE_NAME_INFORMATION;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_file_name_information">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/flt_file_name_information.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-fltkernel-_flt_file_name_information)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_flt_file_name_information-structure">_FLT_FILE_NAME_INFORMATION structure</h1>

<h2 id="description">Description</h2>

<p>The FLT_FILE_NAME_INFORMATION structure contains file name information.</p>

<h2 id="members">Members</h2>

<h3 id="size"><code>Size</code></h3>

<p>Size, in bytes, of the FLT_FILE_NAME_INFORMATION structure.</p>

<h3 id="namesparsed"><code>NamesParsed</code></h3>

<p>Bitmask of flags that indicate which name components have been parsed from the <strong>Name</strong> string by <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a>. Note that, when parsing the <strong>Name</strong> string, <strong><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></strong> sets this flag for each component, whether the component is found to be present in the string. These values may be combined by using the OR operator.</p>

<table>
<thead>
<tr>
  <th>Flag</th>
  <th>Component</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLTFL_FILE_NAME_PARSED_FINAL_COMPONENT</td>
  <td><strong>FinalComponent</strong></td>
</tr>
<tr>
  <td>FLTFL_FILE_NAME_PARSED_EXTENSION</td>
  <td><strong>Extension</strong></td>
</tr>
<tr>
  <td>FLTFL_FILE_NAME_PARSED_STREAM</td>
  <td><strong>Stream</strong></td>
</tr>
<tr>
  <td>FLTFL_FILE_NAME_PARSED_PARENT_DIR</td>
  <td><strong>ParentDir</strong></td>
</tr>
</tbody>
</table>

<h3 id="format"><code>Format</code></h3>

<p>Format of the name information stored in the <strong>Name</strong> member. This member can be one of the following values. (For an explanation of these formats, see the following Remarks section.)</p>

<table>
<thead>
<tr>
  <th>Value</th>
  <th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FLT_FILE_NAME_NORMALIZED</td>
  <td>The <strong>Name</strong> member contains the normalized name for the file.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_OPENED</td>
  <td>The <strong>Name</strong> member contains the name that was used when the file was opened. This name string is not normalized.</td>
</tr>
<tr>
  <td>FLT_FILE_NAME_SHORT</td>
  <td>The <strong>Name</strong> member contains the short (8.3) name for the file. The short name for a file does not include the volume name, directory path, or stream name. This name string is not normalized.</td>
</tr>
</tbody>
</table>

<h3 id="name"><code>Name</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the file name string, formatted as specified by the <strong>Format</strong> member.</p>

<h3 id="volume"><code>Volume</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the volume name parsed from the <strong>Name</strong> string. If <strong>Format</strong> is FLT_FILE_NAME_SHORT, <strong>Volume.Length</strong> is zero.</p>

<h3 id="share"><code>Share</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the network share name parsed from the <strong>Name</strong> string for a remote file. If <strong>Format</strong> is FLT_FILE_NAME_SHORT, <strong>Share.Length</strong> is zero.</p>

<h3 id="extension"><code>Extension</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the extension parsed from the <strong>Name</strong> string. If no extension is found, <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a> sets <strong>Extension.Length</strong> to zero.</p>

<h3 id="stream"><code>Stream</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the stream name parsed from the <strong>Name</strong> string. If no stream name is found, or if <strong>Format</strong> is FLT_FILE_NAME_SHORT, <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a> sets <strong>Stream.Length</strong> to zero.</p>

<h3 id="finalcomponent"><code>FinalComponent</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the final name component parsed from the <strong>Name</strong> string. If no final component name is found, or if <strong>Format</strong> is FLT_FILE_NAME_SHORT, <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a> sets <strong>FinalComponent.Length</strong> to zero.</p>

<h3 id="parentdir"><code>ParentDir</code></h3>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structure that contains the parent directory name parsed from the <strong>Name</strong> string by <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a>. If no parent directory name is found, or if <strong>Format</strong> is FLT_FILE_NAME_SHORT, <strong><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></strong> sets <strong>ParentDir.Length</strong> to zero.</p>

<h2 id="remarks">Remarks</h2>

<p>The <strong>Name</strong> member contains one of the following:</p>

<ul>
<li>The normalized name for the file</li>
<li>The opened name for the file</li>
<li>The short name for the file</li>
</ul>

<p>A file name is considered <em>normalized</em> if all of the following are true:</p>

<ul>
<li>It contains the full directory path for the file, including the volume name, unless the user opened the file by file ID but does not have traverse privilege for the entire path. (For more information, see <a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a>.)</li>
<li>The volume name is the volume's nonpersistent device object name (for example, "\Device\HarddiskVolume1").</li>
<li>All short names are expanded to the equivalent long names.</li>
<li>Any trailing ":$DATA" or "::$DATA" strings are removed from the stream name.</li>
<li>All mount points are resolved.</li>
</ul>

<p>The following is an example of a normalized file name for a local file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>\Device\HarddiskVolume1\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1
</code></pre>

<p>The following is an example of a normalized file name for a remote file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>\Device\LanManRedirector\MyServer\MyShare\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1
</code></pre>

<p>The <em>opened name</em> for a file is the name that was used when the file was opened. Like the normalized name, it contains the full directory path for the file, including the volume name. It differs from the normalized name in the following ways:</p>

<ul>
<li>The directory path for the file can contain short names as well as long names.</li>
<li>Trailing ":$DATA" and "::$DATA" strings are not removed from the stream name.</li>
<li>Mount points are not resolved.</li>
</ul>

<p>The following is an example of an opened file name for a local file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>\Device\HarddiskVolume1\Docume~1\MyUser\MYDOCU~1\Test Results.txt:stream1:$DATA
</code></pre>

<p>The following is an example of an opened file name for a remote file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>\Device\LanManRedirector\MyServer\MyShare\Documents and Settings\MyUser\My Documents\Test Results.txt:stream1
</code></pre>

<p>The <em>short name</em> for a file is the short (8.3) name for the final component of the file name. Because it is generated when the file is opened, the short name is not available for an unopened file object, and it is not available in the create dispatch ("pre-create") path. It is also not available for NTFS stream file objects. Not all open files have short file names. For example, on NTFS partitions where short file name generation has been disabled, no files have short file names.</p>

<p>The following is an example of a short name for a file:</p>

<p><!-- CODE_MARKER --></p>

<pre><code>TestRe~1.txt
</code></pre>

<p>To obtain an FLT_FILE_NAME_INFORMATION structure for a file, call <a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a>, <a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a>, or <a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a>. These routines returns a pointer to a Filter Manager-owned FLT_FILE_NAME_INFORMATION structure that is shared by all minifilters.</p>

<p><strong>Note</strong> Do not modify the contents of FLT_FILE_NAME_INFORMATION structures, because these structures are cached by the Filter Manager so that all minifilters can use them. If your minifilter must modify this information in some way, it should copy the information into another buffer first.</p>

<p>File systems such as NTFS and FAT use a per-volume tunnel cache to briefly preserve file names and other metadata for files that are being renamed, linked to, or deleted. This file name tunneling can cause the final component in normalized file name information returned by a preoperation call to <a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a>, <a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a>, or <a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a> to be invalidated. If a minifilter retrieves normalized file name information in the preoperation callback (<a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a>) routine for a create, hard-link, or rename operation, it must call <a href="fltgettunneledname" title="NTSTATUS FLTAPI FltGetTunneledName(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  PFLT_FILE_NAME_INFORMATION FileNameInformation,&#10;  [out] PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation&#10;);">FltGetTunneledName</a> from its postoperation callback (<a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a>) routine to retrieve the correct file name information for the file.</p>

<p>Although it contains numerous <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structures, the FLT_FILE_NAME_INFORMATION structure does not occupy much space in memory because all of the <a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a> structures in a FLT_FILE_NAME_INFORMATION structure share a single buffer.</p>

<p>To parse the contents of the <strong>Name</strong> string, call <a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a>. This routine sets the values of the <strong>Extension</strong>, <strong>Stream</strong>, <strong>FinalComponent</strong>, <strong>ParentDir</strong>, and <strong>NamesParsed</strong> members of this structure.</p>

<p>Minifilters are responsible for calling <a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a> to release the FLT_FILE_NAME_INFORMATION structure when it is no longer needed.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/flt-file-name-options">FLT_FILE_NAME_OPTIONS</a></p>

<p><a href="fltgetdestinationfilenameinformation" title="NTSTATUS FLTAPI FltGetDestinationFileNameInformation(&#10;  [in]           PFLT_INSTANCE              Instance,&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] HANDLE                     RootDirectory,&#10;  [in]           PWSTR                      FileName,&#10;  [in]           ULONG                      FileNameLength,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *RetFileNameInformation&#10;);">FltGetDestinationFileNameInformation</a></p>

<p><a href="fltgetfilenameinformation" title="NTSTATUS FLTAPI FltGetFileNameInformation(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out] PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformation</a></p>

<p><a href="fltgetfilenameinformationunsafe" title="NTSTATUS FLTAPI FltGetFileNameInformationUnsafe(&#10;  [in]           PFILE_OBJECT               FileObject,&#10;  [in, optional] PFLT_INSTANCE              Instance,&#10;  [in]           FLT_FILE_NAME_OPTIONS      NameOptions,&#10;  [out]          PFLT_FILE_NAME_INFORMATION *FileNameInformation&#10;);">FltGetFileNameInformationUnsafe</a></p>

<p><a href="fltgettunneledname" title="NTSTATUS FLTAPI FltGetTunneledName(&#10;  [in]  PFLT_CALLBACK_DATA         CallbackData,&#10;  [in]  PFLT_FILE_NAME_INFORMATION FileNameInformation,&#10;  [out] PFLT_FILE_NAME_INFORMATION *RetTunneledFileNameInformation&#10;);">FltGetTunneledName</a></p>

<p><a href="fltparsefilename" title="NTSTATUS FLTAPI FltParseFileName(&#10;  [in]      PCUNICODE_STRING FileName,&#10;  [in, out] PUNICODE_STRING  Extension,&#10;  [in, out] PUNICODE_STRING  Stream,&#10;  [in, out] PUNICODE_STRING  FinalComponent&#10;);">FltParseFileName</a></p>

<p><a href="fltparsefilenameinformation" title="NTSTATUS FLTAPI FltParseFileNameInformation(&#10;  [in, out] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltParseFileNameInformation</a></p>

<p><a href="fltreferencefilenameinformation" title="VOID FLTAPI FltReferenceFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReferenceFileNameInformation</a></p>

<p><a href="fltreleasefilenameinformation" title="VOID FLTAPI FltReleaseFileNameInformation(&#10;  [in] PFLT_FILE_NAME_INFORMATION FileNameInformation&#10;);">FltReleaseFileNameInformation</a></p>

<p><a href="pflt_post_operation_callback" title="PFLT_POST_OPERATION_CALLBACK PfltPostOperationCallback;&#10;&#10;FLT_POSTOP_CALLBACK_STATUS PfltPostOperationCallback(&#10;  [in, out]      PFLT_CALLBACK_DATA Data,&#10;  [in]           PCFLT_RELATED_OBJECTS FltObjects,&#10;  [in, optional] PVOID CompletionContext,&#10;  [in]           FLT_POST_OPERATION_FLAGS Flags&#10;)&#10;{...}">PFLT_POST_OPERATION_CALLBACK</a></p>

<p><a href="pflt_pre_operation_callback" title="PFLT_PRE_OPERATION_CALLBACK PfltPreOperationCallback;&#10;&#10;FLT_PREOP_CALLBACK_STATUS PfltPreOperationCallback(&#10;  [in, out] PFLT_CALLBACK_DATA Data,&#10;  [in]      PCFLT_RELATED_OBJECTS FltObjects,&#10;  [out]     PVOID *CompletionContext&#10;)&#10;{...}">PFLT_PRE_OPERATION_CALLBACK</a></p>

<p><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fltkernel/ns-fltkernel-_flt_file_name_information">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fltkernel/ns-fltkernel-_flt_file_name_information.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
