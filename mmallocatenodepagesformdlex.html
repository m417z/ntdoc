<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="MmAllocateNodePagesForMdlEx - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>MmAllocateNodePagesForMdlEx - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            MmAllocateNodePagesForMdlEx - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wdm.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">PMDL</a> MmAllocateNodePagesForMdlEx(
  [in] <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>    LowAddress,
  [in] <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>    HighAddress,
  [in] <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>    SkipBytes,
  [in] <a href="size_t-2" title="typedef ULONG_PTR SIZE_T;">SIZE_T</a>              TotalBytes,
  [in] <a href="memory_caching_type" title="typedef enum _MEMORY_CACHING_TYPE {&#10;  MmNonCached,&#10;  MmCached,&#10;  MmWriteCombined,&#10;  MmHardwareCoherentCached,&#10;  MmNonCachedUnordered,&#10;  MmUSWCCached,&#10;  MmMaximumCacheType,&#10;  MmNotMapped&#10;} MEMORY_CACHING_TYPE;">MEMORY_CACHING_TYPE</a> CacheType,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               IdealNode,
  [in] <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>               Flags
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatenodepagesformdlex">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/mmallocatenodepagesformdlex.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-mmallocatenodepagesformdlex)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2 id="description">Description</h2>

<p>The <strong>MmAllocateNodePagesForMdlEx</strong> routine allocates nonpaged physical memory from an ideal node, and allocates an <strong><a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a></strong> structure to describe this memory.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="lowaddress-in"><code>LowAddress</code> [in]</h3>

<p>The physical address of the start of the first address range from which the allocated pages can come. If <strong>MmAllocateNodePagesForMdlEx</strong> cannot allocate the requested number of bytes in the first address range, the routine iterates through additional address ranges to get more pages. At each iteration, <strong>MmAllocateNodePagesForMdlEx</strong> adds the value of <em>SkipBytes</em> to the previous start address to calculate the start of the next address range.</p>

<h3 id="highaddress-in"><code>HighAddress</code> [in]</h3>

<p>The physical address of the end of the first address range that the allocated pages can come from.</p>

<h3 id="skipbytes-in"><code>SkipBytes</code> [in]</h3>

<p>The number of bytes to skip from the start of the previous address range that the allocated pages can come from. <em>SkipBytes</em> must be an integer multiple of the virtual memory page size, in bytes.</p>

<h3 id="totalbytes-in"><code>TotalBytes</code> [in]</h3>

<p>The total number of bytes to allocate for the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<h3 id="cachetype-in"><code>CacheType</code> [in]</h3>

<p>A <a href="memory_caching_type" title="typedef enum _MEMORY_CACHING_TYPE {&#10;  MmNonCached,&#10;  MmCached,&#10;  MmWriteCombined,&#10;  MmHardwareCoherentCached,&#10;  MmNonCachedUnordered,&#10;  MmUSWCCached,&#10;  MmMaximumCacheType,&#10;  MmNotMapped&#10;} MEMORY_CACHING_TYPE;">MEMORY_CACHING_TYPE</a> value, which indicates the type of caching that is allowed for the requested memory.</p>

<h3 id="idealnode-in"><code>IdealNode</code> [in]</h3>

<p>The ideal node number. If a multiprocessor system contains N nodes, valid node numbers are in the range 0 to N-1. Your driver can call the <a href="kequeryhighestnodenumber" title="USHORT KeQueryHighestNodeNumber();">KeQueryHighestNodeNumber</a> routine to get the highest node number. A single-processor or non-NUMA multiprocessor system has only one node, node 0, from which to allocate memory. For a NUMA multiprocessor system, the allocation is made from the ideal node, if possible. If insufficient memory is available in the ideal node to satisfy the allocation request, and the caller does not set the MM_ALLOCATE_FROM_LOCAL_NODE_ONLY flag, <strong>MmAllocateNodePagesForMdlEx</strong> will try to allocate memory from other nodes.</p>

<h3 id="flags-in"><code>Flags</code> [in]</h3>

<p>Flags for this operation. Set this parameter to zero or to the bitwise-OR of one or more of the following flag bits:</p>

<ul>
<li><p>MM_DONT_ZERO_ALLOCATION</p></li>
<li><p>MM_ALLOCATE_FROM_LOCAL_NODE_ONLY</p></li>
<li><p>MM_ALLOCATE_FULLY_REQUIRED</p></li>
<li><p>MM_ALLOCATE_NO_WAIT</p></li>
<li><p>MM_ALLOCATE_PREFER_CONTIGUOUS</p></li>
<li><p>MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS</p></li>
<li><p>MM_ALLOCATE_AND_HOT_REMOVE</p></li>
</ul>

<p>For more information about these flags, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatepagesformdlex">MM_ALLOCATE_XXX</a>.</p>

<h2 id="return-value">Return value</h2>

<p><strong>MmAllocateNodePagesForMdlEx</strong> returns a pointer to an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> structure if it is successful. Otherwise, if the routine fails to allocate any memory, the routine returns <strong>NULL</strong>.</p>

<p>A return value of <strong>NULL</strong> indicates that no physical memory pages are available in the specified address ranges, or that there is not enough memory pool available to allocate the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> structure.</p>

<p>If the routine successfully allocates some, but not all, of the requested memory, the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> describes as much physical memory as the routine was able to allocate.</p>

<h2 id="remarks">Remarks</h2>

<p>In a non-uniform memory access (NUMA) multiprocessor system, the caller can specify an ideal node from which to allocate the memory. A node is a collection of processors that share fast access to a region of memory. In a non-NUMA multiprocessor or a single-processor system, <strong>MmAllocateNodePagesForMdlEx</strong> treats all memory as belonging to a single node and allocates memory from this node.</p>

<p>By default, the physical memory pages that <strong>MmAllocateNodePagesForMdlEx</strong> returns are not contiguous pages. Callers can override the default behavior of this routine by setting the MM_ALLOCATE_PREFER_CONTIGUOUS or MM_ALLOCATE_REQUIRE_CONTIGUOUS_CHUNKS flag bit in the <em>Flags</em> parameter.</p>

<p><strong>MmAllocateNodePagesForMdlEx</strong> does not map the allocated physical memory into virtual memory. If necessary, the caller can call a routine such as <a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a> to map the physical memory pages described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<p><strong>MmAllocateNodePagesForMdlEx</strong> is designed for kernel-mode drivers that do not need corresponding virtual addresses (that is, they need physical pages and do not need them to be physically contiguous), and for kernel-mode drivers that can achieve substantial performance gains if physical memory for a device is allocated in a specific physical address range (for example, an AGP graphics card).</p>

<p>Depending on how much physical memory is currently available in the requested ranges, <strong>MmAllocateNodePagesForMdlEx</strong> might return an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that describes less memory than was requested. The routine also might return <strong>NULL</strong> if no memory was allocated. The caller should check the amount of memory that is actually allocated, as described by the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a>.</p>

<p>The caller must use <a href="mmfreepagesfrommdl" title="VOID MmFreePagesFromMdl(&#10;  [in] PMDL MemoryDescriptorList&#10;);">MmFreePagesFromMdl</a> to release the memory pages that are described by an <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> that was created by <strong>MmAllocateNodePagesForMdlEx</strong>. After calling <strong><a href="mmfreepagesfrommdl" title="VOID MmFreePagesFromMdl(&#10;  [in] PMDL MemoryDescriptorList&#10;);">MmFreePagesFromMdl</a></strong>, the caller must also call <a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a> to release the memory allocated for the <a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a> structure.</p>

<p>By default, <strong>MmAllocateNodePagesForMdlEx</strong> fills the pages that it allocates with zeros. The caller can specify the MM_DONT_ZERO_ALLOCATION flag to override this default and to possibly improve performance.</p>

<p>Memory that <strong>MmAllocateNodePagesForMdlEx</strong> allocates is uninitialized if you specify the MM_DONT_ZERO_ALLOCATION flag. A kernel-mode driver must first zero this memory if the driver is going to make the memory visible to user-mode software (to avoid leaking potentially privileged contents). For more information about this flag, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatepagesformdlex">MM_ALLOCATE_XXX</a>.</p>

<p>The maximum amount of memory that <strong>MmAllocateNodePagesForMdlEx</strong> can allocate in a single call is (4 gigabytes - <a href="page_size" title="#define PAGE_SIZE 0x1000">PAGE_SIZE</a>). The routine can satisfy an allocation request for this amount only if enough pages are available.</p>

<p><strong>MmAllocateNodePagesForMdlEx</strong> runs at IRQL &lt;= APC_LEVEL. If necessary, your driver can call **MmAllocateNodePagesForMdlEx** at DISPATCH_LEVEL. However, you can improve driver performance by calling at APC_LEVEL or below.</p>

<h2 id="see-also">See also</h2>

<p><a href="exfreepool" title="void ExFreePool(&#10;  a&#10;);">ExFreePool</a></p>

<p><a href="kequeryhighestnodenumber" title="USHORT KeQueryHighestNodeNumber();">KeQueryHighestNodeNumber</a></p>

<p><strong><a href="mdl" title="typedef struct _MDL {&#10;  struct _MDL      *Next;&#10;  CSHORT           Size;&#10;  CSHORT           MdlFlags;&#10;  struct _EPROCESS *Process;&#10;  PVOID            MappedSystemVa;&#10;  PVOID            StartVa;&#10;  ULONG            ByteCount;&#10;  ULONG            ByteOffset;&#10;} MDL, *PMDL;">MDL</a></strong></p>

<p><a href="memory_caching_type" title="typedef enum _MEMORY_CACHING_TYPE {&#10;  MmNonCached,&#10;  MmCached,&#10;  MmWriteCombined,&#10;  MmHardwareCoherentCached,&#10;  MmNonCachedUnordered,&#10;  MmUSWCCached,&#10;  MmMaximumCacheType,&#10;  MmNotMapped&#10;} MEMORY_CACHING_TYPE;">MEMORY_CACHING_TYPE</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatepagesformdlex">MM_ALLOCATE_XXX</a></p>

<p><a href="mmfreepagesfrommdl" title="VOID MmFreePagesFromMdl(&#10;  [in] PMDL MemoryDescriptorList&#10;);">MmFreePagesFromMdl</a></p>

<p><a href="mmmaplockedpagesspecifycache" title="PVOID MmMapLockedPagesSpecifyCache(&#10;  [in]           PMDL                                                                          MemoryDescriptorList,&#10;  [in]           __drv_strictType(KPROCESSOR_MODE / enum _MODE,__drv_typeConst)KPROCESSOR_MODE AccessMode,&#10;  [in]           __drv_strictTypeMatch(__drv_typeCond)MEMORY_CACHING_TYPE                      CacheType,&#10;  [in, optional] PVOID                                                                         RequestedAddress,&#10;  [in]           ULONG                                                                         BugCheckOnFailure,&#10;  [in]           ULONG                                                                         Priority&#10;);">MmMapLockedPagesSpecifyCache</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmallocatenodepagesformdlex">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-mmallocatenodepagesformdlex.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
