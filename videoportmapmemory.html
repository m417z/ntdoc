<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="VideoPortMapMemory - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>VideoPortMapMemory - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            VideoPortMapMemory - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// video.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortMapMemory(
  PVOID            HwDeviceExtension,
  <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a> PhysicalAddress,
  PULONG           Length,
  PULONG           InIoSpace,
  PVOID            *VirtualAddress
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nf-video-videoportmapmemory">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/videoportmapmemory.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-video-videoportmapmemory)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>VideoPortMapMemory function</h1>
<h2>Description</h2>
<p>The <strong>VideoPortMapMemory</strong> function maps a range of bus-relative physical addresses of video memory into system space or into the virtual address space of a user-mode process. A video miniport driver calls <strong>VideoPortMapMemory</strong> when it handles <a href="ioctl_video_map_video_memory" title="// CTL_CODE(0x0023, 0x116, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_MAP_VIDEO_MEMORY 0x00230458">IOCTL_VIDEO_MAP_VIDEO_MEMORY</a>, <a href="ioctl_video_share_video_memory" title="// CTL_CODE(0x0023, 0x11d, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_SHARE_VIDEO_MEMORY 0x00230474">IOCTL_VIDEO_SHARE_VIDEO_MEMORY</a>, or <a href="ioctl_video_query_public_access_ranges" title="// CTL_CODE(0x0023, 0x118, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES 0x00230460">IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES</a>.</p>
<h2>Parameters</h2>
<h3><code>HwDeviceExtension</code></h3>
<p>Pointer to the miniport driver's device extension.</p>
<h3><code>PhysicalAddress</code></h3>
<p>The bus-relative base address of the range to map.</p>
<h3><code>Length</code></h3>
<p>On input, specifies the number of bytes of video memory to map. On output, receives the size of the memory actually mapped, which might be rounded to a system-determined alignment boundary. (However, the miniport and display drivers cannot access any memory that is outside the range delimited by the input value at <em>Length</em>.)</p>
<h3><code>InIoSpace</code></h3>
<p>Pointer to a variable that indicates the location of the range. The variable can be one of the following flags or an ORed, compatible combination of these flags.</p>
<table>
<thead>
<tr>
<th><strong>Flag</strong></th>
<th><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>VIDEO_MEMORY_SPACE_DENSE</td>
<td>Obsolete.</td>
</tr>
<tr>
<td>VIDEO_MEMORY_SPACE_IO</td>
<td>The address range is in I/O space, not in memory space.</td>
</tr>
<tr>
<td>VIDEO_MEMORY_SPACE_MEMORY</td>
<td>The address range is in memory space, not in I/O space.</td>
</tr>
<tr>
<td>VIDEO_MEMORY_SPACE_P6CACHE</td>
<td>The processor aggregates a sequence of write operations, sends them to a cache line, and later flushes the cache. This flag is meaningful only if VIDEO_MEMORY_SPACE_IO is not set.</td>
</tr>
<tr>
<td>Designates the video memory as write-combined (WC). For information about WC caching, see the <a href="https://learn.microsoft.com/previous-versions/windows/hardware/design/dn642116(v=vs.85)">Write-Combining Memory in Video Miniport Drivers</a> website article.</td>
<td></td>
</tr>
<tr>
<td>VIDEO_MEMORY_SPACE_USER_MODE</td>
<td>The address range should be mapped into the virtual address space of a user-mode process, not into system space. This flag is meaningful only if VIDEO_MEMORY_SPACE_IO is not set.</td>
</tr>
</tbody>
</table>
<h3><code>VirtualAddress</code></h3>
<p>Pointer to a variable that, on input, is either <strong>NULL</strong> or a handle to a user-mode process. If the input value is <strong>NULL</strong>, this routine maps the video memory into system space. Otherwise, this routine maps the video memory into the virtual address space of the user-mode process that is identified by the handle. On output, receives the base virtual address of the mapping.</p>
<h2>Return value</h2>
<p><strong>VideoPortMapMemory</strong> returns NO_ERROR if it successfully mapped the specified range; otherwise, it returns ERROR_INVALID_PARAMETER.</p>
<h2>Remarks</h2>
<p><strong>VideoPortMapMemory</strong> runs in kernel mode within the same context as the user-mode thread that initiated the call.</p>
<p><a href="videoportgetdevicebase" title="VIDEOPORT_DEPRECATED VIDEOPORT_API PVOID VideoPortGetDeviceBase(&#10;  PVOID            HwDeviceExtension,&#10;  PHYSICAL_ADDRESS IoAddress,&#10;  ULONG            NumberOfUchars,&#10;  UCHAR            InIoSpace&#10;);">VideoPortGetDeviceBase</a> and <strong>VideoPortMapMemory</strong> can both be called by the video miniport driver to map video memory into a virtual address space. If you call both of these functions to map the same physical addresses, or if you call one of the functions more than once to map the same physical addresses, you might have more than one virtual-address range that maps to the same physical-address range. In that case, you must set the VIDEO_MEMORY_SPACE_P6CACHE flag of the <em>InIoSpace</em> parameter to the same value in all of those calls.</p>
<p>Every universal memory architecture (UMA) display device uses a frame buffer that is located in main memory rather than on a PCI bus. In this case, do not call <strong>VideoPortMapMemory</strong> to map the frame buffer. To map a UMA frame buffer into system space, call <a href="mmmapiospace" title="PVOID MmMapIoSpace(&#10;  [in] PHYSICAL_ADDRESS    PhysicalAddress,&#10;  [in] SIZE_T              NumberOfBytes,&#10;  [in] MEMORY_CACHING_TYPE CacheType&#10;);">MmMapIoSpace</a>. To map a UMA frame buffer into the virtual address space of a user-mode process, perform the following steps:</p>
<ol>
<li>Call <a href="ntopensection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenSection(&#10;    _Out_ PHANDLE SectionHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes&#10;    );">ZwOpenSection</a> to get a handle to the operating system's physical-memory section object, which is named <strong>\Device\PhysicalMemory</strong>.</li>
<li>Call <a href="ntmapviewofsection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtMapViewOfSection(&#10;    _In_ HANDLE SectionHandle,&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,&#10;    _In_ ULONG_PTR ZeroBits,&#10;    _In_ SIZE_T CommitSize,&#10;    _Inout_opt_ PLARGE_INTEGER SectionOffset,&#10;    _Inout_ PSIZE_T ViewSize,&#10;    _In_ SECTION_INHERIT InheritDisposition,&#10;    _In_ ULONG AllocationType,&#10;    _In_ ULONG PageProtection&#10;    );">ZwMapViewOfSection</a> to map a view of the frame buffer into the virtual address space of the current process.</li>
</ol>
<p>The following example shows how to map a UMA frame buffer into the virtual address space of the current process.</p>
<pre><code><a href="unicode_string" title="typedef struct _UNICODE_STRING&#10;{&#10;    USHORT Length;&#10;    USHORT MaximumLength;&#10;    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer;&#10;} UNICODE_STRING, *PUNICODE_STRING;">UNICODE_STRING</a>    UnicodeString;          // Name of the section object
<a href="object_attributes" title="typedef struct _OBJECT_ATTRIBUTES&#10;{&#10;    ULONG Length;&#10;    HANDLE RootDirectory;&#10;    PCUNICODE_STRING ObjectName;&#10;    ULONG Attributes;&#10;    PSECURITY_DESCRIPTOR SecurityDescriptor;&#10;    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;&#10;} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;">OBJECT_ATTRIBUTES</a> ObjectAttributes;       // Description for the section object
HANDLE            hPhysicalMemoryHandle;  // Handle to the section object
<a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>  MappedLength;           // Length of the frame buffer

<a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>  MappedBase;             // Base physical address (CPU-relative)
                                          // of the frame buffer

// Allocate a variable to receive the base virtual address of the view.
// Set it to NULL for input to <a href="ntmapviewofsection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtMapViewOfSection(&#10;    _In_ HANDLE SectionHandle,&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,&#10;    _In_ ULONG_PTR ZeroBits,&#10;    _In_ SIZE_T CommitSize,&#10;    _Inout_opt_ PLARGE_INTEGER SectionOffset,&#10;    _Inout_ PSIZE_T ViewSize,&#10;    _In_ SECTION_INHERIT InheritDisposition,&#10;    _In_ ULONG AllocationType,&#10;    _In_ ULONG PageProtection&#10;    );">ZwMapViewOfSection</a>, to specify that the memory
// manager (rather than the caller) should determine the base virtual address.
PVOID pViewBase = NULL;

<a href="rtlinitunicodestring" title="FORCEINLINE&#10;VOID&#10;NTAPI_INLINE&#10;RtlInitUnicodeString(&#10;    _Out_ PUNICODE_STRING DestinationString,&#10;    _In_opt_z_ PCWSTR SourceString&#10;    )&#10;{&#10;    if (SourceString)&#10;        DestinationString-&gt;MaximumLength = (DestinationString-&gt;Length = (USHORT)(wcslen(SourceString) * sizeof(WCHAR))) + sizeof(UNICODE_NULL);&#10;    else&#10;        DestinationString-&gt;MaximumLength = DestinationString-&gt;Length = 0;&#10;&#10;    DestinationString-&gt;Buffer = (PWCH)SourceString;&#10;}">RtlInitUnicodeString</a>(&amp;UnicodeString, L&quot;\\Device\\PhysicalMemory&quot;);

<a href="initializeobjectattributes" title="#define InitializeObjectAttributes(p, n, a, r, s) { \&#10;    (p)-&gt;Length = sizeof(OBJECT_ATTRIBUTES); \&#10;    (p)-&gt;RootDirectory = r; \&#10;    (p)-&gt;Attributes = a; \&#10;    (p)-&gt;ObjectName = n; \&#10;    (p)-&gt;SecurityDescriptor = s; \&#10;    (p)-&gt;SecurityQualityOfService = NULL; \&#10;    }">InitializeObjectAttributes</a>(
   &amp;ObjectAttributes,
   &amp;UnicodeString,
   <a href="obj_case_insensitive" title="#define OBJ_CASE_INSENSITIVE 0x00000040L">OBJ_CASE_INSENSITIVE</a> | <a href="obj_kernel_handle" title="#define OBJ_KERNEL_HANDLE 0x00000200L">OBJ_KERNEL_HANDLE</a>,
   (HANDLE) NULL,
   (PSECURITY_DESCRIPTOR) NULL);

// Open a handle to the physical-memory section object.
ntStatus = <a href="ntopensection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenSection(&#10;    _Out_ PHANDLE SectionHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes&#10;    );">ZwOpenSection</a>(&amp;hPhysicalMemoryHandle, SECTION_ALL_ACCESS, &amp;ObjectAttributes);

if(<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
{
   ntStatus = <a href="ntmapviewofsection" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtMapViewOfSection(&#10;    _In_ HANDLE SectionHandle,&#10;    _In_ HANDLE ProcessHandle,&#10;    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize)) PVOID *BaseAddress,&#10;    _In_ ULONG_PTR ZeroBits,&#10;    _In_ SIZE_T CommitSize,&#10;    _Inout_opt_ PLARGE_INTEGER SectionOffset,&#10;    _Inout_ PSIZE_T ViewSize,&#10;    _In_ SECTION_INHERIT InheritDisposition,&#10;    _In_ ULONG AllocationType,&#10;    _In_ ULONG PageProtection&#10;    );">ZwMapViewOfSection</a>(
      hPhysicalMemoryHandle,
      <a href="ntcurrentprocess" title="#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)">NtCurrentProcess</a>(),
      &amp;pViewBase,
      0L,
      (<a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a>)MappedLength.QuadPart,
      &amp;MappedBase,
      (PULONG_PTR)(&amp;(MappedLength.QuadPart)),
      ViewUnmap,
      0,
      <a href="page_readwrite" title="#define PAGE_READWRITE 0x04 // Enables read-only or read/write access to the committed region of pages.">PAGE_READWRITE</a> | <a href="page_writecombine" title="#define PAGE_WRITECOMBINE 0x400 // Sets all pages to be write-combined. Applications should not use this attribute. Using interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.">PAGE_WRITECOMBINE</a>);

   if(<a href="nt_success" title="#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)">NT_SUCCESS</a>(ntStatus))
   {
      // pViewBase holds the base virtual address of the view.
   }

   // Close the handle to the physical-memory section object.
   <a href="ntclose" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtClose(&#10;    _In_ _Post_ptr_invalid_ HANDLE Handle&#10;    );">ZwClose</a>(hPhysicalMemoryHandle);
}
</code></pre>
<p>Miniport drivers should use <strong>VideoPortMapMemory</strong> to manage video adapters that allow the video <a href="https://learn.microsoft.com/windows-hardware/drivers/">frame buffer</a> to be completely mapped at all times. That is, miniport drivers for adapters that are not restricted to using <a href="https://learn.microsoft.com/windows-hardware/drivers/">banks</a> to map a slice at a time can use the more efficient <strong>VideoPortMapMemory</strong>.</p>
<h2>See also</h2>
<p><a href="ioctl_video_map_video_memory" title="// CTL_CODE(0x0023, 0x116, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_MAP_VIDEO_MEMORY 0x00230458">IOCTL_VIDEO_MAP_VIDEO_MEMORY</a></p>
<p><a href="video_request_packet" title="typedef struct _VIDEO_REQUEST_PACKET {&#10;  ULONG         IoControlCode;&#10;  PSTATUS_BLOCK StatusBlock;&#10;  PVOID         InputBuffer;&#10;  ULONG         InputBufferLength;&#10;  PVOID         OutputBuffer;&#10;  ULONG         OutputBufferLength;&#10;} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;">VIDEO_REQUEST_PACKET</a></p>
<p><a href="videoportunmapmemory" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortUnmapMemory(&#10;  PVOID  HwDeviceExtension,&#10;  PVOID  VirtualAddress,&#10;  HANDLE ProcessHandle&#10;);">VideoPortUnmapMemory</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nf-video-videoportmapmemory">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/video/nf-video-videoportmapmemory.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
