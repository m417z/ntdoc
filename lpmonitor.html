<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="LPMONITOR - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>LPMONITOR - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            LPMONITOR - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winsplp.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _MONITOR {
  BOOL( )(LPWSTR pName,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> Level,LPBYTE pPorts,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;
  BOOL( )(LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;
  BOOL()(LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR *pMonitor)  * pfnOpenPortEx;
  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> JobId,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> Level,LPBYTE pDocInfo)  *pfnStartDocPort;
  BOOL( )(HANDLE hPort,LPBYTE pBuffer,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbBuf,LPDWORD pcbWritten)  *pfnWritePort;
  BOOL( )(HANDLE hPort,LPBYTE pBuffer,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbBuffer,LPDWORD pcbRead)  *pfnReadPort;
  BOOL( )(HANDLE hPort)  *pfnEndDocPort;
  BOOL( )(HANDLE hPort)  *pfnClosePort;
  BOOL( )(LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;
  BOOL( )(LPWSTR pName,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;
  BOOL( )(LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;
  BOOL( )(LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;
  BOOL( )(HANDLE hPort,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbInBuffer,LPWSTR lpOutBuffer,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;
  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> reserved)  *pfnSetPortTimeOuts;
  BOOL( )(LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;
  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbInputData,PBYTE pOutputData,<a href="dword" title="typedef unsigned long DWORD;">DWORD</a> cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;
  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;
} MONITOR, *LPMONITOR;</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/winsplp/ns-winsplp-_monitor">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/lpmonitor.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-winsplp-_monitor)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h2>Description</h2>
<blockquote>
<p>[!CAUTION]
The <strong>MONITOR</strong> structure is obsolete and is supported only for compatibility reasons. New print monitors should implement <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> so that they can be used with print server clusters.</p>
</blockquote>
<p>The <strong>MONITOR</strong> structure contains pointers to the functions defined by print monitors.</p>
<h2>Members</h2>
<h3><code>pfnEnumPorts</code></h3>
<p>A port monitor server DLL's <strong>EnumPorts</strong> function enumerates the ports that the port monitor supports.</p>
<h3><code>pfnOpenPort</code></h3>
<p>Pointer to the print monitor's <a href="openport" title="BOOL OpenPort(&#10;  LPWSTR  pName,&#10;  PHANDLE pHandle&#10;);">OpenPort</a> function.</p>
<h3><code>pfnOpenPortEx</code></h3>
<p>A language monitor's <code>OpenPortEx</code> function opens a printer port.</p>
<h3><code>pfnStartDocPort</code></h3>
<p>A print monitor's <code>StartDocPort</code> function performs the tasks required to start a print job on the specified port.</p>
<h3><code>pfnWritePort</code></h3>
<p>Pointer to the print monitor's <a href="writeport" title="BOOL WritePort(&#10;  _In_  HANDLE  hPort,&#10;  _In_  LPBYTE  pBuffer,&#10;        DWORD   cbBuf,&#10;  _Out_ LPDWORD pcbWritten&#10;);">WritePort</a> function.</p>
<h3><code>pfnReadPort</code></h3>
<p>Pointer to the print monitor's <a href="readport" title="BOOL ReadPort(&#10;  _In_  HANDLE  hPort,&#10;  _Out_ LPBYTE  pBuffer,&#10;        DWORD   cbBuffer,&#10;  _Out_ LPDWORD pcbRead&#10;);">ReadPort</a> function.</p>
<h3><code>pfnEndDocPort</code></h3>
<p>A print monitor's <strong>EndDocPort</strong> function performs the tasks required to end a print job on the specified port.</p>
<h3><code>pfnClosePort</code></h3>
<p>Pointer to the print monitor's <a href="closeport" title="BOOL ClosePort(&#10;  _In_ HANDLE hPort&#10;);">ClosePort</a> function.</p>
<h3><code>pfnAddPort</code></h3>
<blockquote>
<p>[!CAUTION]
The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545022(v=vs.85)">AddPort</a> function is obsolete and should not be used.</p>
</blockquote>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545022(v=vs.85)">AddPort</a> creates a port and adds it to the list of ports currently supported by the specified monitor in the spooler environment.</p>
<h3><code>pfnAddPortEx</code></h3>
<p>(Obsolete. Must be <strong>NULL</strong>.) Pointer to the print monitor's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545025(v=vs.85)">AddPortEx</a> function. (Port monitors only.)</p>
<h3><code>pfnConfigurePort</code></h3>
<blockquote>
<p>[!CAUTION]
The <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff546286(v=vs.85)">ConfigurePort</a> function is obsolete and should not be used. Use <a href="configureportui" title="BOOL WINAPI pfnConfigurePortUI(&#10;  _In_opt_ PCWSTR pszServer,&#10;  _In_     HWND   hWnd,&#10;  _In_     PCWSTR pszPortName&#10;);">ConfigurePortUI</a> instead.</p>
</blockquote>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff546286(v=vs.85)">ConfigurePort</a> is a port management function that configures the specified port.</p>
<h3><code>pfnDeletePort</code></h3>
<blockquote>
<p>[!CAUTION]
The <strong>DeletePort</strong> function is obsolete and and should not be used.</p>
</blockquote>
<p><strong>DeletePort</strong> deletes a port from the monitor's environment.</p>
<h3><code>pfnGetPrinterDataFromPort</code></h3>
<p>A port monitor's <strong>GetPrinterDataFromPort</strong> function obtains status information from a bidirectional printer and returns it to the caller.</p>
<h3><code>pfnSetPortTimeOuts</code></h3>
<p>A port monitor server DLL's <code>SetPortTimeOuts</code> function sets port time-out values for an open port.</p>
<h3><code>pfnXcvOpenPort</code></h3>
<p>Pointer to the print monitor's <a href="xcvopenport" title="BOOL XcvOpenPort(&#10;  LPCWSTR     pszObject,&#10;  ACCESS_MASK GrantedAccess,&#10;  PHANDLE     phXcv&#10;);">XcvOpenPort</a> function. (Port monitors only.)</p>
<h3><code>pfnXcvDataPort</code></h3>
<p>Pointer to the print monitor's <a href="xcvdataport" title="DWORD XcvDataPort(&#10;  _In_  HANDLE  hXcv,&#10;  _In_  LPCWSTR pszDataName,&#10;  _In_  PBYTE   pInputData,&#10;        DWORD   cbInputData,&#10;  _Out_ PBYTE   pOutputData,&#10;        DWORD   cbOutputData,&#10;  _Out_ PDWORD  pcbOutputNeeded&#10;);">XcvDataPort</a> function. (Port monitors only.)</p>
<h3><code>pfnXcvClosePort</code></h3>
<p>Pointer to the print monitor's <a href="xcvcloseport" title="BOOL XcvClosePort(&#10;  _In_ HANDLE hXcv&#10;);">XcvClosePort</a> function. (Port monitors only.)</p>
<h2>Remarks</h2>
<p>The following sections describe each callback member in more detail.</p>
<h3><a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a></h3>
<pre><code>typedef BOOL (WINAPI *pfnAddPort)(
_In_ HANDLE hMonitor,
_In_ LPWSTR pName,
_In_ HWND   hWnd,
_In_ LPWSTR pMonitorName
);
</code></pre>
<h4>Parameters (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h4>
<h5>Monitor [in] (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h5>
<p>Caller supplied monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.)</p>
<h5>pName [in] (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h5>
<p>Pointer to a null-terminated string that specifies the name of the server to which the port is connected. If pName is NULL, the port is local.</p>
<h5>hWnd [in] (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h5>
<p>Handle to the parent window of the dialog box in which the port name will be entered.</p>
<h5>pMonitorName [in] (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h5>
<p>Pointer to a null-terminated string that specifies the monitor associated with the port.</p>
<h4>Return value (<a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a>)</h4>
<p>The return value is TRUE if the function is successful, and FALSE otherwise.</p>
<h3>ConfigurePort</h3>
<pre><code>typedef BOOL (WINAPI *pfnConfigurePort)(
_In_ HANDLE hMonitor,
_In_ LPWSTR pName,
_In_ HWND   hWnd,
_In_ LPWSTR pPortName
);
</code></pre>
<h4>Parameters (ConfigurePort)</h4>
<h5>hMonitor [in] (ConfigurePort)</h5>
<p>Caller supplied monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor" title="LPMONITOREX InitializePrintMonitor(&#10;  [in] LPWSTR pRegistryRoot&#10;);">InitializePrintMonitor</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.)</p>
<h5>pName [in] (ConfigurePort)</h5>
<p>Pointer to a null-terminated string that specifies the name of the server on which the given port exists. If this string is NULL, the port is local.</p>
<h5>hWnd [in] (ConfigurePort)</h5>
<p>Handle to the parent window of the dialog box in which the configuration information will be entered.</p>
<h5>pPortName [in] (ConfigurePort)</h5>
<p>Pointer to a null-terminated string that specifies the name of the port to be configured.</p>
<h4>Return value (ConfigurePort)</h4>
<p>The return value is TRUE if the function is successful.</p>
<h3>DeletePort</h3>
<pre><code>pfnDeletePort DeletePort;

BOOL WINAPI DeletePort(
_In_ HANDLE hMonitor,
_In_ LPWSTR pName,
_In_ HWND   hWnd,
_In_ LPWSTR pPortName
)
</code></pre>
<h4>Parameters (DeletePort)</h4>
<h5>hMonitor [in] (DeletePort)</h5>
<p>Caller supplied monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor" title="LPMONITOREX InitializePrintMonitor(&#10;  [in] LPWSTR pRegistryRoot&#10;);">InitializePrintMonitor</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.)</p>
<h5>pName [in] (DeletePort)</h5>
<p>Pointer to a null-terminated string that specifies the name of the server on which the port to be deleted exists. If this parameter is NULL, the port is local.</p>
<h5>hWnd [in] (DeletePort)</h5>
<p>Handle to the parent window of the port-deletion dialog box.</p>
<h5>pPortName [in] (DeletePort)</h5>
<p>Pointer to a null-terminated string that names the port to be deleted.</p>
<h4>Return value (DeletePort)</h4>
<p>The return value is TRUE if the function is successful.</p>
<h3>EndDocPort</h3>
<pre><code>typedef BOOL ( WINAPI *pfnEndDocPort)(
_In_ HANDLE hPort
);
</code></pre>
<h4>Parameters (EndDocPort)</h4>
<h5>hPort [in] (EndDocPort)</h5>
<p>Caller-supplied port handle.</p>
<h4>Return value (EndDocPort)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>EnumPorts</h3>
<pre><code>typedef BOOL (WINAPI *pfnEnumPorts)(
_In_     HANDLE  hMonitor,
_In_opt_ LPWSTR  pName,
_In_     <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   Level,
_Out_    LPBYTE  pPorts,
_In_     <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   cbBuf,
_Out_    LPDWORD pcbNeeded,
_Out_    LPDWORD pcReturned
);
</code></pre>
<h4>Parameters (EnumPorts)</h4>
<h5>hMonitor [in] (EnumPorts)</h5>
<p>Caller supplied monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor" title="LPMONITOREX InitializePrintMonitor(&#10;  [in] LPWSTR pRegistryRoot&#10;);">InitializePrintMonitor</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.)</p>
<h5>pName [in, optional] (EnumPorts)</h5>
<p>Caller-supplied pointer to a string containing the name of the server whose ports are to be enumerated. A NULL pointer represents the system on which the port monitor server DLL is executing.</p>
<h5>Level [in] (EnumPorts)</h5>
<p>Caller-supplied value indicating the type of structures to be returned in the buffer pointed to by pPorts.</p>
<p>Possible values are 1 (PORT_INFO_1) or 2 (PORT_INFO_2).</p>
<h5>pPorts [out] (EnumPorts)</h5>
<p>Caller-supplied pointer to a buffer to receive port information. Returned information must consist of an array of <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/port-info-1">PORT_INFO_1</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/port-info-2">PORT_INFO_2</a> structures, followed by the strings pointed to by structure members.</p>
<h5>cbBuf [in] (EnumPorts)</h5>
<p>Caller-supplied size, in bytes, of the buffer pointed to by pPorts.</p>
<h5>pcbNeeded [out] (EnumPorts)</h5>
<p>Caller-supplied pointer to a location to receive the buffer size, in bytes, required to contain all returned information.</p>
<h5>pcReturned [out] (EnumPorts)</h5>
<p>Caller-supplied pointer to a location to receive the number enumerated ports.</p>
<h4>Return value (EnumPorts)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>GetPrinterDataFromPort</h3>
<pre><code>pfnGetPrinterDataFromPort GetPrinterDataFromPort;

BOOL WINAPI GetPrinterDataFromPort(
_In_  HANDLE  hPort,
_In_  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   ControlID,
_In_  LPWSTR  pValueName,
_In_  LPWSTR  lpInBuffer,
_In_  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   cbInBuffer,
_Out_ LPWSTR  lpOutBuffer,
_In_  <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   cbOutBuffer,
_Out_ LPDWORD lpcbReturned
)
</code></pre>
<h4>Parameters (GetPrinterDataFromPort)</h4>
<h5>hPort [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied port handle.</p>
<h5>ControlID [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied device I/O control code. A value of zero indicates a value name is supplied by pValueName.</p>
<h5>pValueName [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied pointer to a string identifying the information being requested. Valid only if ControlID is zero.</p>
<h5>lpInBuffer [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied pointer to a buffer containing input data. Used only if ControlID is nonzero.</p>
<h5>cbInBuffer [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied size, in bytes, of the buffer pointed to by lpInBuffer.</p>
<h5>lpOutBuffer [out] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied pointer to a buffer to receive the requested data.</p>
<h5>cbOutBuffer [in] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied size, in bytes, of the buffer pointed to by lpOutBuffer.</p>
<h5>lpcbReturned [out] (GetPrinterDataFromPort)</h5>
<p>Caller-supplied pointer to a location to receive the number of bytes written into the buffer pointed to by lpOutBuffer.</p>
<h4>Return value (GetPrinterDataFromPort)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>OpenPortEx</h3>
<pre><code>pfnOpenPortEx OpenPortEx;

BOOL WINAPI OpenPortEx(
_In_  HANDLE           hMonitor,
_In_  HANDLE           hMonitorPort,
_In_  LPWSTR           pPortName,
_In_  LPWSTR           pPrinterName,
_Out_ PHANDLE          pHandle,
_In_  <a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">struct _MONITOR2</a> *pMonitor
)
</code></pre>
<h4>Parameters (OpenPortEx)</h4>
<h5>hMonitor [in] (OpenPortEx)</h5>
<p>Caller supplied language monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor" title="LPMONITOREX InitializePrintMonitor(&#10;  [in] LPWSTR pRegistryRoot&#10;);">InitializePrintMonitor</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.) In a cluster environment, there can be multiple instances of language monitors.</p>
<h5>hMonitorPort [in] (OpenPortEx)</h5>
<p>Caller supplied port monitor instance handle. This is the handle returned by the monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function. (This parameter does not exist if the print monitor supports <a href="initializeprintmonitor" title="LPMONITOREX InitializePrintMonitor(&#10;  [in] LPWSTR pRegistryRoot&#10;);">InitializePrintMonitor</a> instead of <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a>.) A language monitor must use this handle when it calls functions in the port monitor's <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure.</p>
<h5>pPortName [in] (OpenPortEx)</h5>
<p>Caller-supplied pointer to a string containing the name of the port to be opened.</p>
<h5>pPrinterName [in] (OpenPortEx)</h5>
<p>Caller-supplied pointer to a string containing the name of the printer that is connected to the port.</p>
<h5>pHandle [out] (OpenPortEx)</h5>
<p>Caller-supplied pointer to a location to receive a port handle.</p>
<h5>pMonitor [in] (OpenPortEx)</h5>
<p>Caller-supplied pointer to the <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure returned by a port monitor's <a href="initializeprintmonitor2" title="LPMONITOR2 InitializePrintMonitor2(&#10;  [in]  PMONITORINIT pMonitorInit,&#10;  [out] PHANDLE      phMonitor&#10;);">InitializePrintMonitor2</a> function.</p>
<h4>Return value (OpenPortEx)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>SetPortTimeOuts</h3>
<pre><code>BOOL (WINAPI *pfnSetPortTimeOuts)
(
_In_ HANDLE  hPort,
_In_ LPCOMMTIMEOUTS lpCTO,
_In_ <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>   reserved    // must be set to 0
);
</code></pre>
<h4>Parameters (SetPortTimeOuts)</h4>
<h5>hPort [in] (SetPortTimeOuts)</h5>
<p>Caller-supplied handle to the open port on which to set the time-out values.</p>
<h5>lpCTO [in] (SetPortTimeOuts)</h5>
<p>Caller-supplied pointer to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a> structure.</p>
<h5>reserved [in] (SetPortTimeOuts)</h5>
<p>Reserved for future use. Must be set to zero.</p>
<h4>Return value (SetPortTimeOuts)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>StartDocPort</h3>
<pre><code>typedef BOOL (WINAPI *pfnStartDocPort)(
_In_ HANDLE hPort,
_In_ LPWSTR pPrinterName,
_In_ <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>  JobId,
_In_ <a href="dword" title="typedef unsigned long DWORD;">DWORD</a>  Level,
_In_ LPBYTE pDocInfo
);
</code></pre>
<h4>Parameters (StartDocPort)</h4>
<h5>hPort [in] (StartDocPort)</h5>
<p>Caller-supplied port handle.</p>
<h5>pPrinterName [in] (StartDocPort)</h5>
<p>Caller-supplied pointer to a string containing the printer name.</p>
<h5>JobId [in] (StartDocPort)</h5>
<p>Caller-supplied, spooler-assigned job identifier.</p>
<h5>Level [in] (StartDocPort)</h5>
<p>Caller-supplied value indicating the type of structure pointed to by pDocInfo.</p>
<p>Possible values are 1 (DOC_INFO_1) or 2 (DOC_INFO_2).</p>
<h5>pDocInfo [in] (StartDocPort)</h5>
<p>Caller-supplied pointer to a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/doc-info-1">DOC_INFO_1</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/doc-info-2">DOC_INFO_2</a> structure.</p>
<h4>Return value (StartDocPort)</h4>
<p>If the operation succeeds, the function should return TRUE. Otherwise it should return FALSE.</p>
<h3>Notes</h3>
<p>The spooler calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545022(v=vs.85)">AddPort</a> when it receives an application request to add a port to its environment. The spooler forwards the call to the named port monitor on the named server.</p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545022(v=vs.85)">AddPort</a> allows a port to be added interactively. A monitor should prompt a user to enter the port name in a dialog box on the window associated with <em>hWnd</em>. <strong><a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a></strong> should validate the entered port name by calling the Win32 EnumPorts function to ensure that no duplicate port names are added to the spooler environment. A monitor should also verify that the port is one that it supports.</p>
<p>The spooler does not support remote <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545022(v=vs.85)">AddPort</a> calls. Consequently, <strong><a href="addport" title="void AddPort(&#10;   [in, HBAType(&quot;HBA_WWN&quot;)] uint8          PortWWN[8],&#10;   [out, HBA_STATUS_QUALIFIERS] HBA_STATUS HBAStatus&#10;);">AddPort</a></strong> implementations can ignore the <em>pName</em> and <em>pMonitorName</em> parameters.</p>
<p>The spooler calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff546286(v=vs.85)">ConfigurePort</a> so a port monitor can perform port configuration. <strong>ConfigurePort</strong> can offer a dialog box to obtain some or all of the necessary port configuration information from the user.</p>
<p>The spooler does not support remote <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff546286(v=vs.85)">ConfigurePort</a> calls; consequently, monitors can ignore the <em>pName</em> parameter.</p>
<p>The spooler calls <strong>DeletePort</strong> so a port monitor can delete a port from the monitor's environment. The monitor should delete the specified port from its state. The spooler will not call <strong>DeletePort</strong> on a monitor as long as a port is open.</p>
<p>Applications can delete local and remote ports. The printer UI displays a confirmation message box before the spooler calls <strong>DeletePort</strong>, so a monitor should ignore the <em>hWnd</em> parameter and not display another dialog box.</p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/language-monitors">Language monitors</a> and port monitor server DLLs are required to define an <strong>EndDocPort</strong> function and include the function's address in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure.</p>
<p>The handle received as the function's hPort argument is the port handle that the monitor's <a href="openport" title="BOOL OpenPort(&#10;  LPWSTR  pName,&#10;  PHANDLE pHandle&#10;);">OpenPort</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff559596(v=vs.85)">OpenPortEx</a> function supplied.</p>
<p>A language monitor's <strong>EndDocPort</strong> function typically calls the associated port monitor's <strong>EndDocPort</strong> function. It should also notify the spooler when the printing device has finished the job by calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/setjob"><strong>SetJob</strong></a>, specifying a command of JOB_CONTROL_LAST_PAGE_EJECTED. Language monitors for bidirectional printers should not call <strong>SetJob</strong> until the printer has sent notification that the job is really finished.</p>
<p>A port monitor server DLL's <strong>EndDocPort</strong> function typically calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/handleapi/nf-handleapi-closehandle"><strong>CloseHandle</strong></a> function, to close the handle that was previously obtained by calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> from within <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff562710(v=vs.85)">StartDocPort</a>. It should also notify the spooler when the printing device has finished the job, by calling <strong>SetJob</strong>, specifying a command of JOB_CONTROL_SENT_TO_PRINTER. (If a spooler is communicating with the port through a language monitor, it doesn't consider the job complete until the language monitor sends JOB_CONTROL_LAST_PAGE_EJECTED.)</p>
<p>The <strong>EndDocPort</strong> function should free all resources that were allocated by the <strong>StartDocPort</strong> function.</p>
<p>You might want to modify the <strong>EndDocPort</strong> function's behavior if the user has deleted or restarted the print job. The function can call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/getjob"><strong>GetJob</strong></a>, and check for a status of JOB_STATUS_DELETING or JOB_STATUS_RESTART, to see if either of these events has occurred.</p>
<p>Port monitor server DLLs are required to define an <strong>EnumPorts</strong> function and include the function's address in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure. Language monitors do not export this function.</p>
<p>The purpose of the <strong>EnumPorts</strong> function is to enumerate the ports currently supported by a print monitor. These ports are ones that were previously specified to the monitor's <a href="addportui" title="BOOL AddPortUI(&#10;  [in, optional]  PCWSTR pszServer,&#10;  [in]            HWND   hWnd,&#10;                  PCWSTR pszMonitorNameIn,&#10;  [out, optional] PWSTR  *ppszPortNameOut&#10;);">AddPortUI</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff545025(v=vs.85)">AddPortEx</a> function.</p>
<p>The <strong>EnumPorts</strong> function should fill the buffer pointed to by <em>pPort</em> with an array of PORT_INFO_1 or PORT_INFO_2 structures. Then starting in a memory location following the last array element, the function must load all the strings pointed to by the array's structure members. Refer to localmon.dll, a <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/sample-port-monitor">sample port monitor</a>, for an example of how to do this. The function must also return the number of structures supplied (that is, the number of supported ports) by placing the number in the location pointed to by <em>pcReturned</em>.</p>
<p>The caller specifies the size of the supplied buffer in <em>cbBuf</em>. If the buffer is too small, the function should place the required buffer size in the location pointed to by <em>pcbNeeded</em>, call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/errhandlingapi/nf-errhandlingapi-setlasterror"><strong>SetLastError</strong></a> specifying ERROR_INSUFFICIENT_BUFFER, and return <strong>FALSE</strong>.</p>
<p>If <em>Level</em> contains an invalid level number, the function should call <strong>SetLastError</strong> specifying ERROR_INVALID_LEVEL, and return <strong>FALSE</strong>. Some port monitors only support a level value of 1.</p>
<p>The port monitor must support localization of strings pointed to by the <strong>pMonitorName</strong> and <strong>pDescription</strong> members of the PORT_INFO_2 structure. These strings should be defined in resource files and obtained by calling <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadstringa"><strong>LoadString</strong></a>.</p>
<p>The <strong>fPortType</strong> member of the PORT_INFO_2 structure is not used with NT-based operating systems.</p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/language-monitors">Language monitors</a> and port monitor server DLLs can optionally define a <strong>GetPrinterDataFromPort</strong> function and include the function's address in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure.</p>
<p>The function is meant for use with bidirectional printers, and can be used in the following two ways:</p>
<ul>
<li>
<p>As a means for requesting a language monitor to poll the printer port, to obtain the current value of printer-specific information that is stored in the registry.</p>
</li>
<li>
<p>As a means for requesting a port monitor to send an I/O control code to the port driver.</p>
</li>
</ul>
<p>If a language monitor's <strong>GetPrinterDataFromPort</strong> function receives a string pointer in <em>pValueName</em>, it should return a value in the supplied output buffer. Typically, the string represents a registry value name, and the spooler calls <strong>GetPrinterDataFromPort</strong> when an application calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/printdocs/getprinterdata"><strong>GetPrinterData</strong></a> function.</p>
<p>The language monitor's responsibility is to send a command to the printer hardware by calling the port monitor's <a href="writeport" title="BOOL WritePort(&#10;  _In_  HANDLE  hPort,&#10;  _In_  LPBYTE  pBuffer,&#10;        DWORD   cbBuf,&#10;  _Out_ LPDWORD pcbWritten&#10;);">WritePort</a> function, and reading the response by calling <a href="readport" title="BOOL ReadPort(&#10;  _In_  HANDLE  hPort,&#10;  _Out_ LPBYTE  pBuffer,&#10;        DWORD   cbBuffer,&#10;  _Out_ LPDWORD pcbRead&#10;);">ReadPort</a>, to obtain the needed value. For example, pjlmon.dll, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/sample-language-monitor">sample language monitor</a>, can return values for a port's "Installed Memory" and "Available Memory" registry value names.</p>
<p>After the spooler calls <strong>GetPrinterDataFromPort</strong> to obtain a registry value, it updates the registry with the new value.</p>
<p>Typically, port monitors do not support calls to <strong>GetPrinterDataFromPort</strong> that include a string pointer in <em>pValueName</em>.</p>
<p>If a language monitor's <strong>GetPrinterDataFromPort</strong> function receives a nonzero I/O control code in <em>ControlID</em>, it should just call the associated port monitor's <strong>GetPrinterDataFromPort</strong> function and return the result. The <em>Kernel-Mode Drivers Reference</em> lists I/O control codes for parallel and serial ports.</p>
<p>When a port monitor's <strong>GetPrinterDataFromPort</strong> function receives a nonzero I/O control code in <em>ControlID</em>, it should call <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIOControl</strong></a> to pass the control code to the kernel-mode port driver. The <em>lpInBuffer</em>, <em>cbInBuffer</em>, <em>lpOutBuffer</em>, <em>cbOutBuffer</em>, and <em>lpcbReturned</em> parameter values should also be passed to <strong>DeviceIOControl</strong>.</p>
<p>Language monitors are required to define an <code>OpenPortEx</code> function and include its address in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure. The <code>OpenPortEx</code> function is called by the print spooler when a print queue is being connected to a port.</p>
<p>The <code>OpenPortEx</code> function's primary purpose is to return a port handle that the caller can use as an input argument for subsequent calls to the language monitor's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff562710(v=vs.85)">StartDocPort</a>, <a href="writeport" title="BOOL WritePort(&#10;  _In_  HANDLE  hPort,&#10;  _In_  LPBYTE  pBuffer,&#10;        DWORD   cbBuf,&#10;  _Out_ LPDWORD pcbWritten&#10;);">WritePort</a>, <a href="readport" title="BOOL ReadPort(&#10;  _In_  HANDLE  hPort,&#10;  _Out_ LPBYTE  pBuffer,&#10;        DWORD   cbBuffer,&#10;  _Out_ LPDWORD pcbRead&#10;);">ReadPort</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff548742(v=vs.85)">EndDocPort</a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff550506(v=vs.85)">GetPrinterDataFromPort</a> functions. Because a language monitor typically implements these functions by calling the equivalent functions in its associated port monitor, a language monitor typically obtains a port handle by calling the port monitor's <a href="openport" title="BOOL OpenPort(&#10;  LPWSTR  pName,&#10;  PHANDLE pHandle&#10;);">OpenPort</a> function. For more information see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/language-and-port-monitor-interaction">Language and Port Monitor Interaction</a>.</p>
<p>The <code>OpenPortEx</code> function's <em>pMonitor</em> parameter is a pointer to the port monitor's <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure. This structure contains pointers to the port monitor's callable functions. The <code>OpenPortEx</code> function should check the structure to verify that all required function pointers are non-<strong>NULL</strong>. If the structure is valid, the function should copy it into local storage. Otherwise <code>OpenPortEx</code> should call <strong>SetLastError</strong>, specifying ERROR_INVALID_PRINT_MONITOR, and return <strong>FALSE</strong>.</p>
<p>Print monitor functions that accept a port handle as input do not also accept a monitor handle. Therefore, the <code>OpenPortEx</code> function must store the received monitor handle in a location that can be referenced by the port handle. This allows the functions that accept a port handle to reference the monitor handle.</p>
<p>A port monitor server DLL's <code>SetPortTimeOuts</code> function allows a language monitor to specify port time-out values for an open port. The function is optional, and must be provided only if the port monitor controls a port that allows the modification of port time-out values. If the function is defined, its address must be included in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure.</p>
<p>The function is called by pjlmon.dll, the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/sample-language-monitor">sample language monitor</a>, and you can write a customized language monitor that calls it. The print spooler does not call <code>SetPortTimeOuts</code>.</p>
<p>The port monitor should initialize the port's time-out values from within its <a href="openport" title="BOOL OpenPort(&#10;  LPWSTR  pName,&#10;  PHANDLE pHandle&#10;);">OpenPort</a> function.</p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/print/language-monitors">Language monitors</a> and port monitor server DLLs are required to define a <code>StartDocPort</code> function and include the function's address in a <strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong> structure.</p>
<p>The handle received as the function's <em>hPort</em> argument is the port handle that the monitor's <a href="openport" title="BOOL OpenPort(&#10;  LPWSTR  pName,&#10;  PHANDLE pHandle&#10;);">OpenPort</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff559596(v=vs.85)">OpenPortEx</a> function supplied.</p>
<p>A language monitor's <code>StartDocPort</code> function typically calls the associated port monitor's <code>StartDocPort</code> function.</p>
<p>A port monitor server DLL's <code>StartDocPort</code> function typically calls the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, to create a connection to the kernel-mode port driver.</p>
<p>If necessary, the port monitor should prevent other processes from using the specified port until <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff548742(v=vs.85)">EndDocPort</a> is called. For example, a port monitor for a COM port must ensure that, while a spooler is sending printer data to the port, another application does not assume the port is connected to a particular communications device and then attempt to communicate with that device. This cautionary note does not apply to the local print provider, which guarantees that it never calls <code>StartDocPort</code> twice in succession without an intervening call to <strong>EndDocPort</strong>, but it does apply to print providers that do not make this guarantee.</p>
<h2>See also</h2>
<p><strong><a href="monitor2" title="typedef struct _MONITOR2 {&#10;  DWORD  cbSize;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE pPorts,DWORD cbBuf,LPDWORD pcbNeeded,LPDWORD pcReturned)  *pfnEnumPorts;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,PHANDLE pHandle)  *pfnOpenPort;&#10;  BOOL()(HANDLE hMonitor,HANDLE hMonitorPort,LPWSTR pPortName,LPWSTR pPrinterName,PHANDLE pHandle,_MONITOR2 *pMonitor2)  * pfnOpenPortEx;&#10;  BOOL( )(HANDLE hPort,LPWSTR pPrinterName,DWORD JobId,DWORD Level,LPBYTE pDocInfo)  *pfnStartDocPort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuf,LPDWORD pcbWritten)  *pfnWritePort;&#10;  BOOL( )(HANDLE hPort,LPBYTE pBuffer,DWORD cbBuffer,LPDWORD pcbRead)  *pfnReadPort;&#10;  BOOL( )(HANDLE hPort)  *pfnEndDocPort;&#10;  BOOL( )(HANDLE hPort)  *pfnClosePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pMonitorName)  *pfnAddPort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,DWORD Level,LPBYTE lpBuffer,LPWSTR lpMonitorName)  *pfnAddPortEx;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnConfigurePort;&#10;  BOOL( )(HANDLE hMonitor,LPWSTR pName,HWND hWnd,LPWSTR pPortName)  *pfnDeletePort;&#10;  BOOL( )(HANDLE hPort,DWORD ControlID,LPWSTR pValueName,LPWSTR lpInBuffer,DWORD cbInBuffer,LPWSTR lpOutBuffer,DWORD cbOutBuffer,LPDWORD lpcbReturned)  *pfnGetPrinterDataFromPort;&#10;  BOOL( )(HANDLE hPort,LPCOMMTIMEOUTS lpCTO,DWORD reserved)  *pfnSetPortTimeOuts;&#10;  BOOL( )(HANDLE hMonitor,LPCWSTR pszObject,ACCESS_MASK GrantedAccess,PHANDLE phXcv)  *pfnXcvOpenPort;&#10;  DWORD( )(HANDLE hXcv,LPCWSTR pszDataName,PBYTE pInputData,DWORD cbInputData,PBYTE pOutputData,DWORD cbOutputData,PDWORD pcbOutputNeeded) *pfnXcvDataPort;&#10;  BOOL( )(HANDLE hXcv)  *pfnXcvClosePort;&#10;  VOID( )(HANDLE hMonitor)  *pfnShutdown;&#10;...">MONITOR2</a></strong></p>
<p><a href="monitorui" title="typedef struct _MONITORUI {&#10;  DWORD dwMonitorUISize;&#10;  BOOL()(PCWSTR pszServer,HWND hWnd,PCWSTR pszMonitorNameIn,PWSTR *ppszPortNameOut) * pfnAddPortUI;&#10;  BOOL( )(PCWSTR pName,HWND hWnd,PCWSTR pPortName) *pfnConfigurePortUI;&#10;  BOOL( )(PCWSTR pszServer,HWND hWnd,PCWSTR pszPortName) *pfnDeletePortUI;&#10;} MONITORUI, *PMONITORUI;">MONITORUI</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/winsplp/ns-winsplp-_monitor">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/winsplp/ns-winsplp-_monitor.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
