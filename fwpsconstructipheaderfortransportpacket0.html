<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FwpsConstructIpHeaderForTransportPacket0 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FwpsConstructIpHeaderForTransportPacket0 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FwpsConstructIpHeaderForTransportPacket0 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// fwpsk.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FwpsConstructIpHeaderForTransportPacket0(
  [in, out]      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a>  *netBufferList,
                 <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            headerIncludeHeaderLength,
  [in]           <a href="address_family" title="typedef USHORT ADDRESS_FAMILY;">ADDRESS_FAMILY</a>   addressFamily,
  [in]           const <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>      *sourceAddress,
  [in]           const <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>      *remoteAddress,
  [in]           IPPROTO          nextProtocol,
  [in, optional] <a href="uint64" title="typedef unsigned __int64 UINT64;">UINT64</a>           endpointHandle,
  [in, optional] const WSACMSGHDR *controlData,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            controlDataLength,
  [in]           <a href="uint32" title="typedef unsigned int UINT32;">UINT32</a>           flags,
                 PVOID            reserved,
  [in, optional] IF_INDEX         interfaceIndex,
  [in, optional] IF_INDEX         subInterfaceIndex
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsconstructipheaderfortransportpacket0">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fwpsconstructipheaderfortransportpacket0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fwpsk-fwpsconstructipheaderfortransportpacket0)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FwpsConstructIpHeaderForTransportPacket0 function</h1>
<h2>Description</h2>
<p>The
<strong>FwpsConstructIpHeaderForTransportPacket0</strong> function is called by a callout to construct a new IP header
or to rebuild a preexisting IP packet header for only one net buffer.</p>
<p><strong>Note</strong> <strong>FwpsConstructIpHeaderForTransportPacket0</strong> is a specific version of <strong>FwpsConstructIpHeaderForTransportPacket</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FWP/wfp-version-independent-names-and-targeting-specific-versions-of-windows">WFP Version-Independent Names and Targeting Specific Versions of Windows</a> for more information.</p>
<h2>Parameters</h2>
<h3><code>netBufferList</code> [in, out]</h3>
<p>A pointer to a
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure that describes
the cloned transport layer packet data for which a new IP header is to be constructed or rebuilt. To
construct a new IP header, locate the offset of the cloned <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure at the beginning of
the transport header. To rebuild a preexisting IP packet header, locate the offset at the beginning of
the IP header.</p>
<h3><code>headerIncludeHeaderLength</code></h3>
<p>If the <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure pointed to by
<em>NetBufferList</em> already contains an IP header, indicates the total size, in bytes, of the existing
IP header (if it exists). If
<em>NetBufferList</em> does not contain an IP header,
<em>headerIncludeHeaderSize</em> is zero. Otherwise, the value of this parameter is equal to the
<strong>ipHeaderSize</strong> member of the
<a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function. Note that
extension headers for an existing IPv6 header will be removed when this function is called, although
IPv4 options will be preserved. For more information, see Remarks.</p>
<h3><code>addressFamily</code> [in]</h3>
<p>One of the following address families:</p>
<h4>AF_INET</h4>
<p>The IPv4 address family.</p>
<h4>AF_INET6</h4>
<p>The IPv6 address family.</p>
<h3><code>sourceAddress</code> [in]</h3>
<p>A pointer to the source IP address that will be part of the IP header to be constructed. For IPv4,
the address is 4 bytes. For IPv6, the address is 16 bytes. The source address bytes are always in
network byte order.</p>
<h3><code>remoteAddress</code> [in]</h3>
<p>A pointer to a buffer that specifies the remote IP address that will be part of the IP header to
be constructed.</p>
<p>The buffer can contain an IPv4 address (4 bytes) or an IPv6 address (16 bytes), and the address must
be specified in network byte order. The IP version must match the
<em>addressFamily</em> parameter.</p>
<h3><code>nextProtocol</code> [in]</h3>
<p>Specifies the IPPROTO protocol type of the new IP header to be constructed. For more information
on the IPPROTO enumeration, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/af-inet">AF_INET</a> or
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/af-inet6">AF_INET6</a>.</p>
<h3><code>endpointHandle</code> [in, optional]</h3>
<p>An optional handle that indicates the stack transport endpoint in the send data path into which
the packet is to be injected. This endpoint handle is provided to a callout through the
<strong>transportEndpointHandle</strong> member of the
<a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function.</p>
<h3><code>controlData</code> [in, optional]</h3>
<p>An optional pointer to a buffer that contains socket control data specified by the
<strong>WSASendMsg</strong> function, which is described in the Microsoft Windows SDK documentation. For
information about the WSACMSGHDR type, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-wsacmsghdr">CMSGHDR</a>.</p>
<p>If present, socket control data is provided to a callout with the
<strong>controlData</strong> member of the
<a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function.</p>
<p>If socket control data is not <strong>NULL</strong>, it must be deep-copied in the callout driver's implementation of
the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> function, and the
<strong>controlData</strong> buffer must be kept valid until the injection completion function is
called.</p>
<h3><code>controlDataLength</code> [in]</h3>
<p>The length, in bytes, of the
<em>controlData</em> parameter.</p>
<h3><code>flags</code> [in]</h3>
<p>Flags that specify whether the NBL is intended for the send or receive path. The <strong>flags</strong> parameter can have the following values:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FWPS_CONSTRUCT_IPHEADER_FOR_SEND</strong></td>
<td>When set, this flag specifies that the NBL is intended for send path.</td>
</tr>
<tr>
<td><strong>FWPS_CONSTRUCT_IPHEADER_FOR_RECEIVE</strong></td>
<td>When set, this flag specifies that the NBL is intended for receive path.</td>
</tr>
</tbody>
</table>
<p>For callout drivers that support USO or URO, it is mandatory to set this parameter to one of these values. Other callout drivers can set this parameter to <strong>zero</strong>. These flags are only supported on Windows Server 2022 23H2 and later. On prior releases of Windows, callout drivers must always set this parameter to <strong>zero</strong>.</p>
<h3><code>reserved</code></h3>
<p>Reserved. Callout drivers must set this parameter to <strong>NULL</strong>.</p>
<h3><code>interfaceIndex</code> [in, optional]</h3>
<p>The index of the interface on which the original packet data was received. A callout driver should use the value of the interface index that is passed as one of the incoming data values to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function for this parameter. This parameter is optional and can be zero.</p>
<h3><code>subInterfaceIndex</code> [in, optional]</h3>
<p>The index of the subinterface on which the original packet data was received. A callout driver
should use the value of the subinterface index that is passed as one of the incoming data values to its
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function for this
parameter if the packet is to be injected into the same subinterface where the original packet was
indicated. This parameter is optional and can be zero.</p>
<h2>Return value</h2>
<p>The
<strong>FwpsConstructIpHeaderForTransportPacket0</strong> function returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
codes.</p>
<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
<td>A new IP header was successfully constructed.</td>
</tr>
<tr>
<td><strong>Other status codes</strong></td>
<td>An error occurred.</td>
</tr>
</tbody>
</table>
<h2>Remarks</h2>
<p>From a net buffer list cloned at a WFP outbound transport layer (FWPS_LAYER_OUTBOUND_TRANSPORT_Xxx),
<strong>FwpsConstructIpHeaderForTransportPacket0</strong> constructs a new header for each net buffer that is part
of the net buffer list chain. This function can also be used to rebuild the preexisting IP header of a
packet, in which case the net buffer list must contain only one net buffer.</p>
<p>This function is useful when the IP header has not yet been created, but the source IP address or the
source port must be modified from the transport layer. Although it would ordinarily be possible to
wait to perform such modifications until the packet reaches the Network layer, this cannot be done in an
IPsec environment in which IP packets are encrypted or digitally signed before they reach the Network
layer.</p>
<p>The source IP address can be modified to be another locally defined IP address or another address that
does not exist on the local computer. Packets so modified can then be sent or injected into the receive
or forwarding data path.</p>
<p>If a nonzero
<em>endpointHandle</em> parameter is specified, session states (socket options), if any, associated with the
socket will be used to construct each new IP header. Similarly, if additional socket options are
specified with the
<em>controlData</em> and
<em>controlDataLength</em> parameters, those options will be used to construct each new IP header.</p>
<p>If the input net buffer list was cloned from an inbound WFP transport layer, or if it was created as a
result of a raw send operation, the net buffers will already contain an IP header. In this case, when
this function is called, IPv4 options will be preserved in the new IP header, but AH/ESP headers and IPv6
extension headers will be removed. Because the TCP/IP stack retains AH/ESP headers after IPsec
processing, packets that have been indicated by WFP and cloned by callouts cannot readily be injected
into the receive data path. Consequently this function is useful for rebuilding IPsec-processed packets
that are to be injected into the receive data path with the
<a href="fwpsinjecttransportreceiveasync0" title="NTSTATUS FwpsInjectTransportReceiveAsync0(&#10;  [in]           HANDLE                injectionHandle,&#10;  [in, optional] HANDLE                injectionContext,&#10;                 PVOID                 reserved,&#10;  [in]           UINT32                flags,&#10;  [in]           ADDRESS_FAMILY        addressFamily,&#10;  [in]           COMPARTMENT_ID        compartmentId,&#10;  [in]           IF_INDEX              interfaceIndex,&#10;  [in]           IF_INDEX              subInterfaceIndex,&#10;  [in, out]      NET_BUFFER_LIST       *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0 completionFn,&#10;  [in, optional] HANDLE                completionContext&#10;);">FwpsInjectTransportReceiveAsync0</a> function.</p>
<p>For a header-include session; for example, to filter Generic Routing Encapsulation (GRE) traffic (IP
protocol 47) sent on a raw socket from outbound transport layers, use the following procedure before you
call
<strong>FwpsConstructIpHeaderForTransportPacket0</strong>:</p>
<ol>
<li>Clone the net buffer list by calling the
<a href="fwpsallocateclonenetbufferlist0" title="NTSTATUS FwpsAllocateCloneNetBufferList0(&#10;  [in, out]      NET_BUFFER_LIST *originalNetBufferList,&#10;  [in, optional] NDIS_HANDLE     netBufferListPoolHandle,&#10;  [in, optional] NDIS_HANDLE     netBufferPoolHandle,&#10;  [in]           ULONG           allocateCloneFlags,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateCloneNetBufferList0</a> function.</li>
<li>If the
<strong>headerIncludeHeaderLength</strong> member of the <a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> structure that is pointed
to by the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> function's
<em>inMetaValues</em> parameter is greater than zero, retreat the cloned net buffer list by that amount; for example, by a call to
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisretreatnetbufferlistdatastart">NdisRetreatNetBufferListDataStart</a>.</li>
<li>Copy the buffer that is pointed to by the
<strong>headerIncludeHeader</strong> member of <a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a> into the newly retreated region of
the cloned net buffer list. The size of the buffer must be equal to the value of
<em>headerIncludeHeaderLength</em>.</li>
<li>Call
<strong>FwpsConstructIpHeaderForTransportPacket0</strong> that has the
<em>NetBufferList</em> parameter pointing to the cloned net buffer list and the
<em>headerIncludeHeaderSize</em> parameter set to the value of
<em>headerIncludeHeaderLength</em>.</li>
</ol>
<p><strong>FwpsConstructIpHeaderForTransportPacket0</strong> disables large send offload (LSO) and checksum offload
support for the resulting net buffer list. Full checksums are calculated for upper-level protocols (TCP,
UDP, and ICMP). The IP checksum is recalculated when the IP header is reconstructed.</p>
<h2>See also</h2>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/af-inet">AF_INET</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/af-inet6">AF_INET6</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ws2def/ns-ws2def-wsacmsghdr">CMSGHDR</a></p>
<p><a href="fwps_incoming_metadata_values0_" title="typedef struct FWPS_INCOMING_METADATA_VALUES0_ {&#10;  UINT32                          currentMetadataValues;&#10;  UINT32                          flags;&#10;  UINT64                          reserved;&#10;  FWPS_DISCARD_METADATA0          discardMetadata;&#10;  UINT64                          flowHandle;&#10;  UINT32                          ipHeaderSize;&#10;  UINT32                          transportHeaderSize;&#10;  FWP_BYTE_BLOB                   *processPath;&#10;  UINT64                          token;&#10;  UINT64                          processId;&#10;  UINT32                          sourceInterfaceIndex;&#10;  UINT32                          destinationInterfaceIndex;&#10;  ULONG                           compartmentId;&#10;  FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;&#10;  ULONG                           pathMtu;&#10;  HANDLE                          completionHandle;&#10;  UINT64                          transportEndpointHandle;&#10;  SCOPE_ID                        remoteScopeId;&#10;  WSACMSGHDR                      *controlData;&#10;...">FWPS_INCOMING_METADATA_VALUES0</a></p>
<p><a href="fwpsinjecttransportreceiveasync0" title="NTSTATUS FwpsInjectTransportReceiveAsync0(&#10;  [in]           HANDLE                injectionHandle,&#10;  [in, optional] HANDLE                injectionContext,&#10;                 PVOID                 reserved,&#10;  [in]           UINT32                flags,&#10;  [in]           ADDRESS_FAMILY        addressFamily,&#10;  [in]           COMPARTMENT_ID        compartmentId,&#10;  [in]           IF_INDEX              interfaceIndex,&#10;  [in]           IF_INDEX              subInterfaceIndex,&#10;  [in, out]      NET_BUFFER_LIST       *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0 completionFn,&#10;  [in, optional] HANDLE                completionContext&#10;);">FwpsInjectTransportReceiveAsync0</a></p>
<p><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsconstructipheaderfortransportpacket0">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fwpsk/nf-fwpsk-fwpsconstructipheaderfortransportpacket0.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
