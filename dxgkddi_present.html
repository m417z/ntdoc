<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="DXGKDDI_PRESENT - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>DXGKDDI_PRESENT - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            DXGKDDI_PRESENT - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dkmddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">DXGKDDI_PRESENT DxgkddiPresent;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> DxgkddiPresent(
  [in]     IN_CONST_HANDLE hContext,
  [in/out] INOUT_PDXGKARG_PRESENT pPresent
)
{...}</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_present">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/dxgkddi_present.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-d3dkmddi-dxgkddi_present)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="dxgkddi_present-callback-function">DXGKDDI_PRESENT callback function</h1>

<h2 id="description">Description</h2>

<p>The <em>DxgkDdiPresent</em> function copies content from source allocations to a primary surface (and sometimes to off-screen system memory allocations).</p>

<h2 id="parameters">Parameters</h2>

<h3 id="hcontext-in"><code>hContext</code> [in]</h3>

<p>A handle to the device context for the copy information. The display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createcontext">DxgkDdiCreateContext</a> function previously returned this handle in the <strong>hContext</strong> member of the <a href="dxgkarg_createcontext" title="typedef struct _DXGKARG_CREATECONTEXT {&#10;  [out] HANDLE                  hContext;&#10;  [in]  UINT                    NodeOrdinal;&#10;  [in]  UINT                    EngineAffinity;&#10;  [in]  DXGK_CREATECONTEXTFLAGS Flags;&#10;  [in]  VOID                    *pPrivateDriverData;&#10;  [in]  UINT                    PrivateDriverDataSize;&#10;  [out] DXGK_CONTEXTINFO        ContextInfo;&#10;} DXGKARG_CREATECONTEXT;">DXGKARG_CREATECONTEXT</a> structure that the <em>pCreateContext</em> parameter of <em>DxgkDdiCreateContext</em> points to.</p>

<p>If the driver does not support context creation, the Microsoft DirectX graphics kernel subsystem replaces the handle to the context with a handle to the device. The display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createdevice">DxgkDdiCreateDevice</a> function previously returned the device handle in the <strong>hDevice</strong> member of the <a href="dxgkarg_createdevice" title="typedef struct _DXGKARG_CREATEDEVICE {&#10;  HANDLE hDevice;&#10;  union {&#10;    DXGK_CREATEDEVICEFLAGS Flags;&#10;    DXGK_DEVICEINFO        *pInfo;&#10;  };&#10;  ULONG  Pasid;&#10;  HANDLE hKmdProcess;&#10;} DXGKARG_CREATEDEVICE;">DXGKARG_CREATEDEVICE</a> structure that the <em>pCreateDevice</em> parameter of <em>DxgkDdiCreateDevice</em> points to.</p>

<h3 id="ppresent-inout"><code>pPresent</code> [in/out]</h3>

<p>A pointer to a <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> structure that contains information about the copy operation.</p>

<h2 id="return-value">Return value</h2>

<p><em>DxgkDdiPresent</em> returns one of the following values:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></td>
  <td>DxgkDdiPresent successfully copied the content.</td>
</tr>
<tr>
  <td>STATUS_NO_MEMORY or STATUS_INSUFFICIENT_RESOURCES</td>
  <td>DxgkDdiPresent could not allocate memory that was required for it to complete.</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER</td>
  <td>The current direct memory access (DMA) buffer is depleted.</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_CANNOTCOLORCONVERT</td>
  <td>The display miniport driver detected a bit-block transfer (bitblt) for color conversion that the device could not perform. The Microsoft Direct3D runtime prevents the application from continuing, and the application receives a failure to copy content.</td>
</tr>
<tr>
  <td>STATUS_PRIVILEGED_INSTRUCTION</td>
  <td>DxgkDdiPresent detected nonprivileged instructions (that is, instructions that access memory beyond the privilege of the current central processing unit [CPU] process).</td>
</tr>
<tr>
  <td>STATUS_ILLEGAL_INSTRUCTION</td>
  <td>DxgkDdiPresent detected instructions that graphics hardware cannot support.</td>
</tr>
<tr>
  <td>STATUS_INVALID_HANDLE</td>
  <td>DxgkDdiPresent detected an invalid handle in the command buffer.</td>
</tr>
<tr>
  <td>STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE</td>
  <td>The display miniport driver detected an error in the DMA stream. The graphics context device is placed in a lost state if the driver returns this error code.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>The DirectX graphics kernel subsystem calls the display miniport driver's <em>DxgkDdiPresent</em> function to copy content from source allocations typically to the primary surface. (This function can also copy content to an off-screen system memory allocation.) Because a primary surface is loosely defined, <em>DxgkDdiPresent</em> can be implemented for the following scenarios:</p>

<ul>
<li>Depending on the position of the window, the <em>DxgkDdiPresent</em> function must be performed across different primaries that can be on the same adapter or across different adapters.</li>
<li>The primary is on a remote monitor and is accessed through a terminal services client or Microsoft NetMeeting.</li>
<li>A mode switch recently occurred and the primary format is different from the source format, so a color conversion is needed. In addition, the <em>DxgkDdiPresent</em> operation can be clipped because of window clipping and ordering.</li>
</ul>

<p>Because the preceding scenarios can change asynchronously, the user-mode display driver cannot compile hardware instructions for the display miniport driver's <em>DxgkDdiPresent</em> function in advance. The display miniport driver must create hardware commands for the actual <em>DxgkDdiPresent</em> operation, and they must be placed in an output DMA buffer. After the display miniport driver's <em>DxgkDdiPresent</em> function is called to generate the DMA buffer, the operating system guarantees that a scenario change will not occur before that buffer is rendered.</p>

<p>The display miniport driver is not required to be aware of the specifics of the preceding scenarios as long as the driver supports the following abstractions:</p>

<ul>
<li>In a copy operation from a video memory source to a primary video or system memory destination, a copy from an off-screen system memory source to the primary destination, a copy from and to the primary, or a copy from the primary source to an off-screen system memory destination, the source is specified by the <strong>hDeviceSpecificAllocation</strong> member of the <strong>pAllocationList</strong>[DXGK_PRESENT_SOURCE_INDEX] array element of the <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> structure that the <em>pPresent</em> parameter of <em>DxgkDdiPresent</em> points to. The destination, which is either the current primary of the device or an off-screen system memory allocation, is specified by the <strong>hDeviceSpecificAllocation</strong> member of the <strong>pAllocationList</strong>[DXGK_PRESENT_DESTINATION_INDEX] array element of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a>. If the destination equals the source (that is, destination == source), the copy operation is a screen-to-screen bit-block transfer (bitblt). Therefore, the graphics subsystem sets the source and destination to the following values:
<ul>
<li>destination != <strong>NULL</strong> (that is, destination == nonNULL)</li>
<li>source != <strong>NULL</strong> (that is, source == nonNULL)</li>
</ul></li>
<li><p>In a video memory flip from the current allocation to another allocation, the source can be specified by the operating system and set in the <strong>hDeviceSpecificAllocation</strong> member of the <strong>pAllocationList</strong>[DXGK_PRESENT_SOURCE_INDEX] array element of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a>. The graphics subsystem sets the source and destination to the following values:</p>

<ul>
<li>destination == <strong>NULL</strong></li>
<li>source != <strong>NULL</strong> (that is, source == nonNULL)</li>
</ul>

<p><strong>Note</strong> A no-op flip can be performed from the same source allocation as the currently scanned-out allocation. A no-op flip is used to insert a queued wait for a vertical blank in the rendering stream. The display miniport driver should insert a hardware flip command as if it were flipping to another allocation.</p></li>
<li>In a color-fill operation to the primary surface, no source allocation is required and the destination is a primary allocation handle that is specified by the <strong>hDeviceSpecificAllocation</strong> member of the <strong>pAllocationList</strong>[DXGK_PRESENT_DESTINATION_INDEX] array element of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a>. The <strong>Color</strong> member of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> is typically in the D3DDDIFMT_A8R8G8B8 format from the <a href="d3dddiformat" title="typedef enum _D3DDDIFORMAT {&#10;  D3DDDIFMT_UNKNOWN,&#10;  D3DDDIFMT_R8G8B8,&#10;  D3DDDIFMT_A8R8G8B8,&#10;  D3DDDIFMT_X8R8G8B8,&#10;  D3DDDIFMT_R5G6B5,&#10;  D3DDDIFMT_X1R5G5B5,&#10;  D3DDDIFMT_A1R5G5B5,&#10;  D3DDDIFMT_A4R4G4B4,&#10;  D3DDDIFMT_R3G3B2,&#10;  D3DDDIFMT_A8,&#10;  D3DDDIFMT_A8R3G3B2,&#10;  D3DDDIFMT_X4R4G4B4,&#10;  D3DDDIFMT_A2B10G10R10,&#10;  D3DDDIFMT_A8B8G8R8,&#10;  D3DDDIFMT_X8B8G8R8,&#10;  D3DDDIFMT_G16R16,&#10;  D3DDDIFMT_A2R10G10B10,&#10;  D3DDDIFMT_A16B16G16R16,&#10;  D3DDDIFMT_A8P8,&#10;...">D3DDDIFORMAT</a> enumeration type. However, when the primary format is palettized RGB, <strong>Color</strong> contains the palette index. Therefore, the graphics subsystem sets the source and destination to the following values:
<ul>
<li>destination != <strong>NULL</strong> (that is, destination == nonNULL)</li>
<li>source == <strong>NULL</strong></li>
</ul></li>
</ul>

<p>For all of the <em>DxgkDdiPresent</em> scenarios to operate correctly, the display miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createdevice">DxgkDdiCreateDevice</a> function should set the <strong>DmaBufferSize</strong> member of the <a href="dxgk_deviceinfo" title="typedef struct _DXGK_DEVICEINFO {&#10;  [out] UINT                 DmaBufferSize;&#10;  [out] UINT                 DmaBufferSegmentSet;&#10;  [out] UINT                 DmaBufferPrivateDataSize;&#10;  [out] UINT                 AllocationListSize;&#10;  [out] UINT                 PatchLocationListSize;&#10;  [out] DXGK_DEVICEINFOFLAGS Flags;&#10;} DXGK_DEVICEINFO;">DXGK_DEVICEINFO</a> structure to be large enough to hold the hardware commands that are needed to present at least one <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/windef/ns-windef-rect">RECT</a> rectangle to the display or off-screen target. However, the driver's <em>DxgkDdiPresent</em> function can return STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER if the number of subrectangles in the <em>DxgkDdiPresent</em> scenario depletes the current DMA buffer and the driver requires another DMA buffer to continue.</p>

<p>The graphics subsystem then acquires a new DMA buffer and calls the driver's <em>DxgkDdiPresent</em> function again with the same list of RECT structures as the previous <em>DxgkDdiPresent</em> call. The driver must use the <strong>MultipassOffset</strong> member of the <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> structure that is pointed to by <em>pPresent</em> to record the amount of progress made in completing the RECT list in the previous call to <em>DxgkDdiPresent</em> so that the driver can continue from where it stopped with the new DMA buffer. When the driver's <em>DxgkDdiPresent</em> function completes the list of RECT structures, it returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>.</p>

<p>In addition to generating a DMA buffer, the display miniport driver must generate a patch-location list that indicates the various offsets within the DMA buffer that must be patched later when physical addresses for allocations are known. At times, the video memory manager provides the driver with pre-patched information (that is, the last know physical addresses for the source and destination) in the allocation list.</p>

<p>When the video memory manager provides this information, the driver must generate the DMA buffer by determining that these physical addresses are the final addresses that the DirectX graphics kernel subsystem will provide. The graphics subsystem might not call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a> function on the DMA buffer to patch it again later. Therefore, the driver must use the pre-patch information to generate the DMA buffer properly. Pre-patched information is provided for element <em>N</em> when the <strong>SegmentId</strong> member of the *N*th element of the <strong>pAllocationList</strong> array of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> is nonzero.</p>

<p><strong>Note</strong> Even though the driver's <em>DxgkDdiPresent</em> function pre-patches the DMA buffer, the driver must still insert all of the references to allocations into the output patch-location list that the <strong>pPatchLocationListOut</strong> member of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> specifies. The driver must insert these references because the addresses of the allocations might change before the DMA buffer is submitted to the GPU; therefore, the DirectX graphics kernel subsystem will call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a> function to repatch the DMA buffer.</p>

<p>If the driver supports rotation (that is, reports support for rotated modes in the <strong>RotationSupport</strong> member of the <a href="d3dkmdt_vidpn_present_path_transformation" title="typedef struct _D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION {&#10;  D3DKMDT_VIDPN_PRESENT_PATH_SCALING          Scaling;&#10;  D3DKMDT_VIDPN_PRESENT_PATH_SCALING_SUPPORT  ScalingSupport;&#10;  D3DKMDT_VIDPN_PRESENT_PATH_ROTATION         Rotation;&#10;  D3DKMDT_VIDPN_PRESENT_PATH_ROTATION_SUPPORT RotationSupport;&#10;} D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION;">D3DKMDT_VIDPN_PRESENT_PATH_TRANSFORMATION</a> structure in a call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_enumvidpncofuncmodality">DxgkDdiEnumVidPnCofuncModality</a> function), the driver must be able to perform rotated bit-block transfers (bitblt) from source to destination. When the <strong>Rotate</strong> bit-field flag is specified in the <a href="dxgk_presentflags" title="typedef struct _DXGK_PRESENTFLAGS {&#10;  union {&#10;    struct {&#10;      UINT Blt : 1;&#10;      UINT ColorFill : 1;&#10;      UINT Flip : 1;&#10;      UINT FlipWithNoWait : 1;&#10;      UINT SrcColorKey : 1;&#10;      UINT DstColorKey : 1;&#10;      UINT LinearToSrgb : 1;&#10;      UINT Rotate : 1;&#10;      UINT FlipStereo : 1;&#10;      UINT FlipStereoTemporaryMono : 1;&#10;      UINT FlipStereoPreferRight : 1;&#10;      UINT BltStereoUseRight : 1;&#10;      UINT FlipWithMultiPlaneOverlay : 1;&#10;      UINT RedirectedFlip : 1;&#10;#if ...&#10;      UINT Reserved : 18;&#10;#elif&#10;...">DXGK_PRESENTFLAGS</a> structure for the <strong>Flags</strong> member of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a>, the driver should apply the rotation as if going from a non-rotated surface to the final orientation of the current source.</p>

<p>The primary allocation of a source is specified in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_commitvidpn">DxgkDdiCommitVidPn</a> function. If multiple paths originate from the given source (clone mode), the display miniport driver must ensure that the outputs are correctly rotated given the path rotation mode for the different targets. All of the parameters that are supplied to <em>DxgkDdiPresent</em> are rotation agnostic. The source and target rectangles could both be the entire screen as clients perceive it (for example, 768 x 1024).</p>

<p><strong>Note</strong> This situation does not address full-screen Direct3D applications in rotated mode.</p>

<p>If the display miniport driver previously indicated, in a call to its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_queryadapterinfo">DxgkDdiQueryAdapterInfo</a> function, that it supports a memory mapped I/O (MMIO)-based flip (by setting the <strong>FlipOnVSyncMmIo</strong> bit-field flag in the <strong>FlipCaps</strong> member of the <a href="dxgk_drivercaps" title="typedef struct _DXGK_DRIVERCAPS {&#10;  [out] PHYSICAL_ADDRESS                   HighestAcceptableAddress;&#10;  [out] UINT                               MaxAllocationListSlotId;&#10;  [out] SIZE_T                             ApertureSegmentCommitLimit;&#10;  [out] UINT                               MaxPointerWidth;&#10;  [out] UINT                               MaxPointerHeight;&#10;  [out] DXGK_POINTERFLAGS                  PointerCaps;&#10;  [out] UINT                               InterruptMessageNumber;&#10;  [out] UINT                               NumberOfSwizzlingRanges;&#10;  [out] UINT                               MaxOverlays;&#10;  union {&#10;    [out] DXGK_GAMMARAMPCAPS      GammaRampCaps;&#10;    [out] DXGK_COLORTRANSFORMCAPS ColorTransformCaps;&#10;  };&#10;  [out] DXGK_PRESENTATIONCAPS              PresentationCaps;&#10;  [out] UINT                               MaxQueuedFlipOnVSync;&#10;  [out] DXGK_FLIPCAPS                      FlipCaps;&#10;  [out] DXGK_VIDSCHCAPS                    SchedulingCaps;&#10;  [out] DXGK_VIDMMCAPS                     MemoryManagementCaps;&#10;  [out] DXGK_GPUENGINETOPOLOGY             GpuEngineTopology;&#10;...">DXGK_DRIVERCAPS</a> structure to <strong>TRUE</strong>), the driver's <em>DxgkDdiPresent</em> function is subsequently called with the <strong>pDmaBuffer</strong> member of <a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a> set to <strong>NULL</strong> because a MMIO-based flip does not require a DMA buffer to run on the GPU. Instead, the driver's <em>DxgkDdiPresent</em> function must validate the source surface and program flip hardware as required. The DirectX graphics kernel subsystem calls the driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff560767(v=vs.85)">DxgkDdiSetVidPnSourceAddress</a> function to run this type of flip.</p>

<p><em>DxgkDdiPresent</em> should be made pageable.</p>

<h2 id="see-also">See also</h2>

<p><a href="d3dddiformat" title="typedef enum _D3DDDIFORMAT {&#10;  D3DDDIFMT_UNKNOWN,&#10;  D3DDDIFMT_R8G8B8,&#10;  D3DDDIFMT_A8R8G8B8,&#10;  D3DDDIFMT_X8R8G8B8,&#10;  D3DDDIFMT_R5G6B5,&#10;  D3DDDIFMT_X1R5G5B5,&#10;  D3DDDIFMT_A1R5G5B5,&#10;  D3DDDIFMT_A4R4G4B4,&#10;  D3DDDIFMT_R3G3B2,&#10;  D3DDDIFMT_A8,&#10;  D3DDDIFMT_A8R3G3B2,&#10;  D3DDDIFMT_X4R4G4B4,&#10;  D3DDDIFMT_A2B10G10R10,&#10;  D3DDDIFMT_A8B8G8R8,&#10;  D3DDDIFMT_X8B8G8R8,&#10;  D3DDDIFMT_G16R16,&#10;  D3DDDIFMT_A2R10G10B10,&#10;  D3DDDIFMT_A16B16G16R16,&#10;  D3DDDIFMT_A8P8,&#10;...">D3DDDIFORMAT</a></p>

<p><a href="dxgkarg_createcontext" title="typedef struct _DXGKARG_CREATECONTEXT {&#10;  [out] HANDLE                  hContext;&#10;  [in]  UINT                    NodeOrdinal;&#10;  [in]  UINT                    EngineAffinity;&#10;  [in]  DXGK_CREATECONTEXTFLAGS Flags;&#10;  [in]  VOID                    *pPrivateDriverData;&#10;  [in]  UINT                    PrivateDriverDataSize;&#10;  [out] DXGK_CONTEXTINFO        ContextInfo;&#10;} DXGKARG_CREATECONTEXT;">DXGKARG_CREATECONTEXT</a></p>

<p><strong><a href="dxgkarg_present" title="typedef struct _DXGKARG_PRESENT {&#10;  [out]    VOID                     *pDmaBuffer;&#10;  [in]     UINT                     DmaSize;&#10;  [in]     VOID                     *pDmaBufferPrivateData;&#10;  [in]     UINT                     DmaBufferPrivateDataSize;&#10;  union {&#10;    [in]     DXGK_ALLOCATIONLIST               *pAllocationList;&#10;    [in]     DXGK_PRESENTALLOCATIONINFO        *pAllocationInfo;&#10;    [in]     DXGK_PRESENTMULTIPLANEOVERLAYINFO *pPresentMultiPlaneOverlayInfo;&#10;  };&#10;#if ...&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#if ...&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;  [in]     DXGK_ALLOCATIONLIST      *pAllocationList;&#10;#else&#10;  [in/out] D3DDDI_PATCHLOCATIONLIST *pPatchLocationListOut;&#10;#endif&#10;#else&#10;  [in]     UINT                     PatchLocationListOutSize;&#10;...">DXGKARG_PRESENT</a></strong></p>

<p><a href="dxgk_deviceinfo" title="typedef struct _DXGK_DEVICEINFO {&#10;  [out] UINT                 DmaBufferSize;&#10;  [out] UINT                 DmaBufferSegmentSet;&#10;  [out] UINT                 DmaBufferPrivateDataSize;&#10;  [out] UINT                 AllocationListSize;&#10;  [out] UINT                 PatchLocationListSize;&#10;  [out] DXGK_DEVICEINFOFLAGS Flags;&#10;} DXGK_DEVICEINFO;">DXGK_DEVICEINFO</a></p>

<p><a href="dxgk_drivercaps" title="typedef struct _DXGK_DRIVERCAPS {&#10;  [out] PHYSICAL_ADDRESS                   HighestAcceptableAddress;&#10;  [out] UINT                               MaxAllocationListSlotId;&#10;  [out] SIZE_T                             ApertureSegmentCommitLimit;&#10;  [out] UINT                               MaxPointerWidth;&#10;  [out] UINT                               MaxPointerHeight;&#10;  [out] DXGK_POINTERFLAGS                  PointerCaps;&#10;  [out] UINT                               InterruptMessageNumber;&#10;  [out] UINT                               NumberOfSwizzlingRanges;&#10;  [out] UINT                               MaxOverlays;&#10;  union {&#10;    [out] DXGK_GAMMARAMPCAPS      GammaRampCaps;&#10;    [out] DXGK_COLORTRANSFORMCAPS ColorTransformCaps;&#10;  };&#10;  [out] DXGK_PRESENTATIONCAPS              PresentationCaps;&#10;  [out] UINT                               MaxQueuedFlipOnVSync;&#10;  [out] DXGK_FLIPCAPS                      FlipCaps;&#10;  [out] DXGK_VIDSCHCAPS                    SchedulingCaps;&#10;  [out] DXGK_VIDMMCAPS                     MemoryManagementCaps;&#10;  [out] DXGK_GPUENGINETOPOLOGY             GpuEngineTopology;&#10;...">DXGK_DRIVERCAPS</a></p>

<p><a href="dxgk_presentflags" title="typedef struct _DXGK_PRESENTFLAGS {&#10;  union {&#10;    struct {&#10;      UINT Blt : 1;&#10;      UINT ColorFill : 1;&#10;      UINT Flip : 1;&#10;      UINT FlipWithNoWait : 1;&#10;      UINT SrcColorKey : 1;&#10;      UINT DstColorKey : 1;&#10;      UINT LinearToSrgb : 1;&#10;      UINT Rotate : 1;&#10;      UINT FlipStereo : 1;&#10;      UINT FlipStereoTemporaryMono : 1;&#10;      UINT FlipStereoPreferRight : 1;&#10;      UINT BltStereoUseRight : 1;&#10;      UINT FlipWithMultiPlaneOverlay : 1;&#10;      UINT RedirectedFlip : 1;&#10;#if ...&#10;      UINT Reserved : 18;&#10;#elif&#10;...">DXGK_PRESENTFLAGS</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_commitvidpn">DxgkDdiCommitVidPn</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createcontext">DxgkDdiCreateContext</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_createdevice">DxgkDdiCreateDevice</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_enumvidpncofuncmodality">DxgkDdiEnumVidPnCofuncModality</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_patch">DxgkDdiPatch</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_queryadapterinfo">DxgkDdiQueryAdapterInfo</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dkmddi/nc-d3dkmddi-dxgkddi_present">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dkmddi/nc-d3dkmddi-dxgkddi_present.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
