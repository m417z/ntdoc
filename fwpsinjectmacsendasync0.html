<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FwpsInjectMacSendAsync0 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FwpsInjectMacSendAsync0 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FwpsInjectMacSendAsync0 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fwpsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FwpsInjectMacSendAsync0(
  [in]           HANDLE               injectionHandle,
  [in, optional] HANDLE               injectionContext,
  [in]           <a href="uint32" title="typedef unsigned int UINT32;">UINT32</a>               flags,
  [in]           <a href="uint16" title="typedef unsigned short UINT16;">UINT16</a>               layerId,
  [in]           IF_INDEX             interfaceIndex,
  [in]           NDIS_PORT_NUMBER     NdisPortNumber,
  [in, out]      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a>      *netBufferLists,
  [in]           FWPS_INJECT_COMPLETE completionFn,
  [in, optional] HANDLE               completionContext
);</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjectmacsendasync0">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fwpsinjectmacsendasync0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fwpsk-fwpsinjectmacsendasync0)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fwpsinjectmacsendasync0-function">FwpsInjectMacSendAsync0 function</h1>

<h2 id="description">Description</h2>

<p>The <strong>FwpsInjectMacSendAsync0</strong> function can reinject a previously absorbed media access control (MAC) frame (or a clone of the frame) back to the layer 2 outbound data path from which it was intercepted, or inject an invented MAC frame.</p>

<p><strong>Note</strong> <strong>FwpsInjectMacSendAsync0</strong> is a specific version of <strong>FwpsInjectMacSendAsync</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FWP/wfp-version-independent-names-and-targeting-specific-versions-of-windows">WFP Version-Independent Names and Targeting Specific Versions of Windows</a> for more information.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="injectionhandle-in"><code>injectionHandle</code> [in]</h3>

<p>An injection handle that was previously obtained by a call to the <a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a> function with the <em>flags</em> parameter set to FWPS_INJECTION_TYPE_L2.</p>

<p><strong>Note</strong> Set the <em>addressFamily</em> parameter of the <a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a> function to AF_UNSPEC.</p>

<h3 id="injectioncontext-in-optional"><code>injectionContext</code> [in, optional]</h3>

<p>An optional handle to the injection context. If specified, it can be obtained by calling the
<a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a> function when the packet injection state
<a href="fwps_packet_injection_state_" title="typedef enum FWPS_PACKET_INJECTION_STATE_ {&#10;  FWPS_PACKET_NOT_INJECTED,&#10;  FWPS_PACKET_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTED_BY_OTHER,&#10;  FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF,&#10;  FWPS_PACKET_INJECTION_STATE_MAX&#10;} FWPS_PACKET_INJECTION_STATE;">FWPS_PACKET_INJECTION_STATE</a> is
<strong>FWPS_PACKET_INJECTED_BY_SELF</strong> or <strong>FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF</strong>.</p>

<h3 id="flags-in"><code>flags</code> [in]</h3>

<p>Reserved. Must be set to zero.</p>

<h3 id="layerid-in"><code>layerId</code> [in]</h3>

<p>The run-time identifier for the filtering layer at which the data stream is being processed.</p>

<h3 id="interfaceindex-in"><code>interfaceIndex</code> [in]</h3>

<p>The interface index that is passed to the callout driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> incoming value FWPS_FIELD<em>*Xxx*</em>MAC_FRAME<em>*Xxx*</em>INTERFACE_INDEX.</p>

<h3 id="ndisportnumber-in"><code>NdisPortNumber</code> [in]</h3>

<p>The NDIS port number that is passed to the callout driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> incoming value FWPS_FIELD<em>*Xxx*</em>MAC_FRAME<em>*Xxx*</em><a href="ndis_port" title="typedef struct _NDIS_PORT {&#10;  PNDIS_PORT                Next;&#10;  PVOID                     NdisReserved;&#10;  PVOID                     MiniportReserved;&#10;  PVOID                     ProtocolReserved;&#10;  NDIS_PORT_CHARACTERISTICS PortCharacteristics;&#10;} NDIS_PORT, *PNDIS_PORT;">NDIS_PORT</a>.</p>

<h3 id="netbufferlists-in-out"><code>netBufferLists</code> [in, out]</h3>

<p>A pointer to a
<a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure that describes
the packet data that is being injected. A callout driver allocates a <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure to use to
inject packet data by calling either the
<a href="fwpsallocateclonenetbufferlist0" title="NTSTATUS FwpsAllocateCloneNetBufferList0(&#10;  [in, out]      NET_BUFFER_LIST *originalNetBufferList,&#10;  [in, optional] NDIS_HANDLE     netBufferListPoolHandle,&#10;  [in, optional] NDIS_HANDLE     netBufferPoolHandle,&#10;  [in]           ULONG           allocateCloneFlags,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateCloneNetBufferList0</a> function or the
<a href="fwpsallocatenetbufferandnetbufferlist0" title="NTSTATUS FwpsAllocateNetBufferAndNetBufferList0(&#10;  [in]           NDIS_HANDLE     poolHandle,&#10;  [in]           USHORT          contextSize,&#10;  [in]           USHORT          contextBackFill,&#10;  [in, optional] MDL             *mdlChain,&#10;  [in]           ULONG           dataOffset,&#10;  [in]           SIZE_T          dataLength,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateNetBufferAndNetBufferList0</a> function. The <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure must begin with a MAC header.</p>

<h3 id="completionfn-in"><code>completionFn</code> [in]</h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a> callout function provided by
the callout driver. The filter engine calls this function after the packet data, described by the
<em>netBufferLists</em> parameter, has been injected into the network stack. This pointer must be specified when injecting cloned or created <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structures. When injecting original <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structures, this parameter can be NULL if the original structures are not altered.</p>

<h3 id="completioncontext-in-optional"><code>completionContext</code> [in, optional]</h3>

<p>A pointer to a callout driver–provided context that is passed to the callout function pointed to
by the
<em>completionFn</em> parameter. This parameter is optional and can be <strong>NULL</strong>.</p>

<h2 id="return-value">Return value</h2>

<p>The
<strong>FwpsInjectMacSendAsync0</strong> function returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> codes.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The MAC frame data injection was initiated successfully. The filter engine calls the completion function after the filter engine has completed injecting the MAC frame data, or when an error occurred subsequently. In case of an error, the <strong>Status</strong> member of the completed <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> structure will indicate the reason for failure.</td>
</tr>
<tr>
  <td><strong>STATUS_FWP_TCPIP_NOT_READY</strong></td>
  <td>The MAC layer is not ready to accept injection of packet data.</td>
</tr>
<tr>
  <td><strong>STATUS_FWP_INJECT_HANDLE_CLOSING</strong></td>
  <td>The injection handle is being closed.</td>
</tr>
<tr>
  <td><strong>STATUS_FWP_INJECT_HANDLE_STALE</strong></td>
  <td>The injection handle was not created with the <em>flags</em> parameter of the <a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a> function set to FWPS_INJECTION_TYPE_L2.</td>
</tr>
<tr>
  <td><strong>Other status codes</strong></td>
  <td>An error occurred.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>A callback driver calls the <strong>FwpsInjectMacSendAsync0</strong> function to reinject a previously absorbed MAC frame (or a clone of the frame) back to the layer 2 inbound data path from which it was intercepted, or to inject an invented MAC frame.</p>

<p>The <em>netBufferLists</em> parameter can be a <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a> chain. However the completion function could be invoked multiple times each, completing a segment (or single <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a>) of the chain.</p>

<p>Injected frames could get classified again if the packets match the same filter as originally classified. Therefore, as with callouts at IP layers, layer 2 callouts must also protect against infinite packet inspection by calling <a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a>.</p>

<h2 id="see-also">See also</h2>

<p><a href="fwpsallocateclonenetbufferlist0" title="NTSTATUS FwpsAllocateCloneNetBufferList0(&#10;  [in, out]      NET_BUFFER_LIST *originalNetBufferList,&#10;  [in, optional] NDIS_HANDLE     netBufferListPoolHandle,&#10;  [in, optional] NDIS_HANDLE     netBufferPoolHandle,&#10;  [in]           ULONG           allocateCloneFlags,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateCloneNetBufferList0</a></p>

<p><a href="fwpsallocatenetbufferandnetbufferlist0" title="NTSTATUS FwpsAllocateNetBufferAndNetBufferList0(&#10;  [in]           NDIS_HANDLE     poolHandle,&#10;  [in]           USHORT          contextSize,&#10;  [in]           USHORT          contextBackFill,&#10;  [in, optional] MDL             *mdlChain,&#10;  [in]           ULONG           dataOffset,&#10;  [in]           SIZE_T          dataLength,&#10;  [out]          NET_BUFFER_LIST **netBufferList&#10;);">FwpsAllocateNetBufferAndNetBufferList0</a></p>

<p><a href="fwpsinjectionhandlecreate0" title="NTSTATUS FwpsInjectionHandleCreate0(&#10;  [in, optional] ADDRESS_FAMILY addressFamily,&#10;  [in]           UINT32         flags,&#10;  [out]          HANDLE         *injectionHandle&#10;);">FwpsInjectionHandleCreate0</a></p>

<p><a href="fwpsquerypacketinjectionstate0" title="FWPS_PACKET_INJECTION_STATE FwpsQueryPacketInjectionState0(&#10;  [in]            HANDLE                injectionHandle,&#10;  [in]            const NET_BUFFER_LIST *netBufferList,&#10;  [out, optional] HANDLE                *injectionContext&#10;);">FwpsQueryPacketInjectionState0</a></p>

<p><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjectmacsendasync0">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fwpsk/nf-fwpsk-fwpsinjectmacsendasync0.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
