<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="VIDEO_PORT_CONFIG_INFO - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>VIDEO_PORT_CONFIG_INFO - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            VIDEO_PORT_CONFIG_INFO - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// video.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _VIDEO_PORT_CONFIG_INFO {
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        Length;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        SystemIoBusNumber;
  <a href="interface_type" title="typedef enum _INTERFACE_TYPE&#10;{&#10;    InterfaceTypeUndefined = -1,&#10;    Internal = 0,&#10;    Isa = 1,&#10;    Eisa = 2,&#10;    MicroChannel = 3,&#10;    TurboChannel = 4,&#10;    PCIBus = 5,&#10;    VMEBus = 6,&#10;    NuBus = 7,&#10;    PCMCIABus = 8,&#10;    CBus = 9,&#10;    MPIBus = 10,&#10;    MPSABus = 11,&#10;    ProcessorInternal = 12,&#10;    InternalPowerBus = 13,&#10;    PNPISABus = 14,&#10;    PNPBus = 15,&#10;    Vmcs = 16,&#10;...">INTERFACE_TYPE</a>               AdapterInterfaceType;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        BusInterruptLevel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        BusInterruptVector;
  <a href="kinterrupt_mode" title="typedef enum _KINTERRUPT_MODE {&#10;  LevelSensitive,&#10;  Latched&#10;} KINTERRUPT_MODE;">KINTERRUPT_MODE</a>              InterruptMode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        NumEmulatorAccessEntries;
  <a href="emulator_access_entry" title="typedef struct _EMULATOR_ACCESS_ENTRY {&#10;  ULONG                     BasePort;&#10;  ULONG                     NumConsecutivePorts;&#10;  EMULATOR_PORT_ACCESS_TYPE AccessType;&#10;  UCHAR                     AccessMode;&#10;  UCHAR                     StringSupport;&#10;  PVOID                     Routine;&#10;} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;">PEMULATOR_ACCESS_ENTRY</a>       EmulatorAccessEntries;
  <a href="ulong_ptr" title="typedef [public] unsigned __int3264 ULONG_PTR;">ULONG_PTR</a>                    EmulatorAccessEntriesContext;
  <a href="physical_address" title="typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;">PHYSICAL_ADDRESS</a>             VdmPhysicalVideoMemoryAddress;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        VdmPhysicalVideoMemoryLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        HardwareStateSize;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        DmaChannel;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        DmaPort;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                        DmaShareable;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                        InterruptShareable;
  BOOLEAN                      Master;
  <a href="dma_width" title="typedef enum _DMA_WIDTH&#10;{&#10;    Width8Bits,&#10;    Width16Bits,&#10;    Width32Bits,&#10;    Width64Bits,&#10;    WidthNoWrap,&#10;    MaximumDmaWidth&#10;} DMA_WIDTH, *PDMA_WIDTH;">DMA_WIDTH</a>                    DmaWidth;
  <a href="dma_speed" title="typedef enum _DMA_SPEED&#10;{&#10;    Compatible,&#10;    TypeA,&#10;    TypeB,&#10;    TypeC,&#10;    TypeF,&#10;    MaximumDmaSpeed&#10;} DMA_SPEED, *PDMA_SPEED;">DMA_SPEED</a>                    DmaSpeed;
  BOOLEAN                      bMapBuffers;
  BOOLEAN                      NeedPhysicalAddresses;
  BOOLEAN                      DemandMode;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        MaximumTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        NumberOfPhysicalBreaks;
  BOOLEAN                      ScatterGather;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                        MaximumScatterGatherChunkSize;
  PVIDEO_PORT_GET_PROC_ADDRESS VideoPortGetProcAddress;
  PWSTR                        DriverRegistryPath;
  <a href="ulonglong" title="typedef unsigned __int64 ULONGLONG;">ULONGLONG</a>                    SystemMemorySize;
} VIDEO_PORT_CONFIG_INFO, *PVIDEO_PORT_CONFIG_INFO;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/ns-video-_video_port_config_info">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/video_port_config_info.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-video-_video_port_config_info)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_video_port_config_info-structure">_VIDEO_PORT_CONFIG_INFO structure</h1>

<h2 id="description">Description</h2>

<p>The VIDEO_PORT_CONFIG_INFO structure contains bus-specific adapter configuration information. This structure is used to set up the video hardware and to supply the video port driver with configuration information. The video port driver can then allocate necessary system resources for the miniport driver and its adapter.</p>

<h2 id="members">Members</h2>

<h3 id="length"><code>Length</code></h3>

<p>Is the size in bytes of this structure. The video port driver always initializes the <strong>Length</strong> member. In effect, its value indicates the version of VIDEO_PORT_CONFIG_INFO being used by the system. Because this structure might grow from one version of the system to the next, a miniport driver should check this member to determine whether it is at least **sizeof**(VIDEO_PORT_CONFIG_INFO) that the miniport driver uses to configure its adapter.</p>

<h3 id="systemiobusnumber"><code>SystemIoBusNumber</code></h3>

<p>Specifies the system-assigned number of the I/O bus on which the miniport driver's adapter might be connected. The video port driver always initializes this member.</p>

<h3 id="adapterinterfacetype"><code>AdapterInterfaceType</code></h3>

<p>Specifies the type of bus interface. The video port driver always sets this member based on the bus on which the PnP manager detected the device.</p>

<h3 id="businterruptlevel"><code>BusInterruptLevel</code></h3>

<p>This member is irrelevant if the video hardware does not generate interrupts, indicated by setting the <strong>HwInterrupt</strong> member in the <a href="video_hw_initialization_data" title="typedef struct _VIDEO_HW_INITIALIZATION_DATA {&#10;  ULONG                          HwInitDataSize;&#10;  INTERFACE_TYPE                 AdapterInterfaceType;&#10;  PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;&#10;  PVIDEO_HW_INITIALIZE           HwInitialize;&#10;  PVIDEO_HW_INTERRUPT            HwInterrupt;&#10;  PVIDEO_HW_START_IO             HwStartIO;&#10;  ULONG                          HwDeviceExtensionSize;&#10;  ULONG                          StartingDeviceNumber;&#10;  PVIDEO_HW_RESET_HW             HwResetHw;&#10;  PVIDEO_HW_TIMER                HwTimer;&#10;  PVIDEO_HW_START_DMA            HwStartDma;&#10;  PVIDEO_HW_POWER_SET            HwSetPowerState;&#10;  PVIDEO_HW_POWER_GET            HwGetPowerState;&#10;  PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;&#10;  PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;&#10;  ULONG                          HwChildDeviceExtensionSize;&#10;  PVIDEO_ACCESS_RANGE            HwLegacyResourceList;&#10;  ULONG                          HwLegacyResourceCount;&#10;  PVIDEO_HW_LEGACYRESOURCES      HwGetLegacyResources;&#10;...">VIDEO_HW_INITIALIZATION_DATA</a> structure to <strong>NULL</strong>. Otherwise, it specifies the bus-relative IRQL that corresponds to the interrupt request on <strong>Isa</strong> or <strong>MicroChannel</strong> type buses. The preset default value for this member is zero. A miniport driver must supply the correct value if it handles interrupts for a video adapter on an <strong>Isa</strong> or <strong>MicroChannel</strong> type bus, or for a video adapter configured for level-sensitive interrupts on an <strong>Eisa</strong> type bus.</p>

<p>If a miniport driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a> function finds that the video adapter does not generate interrupts or that it cannot determine a valid interrupt vector/level for the adapter, <em>HwVidFindAdapter</em> should set both <strong>BusInterruptLevel</strong> and <strong>BusInterruptVector</strong> to zero.</p>

<h3 id="businterruptvector"><code>BusInterruptVector</code></h3>

<p>This member is irrelevant if the video hardware does not generate interrupts, indicated by setting the <strong>HwInterrupt</strong> member in the <a href="video_hw_initialization_data" title="typedef struct _VIDEO_HW_INITIALIZATION_DATA {&#10;  ULONG                          HwInitDataSize;&#10;  INTERFACE_TYPE                 AdapterInterfaceType;&#10;  PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;&#10;  PVIDEO_HW_INITIALIZE           HwInitialize;&#10;  PVIDEO_HW_INTERRUPT            HwInterrupt;&#10;  PVIDEO_HW_START_IO             HwStartIO;&#10;  ULONG                          HwDeviceExtensionSize;&#10;  ULONG                          StartingDeviceNumber;&#10;  PVIDEO_HW_RESET_HW             HwResetHw;&#10;  PVIDEO_HW_TIMER                HwTimer;&#10;  PVIDEO_HW_START_DMA            HwStartDma;&#10;  PVIDEO_HW_POWER_SET            HwSetPowerState;&#10;  PVIDEO_HW_POWER_GET            HwGetPowerState;&#10;  PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;&#10;  PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;&#10;  ULONG                          HwChildDeviceExtensionSize;&#10;  PVIDEO_ACCESS_RANGE            HwLegacyResourceList;&#10;  ULONG                          HwLegacyResourceCount;&#10;  PVIDEO_HW_LEGACYRESOURCES      HwGetLegacyResources;&#10;...">VIDEO_HW_INITIALIZATION_DATA</a> structure to <strong>NULL</strong>. Otherwise, it specifies the bus-relative vector used by the video hardware on I/O buses that use interrupt vectors, such as PCI buses. The preset default value for this member is zero.</p>

<p>If a miniport driver's <em>HwVidFindAdapter</em> function finds that the video adapter does not generate interrupts or that it cannot determine a valid interrupt vector/level for the adapter, <em>HwVidFindAdapter</em> should set both <strong>BusInterruptVector</strong> and <strong>BusInterruptLevel</strong> to zero.</p>

<h3 id="interruptmode"><code>InterruptMode</code></h3>

<p>Indicates whether the video hardware uses <strong>Latched</strong> or <strong>LevelSensitive</strong> interrupts. The video port driver initializes this member if it is relevant, but a miniport driver with an ISR should check that it contains the correct value and reset it if necessary.</p>

<h3 id="numemulatoraccessentries"><code>NumEmulatorAccessEntries</code></h3>

<p>This member and all subsequent members through <strong>HardwareStateSize</strong> are irrelevant to miniport drivers that do not declare themselves to be VGA-compatible miniport drivers on x86-based NT-based operating system platforms. For miniport drivers that do not support VGA-compatible SVGA adapters on x86-based machines, this member should be zero. Otherwise, it specifies the number of EMULATOR_ACCESS_RANGE-type elements in the following array.</p>

<h3 id="emulatoraccessentries"><code>EmulatorAccessEntries</code></h3>

<p>Pointer to an array of emulator access ranges set up by the VGA-compatible miniport driver. Each emulator access range must be a proper subset of the miniport driver's <a href="video_access_range" title="typedef struct _VIDEO_ACCESS_RANGE {&#10;  PHYSICAL_ADDRESS RangeStart;&#10;  ULONG            RangeLength;&#10;  UCHAR            RangeInIoSpace;&#10;  UCHAR            RangeVisible;&#10;  UCHAR            RangeShareable;&#10;  UCHAR            RangePassive;&#10;} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;">VIDEO_ACCESS_RANGE</a>-type array. Each element specifies a range of I/O ports to be hooked out by the V86 emulator and, possibly, monitored by a driver-supplied SvgaHwIoPortXxx function whenever an MS-DOS application, running full screen, attempts to write directly to the video adapter registers. Usually, this array describes all I/O port ranges in the corresponding access ranges array. If the miniport driver defines its array of emulator access entries statically in the driver itself, the port driver initializes this pointer to that array. If <em>NumEmulatorAccessEntries</em> is zero, this member is <strong>NULL</strong>.</p>

<h3 id="emulatoraccessentriescontext"><code>EmulatorAccessEntriesContext</code></h3>

<p>Specifies a value passed with each call to an <em>SvgaHwIoPortXxx</em> function described in the <strong>EmulatorAccessEntries</strong> array. Usually, a VGA-compatible miniport driver sets the value of this member to the <strong>HwDeviceExtension</strong> pointer, or to an offset within the device extension, so the miniport driver can maintain state, such as batched application-issued instructions, in its <em>SvgaHwIoPortXxx</em> functions.</p>

<h3 id="vdmphysicalvideomemoryaddress"><code>VdmPhysicalVideoMemoryAddress</code></h3>

<p>Specifies the base (mapped) logical address of a range of video memory to be mapped into a VDM's address space for x86 BIOS INT10 support. For miniport drivers that do not support VGA-compatible adapters on x86-based machines, this member should be <strong>NULL</strong>.</p>

<h3 id="vdmphysicalvideomemorylength"><code>VdmPhysicalVideoMemoryLength</code></h3>

<p>Specifies the size in bytes of the range be mapped into a VDM's address space for x86 BIOS support. For miniport drivers that do not support VGA-compatible adapters on x86-based machines, this member should be zero.</p>

<h3 id="hardwarestatesize"><code>HardwareStateSize</code></h3>

<p>Specifies the minimum size in bytes required to store hardware state information in response to an <a href="ioctl_video_save_hardware_state" title="// CTL_CODE(0x0023, 0x080, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_SAVE_HARDWARE_STATE 0x00230200">IOCTL_VIDEO_SAVE_HARDWARE_STATE</a> request, which must be supported only by VGA-compatible miniport drivers on x86-based machines. The initialized value for this member is zero. A VGA-compatible miniport driver must set this member to the number of bytes it requires to hold saved adapter state.</p>

<h3 id="dmachannel"><code>DmaChannel</code></h3>

<p>Reserved for system use.</p>

<h3 id="dmaport"><code>DmaPort</code></h3>

<p>Reserved for system use.</p>

<h3 id="dmashareable"><code>DmaShareable</code></h3>

<p>Reserved for system use.</p>

<h3 id="interruptshareable"><code>InterruptShareable</code></h3>

<p>If the miniport driver's device interrupts, this member should be set to zero if the interrupt cannot be shared with another device, or set to one if the interrupt can be shared. Otherwise, a miniport driver can ignore this member.</p>

<h3 id="master"><code>Master</code></h3>

<p>Reserved for system use.</p>

<h3 id="dmawidth"><code>DmaWidth</code></h3>

<p>Reserved for system use.</p>

<h3 id="dmaspeed"><code>DmaSpeed</code></h3>

<p>Reserved for system use.</p>

<h3 id="bmapbuffers"><code>bMapBuffers</code></h3>

<p>Reserved for system use.</p>

<h3 id="needphysicaladdresses"><code>NeedPhysicalAddresses</code></h3>

<p>Reserved for system use.</p>

<h3 id="demandmode"><code>DemandMode</code></h3>

<p>Reserved for system use.</p>

<h3 id="maximumtransferlength"><code>MaximumTransferLength</code></h3>

<p>Reserved for system use.</p>

<h3 id="numberofphysicalbreaks"><code>NumberOfPhysicalBreaks</code></h3>

<p>Reserved for system use.</p>

<h3 id="scattergather"><code>ScatterGather</code></h3>

<p>Reserved for system use.</p>

<h3 id="maximumscattergatherchunksize"><code>MaximumScatterGatherChunkSize</code></h3>

<p>Reserved for system use.</p>

<h3 id="videoportgetprocaddress"><code>VideoPortGetProcAddress</code></h3>

<p>Pointer to the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_port_get_proc_address">VideoPortGetProcAddress</a> callback routine. This member is used to find the address of a video port driver function that the video miniport driver can use without linking to it directly. This enables a driver binary to run on an earlier version of Windows. For details, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/using-videoportgetprocaddress">Using VideoPortGetProcAddress</a>.</p>

<h3 id="driverregistrypath"><code>DriverRegistryPath</code></h3>

<p>Pointer to the registry path containing the device's service. The display driver can use this information in any way it deems useful.</p>

<h3 id="systemmemorysize"><code>SystemMemorySize</code></h3>

<p>Indicates to a driver the amount, in bytes, of physical memory in the system.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_hw_find_adapter">HwVidFindAdapter</a></p>

<p><a href="ioctl_video_save_hardware_state" title="// CTL_CODE(0x0023, 0x080, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_VIDEO_SAVE_HARDWARE_STATE 0x00230200">IOCTL_VIDEO_SAVE_HARDWARE_STATE</a></p>

<p><a href="video_access_range" title="typedef struct _VIDEO_ACCESS_RANGE {&#10;  PHYSICAL_ADDRESS RangeStart;&#10;  ULONG            RangeLength;&#10;  UCHAR            RangeInIoSpace;&#10;  UCHAR            RangeVisible;&#10;  UCHAR            RangeShareable;&#10;  UCHAR            RangePassive;&#10;} VIDEO_ACCESS_RANGE, *PVIDEO_ACCESS_RANGE;">VIDEO_ACCESS_RANGE</a></p>

<p><a href="video_hw_initialization_data" title="typedef struct _VIDEO_HW_INITIALIZATION_DATA {&#10;  ULONG                          HwInitDataSize;&#10;  INTERFACE_TYPE                 AdapterInterfaceType;&#10;  PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;&#10;  PVIDEO_HW_INITIALIZE           HwInitialize;&#10;  PVIDEO_HW_INTERRUPT            HwInterrupt;&#10;  PVIDEO_HW_START_IO             HwStartIO;&#10;  ULONG                          HwDeviceExtensionSize;&#10;  ULONG                          StartingDeviceNumber;&#10;  PVIDEO_HW_RESET_HW             HwResetHw;&#10;  PVIDEO_HW_TIMER                HwTimer;&#10;  PVIDEO_HW_START_DMA            HwStartDma;&#10;  PVIDEO_HW_POWER_SET            HwSetPowerState;&#10;  PVIDEO_HW_POWER_GET            HwGetPowerState;&#10;  PVIDEO_HW_GET_CHILD_DESCRIPTOR HwGetVideoChildDescriptor;&#10;  PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;&#10;  ULONG                          HwChildDeviceExtensionSize;&#10;  PVIDEO_ACCESS_RANGE            HwLegacyResourceList;&#10;  ULONG                          HwLegacyResourceCount;&#10;  PVIDEO_HW_LEGACYRESOURCES      HwGetLegacyResources;&#10;...">VIDEO_HW_INITIALIZATION_DATA</a></p>

<p><a href="videoportgetaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetAccessRanges(&#10;  PVOID                   HwDeviceExtension,&#10;  ULONG                   NumRequestedResources,&#10;  PIO_RESOURCE_DESCRIPTOR RequestedResources,&#10;  ULONG                   NumAccessRanges,&#10;  PVIDEO_ACCESS_RANGE     AccessRanges,&#10;  PVOID                   VendorId,&#10;  PVOID                   DeviceId,&#10;  PULONG                  Slot&#10;);">VideoPortGetAccessRanges</a></p>

<p><a href="videoportgetdevicebase" title="VIDEOPORT_DEPRECATED VIDEOPORT_API PVOID VideoPortGetDeviceBase(&#10;  PVOID            HwDeviceExtension,&#10;  PHYSICAL_ADDRESS IoAddress,&#10;  ULONG            NumberOfUchars,&#10;  UCHAR            InIoSpace&#10;);">VideoPortGetDeviceBase</a></p>

<p><a href="videoportgetdevicedata" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortGetDeviceData(&#10;  PVOID                          HwDeviceExtension,&#10;  VIDEO_DEVICE_DATA_TYPE         DeviceDataType,&#10;  PMINIPORT_QUERY_DEVICE_ROUTINE CallbackRoutine,&#10;  PVOID                          Context&#10;);">VideoPortGetDeviceData</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/nc-video-pvideo_port_get_proc_address">VideoPortGetProcAddress</a></p>

<p><a href="videoportverifyaccessranges" title="VIDEOPORT_DEPRECATED VIDEOPORT_API VP_STATUS VideoPortVerifyAccessRanges(&#10;                 PVOID               HwDeviceExtension,&#10;                 ULONG               NumAccessRanges,&#10;  [in, optional] PVIDEO_ACCESS_RANGE AccessRanges&#10;);">VideoPortVerifyAccessRanges</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/video/ns-video-_video_port_config_info">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/video/ns-video-_video_port_config_info.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
