<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="TAPE_PROCESS_COMMAND_ROUTINE - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>TAPE_PROCESS_COMMAND_ROUTINE - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            TAPE_PROCESS_COMMAND_ROUTINE - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// minitape.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">TAPE_PROCESS_COMMAND_ROUTINE TapeProcessCommandRoutine;

<a href="tape_status" title="typedef enum _TAPE_STATUS {&#10;  TAPE_STATUS_SEND_SRB_AND_CALLBACK,&#10;  TAPE_STATUS_CALLBACK,&#10;  TAPE_STATUS_CHECK_TEST_UNIT_READY,&#10;  TAPE_STATUS_SUCCESS,&#10;  TAPE_STATUS_INSUFFICIENT_RESOURCES,&#10;  TAPE_STATUS_NOT_IMPLEMENTED,&#10;  TAPE_STATUS_INVALID_DEVICE_REQUEST,&#10;  TAPE_STATUS_INVALID_PARAMETER,&#10;  TAPE_STATUS_MEDIA_CHANGED,&#10;  TAPE_STATUS_BUS_RESET,&#10;  TAPE_STATUS_SETMARK_DETECTED,&#10;  TAPE_STATUS_FILEMARK_DETECTED,&#10;  TAPE_STATUS_BEGINNING_OF_MEDIA,&#10;  TAPE_STATUS_END_OF_MEDIA,&#10;  TAPE_STATUS_BUFFER_OVERFLOW,&#10;  TAPE_STATUS_NO_DATA_DETECTED,&#10;  TAPE_STATUS_EOM_OVERFLOW,&#10;  TAPE_STATUS_NO_MEDIA,&#10;  TAPE_STATUS_IO_DEVICE_ERROR,&#10;...">TAPE_STATUS</a> TapeProcessCommandRoutine(
  [in, out]      PVOID MinitapeExtension,
  [in, out]      PVOID CommandExtension,
  [in, out]      PVOID CommandParameters,
  [in, out]      <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">PSCSI_REQUEST_BLOCK</a> Srb,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> CallNumber,
  [in, optional] <a href="tape_status" title="typedef enum _TAPE_STATUS {&#10;  TAPE_STATUS_SEND_SRB_AND_CALLBACK,&#10;  TAPE_STATUS_CALLBACK,&#10;  TAPE_STATUS_CHECK_TEST_UNIT_READY,&#10;  TAPE_STATUS_SUCCESS,&#10;  TAPE_STATUS_INSUFFICIENT_RESOURCES,&#10;  TAPE_STATUS_NOT_IMPLEMENTED,&#10;  TAPE_STATUS_INVALID_DEVICE_REQUEST,&#10;  TAPE_STATUS_INVALID_PARAMETER,&#10;  TAPE_STATUS_MEDIA_CHANGED,&#10;  TAPE_STATUS_BUS_RESET,&#10;  TAPE_STATUS_SETMARK_DETECTED,&#10;  TAPE_STATUS_FILEMARK_DETECTED,&#10;  TAPE_STATUS_BEGINNING_OF_MEDIA,&#10;  TAPE_STATUS_END_OF_MEDIA,&#10;  TAPE_STATUS_BUFFER_OVERFLOW,&#10;  TAPE_STATUS_NO_DATA_DETECTED,&#10;  TAPE_STATUS_EOM_OVERFLOW,&#10;  TAPE_STATUS_NO_MEDIA,&#10;  TAPE_STATUS_IO_DEVICE_ERROR,&#10;...">TAPE_STATUS</a> StatusOfLastCommand,
  [in, out]      PULONG RetryFlags
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/nc-minitape-tape_process_command_routine">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/tape_process_command_routine.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-minitape-tape_process_command_routine)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="tape_process_command_routine-callback-function">TAPE_PROCESS_COMMAND_ROUTINE callback function</h1>

<h2 id="description">Description</h2>

<p><em>TAPE_PROCESS_COMMAND_ROUTINE</em> handles the device-specific aspects of an IOCTL request.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="minitapeextension-in-out"><code>MinitapeExtension</code> [in, out]</h3>

<p>Pointer to the driver-specific minitape extension. This is <strong>NULL</strong> if the miniclass driver did not request a minitape extension when it initialized.</p>

<h3 id="commandextension-in-out"><code>CommandExtension</code> [in, out]</h3>

<p>Pointer to the command extension. This is <strong>NULL</strong> if the miniclass driver did not request a command extension when it initialized.</p>

<h3 id="commandparameters-in-out"><code>CommandParameters</code> [in, out]</h3>

<p>Pointer to a buffer allocated by the caller that contains a <a href="tape_create_partition" title="typedef struct _TAPE_CREATE_PARTITION {&#10;  ULONG Method;&#10;  ULONG Count;&#10;  ULONG Size;&#10;} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;">TAPE_CREATE_PARTITION</a> structure.</p>

<h3 id="srb-in-out"><code>Srb</code> [in, out]</h3>

<p>Pointer to an SRB allocated and partially filled in by the tape class driver. <em>TAPE_PROCESS_COMMAND_ROUTINE</em> must fill in the CDB in the SRB.</p>

<ul>
<li><strong>Cdb</strong> - Pointer to the SCSI CDB for the command. Clear the CDB with <strong><a href="tapeclasszeromemory" title="SCSIPORT_API VOID TapeClassZeroMemory(&#10;  [in, out] PVOID Buffer,&#10;  [in]      ULONG BufferSize&#10;);">TapeClassZeroMemory</a></strong> before filling it in.</li>
<li><strong>CdbLength</strong> - Specifies the number of bytes in the CDB.</li>
</ul>

<p><em>TAPE_PROCESS_COMMAND_ROUTINE</em> might also fill in the following members in the SRB:</p>

<ul>
<li><strong>DataBuffer</strong> - Pointer to the data buffer to be transferred. Use <a href="tapeclassallocatesrbbuffer" title="SCSIPORT_API BOOLEAN TapeClassAllocateSrbBuffer(&#10;  [in, out] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]      ULONG               SrbBufferSize&#10;);">TapeClassAllocateSrbBuffer</a> to allocate a <strong>DataBuffer</strong> of length greater than or equal to <strong>DataTransferLength</strong>.</li>
<li><strong>DataTransferLength</strong> - Specifies the number of bytes to be transferred in the SRB. This member is set by <strong><a href="tapeclassallocatesrbbuffer" title="SCSIPORT_API BOOLEAN TapeClassAllocateSrbBuffer(&#10;  [in, out] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]      ULONG               SrbBufferSize&#10;);">TapeClassAllocateSrbBuffer</a></strong>.</li>
<li><strong>TimeOutValue</strong> - Specifies a time-out value for this command, overriding the default time-out value from the tape class driver's device extension.</li>
<li><strong>SrbFlags</strong> - Specifies a flag for this command. The tape miniclass driver must set SRB_FLAGS_DATA_OUT if the SRB is sending data to the tape drive. This member can be zero if the SRB is requesting data from the tape drive or if no data is being transferred by the command.</li>
</ul>

<h3 id="callnumber-in"><code>CallNumber</code> [in]</h3>

<p>Specifies the number of times <em>TAPE_PROCESS_COMMAND_ROUTINE</em> has been called to process a given tape command. <em>CallNumber</em> is zero the first time this routine is called and is incremented for each subsequent call until the miniclass driver returns a <a href="tape_status" title="typedef enum _TAPE_STATUS {&#10;  TAPE_STATUS_SEND_SRB_AND_CALLBACK,&#10;  TAPE_STATUS_CALLBACK,&#10;  TAPE_STATUS_CHECK_TEST_UNIT_READY,&#10;  TAPE_STATUS_SUCCESS,&#10;  TAPE_STATUS_INSUFFICIENT_RESOURCES,&#10;  TAPE_STATUS_NOT_IMPLEMENTED,&#10;  TAPE_STATUS_INVALID_DEVICE_REQUEST,&#10;  TAPE_STATUS_INVALID_PARAMETER,&#10;  TAPE_STATUS_MEDIA_CHANGED,&#10;  TAPE_STATUS_BUS_RESET,&#10;  TAPE_STATUS_SETMARK_DETECTED,&#10;  TAPE_STATUS_FILEMARK_DETECTED,&#10;  TAPE_STATUS_BEGINNING_OF_MEDIA,&#10;  TAPE_STATUS_END_OF_MEDIA,&#10;  TAPE_STATUS_BUFFER_OVERFLOW,&#10;  TAPE_STATUS_NO_DATA_DETECTED,&#10;  TAPE_STATUS_EOM_OVERFLOW,&#10;  TAPE_STATUS_NO_MEDIA,&#10;  TAPE_STATUS_IO_DEVICE_ERROR,&#10;...">TAPE_STATUS</a> value that indicates the command is complete.</p>

<h3 id="statusoflastcommand-in-optional"><code>StatusOfLastCommand</code> [in, optional]</h3>

<p>Specifies the status of the last command. In the first call to <em>TAPE_PROCESS_COMMAND_ROUTINE</em> to process a given request, <em>StatusOfLastCommand</em> is TAPE_STATUS_SUCCESS. In subsequent calls, <em>StatusOfLastCommand</em> is either TAPE_STATUS_SUCCESS or an error status if an error occurred and the tape miniclass driver set RETURN_ERRORS in <em>RetryFlags</em> in the previous call.</p>

<h3 id="retryflags-in-out"><code>RetryFlags</code> [in, out]</h3>

<p>Pointer to a variable that specifies what action the tape class driver should take when a tape device reports an error.</p>

<p>The low-order word specifies the number of retries to perform in the event of a SCSI command failure. The default is zero (no retries).</p>

<p>The high-order word contains flags that specify how the tape class driver should return control if an error occurs:</p>

<ul>
<li>If RETURN_ERRORS and IGNORE_ERRORS are clear (the default) the tape class driver returns a failure status to the original requester.</li>
<li>If the miniclass driver sets RETURN_ERRORS, the tape class driver calls <em>TAPE_PROCESS_COMMAND_ROUTINE</em> with <em>StatusOfLastCommand</em> set to a failure status.</li>
<li>If the miniclass driver sets IGNORE_ERRORS, the tape class driver converts a failure status to success and calls <em>TAPE_PROCESS_COMMAND_ROUTINE</em> with <em>StatusOfLastCommand</em> set to success.</li>
</ul>

<h2 id="return-value">Return value</h2>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>TAPE_STATUS_SEND_SRB_AND_CALLBACK</strong></td>
  <td>Indicates to the tape class driver that the SRB has been filled in and is ready to be sent to the target device. By default, the tape class driver calls <em>TAPE_PROCESS_COMMAND_ROUTINE</em> again only if the SRB succeeds. A miniclass driver can modify the default behavior by setting <em>RetryFlags</em> before returning from <em>TAPE_PROCESS_COMMAND_ROUTINE</em>.</td>
</tr>
<tr>
  <td><strong>TAPE_STATUS_CALLBACK</strong></td>
  <td>Directs the tape class driver to increment <em>CallNumber</em> and call <em>TAPE_PROCESS_COMMAND_ROUTINE</em> again without sending an SRB to the tape device.</td>
</tr>
<tr>
  <td><strong>TAPE_STATUS_CHECK_TEST_UNIT_READY</strong></td>
  <td>Directs the tape class driver to fill in an SRB for the TEST UNIT READY command and send the SRB to the device.</td>
</tr>
<tr>
  <td><strong>TAPE_STATUS_*XXX</strong>*</td>
  <td>Any other return code indicates to the tape class driver that the command is complete and indicates success, failure, or warning. Possible completion return values for this routine include, but are not limited to:<br><br>TAPE_STATUS_SUCCESS<br><br>TAPE_STATUS_INSUFFICIENT_RESOURCES<br><br>TAPE_STATUS_INVALID_DEVICE_REQUEST<br><br>TAPE_STATUS_INVALID_PARAMETER<br><br>TAPE_STATUS_IO_DEVICE_ERROR<br><br>TAPE_STATUS_MEDIA_WRITE_PROTECTED<br><br>TAPE_STATUS_NOT_IMPLEMENTED</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>The following functions can be assigned to this callback placeholder:</p>

<h3 id="createpartition">CreatePartition</h3>

<p><em>CreatePartition</em> handles the device-specific aspects of an <a href="ioctl_tape_create_partition" title="// CTL_CODE(0x001f, 0x00a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)&#10;#define IOCTL_TAPE_CREATE_PARTITION 0x001FC028">IOCTL_TAPE_CREATE_PARTITION</a> request. This routine is required. <em>CreatePartition</em> creates a partition on a tape by filling in the CDB in an SRB passed by the tape class driver. Creating a partition typically requires a series of SRBs to complete the operation. After <em>CreatePartition</em> fills in a given SRB and returns, the tape class driver sends the SRB to the target device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>TapeMiniCreatePartition</em> again.</p>

<p><em>CreatePartition</em> must fill in the following members in the SRB before returning to the tape class driver:</p>

<p>If the tape miniclass driver stores partition information in the minitape extension, <em>CreatePartition</em> updates the extension before returning to the tape class driver with TAPE_STATUS_SUCCESS.</p>

<h3 id="erase">Erase</h3>

<p><em>Erase</em> handles the device-specific aspects of an <a href="ioctl_tape_erase" title="// CTL_CODE(0x001f, 0x000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)&#10;#define IOCTL_TAPE_ERASE 0x001FC000">IOCTL_TAPE_ERASE</a> request. This routine is required. <em>Erase</em> erases a tape by filling in the CDB in an SRB passed by the tape class driver. Erasing a tape typically requires one SRB to complete the operation. After <em>Erase</em> fills in the SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>Erase</em> again. <em>Erase</em> then returns TAPE_STATUS_SUCCESS.</p>

<h3 id="getdriveparameters">GetDriveParameters</h3>

<p><em>GetDriveParameters</em> handles the device-specific aspects of an <a href="ioctl_tape_get_drive_params" title="// CTL_CODE(0x001f, 0x005, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_GET_DRIVE_PARAMS 0x001F4014">IOCTL_TAPE_GET_DRIVE_PARAMS</a> request. This routine is required. <em>GetDriveParameters</em> gets tape drive parameters by filling in the CDB in an SRB passed by the tape class driver. Getting drive parameters typically requires a series of SRBs to complete the operation. After <em>GetDriveParameters</em> fills in a given SRB and returns, the tape class driver sends the SRB to the target device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>GetDriveParameters</em> again.</p>

<h3 id="getmediaparameters">GetMediaParameters</h3>

<p><em>GetMediaParameters</em> handles the device-specific aspects of an <a href="ioctl_tape_get_media_params" title="// CTL_CODE(0x001f, 0x007, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_GET_MEDIA_PARAMS 0x001F401C">IOCTL_TAPE_GET_MEDIA_PARAMS</a> request. This routine is required. <em>GetMediaParameters</em> gets tape media parameters by filling in the CDB in an SRB passed by the tape class driver. Getting media parameters typically requires more than one SRB to complete the operation, starting with a test unit ready which the miniclass driver requests by returning TAPE_STATUS_CHECK_TEST_UNIT_READY the first time the tape class driver calls the routine.</p>

<p>After <em>GetMediaParameters</em> fills in a given SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls GetMediaParameters again.</p>

<h3 id="getmediatypes">GetMediaTypes</h3>

<p><em>GetMediaTypes</em> handles the device-specific aspects of an <a href="ioctl_storage_get_media_types_ex" title="// CTL_CODE(0x002d, 0x301, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX 0x002D0C04">IOCTL_STORAGE_GET_MEDIA_TYPES_EX</a> request. This routine is required. <em>GetMediaTypes</em> gets information about the media types supported by a tape device by filling in the CDB in an SRB passed by the tape class driver. Getting media types typically requires more than one SRB to complete the operation, starting with a test unit ready which the miniclass driver requests by returning TAPE_STATUS_CHECK_TEST_UNIT_READY the first time the tape class driver calls the routine.</p>

<h3 id="getposition">GetPosition</h3>

<p><em>GetPosition</em> handles the device-specific aspects of an <a href="ioctl_tape_get_position" title="// CTL_CODE(0x001f, 0x003, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_GET_POSITION 0x001F400C">IOCTL_TAPE_GET_POSITION</a> request. This routine is required. <em>GetPosition</em> reads the position of a tape by filling in the CDB in an SRB passed by the tape class driver. Reading tape position typically requires more than one SRB to complete the operation, often starting with a test unit ready which the miniclass driver requests by returning TAPE_STATUS_CHECK_TEST_UNIT_READY the first time the tape class driver calls the routine.</p>

<h3 id="getstatus">GetStatus</h3>

<p><em>GetStatus</em> handles the device-specific aspects of an <a href="ioctl_tape_get_status" title="// CTL_CODE(0x001f, 0x009, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_GET_STATUS 0x001F4024">IOCTL_TAPE_GET_STATUS</a> request. This routine is required. <em>GetStatus</em> reads the status of a tape device, typically by directing the tape class driver to issue a test unit ready command.</p>

<p>If a device indicates whether a drive needs cleaning in sense data (as opposed to reporting the need for cleaning as an error, which a miniclass driver would handle in its <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/nc-minitape-tape_error_routine">TapeMiniTapeError</a> routine), <em>GetStatus</em> fills in the CDB in the SRB passed by the tape class driver to obtain the sense data and, if necessary, returns TAPE_STATUS_REQUIRES_CLEANING.</p>

<h3 id="prepare">Prepare</h3>

<p><em>Prepare</em> handles the device-specific aspects of an <a href="ioctl_tape_prepare" title="// CTL_CODE(0x001f, 0x001, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_PREPARE 0x001F4004">IOCTL_TAPE_PREPARE</a> request. This routine is required. <em>Prepare</em> prepares a tape by filling in the CDB in an SRB passed by the tape class driver. If the device supports the requested operation, preparing a tape typically requires one SRB. After <em>Prepare</em> fills in the SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>Prepare</em> again.</p>

<h3 id="setdriveparameters">SetDriveParameters</h3>

<p><em>SetDriveParameters</em> handles the device-specific aspects of an <a href="ioctl_tape_set_drive_params" title="// CTL_CODE(0x001f, 0x006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)&#10;#define IOCTL_TAPE_SET_DRIVE_PARAMS 0x001FC018">IOCTL_TAPE_SET_DRIVE_PARAMS</a> request. This routine is required. <em>SetDriveParameters</em> sets parameters for a tape device by filling in the CDB in an SRB passed by the tape class driver. Setting parameters typically involves a series of SRBs to complete the operation. After <em>SetDriveParameters</em> fills in a given SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>SetDriveParameters</em> again.</p>

<h3 id="setmediaparameters">SetMediaParameters</h3>

<p><em>SetMediaParameters</em> handles the device-specific aspects of an <a href="ioctl_tape_set_media_params" title="// CTL_CODE(0x001f, 0x008, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_SET_MEDIA_PARAMS 0x001F4020">IOCTL_TAPE_SET_MEDIA_PARAMS</a> request. This routine is required. <em>SetMediaParameters</em> sets the block size of a tape by filling in the CDB in an SRB passed by the tape class driver. Setting the block size typically requires more than one SRB to complete the operation, starting with a test unit ready which the miniclass driver requests by returning TAPE_STATUS_CHECK_TEST_UNIT_READY the first time the tape class driver calls the routine.</p>

<p>After <em>SetMediaParameters</em> fills in a given SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>SetMediaParameters</em> again.</p>

<h3 id="setposition">SetPosition</h3>

<p><em>SetPosition</em> handles the device-specific aspects of an <a href="ioctl_tape_set_position" title="// CTL_CODE(0x001f, 0x004, METHOD_BUFFERED, FILE_READ_ACCESS)&#10;#define IOCTL_TAPE_SET_POSITION 0x001F4010">IOCTL_TAPE_SET_POSITION</a> request. This routine is required. <em>SetPosition</em> sets the position of a tape by filling in the CDB in an SRB passed by the tape class driver. Setting the position typically requires one SRB. After <em>SetPosition</em> fills in the SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>SetPosition</em> again. <em>SetPosition</em> then returns TAPE_STATUS_SUCCESS.</p>

<h3 id="writemarks">WriteMarks</h3>

<p><em>WriteMarks</em> handles the device-specific aspects of an <a href="ioctl_tape_write_marks" title="// CTL_CODE(0x001f, 0x002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)&#10;#define IOCTL_TAPE_WRITE_MARKS 0x001FC008">IOCTL_TAPE_WRITE_MARKS</a> request. This routine is required. <em>WriteMarks</em> writes marks to a tape by filling in the CDB in an SRB passed by the tape class driver. Writing marks typically takes one SRB to complete the operation. After <em>WriteMarks</em> fills in the SRB and returns, the tape class driver sends the SRB to the device and, depending on the result of the SRB and the value of <em>RetryFlags</em>, calls <em>WriteMarks</em> again. <em>WriteMarks</em> then returns TAPE_STATUS_SUCCESS.</p>

<h3 id="preprocessreadwrite">PreProcessReadWrite</h3>

<p><em>PreProcessReadWrite</em> is an optional, special-purpose routine that performs any device-specific operations required before read and write operations. Most tape miniclass drivers do not need this routine. The activities of the <em>PreProcessReadWrite</em> routine are device specific. The routine can use the information passed to it by the class driver to implement special preprocessing for reads and writes. If a drive has limited capabilities, the driver may need this routine to maintain coherent state, for example.</p>

<p>If a tape miniclass driver sets a non-<strong>NULL</strong> entry point for this routine in the <a href="tape_init_data_ex" title="typedef struct _TAPE_INIT_DATA_EX {&#10;  ULONG                        InitDataSize;&#10;  TAPE_VERIFY_INQUIRY_ROUTINE  VerifyInquiry;&#10;  BOOLEAN                      QueryModeCapabilitiesPage;&#10;  ULONG                        MinitapeExtensionSize;&#10;  TAPE_EXTENSION_INIT_ROUTINE  ExtensionInit;&#10;  ULONG                        DefaultTimeOutValue;&#10;  TAPE_ERROR_ROUTINE           TapeError;&#10;  ULONG                        CommandExtensionSize;&#10;  TAPE_PROCESS_COMMAND_ROUTINE CreatePartition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE Erase;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetDriveParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetMediaParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetPosition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetStatus;&#10;  TAPE_PROCESS_COMMAND_ROUTINE Prepare;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetDriveParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetMediaParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetPosition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE WriteMarks;&#10;...">TAPE_INIT_DATA_EX</a> structure it passes to <a href="tapeclassinitialize" title="SCSIPORT_API ULONG TapeClassInitialize(&#10;  [in] PVOID              Argument1,&#10;  [in] PVOID              Argument2,&#10;  [in] PTAPE_INIT_DATA_EX TapeInitData&#10;);">TapeClassInitialize</a> from its <strong><a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a></strong> routine, the tape class driver calls it before each read and write operation on the tape device. The class driver does not expect any information back from this routine.</p>

<h3 id="wmioperations">WMIOperations</h3>

<p><em>WMIOperations</em> is the common entry point for all WMI calls from the tape class driver. A minidriver that supports WMI should set the function pointer member, <strong>WMIOperations</strong>, in the structure <a href="tape_init_data_ex" title="typedef struct _TAPE_INIT_DATA_EX {&#10;  ULONG                        InitDataSize;&#10;  TAPE_VERIFY_INQUIRY_ROUTINE  VerifyInquiry;&#10;  BOOLEAN                      QueryModeCapabilitiesPage;&#10;  ULONG                        MinitapeExtensionSize;&#10;  TAPE_EXTENSION_INIT_ROUTINE  ExtensionInit;&#10;  ULONG                        DefaultTimeOutValue;&#10;  TAPE_ERROR_ROUTINE           TapeError;&#10;  ULONG                        CommandExtensionSize;&#10;  TAPE_PROCESS_COMMAND_ROUTINE CreatePartition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE Erase;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetDriveParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetMediaParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetPosition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE GetStatus;&#10;  TAPE_PROCESS_COMMAND_ROUTINE Prepare;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetDriveParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetMediaParameters;&#10;  TAPE_PROCESS_COMMAND_ROUTINE SetPosition;&#10;  TAPE_PROCESS_COMMAND_ROUTINE WriteMarks;&#10;...">TAPE_INIT_DATA_EX</a> to point to the minidriver's <em>TAPE_PROCESS_COMMAND_ROUTINE</em> routine. The minidriver should do this in its <a href="driverentry" title="NTSTATUS DriverEntry(&#10;  [in] PDRIVER_OBJECT  DriverObject,&#10;  [in] PUNICODE_STRING RegistryPath&#10;);">DriverEntry</a> routine before calling <a href="tapeclassinitialize" title="SCSIPORT_API ULONG TapeClassInitialize(&#10;  [in] PVOID              Argument1,&#10;  [in] PVOID              Argument2,&#10;  [in] PTAPE_INIT_DATA_EX TapeInitData&#10;);">TapeClassInitialize</a>. If a minidriver does not support WMI operations, it should set TapeWMIOperations field to <strong>NULL</strong>.</p>

<p>The tape class driver assigns values to the members of <a href="tape_wmi_operations" title="typedef struct _TAPE_WMI_OPERATIONS {&#10;  ULONG Method;&#10;  ULONG DataBufferSize;&#10;  PVOID DataBuffer;&#10;} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;">TAPE_WMI_OPERATIONS</a> structure, and passes this structure to minidriver's <em>WMIOperations</em> routine in the <em>CommandParameters</em> parameter. As with other minidriver routines, <em>WMIOperations</em> fills, creates, and initializes the SCSI request blocks (SRB) and the command descriptor blocks (CDB) required to implement the indicated WMI method, and returns control to tape class driver. The tape class driver then calls the port driver to execute the request.</p>

<p>The minidriver returns the WMI data in the buffer pointed to by the <strong>DataBuffer</strong> member of the <a href="tape_wmi_operations" title="typedef struct _TAPE_WMI_OPERATIONS {&#10;  ULONG Method;&#10;  ULONG DataBufferSize;&#10;  PVOID DataBuffer;&#10;} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;">TAPE_WMI_OPERATIONS</a> structure.</p>

<h2 id="see-also">See also</h2>

<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>

<p><a href="tape_status" title="typedef enum _TAPE_STATUS {&#10;  TAPE_STATUS_SEND_SRB_AND_CALLBACK,&#10;  TAPE_STATUS_CALLBACK,&#10;  TAPE_STATUS_CHECK_TEST_UNIT_READY,&#10;  TAPE_STATUS_SUCCESS,&#10;  TAPE_STATUS_INSUFFICIENT_RESOURCES,&#10;  TAPE_STATUS_NOT_IMPLEMENTED,&#10;  TAPE_STATUS_INVALID_DEVICE_REQUEST,&#10;  TAPE_STATUS_INVALID_PARAMETER,&#10;  TAPE_STATUS_MEDIA_CHANGED,&#10;  TAPE_STATUS_BUS_RESET,&#10;  TAPE_STATUS_SETMARK_DETECTED,&#10;  TAPE_STATUS_FILEMARK_DETECTED,&#10;  TAPE_STATUS_BEGINNING_OF_MEDIA,&#10;  TAPE_STATUS_END_OF_MEDIA,&#10;  TAPE_STATUS_BUFFER_OVERFLOW,&#10;  TAPE_STATUS_NO_DATA_DETECTED,&#10;  TAPE_STATUS_EOM_OVERFLOW,&#10;  TAPE_STATUS_NO_MEDIA,&#10;  TAPE_STATUS_IO_DEVICE_ERROR,&#10;...">TAPE_STATUS</a></p>

<p><a href="tapeclassallocatesrbbuffer" title="SCSIPORT_API BOOLEAN TapeClassAllocateSrbBuffer(&#10;  [in, out] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]      ULONG               SrbBufferSize&#10;);">TapeClassAllocateSrbBuffer</a></p>

<p><a href="tapeclasszeromemory" title="SCSIPORT_API VOID TapeClassZeroMemory(&#10;  [in, out] PVOID Buffer,&#10;  [in]      ULONG BufferSize&#10;);">TapeClassZeroMemory</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/nc-minitape-tape_process_command_routine">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/minitape/nc-minitape-tape_process_command_routine.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
