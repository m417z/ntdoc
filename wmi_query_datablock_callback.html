<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="WMI_QUERY_DATABLOCK_CALLBACK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>WMI_QUERY_DATABLOCK_CALLBACK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            WMI_QUERY_DATABLOCK_CALLBACK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// wmilib.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">WMI_QUERY_DATABLOCK_CALLBACK WmiQueryDatablockCallback;

<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> WmiQueryDatablockCallback(
  [in]      <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">PDEVICE_OBJECT</a> DeviceObject,
  [in]      PIRP Irp,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> GuidIndex,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> InstanceIndex,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> InstanceCount,
  [in, out] PULONG InstanceLengthArray,
  [in]      <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> BufferAvail,
  [out]     PUCHAR Buffer
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wmilib/nc-wmilib-wmi_query_datablock_callback">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/wmi_query_datablock_callback.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-wmilib-wmi_query_datablock_callback)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="wmi_query_datablock_callback-callback-function">WMI_QUERY_DATABLOCK_CALLBACK callback function</h1>

<h2 id="description">Description</h2>

<p>The <em>DpWmiQueryDataBlock</em> routine returns either a single instance or all instances of a data block. This routine is required.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="deviceobject-in"><code>DeviceObject</code> [in]</h3>

<p>Pointer to the driver's WDM <a href="device_object" title="typedef struct _DEVICE_OBJECT {&#10;  CSHORT                   Type;&#10;  USHORT                   Size;&#10;  LONG                     ReferenceCount;&#10;  struct _DRIVER_OBJECT    *DriverObject;&#10;  struct _DEVICE_OBJECT    *NextDevice;&#10;  struct _DEVICE_OBJECT    *AttachedDevice;&#10;  struct _IRP              *CurrentIrp;&#10;  PIO_TIMER                Timer;&#10;  ULONG                    Flags;&#10;  ULONG                    Characteristics;&#10;  __volatile PVPB          Vpb;&#10;  PVOID                    DeviceExtension;&#10;  DEVICE_TYPE              DeviceType;&#10;  CCHAR                    StackSize;&#10;  union {&#10;    LIST_ENTRY         ListEntry;&#10;    WAIT_CONTEXT_BLOCK Wcb;&#10;  } Queue;&#10;  ULONG                    AlignmentRequirement;&#10;...">DEVICE_OBJECT</a> structure.</p>

<h3 id="irp-in"><code>Irp</code> [in]</h3>

<p>Pointer to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a>.</p>

<h3 id="guidindex-in"><code>GuidIndex</code> [in]</h3>

<p>Specifies the data block by supplying a zero-based index into the list of GUIDs that the driver provided in the <a href="wmilib_context" title="typedef struct _WMILIB_CONTEXT {&#10;  ULONG                 GuidCount;&#10;  PWMIGUIDREGINFO       GuidList;&#10;  PWMI_QUERY_REGINFO    QueryWmiRegInfo;&#10;  PWMI_QUERY_DATABLOCK  QueryWmiDataBlock;&#10;  PWMI_SET_DATABLOCK    SetWmiDataBlock;&#10;  PWMI_SET_DATAITEM     SetWmiDataItem;&#10;  PWMI_EXECUTE_METHOD   ExecuteWmiMethod;&#10;  PWMI_FUNCTION_CONTROL WmiFunctionControl;&#10;} WMILIB_CONTEXT, *PWMILIB_CONTEXT;">WMILIB_CONTEXT</a> structure it passed to <a href="wmisystemcontrol" title="NTSTATUS WmiSystemControl(&#10;  [in]      PWMILIB_CONTEXT         WmiLibInfo,&#10;  [in]      PDEVICE_OBJECT          DeviceObject,&#10;  [in, out] PIRP                    Irp,&#10;  [out]     PSYSCTL_IRP_DISPOSITION IrpDisposition&#10;);">WmiSystemControl</a>.</p>

<h3 id="instanceindex-in"><code>InstanceIndex</code> [in]</h3>

<p>If <em>DpWmiQueryDataBlock</em> is called in response to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-single-instance">IRP_MN_QUERY_SINGLE_INSTANCE</a> request, <em>InstanceIndex</em> specifies a zero-based index that indicates the instance of the specified data block to be queried. If <em>DpWmiQueryDataBlock</em> is called in response to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-all-data">IRP_MN_QUERY_ALL_DATA</a> request, <em>InstanceIndex</em> is zero.</p>

<h3 id="instancecount-in"><code>InstanceCount</code> [in]</h3>

<p>If <em>DpWmiQueryDataBlock</em> is called in response to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-single-instance">IRP_MN_QUERY_SINGLE_INSTANCE</a> request, <em>InstanceCount</em> is 1. If <em>DpWmiQueryDataBlock</em> is called in response to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-all-data">IRP_MN_QUERY_ALL_DATA</a> request, <em>InstanceCount</em> is the number of instances to be returned.</p>

<h3 id="instancelengtharray-in-out"><code>InstanceLengthArray</code> [in, out]</h3>

<p>Pointer to a caller-supplied, <em>InstanceCount</em>-sized array of <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> elements. The driver fills in each array element to indicate the length of each instance that was returned. If <em>BufferAvail</em> is zero, <em>InstanceLengthArray</em> is <strong>NULL</strong>.</p>

<h3 id="bufferavail-in"><code>BufferAvail</code> [in]</h3>

<p>Specifies the maximum number of bytes that are available to receive data in the buffer at <em>Buffer</em>. If this value is zero, the caller is requesting that the driver specify the required buffer size in its call to <a href="wmicompleterequest" title="NTSTATUS WmiCompleteRequest(&#10;  [in]      PDEVICE_OBJECT DeviceObject,&#10;  [in, out] PIRP           Irp,&#10;  [in]      NTSTATUS       Status,&#10;  [in]      ULONG          BufferUsed,&#10;  [in]      CCHAR          PriorityBoost&#10;);">WmiCompleteRequest</a>. See the Remarks section for more information.</p>

<h3 id="buffer-out"><code>Buffer</code> [out]</h3>

<p>Pointer to the buffer to receive instance data. If the buffer is large enough to receive all of the data, the driver writes the instance data to the buffer with each instance aligned on an 8-byte boundary. If the buffer is too small to receive all of the data, the driver calls <a href="wmicompleterequest" title="NTSTATUS WmiCompleteRequest(&#10;  [in]      PDEVICE_OBJECT DeviceObject,&#10;  [in, out] PIRP           Irp,&#10;  [in]      NTSTATUS       Status,&#10;  [in]      ULONG          BufferUsed,&#10;  [in]      CCHAR          PriorityBoost&#10;);">WmiCompleteRequest</a> with <em>BufferUsed</em> set to the size required.</p>

<h2 id="return-value">Return value</h2>

<p><em>DpWmiQueryDataBlock</em> returns <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or an error status such as the following:</p>

<p>If the driver cannot complete the request immediately, it can return STATUS_PENDING.</p>

<h2 id="remarks">Remarks</h2>

<p>WMI calls a driver's <em>DpWmiQueryDataBlock</em> routine after the driver calls <a href="wmisystemcontrol" title="NTSTATUS WmiSystemControl(&#10;  [in]      PWMILIB_CONTEXT         WmiLibInfo,&#10;  [in]      PDEVICE_OBJECT          DeviceObject,&#10;  [in, out] PIRP                    Irp,&#10;  [out]     PSYSCTL_IRP_DISPOSITION IrpDisposition&#10;);">WmiSystemControl</a> in response to an <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-single-instance">IRP_MN_QUERY_SINGLE_INSTANCE</a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-all-data">IRP_MN_QUERY_ALL_DATA</a> request. The driver must place the address of its <em>DpWmiQueryDataBlock</em> routine in the <a href="wmilib_context" title="typedef struct _WMILIB_CONTEXT {&#10;  ULONG                 GuidCount;&#10;  PWMIGUIDREGINFO       GuidList;&#10;  PWMI_QUERY_REGINFO    QueryWmiRegInfo;&#10;  PWMI_QUERY_DATABLOCK  QueryWmiDataBlock;&#10;  PWMI_SET_DATABLOCK    SetWmiDataBlock;&#10;  PWMI_SET_DATAITEM     SetWmiDataItem;&#10;  PWMI_EXECUTE_METHOD   ExecuteWmiMethod;&#10;  PWMI_FUNCTION_CONTROL WmiFunctionControl;&#10;} WMILIB_CONTEXT, *PWMILIB_CONTEXT;">WMILIB_CONTEXT</a> structure that it passes to <strong><a href="wmisystemcontrol" title="NTSTATUS WmiSystemControl(&#10;  [in]      PWMILIB_CONTEXT         WmiLibInfo,&#10;  [in]      PDEVICE_OBJECT          DeviceObject,&#10;  [in, out] PIRP                    Irp,&#10;  [out]     PSYSCTL_IRP_DISPOSITION IrpDisposition&#10;);">WmiSystemControl</a></strong>.</p>

<p>The driver is responsible for validating all input arguments. Specifically, the driver must do the following:</p>

<ul>
<li>Verify that the <em>GuidIndex</em> value is between zero and GuidCount-1, based on the <strong>GuidCount</strong> member of the <a href="wmilib_context" title="typedef struct _WMILIB_CONTEXT {&#10;  ULONG                 GuidCount;&#10;  PWMIGUIDREGINFO       GuidList;&#10;  PWMI_QUERY_REGINFO    QueryWmiRegInfo;&#10;  PWMI_QUERY_DATABLOCK  QueryWmiDataBlock;&#10;  PWMI_SET_DATABLOCK    SetWmiDataBlock;&#10;  PWMI_SET_DATAITEM     SetWmiDataItem;&#10;  PWMI_EXECUTE_METHOD   ExecuteWmiMethod;&#10;  PWMI_FUNCTION_CONTROL WmiFunctionControl;&#10;} WMILIB_CONTEXT, *PWMILIB_CONTEXT;">WMILIB_CONTEXT</a> structure.</li>
<li>Verify that the driver has not flagged the specified data block for removal. If the driver recently specified the WMIREG_FLAG_REMOVE_GUID flag in a <a href="wmiguidreginfo" title="typedef struct _WMIGUIDREGINFO {&#10;  LPCGUID Guid;&#10;  ULONG   InstanceCount;&#10;  ULONG   Flags;&#10;} WMIGUIDREGINFO, *PWMIGUIDREGINFO;">WMIGUIDREGINFO</a> structure that is contained in a <strong><a href="wmilib_context" title="typedef struct _WMILIB_CONTEXT {&#10;  ULONG                 GuidCount;&#10;  PWMIGUIDREGINFO       GuidList;&#10;  PWMI_QUERY_REGINFO    QueryWmiRegInfo;&#10;  PWMI_QUERY_DATABLOCK  QueryWmiDataBlock;&#10;  PWMI_SET_DATABLOCK    SetWmiDataBlock;&#10;  PWMI_SET_DATAITEM     SetWmiDataItem;&#10;  PWMI_EXECUTE_METHOD   ExecuteWmiMethod;&#10;  PWMI_FUNCTION_CONTROL WmiFunctionControl;&#10;} WMILIB_CONTEXT, *PWMILIB_CONTEXT;">WMILIB_CONTEXT</a></strong> structure, it is possible for a query to arrive before the removal occurs.</li>
<li>Verify that the <em>InstanceIndex</em> and <em>InstanceCount</em> values, together, specify a number of data block instances that is within the range supported by the driver for the data block. If <em>InstanceIndex</em> is nonzero, <em>InstanceCount</em> must be 1. If <em>InstanceIndex</em> is 0, <em>InstanceCount</em> must not be greater than the number of instances supported.</li>
<li>Verify that the buffer described by <em>Buffer</em> and <em>BufferAvail</em> is large enough to hold all requested instances of the data block. Each instance must begin on an 8-byte boundary, and additional padding might exist between data items within each instance.</li>
</ul>

<p>After writing instance data to the buffer, the driver calls <a href="wmicompleterequest" title="NTSTATUS WmiCompleteRequest(&#10;  [in]      PDEVICE_OBJECT DeviceObject,&#10;  [in, out] PIRP           Irp,&#10;  [in]      NTSTATUS       Status,&#10;  [in]      ULONG          BufferUsed,&#10;  [in]      CCHAR          PriorityBoost&#10;);">WmiCompleteRequest</a> to complete the request. If the buffer described by <em>Buffer</em> and <em>BufferAvail</em> is zero, or is too small to receive all the requested data, the call to <strong><a href="wmicompleterequest" title="NTSTATUS WmiCompleteRequest(&#10;  [in]      PDEVICE_OBJECT DeviceObject,&#10;  [in, out] PIRP           Irp,&#10;  [in]      NTSTATUS       Status,&#10;  [in]      ULONG          BufferUsed,&#10;  [in]      CCHAR          PriorityBoost&#10;);">WmiCompleteRequest</a></strong> must specify STATUS_BUFFER_TOO_SMALL for the <em>Status</em> parameter and the required buffer size for the <em>BufferUsed</em> parameter.</p>

<p>This routine can be pageable.</p>

<p>For more information about implementing this routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/calling-wmisystemcontrol-to-handle-wmi-irps">Calling WmiSystemControl to Handle WMI IRPs</a>.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-all-data">IRP_MN_QUERY_ALL_DATA</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mn-query-single-instance">IRP_MN_QUERY_SINGLE_INSTANCE</a></p>

<p><a href="wmilib_context" title="typedef struct _WMILIB_CONTEXT {&#10;  ULONG                 GuidCount;&#10;  PWMIGUIDREGINFO       GuidList;&#10;  PWMI_QUERY_REGINFO    QueryWmiRegInfo;&#10;  PWMI_QUERY_DATABLOCK  QueryWmiDataBlock;&#10;  PWMI_SET_DATABLOCK    SetWmiDataBlock;&#10;  PWMI_SET_DATAITEM     SetWmiDataItem;&#10;  PWMI_EXECUTE_METHOD   ExecuteWmiMethod;&#10;  PWMI_FUNCTION_CONTROL WmiFunctionControl;&#10;} WMILIB_CONTEXT, *PWMILIB_CONTEXT;">WMILIB_CONTEXT</a></p>

<p><a href="wmicompleterequest" title="NTSTATUS WmiCompleteRequest(&#10;  [in]      PDEVICE_OBJECT DeviceObject,&#10;  [in, out] PIRP           Irp,&#10;  [in]      NTSTATUS       Status,&#10;  [in]      ULONG          BufferUsed,&#10;  [in]      CCHAR          PriorityBoost&#10;);">WmiCompleteRequest</a></p>

<p><a href="wmisystemcontrol" title="NTSTATUS WmiSystemControl(&#10;  [in]      PWMILIB_CONTEXT         WmiLibInfo,&#10;  [in]      PDEVICE_OBJECT          DeviceObject,&#10;  [in, out] PIRP                    Irp,&#10;  [out]     PSYSCTL_IRP_DISPOSITION IrpDisposition&#10;);">WmiSystemControl</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wmilib/nc-wmilib-wmi_query_datablock_callback">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wmilib/nc-wmilib-wmi_query_datablock_callback.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
