<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FSCTL_REQUEST_OPLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FSCTL_REQUEST_OPLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FSCTL_REQUEST_OPLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winioctl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0009, 0x090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK 0x00090240</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock">View the official Win32 API reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fsctl_request_oplock.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (ni-winioctl-fsctl_request_oplock)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fsctl_request_oplock-ioctl">FSCTL_REQUEST_OPLOCK IOCTL</h1>

<h2 id="description">Description</h2>

<p>Requests an opportunistic lock (oplock) on a file and acknowledges that an oplock break has occurred.</p>

<p>To perform this operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> function using the following parameters.</p>

<div class="codehilite">
<pre><span></span><code><span class="n">BOOL</span><span class="w"> </span><span class="n">DeviceIoControl</span><span class="p">(</span>
<span class="w">  </span><span class="p">(</span><span class="n">HANDLE</span><span class="p">)</span><span class="w"> </span><span class="n">hDevice</span><span class="p">,</span><span class="w">                 </span><span class="c1">// handle to file</span>
<span class="w">  </span><span class="n">FSCTL_REQUEST_OPLOCK</span><span class="p">,</span><span class="w">             </span><span class="c1">// dwIoControlCode</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="n">lpInBuffer</span><span class="p">,</span><span class="w">              </span><span class="c1">// pointer to <a href="request_oplock_input_buffer" title="typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {&#10;  WORD  StructureVersion;&#10;  WORD  StructureLength;&#10;  DWORD RequestedOplockLevel;&#10;  DWORD Flags;&#10;} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;">REQUEST_OPLOCK_INPUT_BUFFER</a></span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="n">nInBufferSize</span><span class="p">,</span><span class="w">            </span><span class="c1">// size of input buffer</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="w"> </span><span class="n">lpOutBuffer</span><span class="p">,</span><span class="w">             </span><span class="c1">// pointer to <a href="request_oplock_output_buffer" title="typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {&#10;  WORD        StructureVersion;&#10;  WORD        StructureLength;&#10;  DWORD       OriginalOplockLevel;&#10;  DWORD       NewOplockLevel;&#10;  DWORD       Flags;&#10;  ACCESS_MASK AccessMode;&#10;  WORD        ShareMode;&#10;} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;">REQUEST_OPLOCK_OUTPUT_BUFFER</a></span>
<span class="w">  </span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="p">)</span><span class="w"> </span><span class="n">nOutBufferSize</span><span class="p">,</span><span class="w">           </span><span class="c1">// size of output buffer</span>
<span class="w">  </span><span class="nb">NULL</span><span class="p">,</span><span class="w">                             </span><span class="c1">// number of bytes returned</span>
<span class="w">  </span><span class="p">(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="w"> </span><span class="n">lpOverlapped</span><span class="w">       </span><span class="c1">// OVERLAPPED structure</span>
<span class="p">);</span>
</code></pre>
</div>

<h2 id="parameters">Parameters</h2>

<h3 id="input-buffer">Input buffer</h3>

<h3 id="input-buffer-length">Input buffer length</h3>

<h3 id="output-buffer">Output buffer</h3>

<h3 id="output-buffer-length">Output buffer length</h3>

<h3 id="inputoutput-buffer">Input/output buffer</h3>

<h3 id="inputoutput-buffer-length">Input/output buffer length</h3>

<h3 id="status-block">Status block</h3>

<h2 id="remarks">Remarks</h2>

<p>This operation is used by client applications to request an opportunistic lock (oplock) from a local server. Client applications must not request opportunistic locks from remote servers directlyâ€”the network redirector transparently requests opportunistic locks for the application. Using this operation to request opportunistic locks from remote servers will result in the request being denied.</p>

<p>If the <strong>DeviceIoControl</strong> operation returns the error code <strong>ERROR_IO_PENDING</strong>, the oplock request has been granted. If it returns any other error code, the oplock has not been granted. If the error code is a warning value such as ERROR_CANNOT_GRANT_REQUESTED_OPLOCK, extended information may be available in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ns-winioctl-request_oplock_output_buffer">REQUEST_OPLOCK_OUTPUT_BUFFER</a> structure.</p>

<p>When a granted oplock breaks, the event object in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure will be signaled, and information will be returned in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ns-winioctl-request_oplock_output_buffer">REQUEST_OPLOCK_OUTPUT_BUFFER</a> structure. The *<em>Internal</em>* member of the <strong>OVERLAPPED</strong> structure will be set to an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value that provides extended information about how the oplock broke.</p>

<table>
<thead>
<tr>
  <th>OVERLAPPED.Internal value</th>
  <th>Meaning</th>
</tr>
</thead>
</table>

<p><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>\
0x0 | The oplock was broken by another file system operation. |
STATUS_OPLOCK_HANDLE_CLOSED<br />
0x00000216 | The oplock is no longer in force because the file handle used to request it was closed. Note that if an oplock breaks because the handle that was used to request it was closed, there is no need to acknowledge the break, regardless of the oplock type. |
STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE<br />
0x00000215 | The oplock is still in force, however it is no longer associated with the file handle that was used to request it. A caller used a different handle to the file to request a new oplock, and that handle now owns the oplock. |</p>

<p>The <strong>FSCTL_REQUEST_OPLOCK</strong> control code provides more efficient functionality than the following related control codes: <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock_level_1">FSCTL_REQUEST_OPLOCK_LEVEL_1</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock_level_2">FSCTL_REQUEST_OPLOCK_LEVEL_2</a>, <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_filter_oplock">FSCTL_REQUEST_FILTER_OPLOCK</a>, and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_batch_oplock">FSCTL_REQUEST_BATCH_OPLOCK</a>. Requesting different oplock levels can be performed repeatedly on the same handle without closing and reopening the handle when using <strong>FSCTL_REQUEST_OPLOCK</strong>; the other control codes require that the handle be closed and then reopened with <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to make such a change. This is accomplished by manipulating the <strong>RequestedOplockLevel<em>* member of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ns-winioctl-request_oplock_input_buffer">REQUEST_OPLOCK_INPUT_BUFFER</a> structure when re-issuing the *</em>FSCTL_REQUEST_OPLOCK</strong> control code.</p>

<p>The following table summarizes how the caching ability of oplock types available from <strong>FSCTL_REQUEST_OPLOCK</strong> correspond to the level 2, level 1, and batch oplocks.</p>

<table>
<thead>
<tr>
  <th>Alternative control code</th>
  <th>Equivalent <strong>RequestedOplockLevel</strong> flags value</th>
  <th>Oplock type</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_batch_oplock">FSCTL_REQUEST_BATCH_OPLOCK</a></td>
  <td><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE | OPLOCK_LEVEL_CACHE_HANDLE</code></td>
  <td>RWH</td>
</tr>
<tr>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock_level_1">FSCTL_REQUEST_OPLOCK_LEVEL_1</a></td>
  <td><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE</code></td>
  <td>RW</td>
</tr>
<tr>
  <td><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock_level_2">FSCTL_REQUEST_OPLOCK_LEVEL_2</a></td>
  <td><code>OPLOCK_LEVEL_CACHE_READ</code></td>
  <td>R</td>
</tr>
</tbody>
</table>

<p>Using the <strong>FSCTL_REQUEST_OPLOCK</strong> control code with the <strong>RequestedOplockLevel</strong> member set to <code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE</code> grants an oplock of type <em>RH</em>. An RH oplock is similar to the filter oplock granted by the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_filter_oplock">FSCTL_REQUEST_FILTER_OPLOCK</a> control code. However, note that the filter oplock allows only one client to hold an oplock on a file at a time; <strong>FSCTL_REQUEST_OPLOCK</strong> allows multiple clients at a time to have the <em>RH</em> lock on a file. Another difference is that <strong><a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a></strong> requires an oplock break acknowledgment before writes can occur, where <strong>FSCTL_REQUEST_OPLOCK</strong> does not because the oplock break notification is advisory-only and writes are allowed to go ahead without acknowledgment. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/breaking-oplocks">Breaking Oplocks</a>.</p>

<p>An <strong>FSCTL_REQUEST_OPLOCK</strong> control code fails if the file is opened in non-overlapped (synchronous) mode.</p>

<p>For the implications of overlapped I/O on this operation, see the Remarks section of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> topic.</p>

<p>In Windows 8 and Windows Server 2012, this code is supported by the following technologies.</p>

<table>
<thead>
<tr>
  <th>Technology</th>
  <th>Supported</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Server Message Block (SMB) 3.0 protocol</td>
  <td>No</td>
</tr>
<tr>
  <td>SMB 3.0 Transparent Failover (TFO)</td>
  <td>No</td>
</tr>
<tr>
  <td>SMB 3.0 with Scale-out File Shares (SO)</td>
  <td>No</td>
</tr>
<tr>
  <td>Cluster Shared Volume File System (CsvFS)</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Resilient File System (ReFS)</td>
  <td>Yes</td>
</tr>
</tbody>
</table>

<p>Also, beginning in Windows 8 and Windows Server 2012, the <strong>FSCTL_REQUEST_OPLOCK</strong> control code can be used to request an oplock on a directory as well as a file. An oplock request on a directory may specify either <code>OPLOCK_LEVEL_CACHE_READ</code> or <code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE</code> in the RequestedOplockLevel member.</p>

<p>An R or RH oplock on a directory breaks to None when the contents of an enumeration of the directory would change. For example, adding/deleting a file in the directory, changing the size of a file in the directory, modifying the timestamp of a file in the directory, etc., would all break the oplock on the directory. This oplock break does not require an acknowledgment before the changes in the directory may occur; it is advisory-only.</p>

<p>An RH oplock on a directory breaks to R when the directory itself is renamed or deleted. This oplock break does require an acknowledgment before the change to the directory can occur.</p>

<h2 id="see-also">See also</h2>

<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-semantics">Oplock Semantics</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/opportunistic-locks">Opportunistic Locks</a></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winioctl/ni-winioctl-fsctl_request_oplock.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
