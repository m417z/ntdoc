<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FSCTL_REQUEST_OPLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FSCTL_REQUEST_OPLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FSCTL_REQUEST_OPLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// winioctl.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0009, 0x090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK 0x00090240</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock">View the official Win32 API reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntifs.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0009, 0x090, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK 0x00090240</span><span class="ntdoc-code-footer"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/fsctl-request-oplock">View the official Windows hardware development documentation</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fsctl_request_oplock.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 API reference (ni-winioctl-fsctl_request_oplock)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>FSCTL_REQUEST_OPLOCK IOCTL</h1>
<h2>Description</h2>
<p>Requests an opportunistic lock (oplock) on a file and acknowledges that an oplock break has occurred.</p>
<p>To perform this operation, call the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><strong>DeviceIoControl</strong></a> function using the following parameters.</p>
<pre><code>BOOL DeviceIoControl(
  (HANDLE) hDevice,                 // handle to file
  FSCTL_REQUEST_OPLOCK,             // dwIoControlCode
  (LPVOID) lpInBuffer,              // pointer to <a href="request_oplock_input_buffer" title="typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {&#10;  WORD  StructureVersion;&#10;  WORD  StructureLength;&#10;  DWORD RequestedOplockLevel;&#10;  DWORD Flags;&#10;} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;">REQUEST_OPLOCK_INPUT_BUFFER</a>
  (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>) nInBufferSize,            // size of input buffer
  (LPVOID) lpOutBuffer,             // pointer to <a href="request_oplock_output_buffer" title="typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {&#10;  WORD        StructureVersion;&#10;  WORD        StructureLength;&#10;  DWORD       OriginalOplockLevel;&#10;  DWORD       NewOplockLevel;&#10;  DWORD       Flags;&#10;  ACCESS_MASK AccessMode;&#10;  WORD        ShareMode;&#10;} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;">REQUEST_OPLOCK_OUTPUT_BUFFER</a>
  (<a href="dword" title="typedef unsigned long DWORD;">DWORD</a>) nOutBufferSize,           // size of output buffer
  NULL,                             // number of bytes returned
  (LPOVERLAPPED) lpOverlapped       // OVERLAPPED structure
);
</code></pre>
<h2>Parameters</h2>
<h3>Input buffer</h3>
<h3>Input buffer length</h3>
<h3>Output buffer</h3>
<h3>Output buffer length</h3>
<h3>Input/output buffer</h3>
<h3>Input/output buffer length</h3>
<h3>Status block</h3>
<h2>Remarks</h2>
<p>This operation is used by client applications to request an opportunistic lock (oplock) from a local server. Client applications must not request opportunistic locks from remote servers directlyâ€”the network redirector transparently requests opportunistic locks for the application. Using this operation to request opportunistic locks from remote servers will result in the request being denied.</p>
<p>If the <strong>DeviceIoControl</strong> operation returns the error code <strong>ERROR_IO_PENDING</strong>, the oplock request has been granted. If it returns any other error code, the oplock has not been granted. If the error code is a warning value such as ERROR_CANNOT_GRANT_REQUESTED_OPLOCK, extended information may be available in the <a href="request_oplock_output_buffer" title="typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {&#10;  WORD        StructureVersion;&#10;  WORD        StructureLength;&#10;  DWORD       OriginalOplockLevel;&#10;  DWORD       NewOplockLevel;&#10;  DWORD       Flags;&#10;  ACCESS_MASK AccessMode;&#10;  WORD        ShareMode;&#10;} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;">REQUEST_OPLOCK_OUTPUT_BUFFER</a> structure.</p>
<p>When a granted oplock breaks, the event object in the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure will be signaled, and information will be returned in the <a href="request_oplock_output_buffer" title="typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {&#10;  WORD        StructureVersion;&#10;  WORD        StructureLength;&#10;  DWORD       OriginalOplockLevel;&#10;  DWORD       NewOplockLevel;&#10;  DWORD       Flags;&#10;  ACCESS_MASK AccessMode;&#10;  WORD        ShareMode;&#10;} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;">REQUEST_OPLOCK_OUTPUT_BUFFER</a> structure. The <strong>Internal</strong> member of the <strong>OVERLAPPED</strong> structure will be set to an <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> value that provides extended information about how the oplock broke.</p>
<table>
<thead>
<tr>
<th>OVERLAPPED.Internal value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a>\</td>
<td></td>
</tr>
<tr>
<td>0x0</td>
<td>The oplock was broken by another file system operation.</td>
</tr>
<tr>
<td>STATUS_OPLOCK_HANDLE_CLOSED\</td>
<td></td>
</tr>
<tr>
<td>0x00000216</td>
<td>The oplock is no longer in force because the file handle used to request it was closed. Note that if an oplock breaks because the handle that was used to request it was closed, there is no need to acknowledge the break, regardless of the oplock type.</td>
</tr>
<tr>
<td>STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE\</td>
<td></td>
</tr>
<tr>
<td>0x00000215</td>
<td>The oplock is still in force, however it is no longer associated with the file handle that was used to request it. A caller used a different handle to the file to request a new oplock, and that handle now owns the oplock.</td>
</tr>
</tbody>
</table>
<p>The <strong>FSCTL_REQUEST_OPLOCK</strong> control code provides more efficient functionality than the following related control codes: <a href="fsctl_request_oplock_level_1" title="// CTL_CODE(0x0009, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_1 0x00090000">FSCTL_REQUEST_OPLOCK_LEVEL_1</a>, <a href="fsctl_request_oplock_level_2" title="// CTL_CODE(0x0009, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_2 0x00090004">FSCTL_REQUEST_OPLOCK_LEVEL_2</a>, <a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a>, and <a href="fsctl_request_batch_oplock" title="// CTL_CODE(0x0009, 0x002, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_BATCH_OPLOCK 0x00090008">FSCTL_REQUEST_BATCH_OPLOCK</a>. Requesting different oplock levels can be performed repeatedly on the same handle without closing and reopening the handle when using <strong>FSCTL_REQUEST_OPLOCK</strong>; the other control codes require that the handle be closed and then reopened with <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to make such a change. This is accomplished by manipulating the <strong>RequestedOplockLevel</strong> member of the <a href="request_oplock_input_buffer" title="typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {&#10;  WORD  StructureVersion;&#10;  WORD  StructureLength;&#10;  DWORD RequestedOplockLevel;&#10;  DWORD Flags;&#10;} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;">REQUEST_OPLOCK_INPUT_BUFFER</a> structure when re-issuing the <strong>FSCTL_REQUEST_OPLOCK</strong> control code.</p>
<p>The following table summarizes how the caching ability of oplock types available from <strong>FSCTL_REQUEST_OPLOCK</strong> correspond to the level 2, level 1, and batch oplocks.</p>
<table>
<thead>
<tr>
<th>Alternative control code</th>
<th>Equivalent <strong>RequestedOplockLevel</strong> flags value</th>
<th>Oplock type</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="fsctl_request_batch_oplock" title="// CTL_CODE(0x0009, 0x002, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_BATCH_OPLOCK 0x00090008">FSCTL_REQUEST_BATCH_OPLOCK</a></td>
<td><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE | OPLOCK_LEVEL_CACHE_HANDLE</code></td>
<td>RWH</td>
</tr>
<tr>
<td><a href="fsctl_request_oplock_level_1" title="// CTL_CODE(0x0009, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_1 0x00090000">FSCTL_REQUEST_OPLOCK_LEVEL_1</a></td>
<td><code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_WRITE</code></td>
<td>RW</td>
</tr>
<tr>
<td><a href="fsctl_request_oplock_level_2" title="// CTL_CODE(0x0009, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_OPLOCK_LEVEL_2 0x00090004">FSCTL_REQUEST_OPLOCK_LEVEL_2</a></td>
<td><code>OPLOCK_LEVEL_CACHE_READ</code></td>
<td>R</td>
</tr>
</tbody>
</table>
<p>Using the <strong>FSCTL_REQUEST_OPLOCK</strong> control code with the <strong>RequestedOplockLevel</strong> member set to <code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE</code> grants an oplock of type <em>RH</em>. An RH oplock is similar to the filter oplock granted by the <a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a> control code. However, note that the filter oplock allows only one client to hold an oplock on a file at a time; <strong>FSCTL_REQUEST_OPLOCK</strong> allows multiple clients at a time to have the <em>RH</em> lock on a file. Another difference is that <strong><a href="fsctl_request_filter_oplock" title="// CTL_CODE(0x0009, 0x017, METHOD_BUFFERED, FILE_ANY_ACCESS)&#10;#define FSCTL_REQUEST_FILTER_OPLOCK 0x0009005C">FSCTL_REQUEST_FILTER_OPLOCK</a></strong> requires an oplock break acknowledgment before writes can occur, where <strong>FSCTL_REQUEST_OPLOCK</strong> does not because the oplock break notification is advisory-only and writes are allowed to go ahead without acknowledgment. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/breaking-oplocks">Breaking Oplocks</a>.</p>
<p>An <strong>FSCTL_REQUEST_OPLOCK</strong> control code fails if the file is opened in non-overlapped (synchronous) mode.</p>
<p>For the implications of overlapped I/O on this operation, see the Remarks section of the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> topic.</p>
<p>In Windows 8 and Windows Server 2012, this code is supported by the following technologies.</p>
<table>
<thead>
<tr>
<th>Technology</th>
<th>Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Server Message Block (SMB) 3.0 protocol</td>
<td>No</td>
</tr>
<tr>
<td>SMB 3.0 Transparent Failover (TFO)</td>
<td>No</td>
</tr>
<tr>
<td>SMB 3.0 with Scale-out File Shares (SO)</td>
<td>No</td>
</tr>
<tr>
<td>Cluster Shared Volume File System (CsvFS)</td>
<td>Yes</td>
</tr>
<tr>
<td>Resilient File System (ReFS)</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Also, beginning in Windows 8 and Windows Server 2012, the <strong>FSCTL_REQUEST_OPLOCK</strong> control code can be used to request an oplock on a directory as well as a file. An oplock request on a directory may specify either <code>OPLOCK_LEVEL_CACHE_READ</code> or <code>OPLOCK_LEVEL_CACHE_READ | OPLOCK_LEVEL_CACHE_HANDLE</code> in the RequestedOplockLevel member.</p>
<p>An R or RH oplock on a directory breaks to None when the contents of an enumeration of the directory would change. For example, adding/deleting a file in the directory, changing the size of a file in the directory, modifying the timestamp of a file in the directory, etc., would all break the oplock on the directory. This oplock break does not require an acknowledgment before the changes in the directory may occur; it is advisory-only.</p>
<p>An RH oplock on a directory breaks to R when the directory itself is renamed or deleted. This oplock break does require an acknowledgment before the change to the directory can occur.</p>
<h2>See also</h2>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-semantics">Oplock Semantics</a></li>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/opportunistic-locks">Opportunistic Locks</a></li>
</ul>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/api/winioctl/ni-winioctl-fsctl_request_oplock">View the official Win32 API reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winioctl/ni-winioctl-fsctl_request_oplock.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows hardware development documentation (fsctl-request-oplock)</h1>
</div>
<div class="ntdoc-description">
<h1>FSCTL_REQUEST_OPLOCK control code</h1>
<p>The <strong>FSCTL_REQUEST_OPLOCK</strong> control code requests an opportunistic lock (oplock) on a file, or acknowledges that an oplock break has occurred.</p>
<p>For more information about opportunistic locks, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/opportunistic-locks">Opportunistic Locks</a> in the Windows Desktop documentation. For more information about user mode OPLOCK controls, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FileIO/file-management-control-codes">File Management Control Codes</a> in the Windows Desktop documentation.</p>
<p>To process this control code, a file system or filter driver calls <strong><a href="fsrtloplockfsctrlex" title="NTSTATUS FsRtlOplockFsctrlEx(&#10;  [in] POPLOCK Oplock,&#10;  [in] PIRP    Irp,&#10;  [in] ULONG   OpenCount,&#10;  [in] ULONG   Flags&#10;);">FsRtlOplockFsctrlEx</a></strong> with the following parameters.</p>
<h2>Parameters</h2>
<ul>
<li>
<p><strong>Oplock</strong>: Opaque oplock object pointer for the file.</p>
</li>
<li>
<p><strong>Irp</strong>: A pointer to the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> for an <a href="irp_mj_file_system_control" title="#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d">IRP_MJ_FILE_SYSTEM_CONTROL</a> FSCTL request. The <strong>FsControlCode</strong> parameter for the operation must be FSCTL_REQUEST_OPLOCK.</p>
</li>
<li>
<p><strong>OpenCount</strong>: The number of user handles for the file if the request is for an exclusive oplock. If the request is for an oplock that can be shared, <em>OpenCount</em> is zero if no byte-range locks exist on the file. Otherwise, <strong>OpenCount</strong> is nonzero. The caller can call the <strong><a href="fsrtloplockissharedrequest" title="BOOLEAN FsRtlOplockIsSharedRequest(&#10;  [in] PIRP Irp&#10;);">FsRtlOplockIsSharedRequest</a></strong> routine on the <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> to determine if the request is for an oplock that can be shared.</p>
</li>
<li>
<p><strong>Flags</strong>: A bitmask for the associated oplock operations. A file system or filter driver sets bits to specify the behavior of <strong><a href="fsrtloplockfsctrlex" title="NTSTATUS FsRtlOplockFsctrlEx(&#10;  [in] POPLOCK Oplock,&#10;  [in] PIRP    Irp,&#10;  [in] ULONG   OpenCount,&#10;  [in] ULONG   Flags&#10;);">FsRtlOplockFsctrlEx</a></strong>. The <em>Flags</em> parameter has the following options:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPLOCK_FSCTRL_FLAG_ALL_KEYS_MATCH (0x00000001)</td>
<td>Specifies that the file system has verified that all opportunistic lock keys match on any handle that is currently open. By specifying this flag, the oplock package can grant an oplock of level RW or RWH when more than one open handle to the file exists. For more information about oplock types, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/oplock-overview">Overview</a>.</td>
</tr>
</tbody>
</table>
<h2>Status block</h2>
<p><strong><a href="fsrtloplockfsctrlex" title="NTSTATUS FsRtlOplockFsctrlEx(&#10;  [in] POPLOCK Oplock,&#10;  [in] PIRP    Irp,&#10;  [in] ULONG   OpenCount,&#10;  [in] ULONG   Flags&#10;);">FsRtlOplockFsctrlEx</a></strong> returns one of the following <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> values for this operation:</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>STATUS_PENDING</td>
<td>The oplock was granted. This is a success code.</td>
</tr>
<tr>
<td>STATUS_CANCELLED</td>
<td>The <a href="irp" title="typedef struct _IRP {&#10;  CSHORT                    Type;&#10;  USHORT                    Size;&#10;  PMDL                      MdlAddress;&#10;  ULONG                     Flags;&#10;  union {&#10;    struct _IRP     *MasterIrp;&#10;    __volatile LONG IrpCount;&#10;    PVOID           SystemBuffer;&#10;  } AssociatedIrp;&#10;  LIST_ENTRY                ThreadListEntry;&#10;  IO_STATUS_BLOCK           IoStatus;&#10;  KPROCESSOR_MODE           RequestorMode;&#10;  BOOLEAN                   PendingReturned;&#10;  CHAR                      StackCount;&#10;  CHAR                      CurrentLocation;&#10;  BOOLEAN                   Cancel;&#10;  KIRQL                     CancelIrql;&#10;  CCHAR                     ApcEnvironment;&#10;  UCHAR                     AllocationFlags;&#10;...">IRP</a> was canceled before the FSCTL_REQUEST_OPLOCK operation was completed. This is an error code.</td>
</tr>
<tr>
<td>STATUS_OPLOCK_NOT_GRANTED</td>
<td>The oplock could not be granted. This is an error code.</td>
</tr>
</tbody>
</table>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement type</th>
<th>Requirement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td><em>Ntifs.h</em> (include <em>Ntifs.h</em> or <em>Fltkernel.h</em>)</td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<p><strong><a href="fsrtloplockfsctrlex" title="NTSTATUS FsRtlOplockFsctrlEx(&#10;  [in] POPLOCK Oplock,&#10;  [in] PIRP    Irp,&#10;  [in] ULONG   OpenCount,&#10;  [in] ULONG   Flags&#10;);">FsRtlOplockFsctrlEx</a></strong></p>
<p><strong><a href="fsrtloplockissharedrequest" title="BOOLEAN FsRtlOplockIsSharedRequest(&#10;  [in] PIRP Irp&#10;);">FsRtlOplockIsSharedRequest</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/irp-mj-file-system-control"><strong>IRP_MJ_FILE_SYSTEM_CONTROL</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ifs/fsctl-request-oplock">View the official Windows hardware development documentation</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs/blob/staging/windows-driver-docs-pr/ifs/fsctl-request-oplock.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
