<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="NtReadFile - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>NtReadFile - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github.ntdoc.min.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/highlight.js/styles/github-dark-dimmed.ntdoc.min.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            NtReadFile - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTIOAPI_H

</span><span class="ntdoc-code-intro language-cpp">/**
 * The NtReadFile function reads data from an open file.
 *
 * \param[in] FileHandle A handle to the file object representing the file or directory on which the specified action is to be performed.
 * \param[in] Event A handle for a caller-created event. This parameter is optional and can be NULL. It must be NULL if the caller will wait for the FileHandle to be set to the Signaled state.
 * \param[in] ApcRoutine Address of a caller-supplied APC routine to be called when the requested operation completes. This parameter is optional and can be NULL.
 * \param[in] ApcContext Pointer to a caller-determined context area. This parameter value is used as the APC context if the caller supplies an APC, or is used as the completion context if an I/O completion object has been associated with the file object.
 * \param[out] IoStatusBlock Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the operation.
 * \param[out] Buffer Pointer to a caller-allocated buffer that receives the data read from the file.
 * \param[in] Length The size, in bytes, of the buffer pointed to by Buffer.
 * \param[in] ByteOffset Pointer to a variable that specifies the starting byte offset in the file where the read operation will begin.
 * \param[in] Key Device and intermediate drivers should set this pointer to NULL.
 * \return <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> Successful or errant status.
 * \sa https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwreadfile
 */
</span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/fdc8ffd5e22d41518e5440cb198d5d587da6ec72/phnt/include/ntioapi.h#L2395">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">#ifndef _NTZWAPI_H

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSCALLAPI
<a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a>
NTAPI
ZwReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a> ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a> Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key
    );
</span><span class="ntdoc-code-footer language-cpp">
#endif
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://github.com/winsiderss/systeminformer/blob/fdc8ffd5e22d41518e5440cb198d5d587da6ec72/phnt/include/ntzwapi.h#L3639">View code on GitHub</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// ntifs.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">__kernel_entry NTSYSCALLAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtReadFile(
  [in]           HANDLE           FileHandle,
  [in, optional] HANDLE           Event,
  [in, optional] <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional] PVOID            ApcContext,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [out]          PVOID            Buffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in, optional] PLARGE_INTEGER   ByteOffset,
  [in, optional] PULONG           Key
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntreadfile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wdm.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp">NTSYSAPI <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> ZwReadFile(
  [in]           HANDLE           FileHandle,
  [in, optional] HANDLE           Event,
  [in, optional] <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  [in, optional] PVOID            ApcContext,
  [out]          <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  [out]          PVOID            Buffer,
  [in]           <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  [in, optional] PLARGE_INTEGER   ByteOffset,
  [in, optional] PULONG           Key
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwreadfile">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header language-cpp">// wdm.h

</span><span class="ntdoc-code-intro language-cpp"></span><span class="ntdoc-code-body language-cpp"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> NtReadFile(
  _In_     HANDLE           FileHandle,
  _In_opt_ HANDLE           Event,
  _In_opt_ <a href="pio_apc_routine" title="typedef IO_APC_ROUTINE* PIO_APC_ROUTINE;">PIO_APC_ROUTINE</a>  ApcRoutine,
  _In_opt_ PVOID            ApcContext,
  _Out_    <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">PIO_STATUS_BLOCK</a> IoStatusBlock,
  _Out_    PVOID            Buffer,
  _In_     <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>            Length,
  _In_opt_ PLARGE_INTEGER   ByteOffset,
  _In_opt_ PULONG           Key
);</span><span class="ntdoc-code-footer language-cpp"></span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ntreadfile">View the official Win32 development documentation</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ntreadfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-ntifs-ntreadfile)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1>NtReadFile function</h1>
<h2>Description</h2>
<p>The <strong>NtReadFile</strong> routine reads data from an open file.</p>
<h2>Parameters</h2>
<h3><code>FileHandle</code> [in]</h3>
<p>Handle to the file object. This handle is created by a successful call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> or <strong><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></strong>.</p>
<h3><code>Event</code> [in, optional]</h3>
<p>Optionally, a handle to an event object to set to the signaled state after the read operation completes. Device and intermediate drivers should set this parameter to NULL.</p>
<h3><code>ApcRoutine</code> [in, optional]</h3>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to NULL.</p>
<h3><code>ApcContext</code> [in, optional]</h3>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to NULL.</p>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the requested read operation. The <strong>Information</strong> member receives the number of bytes actually read from the file.</p>
<h3><code>Buffer</code> [out]</h3>
<p>Pointer to a caller-allocated buffer that receives the data read from the file.</p>
<h3><code>Length</code> [in]</h3>
<p>The size, in bytes, of the buffer pointed to by <strong>Buffer</strong>.</p>
<h3><code>ByteOffset</code> [in, optional]</h3>
<p>Pointer to a variable that specifies the starting byte offset in the file where the read operation will begin. If an attempt is made to read beyond the end of the file, <strong>NtReadFile</strong> returns an error.</p>
<p>If the call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> set either of the <strong>CreateOptions</strong> flags <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, the I/O Manager maintains the current file position. If so, the caller of <strong>NtReadFile</strong> can specify that the current file position offset be used instead of an explicit <strong>ByteOffset</strong> value. This specification can be made by using one of the following methods:</p>
<ul>
<li>Specify a pointer to a LARGE_INTEGER value with the <strong>HighPart</strong> member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a>.</li>
<li>Pass a NULL pointer for <strong>ByteOffset</strong>.</li>
</ul>
<p><strong>NtReadFile</strong> updates the current file position by adding the number of bytes read when it completes the read operation, if it is using the current file position maintained by the I/O Manager.</p>
<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <strong>ByteOffset</strong> value to <strong>NtReadFile</strong>. Doing this automatically changes the current file position to that <strong>ByteOffset</strong> value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service.</p>
<h3><code>Key</code> [in, optional]</h3>
<p>Device and intermediate drivers should set this pointer to NULL.</p>
<h2>Return value</h2>
<p><strong>NtReadFile</strong> returns either <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or the appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code.</p>
<h2>Remarks</h2>
<p>Callers of <strong>NtReadFile</strong> must have already called <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> with the FILE_READ_DATA or GENERIC_READ value set in the <strong>DesiredAccess</strong> parameter.</p>
<p>If the preceding call to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong> set the <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> flag in the <strong>CreateOptions</strong> parameter to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong>, the <strong>Length</strong> and <strong>ByteOffset</strong> parameters to <strong>NtReadFile</strong> must be multiples of the sector size.</p>
<p><strong>NtReadFile</strong> begins reading from the given <strong>ByteOffset</strong> or the current file position into the given <strong>Buffer</strong>. It terminates the read operation under one of the following conditions:</p>
<ul>
<li>The buffer is full because the number of bytes specified by the <strong>Length</strong> parameter has been read. Therefore, no more data can be placed into the buffer without an overflow.</li>
<li>The end of file is reached during the read operation, so there is no more data in the file to be transferred into the buffer.</li>
</ul>
<p>If the caller opened the file with the SYNCHRONIZE flag set in <strong>DesiredAccess</strong>, the calling thread can synchronize to the completion of the read operation by waiting on the file handle, <strong>FileHandle</strong>. The handle is signaled each time that an I/O operation that was issued on the handle completes. However, the caller must not wait on a handle that was opened for synchronous file access (<a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> or <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>). In this case, <strong>NtReadFile</strong> waits on behalf of the caller and does not return until the read operation is complete. The caller can safely wait on the file handle only if all three of the following conditions are met:</p>
<ul>
<li>The handle was opened for asynchronous access (that is, neither FILE_SYNCHRONOUS_IO_<strong>XXX</strong> flag was specified).</li>
<li>The handle is being used for only one I/O operation at a time.</li>
<li><strong>NtReadFile</strong> returned STATUS_PENDING.</li>
</ul>
<p>A driver should call <strong>NtReadFile</strong> in the context of the system process if any of the following conditions exist:</p>
<ul>
<li>The driver created the file handle that it passes to <strong>NtReadFile</strong>.</li>
<li><strong>NtReadFile</strong> will notify the driver of I/O completion by means of an event that the driver created.</li>
<li><strong>NtReadFile</strong> will notify the driver of I/O completion by means of an APC callback routine that the driver passes to <strong>NtReadFile</strong>.</li>
</ul>
<p>File and event handles are valid only in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to <strong>NtReadFile</strong> in the context of the system process rather than the context of the process that the driver is in.</p>
<p>Likewise, <strong>NtReadFile</strong> should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread that issues the I/O request. If the driver calls <strong>NtReadFile</strong> in the context of a process other than the system one, the APC could be delayed indefinitely, or it might not fire at all.</p>
<p>For more information about working with files, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>
<p>Callers of <strong>NtReadFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>
<p>If the call to this function occurs in user mode, you should use the name &quot;<strong>NtReadFile</strong>&quot; instead of &quot;<strong>ZwReadFile</strong>&quot;.</p>
<p>For calls from kernel-mode drivers, the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a Windows Native System Services routine can behave differently in the way that they handle and interpret input parameters. For more information about the relationship between the <strong>Nt<em>Xxx</em></strong> and <strong>Zw<em>Xxx</em></strong> versions of a routine, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-nt-and-zw-versions-of-the-native-system-services-routines">Using Nt and Zw Versions of the Native System Services Routines</a>.</p>
<h2>See also</h2>
<p><strong><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></strong></p>
<p><strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong></p>
<p><strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong></p>
<p><strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong></p>
<p><strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntreadfile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntifs/nf-ntifs-ntreadfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-wdm-zwreadfile)</h1>
</div>
<div class="ntdoc-description">
<h2>Description</h2>
<p>The <strong>ZwReadFile</strong> routine reads data from an open file.</p>
<h2>Parameters</h2>
<h3><code>FileHandle</code> [in]</h3>
<p>Handle to the file object. This handle is created by a successful call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> or <a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">ZwOpenFile</a>.</p>
<h3><code>Event</code> [in, optional]</h3>
<p>Optionally, a handle to an event object to set to the signaled state after the read operation completes. Device and intermediate drivers should set this parameter to <strong>NULL</strong>.</p>
<h3><code>ApcRoutine</code> [in, optional]</h3>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<h3><code>ApcContext</code> [in, optional]</h3>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<h3><code>IoStatusBlock</code> [out]</h3>
<p>Pointer to an <a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a> structure that receives the final completion status and information about the requested read operation. The <strong>Information</strong> member receives the number of bytes actually read from the file.</p>
<h3><code>Buffer</code> [out]</h3>
<p>Pointer to a caller-allocated buffer that receives the data read from the file.</p>
<h3><code>Length</code> [in]</h3>
<p>The size, in bytes, of the buffer pointed to by <em>Buffer</em>.</p>
<h3><code>ByteOffset</code> [in, optional]</h3>
<p>Pointer to a variable that specifies the starting byte offset in the file where the read operation will begin. If an attempt is made to read beyond the end of the file, <strong>ZwReadFile</strong> returns an error.</p>
<p>If the call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> set either of the <strong>CreateOptions</strong> flags <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, the I/O Manager maintains the current file position. If so, the caller of <strong>ZwReadFile</strong> can specify that the current file position offset be used instead of an explicit <strong>ByteOffset</strong> value. This specification can be made by using one of the following methods:</p>
<ul>
<li>
<p>Specify a pointer to a LARGE_INTEGER value with the <strong>HighPart</strong> member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a>.</p>
</li>
<li>
<p>Pass a <strong>NULL</strong> pointer for <em>ByteOffset</em>.</p>
</li>
</ul>
<p><strong>ZwReadFile</strong> updates the current file position by adding the number of bytes read when it completes the read operation, if it is using the current file position maintained by the I/O Manager.</p>
<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <em>ByteOffset</em> value to <strong>ZwReadFile</strong>. Doing this automatically changes the current file position to that <em>ByteOffset</em> value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service.</p>
<h3><code>Key</code> [in, optional]</h3>
<p>Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<h2>Return value</h2>
<p><strong>ZwReadFile</strong> returns either <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or the appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code.</p>
<h2>Remarks</h2>
<p>Callers of <strong>ZwReadFile</strong> must have already called <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> with the FILE_READ_DATA or GENERIC_READ value set in the <em>DesiredAccess</em> parameter.</p>
<p>If the preceding call to <a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a> set the <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> flag in the <em>CreateOptions</em> parameter to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong>, the <em>Length</em> and <em>ByteOffset</em> parameters to <strong>ZwReadFile</strong> must be multiples of the sector size. For more information, see <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></strong>.</p>
<p><strong>ZwReadFile</strong> begins reading from the given <em>ByteOffset</em> or the current file position into the given <em>Buffer</em>. It terminates the read operation under one of the following conditions:</p>
<ul>
<li>
<p>The buffer is full because the number of bytes specified by the <em>Length</em> parameter has been read. Therefore, no more data can be placed into the buffer without an overflow.</p>
</li>
<li>
<p>The end of file is reached during the read operation, so there is no more data in the file to be transferred into the buffer.</p>
</li>
</ul>
<p>If the caller opened the file with the SYNCHRONIZE flag set in <em>DesiredAccess</em>, the calling thread can synchronize to the completion of the read operation by waiting on the file handle, <em>FileHandle</em>. The handle is signaled each time that an I/O operation that was issued on the handle completes. However, the caller must not wait on a handle that was opened for synchronous file access (<a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> or <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>). In this case, <strong>ZwReadFile</strong> waits on behalf of the caller and does not return until the read operation is complete. The caller can safely wait on the file handle only if all three of the following conditions are met:</p>
<ul>
<li>
<p>The handle was opened for asynchronous access (that is, neither FILE_SYNCHRONOUS_IO_<strong>XXX</strong> flag was specified).</p>
</li>
<li>
<p>The handle is being used for only one I/O operation at a time.</p>
</li>
<li>
<p><strong>ZwReadFile</strong> returned STATUS_PENDING.</p>
</li>
</ul>
<p>A driver should call <strong>ZwReadFile</strong> in the context of the system process if any of the following conditions exist:</p>
<ul>
<li>
<p>The driver created the file handle that it passes to <strong>ZwReadFile</strong>.</p>
</li>
<li>
<p><strong>ZwReadFile</strong> will notify the driver of I/O completion by means of an event that the driver created.</p>
</li>
<li>
<p><strong>ZwReadFile</strong> will notify the driver of I/O completion by means of an APC callback routine that the driver passes to <strong>ZwReadFile</strong>.</p>
</li>
</ul>
<p>File and event handles are valid only in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to <strong>ZwReadFile</strong> in the context of the system process rather than the context of the process that the driver is in.</p>
<p>Likewise, <strong>ZwReadFile</strong> should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread that issues the I/O request. If the driver calls <strong>ZwReadFile</strong> in the context of a process other than the system one, the APC could be delayed indefinitely, or it might not fire at all.</p>
<p>For more information about working with files, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>
<p>Callers of <strong>ZwReadFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>
<p>If the call to this function occurs in user mode, you should use the name &quot;NtReadFile&quot; instead of &quot;<strong>ZwReadFile</strong>&quot;.</p>
<h2>See also</h2>
<p><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></p>
<p><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">ZwCreateFile</a></p>
<p><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwQueryInformationFile</a></p>
<p><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">ZwSetInformationFile</a></p>
<p><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">ZwWriteFile</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-zwreadfile">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/wdm/nf-wdm-zwreadfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Win32 development documentation (ntreadfile)</h1>
</div>
<div class="ntdoc-description">
<h1>NtReadFile function</h1>
<p>Reads data from an open file.</p>
<p>This function is the user-mode equivalent to the <strong>ZwReadFile</strong> function documented in the Windows Driver Kit (WDK).</p>
<h2>Parameters</h2>
<p><em>FileHandle</em> [in]</p>
<p>Handle to the file object. This handle is created by a successful call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntcreatefile"><strong>NtCreateFile</strong></a> or <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntopenfile"><strong>NtOpenFile</strong></a>.</p>
<p><em>Event</em> [in, optional]</p>
<p>Optionally, a handle to an event object to set to the signaled state after the read operation completes. Device and intermediate drivers should set this parameter to <strong>NULL</strong>.</p>
<p><em>ApcRoutine</em> [in, optional]</p>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<p><em>ApcContext</em> [in, optional]</p>
<p>This parameter is reserved. Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<p><em>IoStatusBlock</em> [out]</p>
<p>Pointer to an <strong><a href="io_status_block" title="typedef struct _IO_STATUS_BLOCK&#10;{&#10;    union&#10;    {&#10;        NTSTATUS Status;&#10;        PVOID Pointer;&#10;    };&#10;    ULONG_PTR Information;&#10;} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;">IO_STATUS_BLOCK</a></strong> structure that receives the final completion status and information about the requested read operation. The <strong>Information</strong> member receives the number of bytes actually read from the file.</p>
<p><em>Buffer</em> [out]</p>
<p>Pointer to a caller-allocated buffer that receives the data read from the file.</p>
<p><em>Length</em> [in]</p>
<p>The size, in bytes, of the buffer pointed to by <em>Buffer</em>.</p>
<p><em>ByteOffset</em> [in, optional]</p>
<p>Pointer to a variable that specifies the starting byte offset in the file where the read operation will begin. If an attempt is made to read beyond the end of the file, <strong>NtReadFile</strong> returns an error.</p>
<p>If the call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntcreatefile"><strong>NtCreateFile</strong></a> set either of the <em>CreateOptions</em> flags <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a> or <a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a>, the I/O Manager maintains the current file position. If so, the caller of <strong>NtReadFile</strong> can specify that the current file position offset be used instead of an explicit <em>ByteOffset</em> value. This specification can be made by using one of the following methods:</p>
<ul>
<li>
<p>Specify a pointer to a <strong>LARGE_INTEGER</strong> value with the <strong>HighPart</strong> member set to -1 and the <strong>LowPart</strong> member set to the system-defined value <a href="file_use_file_pointer_position" title="#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe">FILE_USE_FILE_POINTER_POSITION</a>.</p>
</li>
<li>
<p>Pass a <strong>NULL</strong> pointer for <em>ByteOffset</em>.</p>
</li>
</ul>
<p><strong>NtReadFile</strong> updates the current file position by adding the number of bytes read when it completes the read operation, if it is using the current file position maintained by the I/O Manager.</p>
<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit <em>ByteOffset</em> value to <strong>NtReadFile</strong>. Doing this automatically changes the current file position to that <em>ByteOffset</em> value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service.</p>
<p><em>Key</em> [in, optional]</p>
<p>Device and intermediate drivers should set this pointer to <strong>NULL</strong>.</p>
<h2>Return value</h2>
<p><strong>NtReadFile</strong> returns either <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> or the appropriate <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> error code.</p>
<h2>Remarks</h2>
<p>Callers of <strong>NtReadFile</strong> must have already called <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntcreatefile"><strong>NtCreateFile</strong></a> with the FILE_READ_DATA or GENERIC_READ value set in the <em>DesiredAccess</em> parameter.</p>
<p>If the preceding call to <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntcreatefile"><strong>NtCreateFile</strong></a> set the <a href="file_no_intermediate_buffering" title="#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008">FILE_NO_INTERMEDIATE_BUFFERING</a> flag in the <em>CreateOptions</em> parameter to <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong>, the <em>Length</em> and <em>ByteOffset</em> parameters to <strong>NtReadFile</strong> must be multiples of the sector size. For more information, see <strong><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></strong>.</p>
<p><strong>NtReadFile</strong> begins reading from the given <em>ByteOffset</em> or the current file position into the given <em>Buffer</em>. It terminates the read operation under one of the following conditions:</p>
<ul>
<li>
<p>The buffer is full because the number of bytes specified by the <em>Length</em> parameter has been read. Therefore, no more data can be placed into the buffer without an overflow.</p>
</li>
<li>
<p>The end of file is reached during the read operation, so there is no more data in the file to be transferred into the buffer.</p>
</li>
</ul>
<p>If the caller opened the file with the SYNCHRONIZE flag set in <em>DesiredAccess</em>, the calling thread can synchronize to the completion of the read operation by waiting on the file handle, <em>FileHandle</em>. The handle is signaled each time that an I/O operation that was issued on the handle completes. However, the caller must not wait on a handle that was opened for synchronous file access (<a href="file_synchronous_io_nonalert" title="#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020">FILE_SYNCHRONOUS_IO_NONALERT</a> or <a href="file_synchronous_io_alert" title="#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010">FILE_SYNCHRONOUS_IO_ALERT</a>). In this case, <strong>NtReadFile</strong> waits on behalf of the caller and does not return until the read operation is complete. The caller can safely wait on the file handle only if all three of the following conditions are met:</p>
<ul>
<li>
<p>The handle was opened for asynchronous access (that is, neither FILE_SYNCHRONOUS_IO_<em>XXX</em> flag was specified).</p>
</li>
<li>
<p>The handle is being used for only one I/O operation at a time.</p>
</li>
<li>
<p><strong>NtReadFile</strong> returned STATUS_PENDING.</p>
</li>
</ul>
<p>A driver should call <strong>NtReadFile</strong> in the context of the system process if any of the following conditions exist:</p>
<ul>
<li>
<p>The driver created the file handle that it passes to <strong>NtReadFile</strong>.</p>
</li>
<li>
<p><strong>NtReadFile</strong> will notify the driver of I/O completion by means of an event that the driver created.</p>
</li>
<li>
<p><strong>NtReadFile</strong> will notify the driver of I/O completion by means of an APC callback routine that the driver passes to <strong>NtReadFile</strong>.</p>
</li>
</ul>
<p>File and event handles are valid only in the process context where the handles are created. Therefore, to avoid security holes, the driver should create any file or event handle that it passes to <strong>NtReadFile</strong> in the context of the system process rather than the context of the process that the driver is in.</p>
<p>Likewise, <strong>NtReadFile</strong> should be called in the context of the system process if it notifies the driver of I/O completion by means of an APC, because APCs are always fired in the context of the thread that issues the I/O request. If the driver calls <strong>NtReadFile</strong> in the context of a process other than the system one, the APC could be delayed indefinitely, or it might not fire at all.</p>
<p>For more information about working with files, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/using-files-in-a-driver">Using Files in a Driver</a>.</p>
<p>Callers of <strong>NtReadFile</strong> must be running at IRQL = PASSIVE_LEVEL and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/disabling-apcs">with special kernel APCs enabled</a>.</p>
<h2>Requirements</h2>
<table>
<thead>
<tr>
<th>Requirement</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client<br /></td>
<td>Windows 2000 Professional [desktop apps only]<br /></td>
</tr>
<tr>
<td>Minimum supported server<br /></td>
<td>Windows 2000 Server [desktop apps only]<br /></td>
</tr>
<tr>
<td>Target platform<br /></td>
<td><a rel="noopener" target="_blank" href="https://msdn.microsoft.com/Library/Windows/Hardware/EB2264A4-BAE8-446B-B9A5-19893936DDCA">Universal</a></td>
</tr>
<tr>
<td>Header<br /></td>
<td>Wdm.h (include Wdm.h, Ntddk.h, or Ntifs.h)</td>
</tr>
<tr>
<td>Library<br /></td>
<td>Ntdll.lib</td>
</tr>
<tr>
<td>DLL<br /></td>
<td>Ntdll.dll (user mode)</td>
</tr>
</tbody>
</table>
<h2>See also</h2>
<p><strong><a href="keinitializeevent" title="VOID KeInitializeEvent(&#10;  [out] PRKEVENT   Event,&#10;  [in]  EVENT_TYPE Type,&#10;  [in]  BOOLEAN    State&#10;);">KeInitializeEvent</a></strong></p>
<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/api/Winternl/nf-winternl-ntcreatefile"><strong>NtCreateFile</strong></a></p>
<p><strong><a href="ntqueryinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtQueryInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _Out_writes_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtQueryInformationFile</a></strong></p>
<p><strong><a href="ntsetinformationfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtSetInformationFile(&#10;    _In_ HANDLE FileHandle,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID FileInformation,&#10;    _In_ ULONG Length,&#10;    _In_ FILE_INFORMATION_CLASS FileInformationClass&#10;    );">NtSetInformationFile</a></strong></p>
<p><strong><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows/win32/devnotes/ntreadfile">View the official Win32 development documentation</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/DevNotes/ntreadfile.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>NTinternals.net (undocumented.ntinternals.net)</h1>
</div>
<div class="ntdoc-description">
<p>This function is documented in Windows Driver Kit <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntreadfile">here</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwreadfile">here</a>.</p>
<hr />
<p><em>(Also described in Win2000 DDK)</em></p>
<h3>FileHandle</h3>
<p><code>HANDLE</code> to File Object opened with <code>FILE_READ_DATA</code> access.</p>
<h3>Event</h3>
<p>Optional <code>HANDLE</code> to Event Object signaled when reading is done.</p>
<h3>ApcRoutine</h3>
<p>User defined <em>APC</em> routine queued for execute after reading is done.</p>
<h3>ApcContext</h3>
<p>User parameter to <code>ApcRoutine</code>.</p>
<h3>IoStatusBlock</h3>
<p>Pointer to IO_STATUS structure received IO status of file reading.</p>
<h3>Buffer</h3>
<p>User-allocated buffer for read data.</p>
<h3>Length</h3>
<p>Length of <code>Buffer</code>, in bytes.</p>
<h3>ByteOffset</h3>
<p>Offset from beginning of file, in bytes.</p>
<h3>Key</h3>
<p>??? (In my opinion: use this, if you previously lock file, and now you want read it, but without unlocking).</p>
<h1>Related Win32 API</h1>
<ul>
<li><a rel="noopener" target="_blank" href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a> (Although it does more than just forwarding the arguments and invoking this procedure.)</li>
</ul>
<h1>Documented by</h1>
<ul>
<li>Tomasz Nowak</li>
</ul>
<h1>See also</h1>
<ul>
<li><code><a href="ntcreatefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtCreateFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_opt_ PLARGE_INTEGER AllocationSize,&#10;    _In_ ULONG FileAttributes,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG CreateDisposition,&#10;    _In_ ULONG CreateOptions,&#10;    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,&#10;    _In_ ULONG EaLength&#10;    );">NtCreateFile</a></code></li>
<li><code><a href="ntopenfile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtOpenFile(&#10;    _Out_ PHANDLE FileHandle,&#10;    _In_ ACCESS_MASK DesiredAccess,&#10;    _In_ PCOBJECT_ATTRIBUTES ObjectAttributes,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_ ULONG ShareAccess,&#10;    _In_ ULONG OpenOptions&#10;    );">NtOpenFile</a></code></li>
<li><code><a href="ntwritefile" title="NTSYSCALLAPI&#10;NTSTATUS&#10;NTAPI&#10;NtWriteFile(&#10;    _In_ HANDLE FileHandle,&#10;    _In_opt_ HANDLE Event,&#10;    _In_opt_ PIO_APC_ROUTINE ApcRoutine,&#10;    _In_opt_ PVOID ApcContext,&#10;    _Out_ PIO_STATUS_BLOCK IoStatusBlock,&#10;    _In_reads_bytes_(Length) PVOID Buffer,&#10;    _In_ ULONG Length,&#10;    _In_opt_ PLARGE_INTEGER ByteOffset,&#10;    _In_opt_ PULONG Key&#10;    );">NtWriteFile</a></code></li>
</ul>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/undocumented.ntinternals.net/ntreadfile.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script src="modules/highlight.js/highlight.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
