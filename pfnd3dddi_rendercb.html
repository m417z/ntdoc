<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="PFND3DDDI_RENDERCB - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>PFND3DDDI_RENDERCB - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            PFND3DDDI_RENDERCB - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// d3dumddi.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">PFND3DDDI_RENDERCB Pfnd3dddiRendercb;

HRESULT Pfnd3dddiRendercb(
  HANDLE hDevice,
  <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> *unnamedParam2
)
{...}</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/pfnd3dddi_rendercb.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nc-d3dumddi-pfnd3dddi_rendercb)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="pfnd3dddi_rendercb-callback-function">PFND3DDDI_RENDERCB callback function</h1>

<h2 id="description">Description</h2>

<p>The <strong>pfnRenderCb</strong> function submits the current command buffer for rendering to the display miniport driver.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="hdevice"><code>hDevice</code></h3>

<p>A handle to the display device (graphics context).</p>

<h3 id="unnamedparam2"><code>unnamedParam2</code></h3>

<p><em>pData</em> [in, out]</p>

<p>A pointer to a <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> structure that describes the current command buffer to render.</p>

<h2 id="return-value">Return value</h2>

<p><strong>pfnRenderCb</strong> returns one of the following values:</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>S_OK</td>
  <td>The command buffer was successfully rendered.</td>
</tr>
<tr>
  <td>D3DDDIERR_PRIVILEGEDINSTRUCTION</td>
  <td>The display miniport driver detected a privileged instruction in the command buffer; privileged instructions cannot be present in a command buffer.</td>
</tr>
<tr>
  <td>D3DDDIERR_ILLEGALINSTRUCTION</td>
  <td>The display miniport driver detected instructions that graphics hardware cannot support.</td>
</tr>
<tr>
  <td>D3DDDIERR_INVALIDHANDLE</td>
  <td>The display miniport driver detected an invalid handle in the command buffer.</td>
</tr>
<tr>
  <td>D3DDDIERR_CANTRENDERLOCKEDALLOCATION</td>
  <td>The video memory manager detected references to a locked allocation in the allocation list. Note that the video memory manager returns this error only if it could not reposition the allocation to an AGP or system memory segment.</td>
</tr>
<tr>
  <td>D3DDDIERR_INVALIDUSERBUFFER</td>
  <td>The display miniport driver detected an underrun or overrun of data or instructions. That is, the driver received less or more instructions or data than it expected.</td>
</tr>
<tr>
  <td>E_OUTOFMEMORY</td>
  <td>pfnRenderCb could not complete because of insufficient memory.</td>
</tr>
<tr>
  <td>E_INVALIDARG</td>
  <td>Parameters were validated and determined to be incorrect.</td>
</tr>
</tbody>
</table>

<p>This function might also return other HRESULT values.</p>

<h2 id="remarks">Remarks</h2>

<p>When the user-mode display driver must submit the current command buffer for rendering to the display miniport driver (for example, during a call to the user-mode display driver's <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfddi/nf-wudfddi-iwdfworkitem-flush">Flush</a> or Flush(D3D10) function), the user-mode display driver must call the <strong>pfnRenderCb</strong> function. The user-mode display driver should set the <em>hDevice</em> parameter to the value the Microsoft Direct3D runtime supplied during the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_createdevice">CreateDevice</a> or CreateDevice(D3D10) call. In the <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> structure that is pointed to by the <em>pData</em> parameter, the user-mode display driver should also set:</p>

<ul>
<li>The <strong>CommandLength</strong> member to the number of bytes of commands in the command buffer that start from offset zero.</li>
<li>The <strong>CommandOffset</strong> member to nonzero if the user-mode display driver must specify an offset to the first hardware command in the command buffer.</li>
<li>The <strong>NumAllocations</strong> member to the number of elements in the allocation list.</li>
<li>The <strong>NumPatchLocations</strong> member to the number of elements in the patch-location list.</li>
</ul>

<p>After a call to <strong>pfnRenderCb</strong>, the user-mode display driver must determine the base address and size of the command buffer that it should use for its next submission from the values that are returned in the <strong>pNewCommandBuffer</strong> and <strong>NewCommandBufferSize</strong> members of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a>. Similarly, the driver must determine the base address and number of elements of the next allocation list and patch-location list from the values that are returned in the <strong>pNewAllocationList</strong> and <strong>NewAllocationListSize</strong> members and <strong>pNewPatchLocationList</strong> and <strong>NewPatchLocationListSize</strong> members respectively.</p>

<p>If the user-mode display driver detects that most of the command buffer flushes are because the driver runs out of space in the command buffer, allocation list, or patch-location list, the driver can request for them to be resized. To resize the command buffer, the driver sets the <strong>ResizeCommandBuffer</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> and puts the requested size in the <strong>NewCommandBufferSize</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a>. Similarly, to resize the allocation list, the driver sets the <strong>ResizeAllocationList</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> and puts the requested number of elements in the <strong>NewAllocationListSize</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a>. To resize the patch-location list, the driver sets the <strong>ResizePatchLocationList</strong> bit-field flag in the <strong>Flags</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> and puts the requested number of elements in the <strong>NewPatchLocationListSize</strong> member of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a>.</p>

<p><strong>Note</strong> Even though the driver can request that the command buffer and the allocation and patch-location lists be resized, the video memory manager might not be able to comply. Therefore, regardless of whether the call to <strong>pfnRenderCb</strong> is successful, the driver should verify the values that are returned in the <strong>NewCommandBufferSize</strong>, <strong>NewAllocationListSize</strong>, and <strong>NewPatchLocationListSize</strong> members of <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a>.</p>

<p>If the user-mode display driver sets the <strong>hContext</strong> member of the <a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a> structure that is pointed to by the <em>pData</em> parameter to <strong>NULL</strong>, the Microsoft Direct3D runtime sends the rendering operation to the default context of the device. If the user-mode display driver sets <strong>hContext</strong> to a valid handle that the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff568895(v=vs.85)">pfnCreateContextCb</a> function previously returned and that represents a device context, the Direct3D runtime sends the rendering operation to that context. <strong>Direct3D Version 11 Note:</strong> For more information about how the driver calls <strong>pfnRenderCb</strong>, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/display/changes-from-direct3d-10">Changes from Direct3D 10</a>.</p>

<h4 id="examples">Examples</h4>

<p>The following code example shows how to submit the current command buffer for rendering to the display miniport driver. This code example generates the allocation list after the command buffer and patch list are generated. This is not optimal for performance because the command buffer is parsed more than necessary. However, this implementation is easier to show. In a production driver, generating the command buffer at the same time as the allocation and patch lists is more efficient.</p>

<div class="codehilite">
<pre><span></span><code><span class="n">VOID</span><span class="w"> </span><span class="nf">CD3DContext::SubmitDXVABuffer</span><span class="p">(</span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="w"> </span><span class="n">Size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n"><a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a></span><span class="w">     </span><span class="n">renderCBData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="n"><a href="dword" title="typedef unsigned long DWORD;">DWORD</a></span><span class="w">               </span><span class="n">dwAllocationListUsed</span><span class="p">;</span>
<span class="w">    </span><span class="n">HRESULT</span><span class="w">             </span><span class="n">hr</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GenerateAllocationListFromCmdBuf</span><span class="p">(</span><span class="n">R200UpdateQSParamsForDXVASubmit</span><span class="p">(</span><span class="n">m_pR200Ctx</span><span class="p">,</span><span class="w"> </span><span class="n">Size</span><span class="p">),</span><span class="w"> </span><span class="n">m_sContexts</span><span class="p">[</span><span class="n">MULTI_ENGINE_NODE_VIDEO</span><span class="p">].</span><span class="n">pHwCmdBufAllocList</span><span class="p">,</span><span class="w"> </span><span class="n">m_dwHwCmdBufAllocListSize</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dwAllocationListUsed</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FALSE</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">DBG_BREAK</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 3-D and video packets must be in sync. If the last packet that was sent went to</span>
<span class="w">    </span><span class="c1">// the 3-D engine, that packet must finish before the new packet runs on the hardware.</span>

<span class="w">    </span><span class="n">renderCBData</span><span class="p">.</span><span class="n">CommandOffset</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">renderCBData</span><span class="p">.</span><span class="n">CommandLength</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">Size</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">UMD_CMDBUF_INFO</span><span class="p">);</span>
<span class="w">    </span><span class="n">renderCBData</span><span class="p">.</span><span class="n">NumAllocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dwAllocationListUsed</span><span class="p">;</span>
<span class="w">    </span><span class="n">renderCBData</span><span class="p">.</span><span class="n">hContext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_sContexts</span><span class="p">[</span><span class="n">MULTI_ENGINE_NODE_VIDEO</span><span class="p">].</span><span class="n">hContext</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Copy command-buffer data from the internal buffer to the buffer that was created by dxgkrnl</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">m_sContexts</span><span class="p">[</span><span class="n">MULTI_ENGINE_NODE_VIDEO</span><span class="p">].</span><span class="n">pHwCmdBuf</span><span class="p">,</span><span class="w"> </span><span class="n">m_pHwCmdBuf</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GetCmdBufPreambleSize</span><span class="p">(</span><span class="n">m_pR200Ctx</span><span class="p">),</span><span class="w"> </span><span class="n">renderCBData</span><span class="p">.</span><span class="n">CommandLength</span><span class="p">);</span>

<span class="w">    </span><span class="n">m_d3dCallbacks</span><span class="p">.</span><span class="n">pfnRenderCb</span><span class="p">(</span><span class="n">m_hD3D</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">renderCBData</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Makes video the last engine that work was submitted to</span>
<span class="w">        </span><span class="n">m_LastEngineSubmit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MULTI_ENGINE_NODE_VIDEO</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre>
</div>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_createdevice">CreateDevice</a></p>

<p><a href="d3dddicb_render" title="typedef struct _D3DDDICB_RENDER {&#10;  UINT                     CommandLength;&#10;  UINT                     CommandOffset;&#10;  UINT                     NumAllocations;&#10;  UINT                     NumPatchLocations;&#10;  VOID                     *pNewCommandBuffer;&#10;  UINT                     NewCommandBufferSize;&#10;  D3DDDI_ALLOCATIONLIST    *pNewAllocationList;&#10;  UINT                     NewAllocationListSize;&#10;  D3DDDI_PATCHLOCATIONLIST *pNewPatchLocationList;&#10;  UINT                     NewPatchLocationListSize;&#10;  D3DDDICB_RENDERFLAGS     Flags;&#10;  HANDLE                   hContext;&#10;  UINT                     BroadcastContextCount;&#10;  HANDLE                   BroadcastContext[D3DDDI_MAX_BROADCAST_CONTEXT];&#10;  ULONG                    QueuedBufferCount;&#10;  D3DGPU_VIRTUAL_ADDRESS   NewCommandBuffer;&#10;  VOID                     *pPrivateDriverData;&#10;  UINT                     PrivateDriverDataSize;&#10;  D3DDDI_MARKERLOGTYPE     MarkerLogType;&#10;...">D3DDDICB_RENDER</a></p>

<p><a href="d3dddi_devicecallbacks" title="typedef struct _D3DDDI_DEVICECALLBACKS {&#10;  PFND3DDDI_ALLOCATECB                            pfnAllocateCb;&#10;  PFND3DDDI_DEALLOCATECB                          pfnDeallocateCb;&#10;  PFND3DDDI_SETPRIORITYCB                         pfnSetPriorityCb;&#10;  PFND3DDDI_QUERYRESIDENCYCB                      pfnQueryResidencyCb;&#10;  PFND3DDDI_SETDISPLAYMODECB                      pfnSetDisplayModeCb;&#10;  PFND3DDDI_PRESENTCB                             pfnPresentCb;&#10;  PFND3DDDI_RENDERCB                              pfnRenderCb;&#10;  PFND3DDDI_LOCKCB                                pfnLockCb;&#10;  PFND3DDDI_UNLOCKCB                              pfnUnlockCb;&#10;  PFND3DDDI_ESCAPECB                              pfnEscapeCb;&#10;  PFND3DDDI_CREATEOVERLAYCB                       pfnCreateOverlayCb;&#10;  PFND3DDDI_UPDATEOVERLAYCB                       pfnUpdateOverlayCb;&#10;  PFND3DDDI_FLIPOVERLAYCB                         pfnFlipOverlayCb;&#10;  PFND3DDDI_DESTROYOVERLAYCB                      pfnDestroyOverlayCb;&#10;  PFND3DDDI_CREATECONTEXTCB                       pfnCreateContextCb;&#10;  PFND3DDDI_DESTROYCONTEXTCB                      pfnDestroyContextCb;&#10;  PFND3DDDI_CREATESYNCHRONIZATIONOBJECTCB         pfnCreateSynchronizationObjectCb;&#10;  PFND3DDDI_DESTROYSYNCHRONIZATIONOBJECTCB        pfnDestroySynchronizationObjectCb;&#10;  PFND3DDDI_WAITFORSYNCHRONIZATIONOBJECTCB        pfnWaitForSynchronizationObjectCb;&#10;...">D3DDDI_DEVICECALLBACKS</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/wudfddi/nf-wudfddi-iwdfworkitem-flush">Flush</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/ff568895(v=vs.85)">pfnCreateContextCb</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/d3dumddi/nc-d3dumddi-pfnd3dddi_rendercb.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
