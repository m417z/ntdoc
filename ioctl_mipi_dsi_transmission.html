<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="IOCTL_MIPI_DSI_TRANSMISSION - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>IOCTL_MIPI_DSI_TRANSMISSION - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            IOCTL_MIPI_DSI_TRANSMISSION - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// ntddvdeo.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">// <a href="ctl_code" title="void CTL_CODE(&#10;  DeviceType,&#10;  Function,&#10;  Method,&#10;  Access&#10;);">CTL_CODE</a>(0x0023, 0x501, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MIPI_DSI_TRANSMISSION 0x00231404</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddvdeo/ni-ntddvdeo-ioctl_mipi_dsi_transmission">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/ioctl_mipi_dsi_transmission.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ni-ntddvdeo-ioctl_mipi_dsi_transmission)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="ioctl_mipi_dsi_transmission-ioctl">IOCTL_MIPI_DSI_TRANSMISSION IOCTL</h1>

<h2 id="description">Description</h2>

<p>Major Code: <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/irp-mj-device-control">IRP_MJ_DEVICE_CONTROL</a></p>

<p><strong>IOCTL_MIPI_DSI_TRANSMISSION</strong> is issued to send a sequence of MIPI DSI packets to a peripheral.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="major-code">Major code</h3>

<h3 id="input-buffer">Input buffer</h3>

<p>n/a</p>

<h3 id="input-buffer-length">Input buffer length</h3>

<p>n/a</p>

<h3 id="output-buffer">Output buffer</h3>

<p>n/a</p>

<h3 id="output-buffer-length">Output buffer length</h3>

<p>n/a</p>

<h3 id="inputoutput-buffer">Input/output buffer</h3>

<p>A <a rel="noopener" target="_blank" href="dxgk_dsi_transmission"><strong>DXGK_DSI_TRANSMISSION</strong></a> structure followed by <a rel="noopener" target="_blank" href="dxgk_dsi_packet"><strong>DXGK_DSI_PACKET</strong></a> structures containing the packets.</p>

<h3 id="inputoutput-buffer-length">Input/output buffer length</h3>

<p>At least <code>sizeof(<a href="dxgk_dsi_transmission" title="typedef struct _DXGK_DSI_TRANSMISSION {&#10;  UINT            TotalBufferSize;&#10;  BYTE            PacketCount;&#10;  BYTE            FailedPacket;&#10;  struct {&#10;    WORD TransmissionMode : 2;&#10;    WORD ReportMipiErrors : 1;&#10;    WORD ClearMipiErrors : 1;&#10;    WORD SecondaryPort : 1;&#10;    WORD ManufacturingMode : 1;&#10;    WORD Reserved : 10;&#10;  };&#10;  WORD            ReadWordCount;&#10;  WORD            FinalCommandExtraPayload;&#10;  WORD            MipiErrors;&#10;  WORD            HostErrors;&#10;  DXGK_DSI_PACKET Packets[1];&#10;} DXGK_DSI_TRANSMISSION, *PDXGK_DSI_TRANSMISSION;">DXGK_DSI_TRANSMISSION</a>) + ((PacketCount - 1) * sizeof(<a href="dxgk_dsi_packet" title="typedef struct _DXGK_DSI_PACKET {&#10;  union {&#10;    BYTE DataId;&#10;    struct {&#10;      BYTE DataType : 6;&#10;      BYTE VirtualChannel : 2;&#10;    };&#10;  };&#10;  union {&#10;    struct {&#10;      BYTE Data0;&#10;      BYTE Data1;&#10;    };&#10;    WORD LongWriteWordCount;&#10;  };&#10;  BYTE  EccFiller;&#10;  BYTE  Payload[DXGK_DSI_PACKET_EMBEDDED_PAYLOAD_SIZE];&#10;} DXGK_DSI_PACKET, *PDXGK_DSI_PACKET;">DXGK_DSI_PACKET</a>)) + FinalPacketExtraPayload</code>. See Remarks for details.</p>

<h3 id="status-block">Status block</h3>

<p><strong>Irp->IoStatus.Status</strong> is set to <a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a> if the request is successful.
Otherwise, <strong>Status</strong> is set to the appropriate error condition as a <a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> code. For more information, see <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/kernel/ntstatus-values">NTSTATUS Values</a>.</p>

<h2 id="remarks">Remarks</h2>

<p>Monitor, oem-panel, and display port/miniport drivers must handle Mobile Industry Processor Interface (MIPI) Digital Serial Interface(DSI) IOCTLs.</p>

<h3 id="performing-transmissions">Performing Transmissions</h3>

<p>To allow a panel driver to interact over this otherwise private interface between the graphics adapter and panel hardware, the transactions must either have no graphics driver effect, other than time occupying the bus, or they must be fully defined so that the graphics driver is in control. Since the point of allowing a panel driver to interact is to provide support for custom panel features which are opaque to the graphics driver, fully defined operations are intended to be restricted to transactions where the panel driver needs to perform a standardized operation which cannot be performed without the graphics driver involvement. Such transactions will be treated as exceptions routed explicitly rather than as transmissions.</p>

<p>Each transmission request consists of a single buffer which is filled by the OEM panel driver, passed down the monitor stack and returned with the results of the transmission, if any. The buffer contains overall information about the transmission, with both input and output fields, followed by a variable sized array of <a rel="noopener" target="_blank" href="dxgk_dsi_packet"><strong>DXGK_DSI_PACKET</strong></a> structures. The packets are described in DSI terms, such that any DSI packet can be described however the OS will parse the packets and reject any transmission that includes disallowed packets. All packets except the last are, by DSI definition, write packets that may be either short writes, in which case the <strong>Payload</strong> buffer is unused, or long writes which fit within the <strong>Payload</strong> buffer. The last packet in a transmission, which may be a read or a write, is allowed to use an extended payload by allocating and describing a larger buffer which will allows space for reads or writes of any size up to the DSI long packet data limit of 64K-1 data bytes. This allows sequences of small write packets to be queued to the driver in a single call but does require that larger packets are sent individually. The value of the <strong>FinalPacketExtraPayload</strong> field indicates how many extra bytes have been allocated but this must also be accounted for in the <strong>TotalBufferSize</strong> field.</p>

<p>The OEM panel driver is responsible for ensuring that the transmissions it requests do not conflict or interfere with other transmissions that the graphics driver uses for normal interaction with the panel due to excessive requests or requesting operations which would cause delays in processing other transmissions. The panel driver must not change any state which would cause subsequent failures in the graphics driver, for example changing the panel timing via MCS commands. Similarly, if the OS has requested a display change, via the graphics driver, for example an increase in brightness, the panel driver must not use DSI commands to undo that change, either in response or for other purposes.</p>

<p><strong>IOCTL_MIPI_DSI_TRANSMISSION</strong> is used to request a transmission to the peripheral containing one or more DSI packets. The panel driver must always initialize <strong>TotalBufferSize</strong>, <strong>PacketCount</strong> and the first three BYTES of each packet. The panel driver may override the default behavior using non-zero values for <strong>TransmissionMode</strong>, <strong>ReportMipiErrors</strong>, <strong>ClearMipiErrors</strong>, <strong>SecondaryPort</strong>, <strong>ManufacturingMode</strong> and <strong>FinalCommandExtraPayload</strong>. All uninitialized values must be set to zero.</p>

<p>The OS will ensure that the sequence of DSI packets is well-formed, with valid info in all defined fields and correct buffer sizes. The OS is responsible for initializing the <strong>FailedPacket</strong> field to DXGK_DSI_INVALID_PACKET_INDEX so that further validation in the OS or driver only needs to set the field if a problem is found with a particular packet. If the <a rel="noopener" target="_blank" href="dxgk_dsi_transmission"><strong>DXGK_DSI_TRANSMISSION</strong></a> structure is not well-formed, the OS will set the DXGK_HOST_DSI_INVALID_TRANSMISSION flag in the *<em>HostErrors</em>* field to distinguish this from other invalid params errors.</p>

<p>To be considered well-formed, the following must all be true:</p>

<ul>
<li>TotalBufferSize &gt;= sizeof(<a href="dxgk_dsi_transmission" title="typedef struct _DXGK_DSI_TRANSMISSION {&#10;  UINT            TotalBufferSize;&#10;  BYTE            PacketCount;&#10;  BYTE            FailedPacket;&#10;  struct {&#10;    WORD TransmissionMode : 2;&#10;    WORD ReportMipiErrors : 1;&#10;    WORD ClearMipiErrors : 1;&#10;    WORD SecondaryPort : 1;&#10;    WORD ManufacturingMode : 1;&#10;    WORD Reserved : 10;&#10;  };&#10;  WORD            ReadWordCount;&#10;  WORD            FinalCommandExtraPayload;&#10;  WORD            MipiErrors;&#10;  WORD            HostErrors;&#10;  DXGK_DSI_PACKET Packets[1];&#10;} DXGK_DSI_TRANSMISSION, *PDXGK_DSI_TRANSMISSION;">DXGK_DSI_TRANSMISSION</a>) + ((PacketCount - 1) * sizeof(<a href="dxgk_dsi_packet" title="typedef struct _DXGK_DSI_PACKET {&#10;  union {&#10;    BYTE DataId;&#10;    struct {&#10;      BYTE DataType : 6;&#10;      BYTE VirtualChannel : 2;&#10;    };&#10;  };&#10;  union {&#10;    struct {&#10;      BYTE Data0;&#10;      BYTE Data1;&#10;    };&#10;    WORD LongWriteWordCount;&#10;  };&#10;  BYTE  EccFiller;&#10;  BYTE  Payload[DXGK_DSI_PACKET_EMBEDDED_PAYLOAD_SIZE];&#10;} DXGK_DSI_PACKET, *PDXGK_DSI_PACKET;">DXGK_DSI_PACKET</a>)) + FinalPacketExtraPayload</li>
<li>FinalPacketExtraPayload &lt;= 64K-1-DXGK_DSI_PACKET_EMBEDDED_PAYLOAD_SIZE (0xFFF7)</li>
<li>TotalBufferSize &lt;= <a href="round_to_pages" title="#define ROUND_TO_PAGES(Size) (((ULONG_PTR)(Size) + PAGE_MASK) &amp; ~PAGE_MASK)">ROUND_TO_PAGES</a>( sizeof(<a href="dxgk_dsi_transmission" title="typedef struct _DXGK_DSI_TRANSMISSION {&#10;  UINT            TotalBufferSize;&#10;  BYTE            PacketCount;&#10;  BYTE            FailedPacket;&#10;  struct {&#10;    WORD TransmissionMode : 2;&#10;    WORD ReportMipiErrors : 1;&#10;    WORD ClearMipiErrors : 1;&#10;    WORD SecondaryPort : 1;&#10;    WORD ManufacturingMode : 1;&#10;    WORD Reserved : 10;&#10;  };&#10;  WORD            ReadWordCount;&#10;  WORD            FinalCommandExtraPayload;&#10;  WORD            MipiErrors;&#10;  WORD            HostErrors;&#10;  DXGK_DSI_PACKET Packets[1];&#10;} DXGK_DSI_TRANSMISSION, *PDXGK_DSI_TRANSMISSION;">DXGK_DSI_TRANSMISSION</a>) + (0xFE * sizeof(<a href="dxgk_dsi_packet" title="typedef struct _DXGK_DSI_PACKET {&#10;  union {&#10;    BYTE DataId;&#10;    struct {&#10;      BYTE DataType : 6;&#10;      BYTE VirtualChannel : 2;&#10;    };&#10;  };&#10;  union {&#10;    struct {&#10;      BYTE Data0;&#10;      BYTE Data1;&#10;    };&#10;    WORD LongWriteWordCount;&#10;  };&#10;  BYTE  EccFiller;&#10;  BYTE  Payload[DXGK_DSI_PACKET_EMBEDDED_PAYLOAD_SIZE];&#10;} DXGK_DSI_PACKET, *PDXGK_DSI_PACKET;">DXGK_DSI_PACKET</a>)) + 0xFFF7 )</li>
<li>PacketCount != 0</li>
<li>Only the last packet is allowed to be a read</li>
<li>Only a final long write packet can have a LongWriteWordCount value larger than DXGK_DSI_PACKET_EMBEDDED_PAYLOAD_SIZE</li>
</ul>

<h3 id="packet-validation">Packet Validation</h3>

<p>Although the OS will not attempt to fully validate the content of all packets, it will reject a transmission containing any DSI commands other than the following, completing the IOCTL without calling the graphics driver:</p>

<table>
<thead>
<tr>
  <th>Data type value</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0x03</td>
  <td>Generic Short WRITE, no parameters</td>
</tr>
<tr>
  <td>0x13</td>
  <td>Generic Short WRITE, 1 parameter</td>
</tr>
<tr>
  <td>0x23</td>
  <td>Generic Short WRITE, 2 parameters</td>
</tr>
<tr>
  <td>0x04</td>
  <td>Generic READ, no parameters</td>
</tr>
<tr>
  <td>0x14</td>
  <td>Generic READ, 1 parameter</td>
</tr>
<tr>
  <td>0x24</td>
  <td>Generic READ, 2 parameters</td>
</tr>
<tr>
  <td>0x05</td>
  <td>DCS Short WRITE, no parameters</td>
</tr>
<tr>
  <td>0x15</td>
  <td>DCS Short WRITE, 1 parameter</td>
</tr>
<tr>
  <td>0x06</td>
  <td>DCS READ, no parameters</td>
</tr>
<tr>
  <td>0x29</td>
  <td>Generic Long Write</td>
</tr>
<tr>
  <td>0x39</td>
  <td>DCS Long Write/write_LUT</td>
</tr>
</tbody>
</table>

<p>Generic read and write commands require understanding the panel specification so the expectation is that these commands can be used freely by the panel driver without causing problems for the graphics driver as long as the bus is not used excessively. Similarly, DCS MCS commands are explicitly defined for manufacturer use so there should be no problem with interference between the graphics driver and the panel driver.</p>

<p>For DCS UCS, undefined commands are not expected to be used by the graphics driver, so the OS will allow them to be used by the panel driver although there is clearly a risk that future <a rel="noopener" target="_blank" href="https://www.mipi.org/specifications/display-command-set">MIPI-DCS</a> spec changes define the command so MCS commands are preferred.</p>

<p>Standardized DCS UCS commands will be used by the graphics driver during normal operation and are potentially usable by the panel driver so the risk of commands sent by the OEM panel driver causing problems with subsequent graphics driver commands needs to be mitigated. To do this, the OS will parse DCS commands and reject packets which are expected to cause conflicts unless the OEM panel driver sets the <code>ManufacturingMode</code> flag and the OS confirms that the system is in manufacturing mode. If the flag is set but the system is not in manufacturing mode, the transmission IOCTL will be completed with the <strong>DXGK_HOST_DSI_INVALID_TRANSMISSION</strong> flag set in the <code>HostErrors</code> field without calling the graphics driver.</p>

<p>Conditions which would require a fully defined transaction instead of using a transmission would be where:</p>

<ul>
<li>Timed idle periods are required before or after, such as DCS soft_reset</li>
<li>Changing the operating environment for frame output, such as DCS set_vsync_timing and enter_sleep_mode</li>
<li>Using transactions with start/continue semantics where the graphics driver may also need to access the same data, such as DCS write_memory_start/write_memory_continue</li>
</ul>

<p>In addition, there are classes of DCS commands that will be rejected by the OS when sent as a transmission:</p>

<ul>
<li>Any command which would need to be fully defined, as described above</li>
<li>Reads of pixel data which could be used for screen scraping</li>
<li>Writes of pixel data</li>
</ul>

<p>UCS commands that the OS will pass through to the graphics driver</p>

<table>
<thead>
<tr>
  <th>Hex</th>
  <th>Command</th>
</tr>
</thead>
<tbody>
<tr>
  <td>00h</td>
  <td>nop</td>
</tr>
<tr>
  <td>26h</td>
  <td>set_gamma_curve</td>
</tr>
<tr>
  <td>2Dh</td>
  <td>write_LUT</td>
</tr>
<tr>
  <td>51h</td>
  <td>set_display_brightness</td>
</tr>
<tr>
  <td>52h</td>
  <td>get_display_brightness</td>
</tr>
<tr>
  <td>53h</td>
  <td>write_control_display</td>
</tr>
<tr>
  <td>54h</td>
  <td>get_control_display</td>
</tr>
<tr>
  <td>55h</td>
  <td>write_power_save</td>
</tr>
<tr>
  <td>56h</td>
  <td>get_power_save</td>
</tr>
<tr>
  <td>5Eh</td>
  <td>set_CABC_min_brightness</td>
</tr>
<tr>
  <td>5Fh</td>
  <td>get_CABC_min_brightness</td>
</tr>
<tr>
  <td>03h</td>
  <td>get_compression_mode</td>
</tr>
<tr>
  <td>05h</td>
  <td>get_error_count_on_DSI</td>
</tr>
<tr>
  <td>06h</td>
  <td>get_red_channel</td>
</tr>
<tr>
  <td>07h</td>
  <td>get_green_channel</td>
</tr>
<tr>
  <td>08h</td>
  <td>get_blue_channel</td>
</tr>
<tr>
  <td>0Ah</td>
  <td>get_power_mode</td>
</tr>
<tr>
  <td>0Bh</td>
  <td>get_address_mode</td>
</tr>
<tr>
  <td>0Ch</td>
  <td>get_pixel_format</td>
</tr>
<tr>
  <td>0Dh</td>
  <td>get_display_mode</td>
</tr>
<tr>
  <td>0Eh</td>
  <td>get_signal_mode</td>
</tr>
<tr>
  <td>0Fh</td>
  <td>get_diagnostic_result</td>
</tr>
<tr>
  <td>14h</td>
  <td>get_image_checksum_rgb</td>
</tr>
<tr>
  <td>15h</td>
  <td>get_image_checksum_ct</td>
</tr>
<tr>
  <td>3Fh</td>
  <td>get_3D_control</td>
</tr>
<tr>
  <td>45h</td>
  <td>get_scanline</td>
</tr>
</tbody>
</table>

<p>UCS commands that the OS will reject</p>

<table>
<thead>
<tr>
  <th>Hex</th>
  <th>Command</th>
</tr>
</thead>
<tbody>
<tr>
  <td>01h</td>
  <td>soft_reset - note, this must be sent via an <a rel="noopener" target="_blank" href="ioctl_mipi_dsi_reset">IOCTL_MIPI_DSI_RESET</a></td>
</tr>
<tr>
  <td>10h</td>
  <td>enter_sleep_mode</td>
</tr>
<tr>
  <td>11h</td>
  <td>exit_sleep_mode</td>
</tr>
<tr>
  <td>12h</td>
  <td>enter_partial_mode</td>
</tr>
<tr>
  <td>13h</td>
  <td>enter_normal_mode</td>
</tr>
<tr>
  <td>20h</td>
  <td>exit_invert_mode</td>
</tr>
<tr>
  <td>21h</td>
  <td>enter_invert_mode</td>
</tr>
<tr>
  <td>28h</td>
  <td>set_display_off</td>
</tr>
<tr>
  <td>29h</td>
  <td>set_display_on</td>
</tr>
<tr>
  <td>2Ah</td>
  <td>set_column_address</td>
</tr>
<tr>
  <td>2Bh</td>
  <td>set_page_address</td>
</tr>
<tr>
  <td>2Ch</td>
  <td>write_memory_start</td>
</tr>
<tr>
  <td>2Eh</td>
  <td>read_memory_start</td>
</tr>
<tr>
  <td>30h</td>
  <td>set_partial_rows</td>
</tr>
<tr>
  <td>31h</td>
  <td>set_partial_columns</td>
</tr>
<tr>
  <td>33h</td>
  <td>set_scroll_area</td>
</tr>
<tr>
  <td>34h</td>
  <td>set_tear_off</td>
</tr>
<tr>
  <td>35h</td>
  <td>set_tear_on</td>
</tr>
<tr>
  <td>36h</td>
  <td>set_address_mode</td>
</tr>
<tr>
  <td>37h</td>
  <td>set_scroll_start</td>
</tr>
<tr>
  <td>38h</td>
  <td>exit_idle_mode</td>
</tr>
<tr>
  <td>39h</td>
  <td>enter_idle_mode</td>
</tr>
<tr>
  <td>3Ah</td>
  <td>set_pixel_format</td>
</tr>
<tr>
  <td>3Ch</td>
  <td>write_memory_continue</td>
</tr>
<tr>
  <td>3Dh</td>
  <td>set_3D_control</td>
</tr>
<tr>
  <td>3Eh</td>
  <td>read_memory_continue</td>
</tr>
<tr>
  <td>40h</td>
  <td>set_vsync_timing</td>
</tr>
<tr>
  <td>44h</td>
  <td>set_tear_scanline</td>
</tr>
<tr>
  <td>A1h</td>
  <td>read_DDB_start</td>
</tr>
<tr>
  <td>A2h</td>
  <td>read_PPS_start</td>
</tr>
<tr>
  <td>A8h</td>
  <td>read_DDB_continue</td>
</tr>
<tr>
  <td>A9h</td>
  <td>read_PPS_continue</td>
</tr>
</tbody>
</table>

<blockquote>
  <p>[!NOTE]
  The OS validation policies may be modified in future releases.</p>
</blockquote>

<h3 id="graphics-driver-implementation">Graphics Driver Implementation</h3>

<p>If the transmission passes OS validation, the OS passes the buffer to the graphics driver using <a rel="noopener" target="_blank" href="dxgkddi_dsitransmission"><strong>DsiTransmission</strong></a>.</p>

<p>Adding OEM transmissions into an interface which is already being used to send both pixel and control data based on OS requests and the needs of peripheral control, inevitably means that the graphics driver will need to enhance its internal sequencing to ensure that this additional stream of packets can be incorporated correctly. The graphics driver must not reorder packets within a transmission from the OEM panel driver and must send the entire sequence uninterrupted and without interleaving of other packets. The graphics driver is not required to maintain the order of its own packets with respect to the time of arrival of OEM panel transmission request, so may elect to send packets to set up the following frame before (or after) sending an OEM panel transmission. If completion of a started OEM panel transmission threatens to cause critical packets to miss their time window, the driver should report the transmission as cancelled. If a transmission has not started but the driver expects it to cause critical packets to miss their time window, the driver should defer starting the transmission until the next blanking period. If deferring an OEM panel transmission would cause it to have been waiting for more than two frames to start, the driver should report the transmission as dropped.</p>

<p>It is not possible for a graphics driver to ensure that the transmissions it is sending on behalf of the panel driver do not conflict with the transmissions over which it has control. The driver may choose to inspect packets within a transmission and reject the transmission if they would cause problems but any packets which are considered to be unsafe should be flagged for OS level rejection, so driver level rejection should ideally be due to graphics vendor specific concerns. The driver must not attempt to cache or optimize either reads or writes, even if the packets appear to be standardized commands.</p>

<p>If the graphics driver rejects a transmission due to a problem with a packet, it must update the <code>FailedPacket</code> field with the index of the first packet causing the transmission to be rejected and set the <code>HostErrors</code> DXGK_HOST_DSI_DRIVER_REJECTED_PACKET flag before returning. If a transmission mode override is provided, the driver should verify that the override is compatible with its hardware constraints and if not, set the <code>HostErrors</code> DXGK_HOST_DSI_BAD_TRANSMISSION_MODE flag before returning.</p>

<p>If a failure occurs during communication, the graphics driver should update the <code>FailedPacket</code> field with the index of the packet which failed however it may not be possible in all cases for the driver to identify the packet so the driver should leave the default value, DXGK_DSI_INVALID_PACKET_INDEX, for such cases.</p>

<p>The graphics driver is responsible for the communication of the packets so must ensure any check sums are calculated and verified. Any transmission which ends with a read, will be a short packet, so the Data0 and Data1 fields contain any parameters and the response may be either a short or long packet. The graphics driver may not know which form and how long the returned data will be but the maximum size is the full size of the payload for the final packet, including the <code>FinalPacketExtraPayload</code>. The OS will validate that this value is no larger than the <code>TargetMaximumReturnPacketSize</code> reported by the driver in its capabilities for the target but the driver must ensure both that this buffer is not overrun by a peripheral reporting more data, and that data from the peripheral is not truncated due to being larger than the MaximumReturnPacketSize currently applied to the peripheral. The driver writes the number of bytes read into the buffer into the <code>ReadWordCount</code> field describing the transmission.</p>

<p>There may be cases where the graphics driver is forced to reset either the communications interface to the panel, or the whole panel due to errors which may not be related to and may not be observable to the OEM panel driver. To deal with this, the driver must report either DXGK_HOST_DSI_INTERFACE_RESET or DXGK_HOST_DSI_DEVICE_RESET set in the <code>HostErrors</code> field on the first transmission attempt following the reset so that the OEM panel driver can detect the situation and recover. The driver must not send this transmission to the hardware but the OEM panel driver may simply retry the same command if no recovery is required, in which case the driver should proceed with processing the transmission as usual.</p>

<h3 id="completing-a-transmission">Completing a Transmission</h3>

<p>When the IOCTL completes the <code>FailedPacket</code>, <code>ReadWordCount</code>, <code>MipiErrors</code>, <code>HostErrors</code> and payload for a read (final) packet may have been updated depending on the outcome. If errors were found while processing the transmission, the OEM panel driver needs to use the <code>MipiErrors</code> and <code>HostErrors</code> output values to determine how to recover and proceed.</p>

<p>To ensure that output is returned to the caller to provide details of any errors, IOCTL and DDI calls need to report a success, even if errors are found. Success does not indicate that the transaction was successful, it indicates that the calls to handle the transaction proceeded as expected and error flags have been set, if appropriate. Failures may still be reported for conditions such as an unsupported DDI call (presumably due to a driver mismatch), memory allocation failures or passing completely bad parameters, such as passing a NULL buffer. If no errors are reported for a successful call, the caller should assume that the transaction was successful.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="dxgkddi_dsitransmission"><strong>DsiTransmission</strong></a></p>

<p><a rel="noopener" target="_blank" href="dxgk_dsi_packet"><strong>DXGK_DSI_PACKET</strong></a></p>

<p><a rel="noopener" target="_blank" href="dxgk_dsi_transmission"><strong>DXGK_DSI_TRANSMISSION</strong></a></p>

<p><a rel="noopener" target="_blank" href="ioctl_mipi_dsi_query_caps"><strong>IOCTL_MIPI_DSI_QUERY_CAPS</strong></a></p>

<p><a rel="noopener" target="_blank" href="ioctl_mipi_dsi_reset"><strong>IOCTL_MIPI_DSI_RESET</strong></a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/ntddvdeo/ni-ntddvdeo-ioctl_mipi_dsi_transmission">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/ntddvdeo/ni-ntddvdeo-ioctl_mipi_dsi_transmission.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
