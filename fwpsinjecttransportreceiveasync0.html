<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="FwpsInjectTransportReceiveAsync0 - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FwpsInjectTransportReceiveAsync0 - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            FwpsInjectTransportReceiveAsync0 - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// fwpsk.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body"><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a> FwpsInjectTransportReceiveAsync0(
  [in]           HANDLE                injectionHandle,
  [in, optional] HANDLE                injectionContext,
                 PVOID                 reserved,
  [in]           <a href="uint32" title="typedef unsigned int UINT32;">UINT32</a>                flags,
  [in]           <a href="address_family" title="typedef USHORT ADDRESS_FAMILY;">ADDRESS_FAMILY</a>        addressFamily,
  [in]           COMPARTMENT_ID        compartmentId,
  [in]           IF_INDEX              interfaceIndex,
  [in]           IF_INDEX              subInterfaceIndex,
  [in, out]      <a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a>       *netBufferList,
  [in]           FWPS_INJECT_COMPLETE0 completionFn,
  [in, optional] HANDLE                completionContext
);</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjecttransportreceiveasync0">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/fwpsinjecttransportreceiveasync0.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (nf-fwpsk-fwpsinjecttransportreceiveasync0)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="fwpsinjecttransportreceiveasync0-function">FwpsInjectTransportReceiveAsync0 function</h1>

<h2 id="description">Description</h2>

<p>The
<strong>FwpsInjectTransportReceiveAsync0</strong> function injects packet data from the transport, datagram data, or
ICMP error layers into the receive data path.</p>

<p><strong>Note</strong> <strong>FwpsInjectTransportReceiveAsync0</strong> is a specific version of <strong>FwpsInjectTransportReceiveAsync</strong>. See <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/desktop/FWP/wfp-version-independent-names-and-targeting-specific-versions-of-windows">WFP Version-Independent Names and Targeting Specific Versions of Windows</a> for more information.</p>

<h2 id="parameters">Parameters</h2>

<h3 id="injectionhandle-in"><code>injectionHandle</code> [in]</h3>

<p>An injection handle that was previously created by a call to the
<a rel="noopener" target="_blank" href="fwpsinjectionhandlecreate0">FwpsInjectionHandleCreate0</a> function.</p>

<h3 id="injectioncontext-in-optional"><code>injectionContext</code> [in, optional]</h3>

<p>An optional handle to the injection context. If specified, it can be obtained by calling the
<a rel="noopener" target="_blank" href="fwpsquerypacketinjectionstate0">FwpsQueryPacketInjectionState0</a> function when the packet injection state
<a rel="noopener" target="_blank" href="fwps_packet_injection_state_">FWPS_PACKET_INJECTION_STATE</a> is
<strong>FWPS_PACKET_INJECTED_BY_SELF</strong> or <strong>FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF</strong>.</p>

<h3 id="reserved"><code>reserved</code></h3>

<p>Reserved. Callout drivers must set this parameter to zero.</p>

<h3 id="flags-in"><code>flags</code> [in]</h3>

<p>Reserved. Callout drivers must set this parameter to zero.</p>

<h3 id="addressfamily-in"><code>addressFamily</code> [in]</h3>

<p>One of the following address families:</p>

<h4 id="af_inet">AF_INET</h4>

<p>The IPv4 address family.</p>

<h4 id="af_inet6">AF_INET6</h4>

<p>The IPv6 address family.</p>

<h3 id="compartmentid-in"><code>compartmentId</code> [in]</h3>

<p>The identifier of the routing compartment into which the packet data is injected, specified as a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/winnt/ne-winnt-compartment_id">COMPARTMENT_ID</a> type. This identifier is provided
to a callout through the
**compartmentId** member of the
<a rel="noopener" target="_blank" href="fwps_incoming_metadata_values0_">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function. If the
<strong>compartmentId</strong> member is available to callouts, <strong>FWPS_METADATA_FIELD_COMPARTMENT_ID</strong> will be set in
the
<strong>currentMetadataValues</strong> member. Otherwise, set this parameter to <strong>UNSPECIFIED_COMPARTMENT_ID</strong>.</p>

<h3 id="interfaceindex-in"><code>interfaceIndex</code> [in]</h3>

<p>The index of the interface on which the original packet data was received. A callout driver should
use the value of the interface index that is passed as one of the incoming data values to its
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function for this
parameter if the packet is to be injected into the same interface where the original packet was
indicated.</p>

<h3 id="subinterfaceindex-in"><code>subInterfaceIndex</code> [in]</h3>

<p>The index of the subinterface on which the original packet data was received. A callout driver
should use the value of the subinterface index that is passed as one of the incoming data values to its
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function for this
parameter if the packet is to be injected into the same subinterface where the original packet was
indicated.</p>

<h3 id="netbufferlist-in-out"><code>netBufferList</code> [in, out]</h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="net_buffer_list">NET_BUFFER_LIST</a> structure that describes
the packet data that is being injected. A callout driver allocates a <strong><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></strong> structure to use to
inject packet data by calling either the
<a rel="noopener" target="_blank" href="fwpsallocateclonenetbufferlist0">FwpsAllocateCloneNetBufferList0</a> function or the
<a rel="noopener" target="_blank" href="fwpsallocatenetbufferandnetbufferlist0">FwpsAllocateNetBufferAndNetBufferList0</a> function. The <strong><a href="net_buffer_list" title="typedef struct _NET_BUFFER_LIST {&#10;  union {&#10;    struct {&#10;      NET_BUFFER_LIST *Next;&#10;      NET_BUFFER      *FirstNetBuffer;&#10;    };&#10;    SLIST_HEADER           Link;&#10;    NET_BUFFER_LIST_HEADER NetBufferListHeader;&#10;  };&#10;  NET_BUFFER_LIST_CONTEXT *Context;&#10;  NET_BUFFER_LIST         *ParentNetBufferList;&#10;  NDIS_HANDLE             NdisPoolHandle;&#10;  PVOID                   NdisReserved[2];&#10;  PVOID                   ProtocolReserved[4];&#10;  PVOID                   MiniportReserved[2];&#10;  PVOID                   Scratch;&#10;  NDIS_HANDLE             SourceHandle;&#10;  ULONG                   NblFlags;&#10;  LONG                    ChildRefCount;&#10;  ULONG                   Flags;&#10;...">NET_BUFFER_LIST</a></strong> structure must begin with an
IP header.</p>

<h3 id="completionfn-in"><code>completionFn</code> [in]</h3>

<p>A pointer to a
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a> callout function provided by
the callout driver. The filter engine calls this function after the packet data, described by the
<em>netBufferList</em> parameter, has been injected into the network stack.</p>

<h3 id="completioncontext-in-optional"><code>completionContext</code> [in, optional]</h3>

<p>A pointer to a callout driver–provided context that is passed to the callout function pointed to
by the
<em>completionFn</em> parameter. This parameter is optional and can be <strong>NULL</strong>.</p>

<h2 id="return-value">Return value</h2>

<p>The
<strong>FwpsInjectTransportReceiveAsync0</strong> function returns one of the following <strong><a href="ntstatus" title="typedef _Return_type_success_(return &gt;= 0) long NTSTATUS;">NTSTATUS</a></strong> codes.</p>

<table>
<thead>
<tr>
  <th>Return code</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong></td>
  <td>The packet data injection was initiated successfully. The filter engine will call the completion function after the filter engine has completed injecting the packet data into the network stack, or when an error occurred subsequently. In case of an error, the <strong>Status</strong> member of the completed <a rel="noopener" target="_blank" href="net_buffer_list">NET_BUFFER_LIST</a> structure will indicate the reason for failure.</td>
</tr>
<tr>
  <td><strong>STATUS_FWP_TCPIP_NOT_READY</strong></td>
  <td>The TCP/IP network stack is not ready to accept injection of packet data.</td>
</tr>
<tr>
  <td><strong>STATUS_FWP_INJECT_HANDLE_CLOSING</strong></td>
  <td>The injection handle is being closed.</td>
</tr>
<tr>
  <td><strong>Other status codes</strong></td>
  <td>An error occurred.</td>
</tr>
</tbody>
</table>

<h2 id="remarks">Remarks</h2>

<p>A callout driver calls the
<strong>FwpsInjectTransportReceiveAsync0</strong> function to inject packet data from the transport, datagram data,
or ICMP error layers into the receive data path. This function can execute asynchronously. Callout
drivers normally inject data into the network stack when modifying packet data. For more information
about how a callout driver can modify packet data, see
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/network/callout-driver-operations">Callout Driver Operations</a>.</p>

<p>If a callout driver modified a packet that it will inject with
<strong>FwpsInjectTransportReceiveAsync0</strong>, it should call the
<a rel="noopener" target="_blank" href="fwpsconstructipheaderfortransportpacket0">FwpsConstructIpHeaderForTransportPacket0</a> function to correct the IP and upper-level protocol (TCP,
UDP, and ICMP) checksums. The
<em>headerIncludeHeaderSize</em> parameter of
<strong><a href="fwpsconstructipheaderfortransportpacket0" title="NTSTATUS FwpsConstructIpHeaderForTransportPacket0(&#10;  [in, out]      NET_BUFFER_LIST  *netBufferList,&#10;                 ULONG            headerIncludeHeaderLength,&#10;  [in]           ADDRESS_FAMILY   addressFamily,&#10;  [in]           const UCHAR      *sourceAddress,&#10;  [in]           const UCHAR      *remoteAddress,&#10;  [in]           IPPROTO          nextProtocol,&#10;  [in, optional] UINT64           endpointHandle,&#10;  [in, optional] const WSACMSGHDR *controlData,&#10;  [in]           ULONG            controlDataLength,&#10;  [in]           UINT32           flags,&#10;                 PVOID            reserved,&#10;  [in, optional] IF_INDEX         interfaceIndex,&#10;  [in, optional] IF_INDEX         subInterfaceIndex&#10;);">FwpsConstructIpHeaderForTransportPacket0</a></strong> should be the same value as the
<strong>ipHeaderSize</strong> member of the
<a rel="noopener" target="_blank" href="fwps_incoming_metadata_values0_">FWPS_INCOMING_METADATA_VALUES0</a> structure that is passed to the <em>inMetaValues</em> parameter of the
callout driver's
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function.</p>

<p>If the return value is not <strong><a href="status_success" title="#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)">STATUS_SUCCESS</a></strong>, the completion function will not be called. In this case,
the net buffer list pointed to by
<em>netBufferList</em> must be freed by a call to
<a rel="noopener" target="_blank" href="fwpsfreenetbufferlist0">FwpsFreeNetBufferList0</a> or
<a rel="noopener" target="_blank" href="fwpsfreeclonenetbufferlist0">FwpsFreeCloneNetBufferList0</a>.</p>

<p>If the original inbound packet data had been subject to IPsec policy enforcement when it was
originally processed by the transport layer, the cloned packet injected by this function will bypass
IPsec verification when it reenters the network stack. Locally generated inbound packets that use the
<a rel="noopener" target="_blank" href="fwpsallocatenetbufferandnetbufferlist0">FwpsAllocateNetBufferAndNetBufferList0</a> function also bypass IPsec verification.</p>

<p>To allow IPsec to process inbound packets first, the callout that inspects the transport layer data
must have a lower value of
<strong>subLayerWeight</strong> in the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fwpstypes/ns-fwpstypes-fwps_filter0">FWPS_FILTER0</a> structure than the universal
sublayer. In addition, the callout driver must not intercept tunnel-mode packets for which the
combination of
<a rel="noopener" target="_blank" href="fwps_packet_list_inbound_ipsec_information0_">FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0</a> members (
<strong>isTunnelMode</strong> &amp;&amp; !
<strong>isDeTunneled</strong> ) is returned by the
<a rel="noopener" target="_blank" href="fwpsgetpacketlistsecurityinformation0">FwpsGetPacketListSecurityInformation0</a> function. The callout driver must wait for the packet to be
detunneled and then should intercept it at the transport layer or at a forward layer.</p>

<p>Due to the TCP protocol locking semantics, TCP can only be injected Out of Band at any transport layer or equivalent layer, so FwpsInjectTransportReceiveAsync0 and <a href="fwpsinjecttransportsendasync0" title="NTSTATUS FwpsInjectTransportSendAsync0(&#10;  [in]           HANDLE                      injectionHandle,&#10;  [in, optional] HANDLE                      injectionContext,&#10;  [in]           UINT64                      endpointHandle,&#10;  [in]           UINT32                      flags,&#10;  [in, optional] FWPS_TRANSPORT_SEND_PARAMS0 *sendArgs,&#10;  [in]           ADDRESS_FAMILY              addressFamily,&#10;  [in]           COMPARTMENT_ID              compartmentId,&#10;  [in, out]      NET_BUFFER_LIST             *netBufferList,&#10;  [in]           FWPS_INJECT_COMPLETE0       completionFn,&#10;  [in, optional] HANDLE                      completionContext&#10;);">FwpsInjectTransportSendAsync0</a> must be queued and run by a DPC.</p>

<p>This function can be called from one of the following transport layers if the
<strong>FWPS_METADATA_FIELD_ALE_CLASSIFY_REQUIRED</strong> metadata flag is not set:</p>

<p><strong>FWPS_LAYER_INBOUND_TRANSPORT_V4</strong></p>

<p><strong>FWPS_LAYER_INBOUND_TRANSPORT_V6</strong></p>

<p><strong>FWPS_LAYER_DATAGRAM_DATA_V4</strong> (when inbound direction is specified with <strong>FWP_DIRECTION_INBOUND</strong>)</p>

<p><strong>FWPS_LAYER_DATAGRAM_DATA_V6</strong> (when inbound direction is specified with <strong>FWP_DIRECTION_INBOUND</strong>)</p>

<p><strong>FWPS_LAYER_INBOUND_ICMP_ERROR_V4</strong></p>

<p><strong>FWPS_LAYER_INBOUND_ICMP_ERROR_V6</strong></p>

<p>Otherwise, this function should be called from the following Application Layer Enforcement (ALE) layers
after a pended ALE operation was initiated with a call to
<a rel="noopener" target="_blank" href="fwpspendoperation0">FwpsPendOperation0</a> and has completed
with a call to
<a rel="noopener" target="_blank" href="fwpscompleteoperation0">FwpsCompleteOperation0</a>:</p>

<p><strong>FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4</strong></p>

<p><strong>FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6</strong></p>

<p>A net buffer list to be injected must be passed to the
<a rel="noopener" target="_blank" href="fwpscompleteoperation0">FwpsCompleteOperation0</a> function as the
<em>netBufferList</em> argument.</p>

<p>The injected packet can be indicated to the callout driver again. To prevent infinite looping, the
driver should first call the
<a rel="noopener" target="_blank" href="fwpsquerypacketinjectionstate0">FwpsQueryPacketInjectionState0</a> function before proceeding with a call to the
<a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a> callout function, and the driver
should permit packets that have the injection state
<a rel="noopener" target="_blank" href="fwps_packet_injection_state_">FWPS_PACKET_INJECTION_STATE</a> set to
<strong>FWPS_PACKET_INJECTED_BY_SELF</strong> or <strong>FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF</strong> to pass through unaltered.</p>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fwpstypes/ns-fwpstypes-fwps_filter0">FWPS_FILTER0</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows/win32/api/fwpstypes/ns-fwpstypes-fwps_filter_condition0">FWPS_FILTER_CONDITION0</a></p>

<p><a rel="noopener" target="_blank" href="fwps_incoming_metadata_values0_">FWPS_INCOMING_METADATA_VALUES0</a></p>

<p><a rel="noopener" target="_blank" href="fwps_packet_injection_state_">FWPS_PACKET_INJECTION_STATE</a></p>

<p><a rel="noopener" target="_blank" href="fwps_packet_list_inbound_ipsec_information0_">FWPS_PACKET_LIST_INBOUND_IPSEC_INFORMATION0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsallocateclonenetbufferlist0">FwpsAllocateCloneNetBufferList0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsallocatenetbufferandnetbufferlist0">FwpsAllocateNetBufferAndNetBufferList0</a></p>

<p><a rel="noopener" target="_blank" href="fwpscompleteoperation0">FwpsCompleteOperation0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsfreeclonenetbufferlist0">FwpsFreeCloneNetBufferList0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsfreenetbufferlist0">FwpsFreeNetBufferList0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsgetpacketlistsecurityinformation0">FwpsGetPacketListSecurityInformation0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsinjectnetworksendasync0">FwpsInjectNetworkSendAsync0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsinjectionhandlecreate0">FwpsInjectionHandleCreate0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsinjectionhandledestroy0">FwpsInjectionHandleDestroy0</a></p>

<p><a rel="noopener" target="_blank" href="fwpspendoperation0">FwpsPendOperation0</a></p>

<p><a rel="noopener" target="_blank" href="fwpsquerypacketinjectionstate0">FwpsQueryPacketInjectionState0</a></p>

<p><a rel="noopener" target="_blank" href="net_buffer_list">NET_BUFFER_LIST</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/_netvista/">classifyFn</a></p>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nc-fwpsk-fwps_inject_complete0">completionFn</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/fwpsk/nf-fwpsk-fwpsinjecttransportreceiveasync0">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/fwpsk/nf-fwpsk-fwpsinjecttransportreceiveasync0.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
