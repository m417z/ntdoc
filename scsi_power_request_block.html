<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="description" content="SCSI_POWER_REQUEST_BLOCK - NtDoc, the native NT API online documentation">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>SCSI_POWER_REQUEST_BLOCK - NtDoc</title>
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="manifest" href="icons/site.webmanifest">
    <link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="icons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <noscript id="dark-mode-toggle-stylesheets">
        <link rel="stylesheet" href="modules/water-2.1.1-light.css" media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="modules/water-2.1.1-dark.css" media="(prefers-color-scheme: dark)">
    </noscript>
    <script src="dark-mode-toggle-stylesheets-loader.min.js"></script>
    <link rel="stylesheet" href="modules/virtual-select/virtual-select.css">
    <link rel="stylesheet" href="modules/pygments-css.css">
    <link rel="stylesheet" href="ntdoc.css">
    <noscript>
        <link rel="stylesheet" href="ntdoc-noscript.css">
    </noscript>
</head>
<body>
    <header>
        <a href="."><img class="ntdoc-title-logo" src="logo.png" alt="logo"></a>
        <h1 class="ntdoc-title">
            SCSI_POWER_REQUEST_BLOCK - NtDoc
        </h1>
        <div class="ntdoc-subtitle">
            Native API online documentation, based on the System Informer
            (formerly Process Hacker) <a target="_blank"
            href="https://github.com/winsiderss/systeminformer/tree/master/phnt">phnt
            headers</a>
        </div>
        <div id="ntdoc-search-select"></div>
    </header>
    <div class="ntdoc-code-elements">
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// minitape.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_POWER_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                     Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbPowerFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Lun;
  <a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a>    DevicePowerState;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      TimeOutValue;
  PVOID                      DataBuffer;
  PVOID                      SenseInfoBuffer;
  <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">struct _SCSI_REQUEST_BLOCK</a> *NextSrb;
  PVOID                      OriginalRequest;
  PVOID                      SrbExtension;
  <a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a>          PowerAction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Reserved5[16];
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// srb.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_POWER_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                     Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbPowerFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Lun;
  <a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a>    DevicePowerState;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      TimeOutValue;
  PVOID                      DataBuffer;
  PVOID                      SenseInfoBuffer;
  <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">struct _SCSI_REQUEST_BLOCK</a> *NextSrb;
  PVOID                      OriginalRequest;
  PVOID                      SrbExtension;
  <a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a>          PowerAction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Reserved5[16];
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
<div class="ntdoc-code-element">
<pre class="ntdoc-code-pre"><code class="ntdoc-code"><span class="ntdoc-code-header">// storport.h

</span><span class="ntdoc-code-intro"></span><span class="ntdoc-code-body">typedef struct _SCSI_POWER_REQUEST_BLOCK {
  <a href="ushort" title="typedef unsigned short USHORT;">USHORT</a>                     Length;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Function;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbStatus;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      SrbPowerFlags;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      PathId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      TargetId;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Lun;
  <a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a>    DevicePowerState;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      SrbFlags;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      DataTransferLength;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      TimeOutValue;
  PVOID                      DataBuffer;
  PVOID                      SenseInfoBuffer;
  <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">struct _SCSI_REQUEST_BLOCK</a> *NextSrb;
  PVOID                      OriginalRequest;
  PVOID                      SrbExtension;
  <a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a>          PowerAction;
  <a href="ulong" title="typedef unsigned long ULONG;">ULONG</a>                      Reserved;
  <a href="uchar" title="typedef unsigned char UCHAR;">UCHAR</a>                      Reserved5[16];
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;</span><span class="ntdoc-code-footer">
</span><span class="ntdoc-code-links"><hr><a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a></span></code></pre></div>
</div>
<div class="ntdoc-descriptions">
<div class="ntdoc-description-title">
<h1>NtDoc</h1>
</div>
<div class="ntdoc-description">
<div class="ntdoc-description-none">
<p>No description available.</p>
</div>
<div class="ntdoc-description-links">
<a target="_blank" href="https://github.com/m417z/ntdoc/blob/main/descriptions/scsi_power_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-minitape-_scsi_power_request_block)</h1>
</div>
<div class="ntdoc-description ntdoc-description-selected">
<h1 id="_scsi_power_request_block-structure-minitapeh">_SCSI_POWER_REQUEST_BLOCK structure (minitape.h)</h1>

<h2 id="description">Description</h2>

<p>The <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure is a special version of a <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> that is used for power management requests.</p>

<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>

<h2 id="members">Members</h2>

<h3 id="length"><code>Length</code></h3>

<p>The size, in bytes, of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure.</p>

<h3 id="function"><code>Function</code></h3>

<p>The operation to perform. For the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure, this member is always set to SRB_FUNCTION_POWER.</p>

<h3 id="srbstatus"><code>SrbStatus</code></h3>

<p>The status of the completed request. This member should be set by the miniport driver before it notifies the Storport driver that the request has completed. A miniport driver notifies the Storport driver that the request has completed by calling the <a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a> function with the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nf-storport-storportnotification">RequestComplete</a> notification type.</p>

<p>See <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> in the WDK documentation for a list of possible values for this member.</p>

<h3 id="srbpowerflags"><code>SrbPowerFlags</code></h3>

<p>The power management flags. Currently, the only flag allowed is SRB_POWER_FLAGS_ADAPTER_REQUEST, which indicates that the power management request is for the adapter. If this flag is set, the miniport driver should ignore the values in the <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>

<h3 id="pathid"><code>PathId</code></h3>

<p>The SCSI port or bus identifier for the request. This value is zero based.</p>

<h3 id="targetid"><code>TargetId</code></h3>

<p>The target controller or device identifier on the bus.</p>

<h3 id="lun"><code>Lun</code></h3>

<p>The logical unit number (LUN) of the device.</p>

<h3 id="devicepowerstate"><code>DevicePowerState</code></h3>

<p>An enumerator value of type <a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a> that specifies the requested power state of the device.</p>

<h3 id="srbflags"><code>SrbFlags</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="datatransferlength"><code>DataTransferLength</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="timeoutvalue"><code>TimeOutValue</code></h3>

<p>The interval, in seconds, that the request can execute before the Storport driver determines that the request has timed out.</p>

<h3 id="databuffer"><code>DataBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="senseinfobuffer"><code>SenseInfoBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="nextsrb"><code>NextSrb</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="originalrequest"><code>OriginalRequest</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3 id="srbextension"><code>SrbExtension</code></h3>

<p>A pointer to the SRB extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> structure. The Storport driver does not initialize the memory that this member points to. The HBA can directly access the data that the miniport driver writes into the SRB extension. A miniport driver can obtain the physical address of the SRB extension by calling the <a href="storportgetphysicaladdress" title="STORPORT_API STOR_PHYSICAL_ADDRESS StorPortGetPhysicalAddress(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           PVOID               VirtualAddress,&#10;  [out]          ULONG               *Length&#10;);">StorPortGetPhysicalAddress</a> routine.</p>

<h3 id="poweraction"><code>PowerAction</code></h3>

<p>An enumerator value of type <a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a> that specifies the type of system shutdown that is about to occur. This value is meaningful only if the device is moving into the D1, D2, or D3 power state as indicated by the <strong>DevicePowerState</strong> member.</p>

<h3 id="reserved"><code>Reserved</code></h3>

<p>Reserved for system use.</p>

<h3 id="reserved5"><code>Reserved5</code></h3>

<p>Reserved for system use.</p>

<h2 id="remarks">Remarks</h2>

<p>The Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio">HwStorBuildIo</a> to pass SRBs to the miniport driver. <strong>HwStorBuildIo</strong> should check the <strong>Function</strong> member of the SRB to determine the type of the SRB. If the <strong>Function</strong> member is set to SRB_FUNCTION_POWER, the SRB is a structure of type <strong>SCSI_POWER_REQUEST_BLOCK</strong>.</p>

<p>The Storport driver sends <strong>SCSI_POWER_REQUEST_BLOCK</strong> requests to a miniport driver to notify the miniport driver of Windows power events that affect storage devices that are connected to the adapter. In the case of a power up event, this request gives the miniport driver an opportunity to initialize itself. In the case of a hibernation or shutdown event, this request gives the miniport driver an opportunity to complete I/O requests and prepare for a power down. The miniport driver can use the value in the <strong>PowerAction</strong> member of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> to determine what actions are required. After the miniport driver completes the <strong>SCSI_POWER_REQUEST_BLOCK</strong> request, the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557274(v=vs.85)">HwScsiAdapterControl</a> with a control request of <strong>ScsiStopAdapter</strong> to power down the adapter. The miniport driver reinitialize while processing the SRB_FUNCTION_POWER request, or it can wait and reinitialize when the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control">HwStorAdapterControl</a> to perform a an <strong>ScsiRestartAdapter</strong> control request.</p>

<p>When transitioning from the D0 power state to a lower-powered state (D1, D2, or D3) the Storport driver sends a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver before the underlying bus driver powers down the adapter.</p>

<p>The following conditions must exist before the Storport driver will send a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver:</p>

<ul>
<li>The adapter is not stopped.</li>
<li>The I/O queue for the adapter is paused.</li>
<li>The adapter hardware is powered up.</li>
<li>The miniport can access the adapter's hardware resources.</li>
</ul>

<h2 id="see-also">See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio">HwStorBuildIo</a></p>

<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>

<p><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/minitape/ns-minitape-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/minitape/ns-minitape-_scsi_power_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-srb-_scsi_power_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>_SCSI_POWER_REQUEST_BLOCK structure (srb.h)</h1>

<h2>Description</h2>

<p>The <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure is a special version of a <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> that is used for power management requests.</p>

<p><strong>Note</strong> The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>

<h2>Members</h2>

<h3><code>Length</code></h3>

<p>The size, in bytes, of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure.</p>

<h3><code>Function</code></h3>

<p>The operation to perform. For the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure, this member is always set to SRB_FUNCTION_POWER.</p>

<h3><code>SrbStatus</code></h3>

<p>The status of the completed request. This member should be set by the miniport driver before it notifies the Storport driver that the request has completed. A miniport driver notifies the Storport driver that the request has completed by calling the <a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a> function with the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nf-storport-storportnotification">RequestComplete</a> notification type.</p>

<p>See <a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a> in the WDK documentation for a list of possible values for this member.</p>

<h3><code>SrbPowerFlags</code></h3>

<p>The power management flags. Currently, the only flag allowed is SRB_POWER_FLAGS_ADAPTER_REQUEST, which indicates that the power management request is for the adapter. If this flag is set, the miniport driver should ignore the values in the <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>

<h3><code>PathId</code></h3>

<p>The SCSI port or bus identifier for the request. This value is zero based.</p>

<h3><code>TargetId</code></h3>

<p>The target controller or device identifier on the bus.</p>

<h3><code>Lun</code></h3>

<p>The logical unit number (LUN) of the device.</p>

<h3><code>DevicePowerState</code></h3>

<p>An enumerator value of type <a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a> that specifies the requested power state of the device.</p>

<h3><code>SrbFlags</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>DataTransferLength</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>TimeOutValue</code></h3>

<p>The interval, in seconds, that the request can execute before the Storport driver determines that the request has timed out.</p>

<h3><code>DataBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>SenseInfoBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>NextSrb</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>OriginalRequest</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>SrbExtension</code></h3>

<p>A pointer to the SRB extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a> structure. The Storport driver does not initialize the memory that this member points to. The HBA can directly access the data that the miniport driver writes into the SRB extension. A miniport driver can obtain the physical address of the SRB extension by calling the <a href="storportgetphysicaladdress" title="STORPORT_API STOR_PHYSICAL_ADDRESS StorPortGetPhysicalAddress(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           PVOID               VirtualAddress,&#10;  [out]          ULONG               *Length&#10;);">StorPortGetPhysicalAddress</a> routine.</p>

<h3><code>PowerAction</code></h3>

<p>An enumerator value of type <a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a> that specifies the type of system shutdown that is about to occur. This value is meaningful only if the device is moving into the D1, D2, or D3 power state as indicated by the <strong>DevicePowerState</strong> member.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for system use.</p>

<h3><code>Reserved5</code></h3>

<p>Reserved for system use.</p>

<h2>Remarks</h2>

<p>The Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio">HwStorBuildIo</a> to pass SRBs to the miniport driver. <strong>HwStorBuildIo</strong> should check the <strong>Function</strong> member of the SRB to determine the type of the SRB. If the <strong>Function</strong> member is set to SRB_FUNCTION_POWER, the SRB is a structure of type <strong>SCSI_POWER_REQUEST_BLOCK</strong>.</p>

<p>The Storport driver sends <strong>SCSI_POWER_REQUEST_BLOCK</strong> requests to a miniport driver to notify the miniport driver of Windows power events that affect storage devices that are connected to the adapter. In the case of a power up event, this request gives the miniport driver an opportunity to initialize itself. In the case of a hibernation or shutdown event, this request gives the miniport driver an opportunity to complete I/O requests and prepare for a power down. The miniport driver can use the value in the <strong>PowerAction</strong> member of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> to determine what actions are required. After the miniport driver completes the <strong>SCSI_POWER_REQUEST_BLOCK</strong> request, the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557274(v=vs.85)">HwScsiAdapterControl</a> with a control request of <strong>ScsiStopAdapter</strong> to power down the adapter. The miniport driver reinitialize while processing the SRB_FUNCTION_POWER request, or it can wait and reinitialize when the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control">HwStorAdapterControl</a> to perform a an <strong>ScsiRestartAdapter</strong> control request.</p>

<p>When transitioning from the D0 power state to a lower-powered state (D1, D2, or D3) the Storport driver sends a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver before the underlying bus driver powers down the adapter.</p>

<p>The following conditions must exist before the Storport driver will send a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver:</p>

<ul>
<li>The adapter is not stopped.</li>
<li>The I/O queue for the adapter is paused.</li>
<li>The adapter hardware is powered up.</li>
<li>The miniport can access the adapter's hardware resources.</li>
</ul>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio">HwStorBuildIo</a></p>

<p><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></p>

<p><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/srb/ns-srb-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/srb/ns-srb-_scsi_power_request_block.md">Edit description on GitHub</a>
</div>
</div>
<div class="ntdoc-description-title">
<h1>Windows Driver Kit DDI reference (ns-storport-_scsi_power_request_block)</h1>
</div>
<div class="ntdoc-description">
<h1>_SCSI_POWER_REQUEST_BLOCK structure (storport.h)</h1>

<h2>Description</h2>

<p>The <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure is a special version of a <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> that is used for power management requests.</p>

<blockquote>
  <p>[!NOTE]</p>
  
  <p>The SCSI port driver and SCSI miniport driver models may be altered or unavailable in the future. Instead, we recommend using the <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-driver">Storport driver</a> and <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/storage/storport-miniport-drivers">Storport miniport</a> driver models.</p>
</blockquote>

<h2>Members</h2>

<h3><code>Length</code></h3>

<p>The size, in bytes, of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure.</p>

<h3><code>Function</code></h3>

<p>The operation to perform. For the <strong>SCSI_POWER_REQUEST_BLOCK</strong> structure, this member is always set to SRB_FUNCTION_POWER.</p>

<h3><code>SrbStatus</code></h3>

<p>The status of the completed request. This member should be set by the miniport driver before it notifies the Storport driver that the request has completed. A miniport driver notifies the Storport driver that the request has completed by calling the <strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong> function with the <strong>RequestComplete</strong> notification type.</p>

<p>See <strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong> in the WDK documentation for a list of possible values for this member.</p>

<h3><code>SrbPowerFlags</code></h3>

<p>The power management flags. Currently, the only flag allowed is SRB_POWER_FLAGS_ADAPTER_REQUEST, which indicates that the power management request is for the adapter. If this flag is set, the miniport driver should ignore the values in the <strong>PathId</strong>, <strong>TargetId</strong>, and <strong>Lun</strong>.</p>

<h3><code>PathId</code></h3>

<p>The SCSI port or bus identifier for the request. This value is zero based.</p>

<h3><code>TargetId</code></h3>

<p>The target controller or device identifier on the bus.</p>

<h3><code>Lun</code></h3>

<p>The logical unit number (LUN) of the device.</p>

<h3><code>DevicePowerState</code></h3>

<p>An enumerator value of type <strong><a href="stor_device_power_state" title="typedef enum _STOR_DEVICE_POWER_STATE {&#10;  StorPowerDeviceUnspecified,&#10;  StorPowerDeviceD0,&#10;  StorPowerDeviceD1,&#10;  StorPowerDeviceD2,&#10;  StorPowerDeviceD3,&#10;  StorPowerDeviceMaximum&#10;} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;">STOR_DEVICE_POWER_STATE</a></strong> that specifies the requested power state of the device.</p>

<h3><code>SrbFlags</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>DataTransferLength</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>TimeOutValue</code></h3>

<p>The interval, in seconds, that the request can execute before the Storport driver determines that the request has timed out.</p>

<h3><code>DataBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>SenseInfoBuffer</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>NextSrb</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>OriginalRequest</code></h3>

<p>Miniport driver should ignore this member.</p>

<h3><code>SrbExtension</code></h3>

<p>A pointer to the SRB extension. A miniport driver must not use this member if it set <strong>SrbExtensionSize</strong> to zero in the <strong><a href="hw_initialization_data" title="typedef struct _HW_INITIALIZATION_DATA {&#10;  ULONG               HwInitializationDataSize;&#10;  INTERFACE_TYPE      AdapterInterfaceType;&#10;  PHW_INITIALIZE      HwInitialize;&#10;  PHW_STARTIO         HwStartIo;&#10;  PHW_INTERRUPT       HwInterrupt;&#10;  PHW_FIND_ADAPTER    HwFindAdapter;&#10;  PHW_RESET_BUS       HwResetBus;&#10;  PHW_DMA_STARTED     HwDmaStarted;&#10;  PHW_ADAPTER_STATE   HwAdapterState;&#10;  ULONG               DeviceExtensionSize;&#10;  ULONG               SpecificLuExtensionSize;&#10;  ULONG               SrbExtensionSize;&#10;  ULONG               NumberOfAccessRanges;&#10;  PVOID               Reserved;&#10;  BOOLEAN             MapBuffers;&#10;  BOOLEAN             NeedPhysicalAddresses;&#10;  BOOLEAN             TaggedQueuing;&#10;  BOOLEAN             AutoRequestSense;&#10;  BOOLEAN             MultipleRequestPerLu;&#10;...">HW_INITIALIZATION_DATA</a></strong> structure. The Storport driver does not initialize the memory that this member points to. The HBA can directly access the data that the miniport driver writes into the SRB extension. A miniport driver can obtain the physical address of the SRB extension by calling the <strong><a href="storportgetphysicaladdress" title="STORPORT_API STOR_PHYSICAL_ADDRESS StorPortGetPhysicalAddress(&#10;  [in]           PVOID               HwDeviceExtension,&#10;  [in, optional] PSCSI_REQUEST_BLOCK Srb,&#10;  [in]           PVOID               VirtualAddress,&#10;  [out]          ULONG               *Length&#10;);">StorPortGetPhysicalAddress</a></strong> routine.</p>

<h3><code>PowerAction</code></h3>

<p>An enumerator value of type <strong><a href="stor_power_action" title="typedef enum {&#10;  StorPowerActionNone,&#10;  StorPowerActionReserved,&#10;  StorPowerActionSleep,&#10;  StorPowerActionHibernate,&#10;  StorPowerActionShutdown,&#10;  StorPowerActionShutdownReset,&#10;  StorPowerActionShutdownOff,&#10;  StorPowerActionWarmEject&#10;} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;">STOR_POWER_ACTION</a></strong> that specifies the type of system shutdown that is about to occur. This value is meaningful only if the device is moving into the D1, D2, or D3 power state as indicated by the <strong>DevicePowerState</strong> member.</p>

<h3><code>Reserved</code></h3>

<p>Reserved for system use.</p>

<h3><code>Reserved5</code></h3>

<p>Reserved for system use.</p>

<h2>Remarks</h2>

<p>The Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio"><strong>HwStorBuildIo</strong></a> to pass SRBs to the miniport driver. <strong>HwStorBuildIo</strong> should check the <strong>Function</strong> member of the SRB to determine the type of the SRB. If the <strong>Function</strong> member is set to SRB_FUNCTION_POWER, the SRB is a structure of type <strong>SCSI_POWER_REQUEST_BLOCK</strong>.</p>

<p>The Storport driver sends <strong>SCSI_POWER_REQUEST_BLOCK</strong> requests to a miniport driver to notify the miniport driver of Windows power events that affect storage devices that are connected to the adapter. In the case of a power up event, this request gives the miniport driver an opportunity to initialize itself. In the case of a hibernation or shutdown event, this request gives the miniport driver an opportunity to complete I/O requests and prepare for a power down. The miniport driver can use the value in the <strong>PowerAction</strong> member of the <strong>SCSI_POWER_REQUEST_BLOCK</strong> to determine what actions are required. After the miniport driver completes the <strong>SCSI_POWER_REQUEST_BLOCK</strong> request, the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/previous-versions/windows/hardware/drivers/ff557274(v=vs.85)"><strong>HwScsiAdapterControl</strong></a> with a control request of <strong>ScsiStopAdapter</strong> to power down the adapter. The miniport driver reinitialize while processing the SRB_FUNCTION_POWER request, or it can wait and reinitialize when the Storport driver calls <a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_adapter_control"><strong>HwStorAdapterControl</strong></a> to perform a <strong>ScsiRestartAdapter</strong> control request.</p>

<p>When transitioning from the D0 power state to a lower-powered state (D1, D2, or D3) the Storport driver sends a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver before the underlying bus driver powers down the adapter.</p>

<p>The following conditions must exist before the Storport driver will send a <strong>SCSI_POWER_REQUEST_BLOCK</strong> request to the miniport driver:</p>

<ul>
<li>The adapter is not stopped.</li>
<li>The I/O queue for the adapter is paused.</li>
<li>The adapter hardware is powered up.</li>
<li>The miniport can access the adapter's hardware resources.</li>
</ul>

<h2>See also</h2>

<p><a rel="noopener" target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/nc-storport-hw_buildio"><strong>HwStorBuildIo</strong></a></p>

<p><strong><a href="scsi_request_block" title="typedef struct _SCSI_REQUEST_BLOCK {&#10;  USHORT                     Length;&#10;  UCHAR                      Function;&#10;  UCHAR                      SrbStatus;&#10;  UCHAR                      ScsiStatus;&#10;  UCHAR                      PathId;&#10;  UCHAR                      TargetId;&#10;  UCHAR                      Lun;&#10;  UCHAR                      QueueTag;&#10;  UCHAR                      QueueAction;&#10;  UCHAR                      CdbLength;&#10;  UCHAR                      SenseInfoBufferLength;&#10;  ULONG                      SrbFlags;&#10;  ULONG                      DataTransferLength;&#10;  ULONG                      TimeOutValue;&#10;  PVOID                      DataBuffer;&#10;  PVOID                      SenseInfoBuffer;&#10;  struct _SCSI_REQUEST_BLOCK *NextSrb;&#10;  PVOID                      OriginalRequest;&#10;  PVOID                      SrbExtension;&#10;...">SCSI_REQUEST_BLOCK</a></strong></p>

<p><strong><a href="storportnotification" title="STORPORT_API VOID StorPortNotification(&#10;  SCSI_NOTIFICATION_TYPE NotificationType,&#10;  PVOID                  HwDeviceExtension,&#10;  ...                    &#10;);">StorPortNotification</a></strong></p>
<hr>
<div class="ntdoc-description-links">
<p>
<a target="_blank" href="https://learn.microsoft.com/windows-hardware/drivers/ddi/storport/ns-storport-_scsi_power_request_block">View the official Windows Driver Kit DDI reference</a>
</p>
<a target="_blank" href="https://github.com/MicrosoftDocs/windows-driver-docs-ddi/blob/staging/wdk-ddi-src/content/storport/ns-storport-_scsi_power_request_block.md">Edit description on GitHub</a>
</div>
</div>
</div>

    <!-- For sticky footer: https://stackoverflow.com/a/34146411 -->
    <div class="spacer"></div>
    <footer>
        By <a href="https://m417z.com/" target="_blank" rel="noopener">m417z</a> &bull;
        content by <a href="https://github.com/diversenok" target="_blank" rel="noopener">diversenok</a> &bull;
        <a href="https://github.com/m417z/ntdoc" target="_blank" rel="noopener">GitHub repository</a> &bull;
        <dark-mode-toggle permanent></dark-mode-toggle>
    </footer>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YWF4NP61SX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-YWF4NP61SX');
    </script>
    <script src="modules/jquery-3.7.0.min.js"></script>
    <script src="modules/q-1.5.1.js"></script>
    <script src="modules/virtual-select/virtual-select-jquery.min.js"></script>
    <script src="modules/popper-2.11.8.min.js"></script>
    <script src="modules/tippy-6.3.7.min.js"></script>
    <script src="modules/anchor-5.0.0.min.js"></script>
    <script type="module" src="modules/dark-mode-toggle-0.14.6.min.mjs"></script>
    <script src="ntdoc.js"></script>
</body>
</html>
